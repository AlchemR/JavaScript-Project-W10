/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scripts_level1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scripts/level1.js */ \"./src/scripts/level1.js\");\n/* harmony import */ var _scripts_level2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scripts/level2.js */ \"./src/scripts/level2.js\");\n/* harmony import */ var _scripts_level3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scripts/level3.js */ \"./src/scripts/level3.js\");\n/* harmony import */ var _scripts_level4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scripts/level4.js */ \"./src/scripts/level4.js\");\n/* harmony import */ var planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! planck/dist/planck-with-testbed */ \"./node_modules/planck/dist/planck-with-testbed.js\");\n/* harmony import */ var planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_4__);\n// entry file\n// const Level1 = require(\"./level1.js\")\n\n\n\n\n\nvar canvas1 = document.getElementById('overlay');\nvar context2 = canvas1.getContext('2d');\n\nwindow.onload = function () {\n  var playbutton = document.querySelector('#playbutton');\n  var destroybutton = document.querySelector('#destroybutton');\n  var startbutton = document.querySelector('#startbutton');\n  var startbutton2 = document.querySelector('#startbutton2');\n  var startbutton3 = document.querySelector('#startbutton3');\n  var startbutton4 = document.querySelector('#startbutton4');\n  playbutton.addEventListener('click', function () {\n    testbed.togglePause();\n  }); // doesnt update text file, might need to look into how to bind later\n\n  destroybutton.addEventListener('click', function () {\n    console.log(\"destroy works\");\n  });\n  startbutton.addEventListener('click', function () {\n    (0,_scripts_level1_js__WEBPACK_IMPORTED_MODULE_0__.level1)();\n  });\n  startbutton2.addEventListener('click', function () {\n    (0,_scripts_level2_js__WEBPACK_IMPORTED_MODULE_1__.level2)();\n  });\n  startbutton3.addEventListener('click', function () {\n    (0,_scripts_level3_js__WEBPACK_IMPORTED_MODULE_2__.level3)();\n  });\n  startbutton4.addEventListener('click', function () {\n    (0,_scripts_level4_js__WEBPACK_IMPORTED_MODULE_3__.level4)();\n  });\n  window.destroybutton = destroybutton;\n  window.playbutton = playbutton;\n};\n\ncanvas1.height = 100;\ncanvas1.width = innerWidth;\nwindow.context2 = context2;\nwindow.canvas1 = canvas1; // import * as planck from '../node_modules/planck/dist/planck-with-testbed'\n// level1()//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0EsSUFBTUssT0FBTyxHQUFHQyxRQUFRLENBQUNDLGNBQVQsQ0FBd0IsU0FBeEIsQ0FBaEI7QUFDQSxJQUFNQyxRQUFRLEdBQUdILE9BQU8sQ0FBQ0ksVUFBUixDQUFtQixJQUFuQixDQUFqQjs7QUFFQUMsTUFBTSxDQUFDQyxNQUFQLEdBQWdCLFlBQVk7RUFDMUIsSUFBTUMsVUFBVSxHQUFHTixRQUFRLENBQUNPLGFBQVQsQ0FBdUIsYUFBdkIsQ0FBbkI7RUFDQSxJQUFNQyxhQUFhLEdBQUdSLFFBQVEsQ0FBQ08sYUFBVCxDQUF1QixnQkFBdkIsQ0FBdEI7RUFDQSxJQUFNRSxXQUFXLEdBQUdULFFBQVEsQ0FBQ08sYUFBVCxDQUF1QixjQUF2QixDQUFwQjtFQUNBLElBQU1HLFlBQVksR0FBR1YsUUFBUSxDQUFDTyxhQUFULENBQXVCLGVBQXZCLENBQXJCO0VBQ0EsSUFBTUksWUFBWSxHQUFHWCxRQUFRLENBQUNPLGFBQVQsQ0FBdUIsZUFBdkIsQ0FBckI7RUFDQSxJQUFNSyxZQUFZLEdBQUdaLFFBQVEsQ0FBQ08sYUFBVCxDQUF1QixlQUF2QixDQUFyQjtFQUNBRCxVQUFVLENBQUNPLGdCQUFYLENBQTRCLE9BQTVCLEVBQXFDLFlBQU07SUFBRUMsT0FBTyxDQUFDQyxXQUFSO0VBQXdCLENBQXJFLEVBUDBCLENBTzZDOztFQUN2RVAsYUFBYSxDQUFDSyxnQkFBZCxDQUErQixPQUEvQixFQUF3QyxZQUFNO0lBQUVHLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLGVBQVo7RUFBZ0MsQ0FBaEY7RUFDQVIsV0FBVyxDQUFDSSxnQkFBWixDQUE2QixPQUE3QixFQUFzQyxZQUFNO0lBQUVuQiwwREFBTTtFQUFJLENBQXhEO0VBQ0FnQixZQUFZLENBQUNHLGdCQUFiLENBQThCLE9BQTlCLEVBQXVDLFlBQU07SUFBRWxCLDBEQUFNO0VBQUksQ0FBekQ7RUFDQWdCLFlBQVksQ0FBQ0UsZ0JBQWIsQ0FBOEIsT0FBOUIsRUFBdUMsWUFBTTtJQUFFakIsMERBQU07RUFBSSxDQUF6RDtFQUNBZ0IsWUFBWSxDQUFDQyxnQkFBYixDQUE4QixPQUE5QixFQUF1QyxZQUFNO0lBQUVoQiwwREFBTTtFQUFJLENBQXpEO0VBQ0FPLE1BQU0sQ0FBQ0ksYUFBUCxHQUF1QkEsYUFBdkI7RUFDQUosTUFBTSxDQUFDRSxVQUFQLEdBQW9CQSxVQUFwQjtBQUNELENBZkQ7O0FBa0JBUCxPQUFPLENBQUNtQixNQUFSLEdBQWlCLEdBQWpCO0FBQ0FuQixPQUFPLENBQUNvQixLQUFSLEdBQWdCQyxVQUFoQjtBQUNBaEIsTUFBTSxDQUFDRixRQUFQLEdBQWtCQSxRQUFsQjtBQUNBRSxNQUFNLENBQUNMLE9BQVAsR0FBaUJBLE9BQWpCLEVBRUE7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Rlc3QtcmVwby8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGVudHJ5IGZpbGVcblxuLy8gY29uc3QgTGV2ZWwxID0gcmVxdWlyZShcIi4vbGV2ZWwxLmpzXCIpXG5pbXBvcnQge2xldmVsMX0gZnJvbSBcIi4vc2NyaXB0cy9sZXZlbDEuanNcIlxuaW1wb3J0IHsgbGV2ZWwyIH0gZnJvbSBcIi4vc2NyaXB0cy9sZXZlbDIuanNcIlxuaW1wb3J0IHsgbGV2ZWwzIH0gZnJvbSBcIi4vc2NyaXB0cy9sZXZlbDMuanNcIlxuaW1wb3J0IHsgbGV2ZWw0IH0gZnJvbSBcIi4vc2NyaXB0cy9sZXZlbDQuanNcIlxuXG5pbXBvcnQgKiBhcyBwbGFuY2sgZnJvbSAncGxhbmNrL2Rpc3QvcGxhbmNrLXdpdGgtdGVzdGJlZCdcbmNvbnN0IGNhbnZhczEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3ZlcmxheScpXG5jb25zdCBjb250ZXh0MiA9IGNhbnZhczEuZ2V0Q29udGV4dCgnMmQnKVxuXG53aW5kb3cub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBwbGF5YnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3BsYXlidXR0b24nKVxuICBjb25zdCBkZXN0cm95YnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2Rlc3Ryb3lidXR0b24nKVxuICBjb25zdCBzdGFydGJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzdGFydGJ1dHRvbicpXG4gIGNvbnN0IHN0YXJ0YnV0dG9uMiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzdGFydGJ1dHRvbjInKVxuICBjb25zdCBzdGFydGJ1dHRvbjMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc3RhcnRidXR0b24zJylcbiAgY29uc3Qgc3RhcnRidXR0b240ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3N0YXJ0YnV0dG9uNCcpXG4gIHBsYXlidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7IHRlc3RiZWQudG9nZ2xlUGF1c2UoKTsgfSkgLy8gZG9lc250IHVwZGF0ZSB0ZXh0IGZpbGUsIG1pZ2h0IG5lZWQgdG8gbG9vayBpbnRvIGhvdyB0byBiaW5kIGxhdGVyXG4gIGRlc3Ryb3lidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7IGNvbnNvbGUubG9nKFwiZGVzdHJveSB3b3Jrc1wiKSA7IH0gKVxuICBzdGFydGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHsgbGV2ZWwxKCkgfSlcbiAgc3RhcnRidXR0b24yLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4geyBsZXZlbDIoKSB9KVxuICBzdGFydGJ1dHRvbjMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7IGxldmVsMygpIH0pXG4gIHN0YXJ0YnV0dG9uNC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHsgbGV2ZWw0KCkgfSlcbiAgd2luZG93LmRlc3Ryb3lidXR0b24gPSBkZXN0cm95YnV0dG9uXG4gIHdpbmRvdy5wbGF5YnV0dG9uID0gcGxheWJ1dHRvblxufVxuXG5cbmNhbnZhczEuaGVpZ2h0ID0gMTAwXG5jYW52YXMxLndpZHRoID0gaW5uZXJXaWR0aFxud2luZG93LmNvbnRleHQyID0gY29udGV4dDJcbndpbmRvdy5jYW52YXMxID0gY2FudmFzMVxuXG4vLyBpbXBvcnQgKiBhcyBwbGFuY2sgZnJvbSAnLi4vbm9kZV9tb2R1bGVzL3BsYW5jay9kaXN0L3BsYW5jay13aXRoLXRlc3RiZWQnXG5cblxuLy8gbGV2ZWwxKCkiXSwibmFtZXMiOlsibGV2ZWwxIiwibGV2ZWwyIiwibGV2ZWwzIiwibGV2ZWw0IiwicGxhbmNrIiwiY2FudmFzMSIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjb250ZXh0MiIsImdldENvbnRleHQiLCJ3aW5kb3ciLCJvbmxvYWQiLCJwbGF5YnV0dG9uIiwicXVlcnlTZWxlY3RvciIsImRlc3Ryb3lidXR0b24iLCJzdGFydGJ1dHRvbiIsInN0YXJ0YnV0dG9uMiIsInN0YXJ0YnV0dG9uMyIsInN0YXJ0YnV0dG9uNCIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0ZXN0YmVkIiwidG9nZ2xlUGF1c2UiLCJjb25zb2xlIiwibG9nIiwiaGVpZ2h0Iiwid2lkdGgiLCJpbm5lcldpZHRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/scripts/level1.js":
/*!*******************************!*\
  !*** ./src/scripts/level1.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"level1\": function() { return /* binding */ level1; }\n/* harmony export */ });\n/* harmony import */ var planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! planck/dist/planck-with-testbed */ \"./node_modules/planck/dist/planck-with-testbed.js\");\n/* harmony import */ var planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__);\n//level1trial\n\nfunction level1() {\n  planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__.testbed('Sandbox', function (testbed) {\n    testbed.background = \"#111111\";\n    testbed.speed = 2;\n    testbed.width = innerWidth / 4;\n    testbed.height = innerHeight / 4;\n    testbed.hz = 30;\n    var pl = planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__,\n        Vec2 = pl.Vec2;\n    var world = new pl.World(Vec2(0, -10));\n    testbed.mouseForce = 6000;\n    var levelscore = 10000; // 10K tenative\n    // turns on/off impulses to apply like slingshot\n\n    var COUNT = 4;\n    var ground = world.createBody();\n    ground.createFixture(pl.Edge(Vec2(-80.0, 0.0), Vec2(60.0, 0.0)), 0.0);\n    ground.createFixture(pl.Edge(Vec2(100.0, 0.0), Vec2(200.0, 20.0)), 0.0);\n    ground.createFixture(pl.Edge(Vec2(60.0, 0.0), Vec2(130.0, -30.0)), 0.0);\n    ground.createFixture(pl.Edge(Vec2(200.0, -30.0), Vec2(120.0, -80.0)), 0.0);\n    ground.createFixture(pl.Edge(Vec2(-80.0, -80.0), Vec2(200.0, -80.0)), 0.0);\n    ground.createFixture(pl.Edge(Vec2(200.0, 150.0), Vec2(200.0, -80.0)), 0.0);\n    ground.createFixture(pl.Edge(Vec2(-80.0, 150.0), Vec2(-80.0, -80.0)), 0.0);\n    ground.createFixture(pl.Edge(Vec2(-80.0, 150.0), Vec2(200.0, 150.0)), 0.0);\n    var ballBodyDef = {\n      position: Vec2(-50, 10),\n      bullet: false,\n      allowSleep: true,\n      linearDamping: .01,\n      angularDamping: .5\n    };\n    var ballStartAttr = {\n      friction: .1,\n      restitution: .5,\n      // bounce\n      density: 10,\n      userData: 'ball'\n    };\n    var ballFinishAttr = {\n      friction: .2,\n      restitution: .1,\n      // bounce\n      density: 1,\n      userData: 'finish'\n    };\n    var ball1 = world.createDynamicBody(ballBodyDef);\n    world.destroyBody(ball1);\n\n    function generateShot() {\n      if (ball1.m_destroyed) {\n        ball1 = world.createDynamicBody(ballBodyDef);\n        ball1.createFixture(pl.Circle(1), ballStartAttr);\n        ball1.render = {\n          texture: img\n        };\n        var img = new Image();\n        img.src = \"https://upload.wikimedia.org/wikipedia/commons/2/27/Wey_source_farringdon.jpg\";\n      }\n    }\n\n    generateShot();\n    var ball3 = world.createDynamicBody(ballBodyDef);\n    ball3.setPosition(Vec2(30, 2));\n    ball3.createFixture(pl.Circle(1), ballStartAttr);\n    ball3.render = {\n      fill: 'blue',\n      stroke: 'blue'\n    };\n    var ball2 = world.createBody(Vec2(40, -78));\n    ball2.createFixture(pl.Circle(1), ballFinishAttr);\n    ball2.render = {\n      fill: 'red',\n      stroke: 'red'\n    };\n    var a = 2;\n    var box = planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__.Box(a, a);\n    var x = Vec2(8.0, 8);\n    var y = Vec2();\n    var deltaX = Vec2(0, 4);\n    var deltaY = Vec2(0, 4);\n\n    for (var i = 0; i < COUNT; ++i) {\n      y.set(x);\n      world.createDynamicBody(y).createFixture(box, 5.0);\n      y.add(deltaY);\n      x.add(deltaX);\n    } // ball1.addEventListener(\"click\", () => { isClicked(); } )\n\n\n    function keylistener() {\n      //there is probably a way to do this with a case statement\n      //camera\n      if (testbed.activeKeys.right) {\n        if (cameraLimitX(testbed.x)) {\n          testbed.x += 2;\n        } else {\n          testbed.x = ball1pos.x;\n        }\n      } else if (testbed.activeKeys.left) {\n        if (cameraLimitX(testbed.x)) {\n          testbed.x -= 2;\n        } else {\n          testbed.x = ball1pos.x;\n        }\n      } else if (testbed.activeKeys.up) {\n        if (cameraLimitY(testbed.y)) {\n          testbed.y -= 2;\n        } else {\n          testbed.y = ball1pos.y;\n        }\n      } else if (testbed.activeKeys.down) {\n        if (cameraLimitY(testbed.y)) {\n          testbed.y += 2;\n        } else {\n          testbed.y = ball1pos.y;\n        }\n      } else if (testbed.activeKeys.C) {\n        testbed.togglePause();\n      } else if (testbed.activeKeys.fire) {\n        generateShot();\n      }\n    }\n\n    var ball1pos = ball1.getPosition();\n\n    function cameraLimitX(xPos) {\n      if (testbed.x + testbed.width * .4 > ball1pos.x && testbed.x - testbed.width * .4 < ball1pos.x) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    function cameraLimitY(yPos) {\n      if (testbed.y + testbed.height * .4 > ball1pos.y && testbed.y - testbed.height * .6 < ball1pos.y) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    function textOut() {\n      var scale = 20;\n      var ballpos = ball1.getPosition();\n      context2.clearRect(0, 0, canvas1.width, canvas1.height);\n      context2.font = \"\".concat(scale, \"px Courier New\");\n      context2.fillStyle = 'blue';\n      context2.fillText(\"X POS : \".concat(Math.round(ballpos.x)), 20, \"\".concat(scale));\n      context2.fillText(\"Y POS :\".concat(Math.round(ballpos.y)), 20, \"\".concat(scale * 2));\n      context2.fillText(\"testbed X POS : \".concat(Math.round(testbed.x)), 20, \"\".concat(scale * 3));\n      context2.fillText(\"testbed Y POS : \".concat(Math.round(testbed.y)), 20, \"\".concat(scale * 4));\n      context2.fillText(\"Pause : \".concat(testbed.isPaused()), 250, \"\".concat(scale));\n      context2.fillText(\"Shot destroyed : \".concat(ball1.m_destroyed), 250, \"\".concat(scale * 2));\n      context2.fillText(\"testbed Y height :\".concat(Math.round(testbed.height)), 20, \"\".concat(scale * 5));\n    }\n\n    function isClicked() {\n      console.log(\"clicked\");\n    }\n\n    function finishTouch() {\n      world.on('post-solve', function (contact) {\n        var fA = contact.getFixtureA(),\n            bA = fA.getBody();\n        var fB = contact.getFixtureB(),\n            bB = fB.getBody();\n        var throwBall = fA.getUserData() === \"ball\" ? bA : fB.getUserData() === \"ball\" ? bB : null;\n        var finishBall = fA.getUserData() === \"finish\" ? bA : fB.getUserData() === \"finish\" ? bB : null;\n        setTimeout(function () {\n          if (throwBall && finishBall) {\n            world.destroyBody(throwBall);\n            console.log(\"\");\n          }\n        }, 1);\n        isClicked();\n      });\n    }\n\n    testbed.step = function () {\n      keylistener();\n      textOut();\n      finishTouch();\n    };\n\n    return world;\n  });\n} // export {level1};\n// export default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy9sZXZlbDEuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFFQTtBQUVPLFNBQVNDLE1BQVQsR0FBa0I7RUFDckJELG9FQUFBLENBQWUsU0FBZixFQUEwQixVQUFVRSxPQUFWLEVBQW1CO0lBQzNDQSxPQUFPLENBQUNDLFVBQVIsR0FBcUIsU0FBckI7SUFDQUQsT0FBTyxDQUFDRSxLQUFSLEdBQWdCLENBQWhCO0lBQ0FGLE9BQU8sQ0FBQ0csS0FBUixHQUFpQkMsVUFBVSxHQUFHLENBQTlCO0lBQ0FKLE9BQU8sQ0FBQ0ssTUFBUixHQUFrQkMsV0FBVyxHQUFHLENBQWhDO0lBQ0FOLE9BQU8sQ0FBQ08sRUFBUixHQUFhLEVBQWI7SUFDQSxJQUFJQyxFQUFFLEdBQUdWLDREQUFUO0lBQUEsSUFBaUJXLElBQUksR0FBR0QsRUFBRSxDQUFDQyxJQUEzQjtJQUNBLElBQUlDLEtBQUssR0FBRyxJQUFJRixFQUFFLENBQUNHLEtBQVAsQ0FBYUYsSUFBSSxDQUFDLENBQUQsRUFBSSxDQUFDLEVBQUwsQ0FBakIsQ0FBWjtJQUNBVCxPQUFPLENBQUNZLFVBQVIsR0FBcUIsSUFBckI7SUFDQSxJQUFJQyxVQUFVLEdBQUcsS0FBakIsQ0FUMkMsQ0FTcEI7SUFDdkI7O0lBRUEsSUFBSUMsS0FBSyxHQUFHLENBQVo7SUFFQSxJQUFJQyxNQUFNLEdBQUdMLEtBQUssQ0FBQ00sVUFBTixFQUFiO0lBQ0FELE1BQU0sQ0FBQ0UsYUFBUCxDQUFxQlQsRUFBRSxDQUFDVSxJQUFILENBQVFULElBQUksQ0FBQyxDQUFDLElBQUYsRUFBUSxHQUFSLENBQVosRUFBMEJBLElBQUksQ0FBQyxJQUFELEVBQU8sR0FBUCxDQUE5QixDQUFyQixFQUFpRSxHQUFqRTtJQUNBTSxNQUFNLENBQUNFLGFBQVAsQ0FBcUJULEVBQUUsQ0FBQ1UsSUFBSCxDQUFRVCxJQUFJLENBQUMsS0FBRCxFQUFRLEdBQVIsQ0FBWixFQUEwQkEsSUFBSSxDQUFDLEtBQUQsRUFBUSxJQUFSLENBQTlCLENBQXJCLEVBQW1FLEdBQW5FO0lBQ0FNLE1BQU0sQ0FBQ0UsYUFBUCxDQUFxQlQsRUFBRSxDQUFDVSxJQUFILENBQVFULElBQUksQ0FBQyxJQUFELEVBQU8sR0FBUCxDQUFaLEVBQXlCQSxJQUFJLENBQUMsS0FBRCxFQUFRLENBQUMsSUFBVCxDQUE3QixDQUFyQixFQUFtRSxHQUFuRTtJQUNBTSxNQUFNLENBQUNFLGFBQVAsQ0FBcUJULEVBQUUsQ0FBQ1UsSUFBSCxDQUFRVCxJQUFJLENBQUMsS0FBRCxFQUFRLENBQUMsSUFBVCxDQUFaLEVBQTRCQSxJQUFJLENBQUMsS0FBRCxFQUFRLENBQUMsSUFBVCxDQUFoQyxDQUFyQixFQUFzRSxHQUF0RTtJQUNBTSxNQUFNLENBQUNFLGFBQVAsQ0FBcUJULEVBQUUsQ0FBQ1UsSUFBSCxDQUFRVCxJQUFJLENBQUMsQ0FBQyxJQUFGLEVBQVEsQ0FBQyxJQUFULENBQVosRUFBNEJBLElBQUksQ0FBQyxLQUFELEVBQVEsQ0FBQyxJQUFULENBQWhDLENBQXJCLEVBQXNFLEdBQXRFO0lBQ0FNLE1BQU0sQ0FBQ0UsYUFBUCxDQUFxQlQsRUFBRSxDQUFDVSxJQUFILENBQVFULElBQUksQ0FBQyxLQUFELEVBQVEsS0FBUixDQUFaLEVBQTRCQSxJQUFJLENBQUMsS0FBRCxFQUFRLENBQUMsSUFBVCxDQUFoQyxDQUFyQixFQUFzRSxHQUF0RTtJQUNBTSxNQUFNLENBQUNFLGFBQVAsQ0FBcUJULEVBQUUsQ0FBQ1UsSUFBSCxDQUFRVCxJQUFJLENBQUMsQ0FBQyxJQUFGLEVBQVEsS0FBUixDQUFaLEVBQTRCQSxJQUFJLENBQUMsQ0FBQyxJQUFGLEVBQVEsQ0FBQyxJQUFULENBQWhDLENBQXJCLEVBQXNFLEdBQXRFO0lBQ0FNLE1BQU0sQ0FBQ0UsYUFBUCxDQUFxQlQsRUFBRSxDQUFDVSxJQUFILENBQVFULElBQUksQ0FBQyxDQUFDLElBQUYsRUFBUSxLQUFSLENBQVosRUFBNEJBLElBQUksQ0FBQyxLQUFELEVBQVEsS0FBUixDQUFoQyxDQUFyQixFQUFzRSxHQUF0RTtJQUVBLElBQUlVLFdBQVcsR0FBRztNQUNoQkMsUUFBUSxFQUFFWCxJQUFJLENBQUMsQ0FBQyxFQUFGLEVBQU0sRUFBTixDQURFO01BRWhCWSxNQUFNLEVBQUUsS0FGUTtNQUdoQkMsVUFBVSxFQUFFLElBSEk7TUFJaEJDLGFBQWEsRUFBRSxHQUpDO01BS2hCQyxjQUFjLEVBQUU7SUFMQSxDQUFsQjtJQVNBLElBQUlDLGFBQWEsR0FBRztNQUNsQkMsUUFBUSxFQUFFLEVBRFE7TUFFbEJDLFdBQVcsRUFBRSxFQUZLO01BRUQ7TUFDakJDLE9BQU8sRUFBRSxFQUhTO01BSWxCQyxRQUFRLEVBQUU7SUFKUSxDQUFwQjtJQU9BLElBQUlDLGNBQWMsR0FBRztNQUNuQkosUUFBUSxFQUFFLEVBRFM7TUFFbkJDLFdBQVcsRUFBRSxFQUZNO01BRUY7TUFDakJDLE9BQU8sRUFBRSxDQUhVO01BSW5CQyxRQUFRLEVBQUU7SUFKUyxDQUFyQjtJQVFBLElBQUlFLEtBQUssR0FBR3JCLEtBQUssQ0FBQ3NCLGlCQUFOLENBQXdCYixXQUF4QixDQUFaO0lBQ0FULEtBQUssQ0FBQ3VCLFdBQU4sQ0FBa0JGLEtBQWxCOztJQUVBLFNBQVNHLFlBQVQsR0FBd0I7TUFDdEIsSUFBSUgsS0FBSyxDQUFDSSxXQUFWLEVBQXVCO1FBQ3JCSixLQUFLLEdBQUdyQixLQUFLLENBQUNzQixpQkFBTixDQUF3QmIsV0FBeEIsQ0FBUjtRQUNBWSxLQUFLLENBQUNkLGFBQU4sQ0FBb0JULEVBQUUsQ0FBQzRCLE1BQUgsQ0FBVSxDQUFWLENBQXBCLEVBQWtDWCxhQUFsQztRQUNBTSxLQUFLLENBQUNNLE1BQU4sR0FBZTtVQUFFQyxPQUFPLEVBQUVDO1FBQVgsQ0FBZjtRQUNBLElBQU1BLEdBQUcsR0FBRyxJQUFJQyxLQUFKLEVBQVo7UUFDQUQsR0FBRyxDQUFDRSxHQUFKLEdBQVUsK0VBQVY7TUFDRDtJQUNGOztJQUVEUCxZQUFZO0lBRVosSUFBTVEsS0FBSyxHQUFHaEMsS0FBSyxDQUFDc0IsaUJBQU4sQ0FBd0JiLFdBQXhCLENBQWQ7SUFDQXVCLEtBQUssQ0FBQ0MsV0FBTixDQUFrQmxDLElBQUksQ0FBQyxFQUFELEVBQUssQ0FBTCxDQUF0QjtJQUNBaUMsS0FBSyxDQUFDekIsYUFBTixDQUFvQlQsRUFBRSxDQUFDNEIsTUFBSCxDQUFVLENBQVYsQ0FBcEIsRUFBa0NYLGFBQWxDO0lBQ0FpQixLQUFLLENBQUNMLE1BQU4sR0FBZTtNQUFFTyxJQUFJLEVBQUUsTUFBUjtNQUFnQkMsTUFBTSxFQUFFO0lBQXhCLENBQWY7SUFHQSxJQUFJQyxLQUFLLEdBQUdwQyxLQUFLLENBQUNNLFVBQU4sQ0FBaUJQLElBQUksQ0FBQyxFQUFELEVBQUksQ0FBQyxFQUFMLENBQXJCLENBQVo7SUFDQXFDLEtBQUssQ0FBQzdCLGFBQU4sQ0FBb0JULEVBQUUsQ0FBQzRCLE1BQUgsQ0FBVSxDQUFWLENBQXBCLEVBQWtDTixjQUFsQztJQUNBZ0IsS0FBSyxDQUFDVCxNQUFOLEdBQWU7TUFBRU8sSUFBSSxFQUFFLEtBQVI7TUFBZUMsTUFBTSxFQUFFO0lBQXZCLENBQWY7SUFFQSxJQUFJRSxDQUFDLEdBQUcsQ0FBUjtJQUNBLElBQUlDLEdBQUcsR0FBR2xELGdFQUFBLENBQVdpRCxDQUFYLEVBQWNBLENBQWQsQ0FBVjtJQUVBLElBQUlHLENBQUMsR0FBR3pDLElBQUksQ0FBQyxHQUFELEVBQU0sQ0FBTixDQUFaO0lBQ0EsSUFBSTBDLENBQUMsR0FBRzFDLElBQUksRUFBWjtJQUNBLElBQUkyQyxNQUFNLEdBQUczQyxJQUFJLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBakI7SUFDQSxJQUFJNEMsTUFBTSxHQUFHNUMsSUFBSSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWpCOztJQUVBLEtBQUssSUFBSTZDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd4QyxLQUFwQixFQUEyQixFQUFFd0MsQ0FBN0IsRUFBZ0M7TUFDOUJILENBQUMsQ0FBQ0ksR0FBRixDQUFNTCxDQUFOO01BQ0V4QyxLQUFLLENBQUNzQixpQkFBTixDQUF3Qm1CLENBQXhCLEVBQTJCbEMsYUFBM0IsQ0FBeUMrQixHQUF6QyxFQUE4QyxHQUE5QztNQUNBRyxDQUFDLENBQUNLLEdBQUYsQ0FBTUgsTUFBTjtNQUNGSCxDQUFDLENBQUNNLEdBQUYsQ0FBTUosTUFBTjtJQUNELENBdEYwQyxDQTRGM0M7OztJQUdBLFNBQVNLLFdBQVQsR0FBdUI7TUFDckI7TUFDQTtNQUVBLElBQUl6RCxPQUFPLENBQUMwRCxVQUFSLENBQW1CQyxLQUF2QixFQUE4QjtRQUM1QixJQUFJQyxZQUFZLENBQUM1RCxPQUFPLENBQUNrRCxDQUFULENBQWhCLEVBQTZCO1VBQUVsRCxPQUFPLENBQUNrRCxDQUFSLElBQWEsQ0FBYjtRQUFnQixDQUEvQyxNQUFxRDtVQUFFbEQsT0FBTyxDQUFDa0QsQ0FBUixHQUFZVyxRQUFRLENBQUNYLENBQXJCO1FBQXdCO01BQ2hGLENBRkQsTUFFTyxJQUFJbEQsT0FBTyxDQUFDMEQsVUFBUixDQUFtQkksSUFBdkIsRUFBNkI7UUFDbEMsSUFBSUYsWUFBWSxDQUFDNUQsT0FBTyxDQUFDa0QsQ0FBVCxDQUFoQixFQUE2QjtVQUFFbEQsT0FBTyxDQUFDa0QsQ0FBUixJQUFhLENBQWI7UUFBZ0IsQ0FBL0MsTUFBcUQ7VUFBRWxELE9BQU8sQ0FBQ2tELENBQVIsR0FBWVcsUUFBUSxDQUFDWCxDQUFyQjtRQUF3QjtNQUNoRixDQUZNLE1BRUEsSUFBSWxELE9BQU8sQ0FBQzBELFVBQVIsQ0FBbUJLLEVBQXZCLEVBQTJCO1FBQ2hDLElBQUlDLFlBQVksQ0FBQ2hFLE9BQU8sQ0FBQ21ELENBQVQsQ0FBaEIsRUFBNkI7VUFBRW5ELE9BQU8sQ0FBQ21ELENBQVIsSUFBYSxDQUFiO1FBQWdCLENBQS9DLE1BQXFEO1VBQUVuRCxPQUFPLENBQUNtRCxDQUFSLEdBQVlVLFFBQVEsQ0FBQ1YsQ0FBckI7UUFBd0I7TUFDaEYsQ0FGTSxNQUVBLElBQUluRCxPQUFPLENBQUMwRCxVQUFSLENBQW1CTyxJQUF2QixFQUE2QjtRQUNsQyxJQUFJRCxZQUFZLENBQUNoRSxPQUFPLENBQUNtRCxDQUFULENBQWhCLEVBQTZCO1VBQUVuRCxPQUFPLENBQUNtRCxDQUFSLElBQWEsQ0FBYjtRQUFnQixDQUEvQyxNQUFxRDtVQUFFbkQsT0FBTyxDQUFDbUQsQ0FBUixHQUFZVSxRQUFRLENBQUNWLENBQXJCO1FBQXdCO01BQ2hGLENBRk0sTUFFQSxJQUFJbkQsT0FBTyxDQUFDMEQsVUFBUixDQUFtQlEsQ0FBdkIsRUFBMEI7UUFDL0JsRSxPQUFPLENBQUNtRSxXQUFSO01BQ0QsQ0FGTSxNQUVBLElBQUluRSxPQUFPLENBQUMwRCxVQUFSLENBQW1CVSxJQUF2QixFQUE2QjtRQUFFbEMsWUFBWTtNQUFJO0lBRXZEOztJQUVELElBQUkyQixRQUFRLEdBQUc5QixLQUFLLENBQUNzQyxXQUFOLEVBQWY7O0lBRUEsU0FBU1QsWUFBVCxDQUFzQlUsSUFBdEIsRUFBNEI7TUFDMUIsSUFBS3RFLE9BQU8sQ0FBQ2tELENBQVIsR0FBYWxELE9BQU8sQ0FBQ0csS0FBUixHQUFnQixFQUE3QixHQUFtQzBELFFBQVEsQ0FBQ1gsQ0FBN0MsSUFBb0RsRCxPQUFPLENBQUNrRCxDQUFSLEdBQWFsRCxPQUFPLENBQUNHLEtBQVIsR0FBZ0IsRUFBN0IsR0FBbUMwRCxRQUFRLENBQUNYLENBQXBHLEVBQXdHO1FBQUUsT0FBTyxJQUFQO01BQWEsQ0FBdkgsTUFBNkg7UUFBRSxPQUFPLEtBQVA7TUFBYztJQUM5STs7SUFFRCxTQUFTYyxZQUFULENBQXNCTyxJQUF0QixFQUE0QjtNQUMxQixJQUFLdkUsT0FBTyxDQUFDbUQsQ0FBUixHQUFhbkQsT0FBTyxDQUFDSyxNQUFSLEdBQWlCLEVBQTlCLEdBQW9Dd0QsUUFBUSxDQUFDVixDQUE5QyxJQUFxRG5ELE9BQU8sQ0FBQ21ELENBQVIsR0FBY25ELE9BQU8sQ0FBQ0ssTUFBVCxHQUFvQixFQUFqQyxHQUF1Q3dELFFBQVEsQ0FBQ1YsQ0FBekcsRUFBNkc7UUFBRSxPQUFPLElBQVA7TUFBYSxDQUE1SCxNQUFrSTtRQUFFLE9BQU8sS0FBUDtNQUFjO0lBQ25KOztJQUVELFNBQVNxQixPQUFULEdBQW1CO01BQ2pCLElBQUlDLEtBQUssR0FBRyxFQUFaO01BQ0EsSUFBSUMsT0FBTyxHQUFHM0MsS0FBSyxDQUFDc0MsV0FBTixFQUFkO01BQ0FNLFFBQVEsQ0FBQ0MsU0FBVCxDQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QkMsT0FBTyxDQUFDMUUsS0FBakMsRUFBd0MwRSxPQUFPLENBQUN4RSxNQUFoRDtNQUNBc0UsUUFBUSxDQUFDRyxJQUFULGFBQW1CTCxLQUFuQjtNQUNBRSxRQUFRLENBQUNJLFNBQVQsR0FBcUIsTUFBckI7TUFDQUosUUFBUSxDQUFDSyxRQUFULG1CQUE2QkMsSUFBSSxDQUFDQyxLQUFMLENBQVdSLE9BQU8sQ0FBQ3hCLENBQW5CLENBQTdCLEdBQXNELEVBQXRELFlBQTZEdUIsS0FBN0Q7TUFDQUUsUUFBUSxDQUFDSyxRQUFULGtCQUE0QkMsSUFBSSxDQUFDQyxLQUFMLENBQVdSLE9BQU8sQ0FBQ3ZCLENBQW5CLENBQTVCLEdBQXFELEVBQXJELFlBQTREc0IsS0FBSyxHQUFHLENBQXBFO01BQ0FFLFFBQVEsQ0FBQ0ssUUFBVCwyQkFBcUNDLElBQUksQ0FBQ0MsS0FBTCxDQUFXbEYsT0FBTyxDQUFDa0QsQ0FBbkIsQ0FBckMsR0FBOEQsRUFBOUQsWUFBcUV1QixLQUFLLEdBQUcsQ0FBN0U7TUFDQUUsUUFBUSxDQUFDSyxRQUFULDJCQUFxQ0MsSUFBSSxDQUFDQyxLQUFMLENBQVdsRixPQUFPLENBQUNtRCxDQUFuQixDQUFyQyxHQUE4RCxFQUE5RCxZQUFxRXNCLEtBQUssR0FBRyxDQUE3RTtNQUNBRSxRQUFRLENBQUNLLFFBQVQsbUJBQTZCaEYsT0FBTyxDQUFDbUYsUUFBUixFQUE3QixHQUFtRCxHQUFuRCxZQUEyRFYsS0FBM0Q7TUFDQUUsUUFBUSxDQUFDSyxRQUFULDRCQUFzQ2pELEtBQUssQ0FBQ0ksV0FBNUMsR0FBMkQsR0FBM0QsWUFBbUVzQyxLQUFLLEdBQUcsQ0FBM0U7TUFDQUUsUUFBUSxDQUFDSyxRQUFULDZCQUF1Q0MsSUFBSSxDQUFDQyxLQUFMLENBQVdsRixPQUFPLENBQUNLLE1BQW5CLENBQXZDLEdBQXFFLEVBQXJFLFlBQTRFb0UsS0FBSyxHQUFHLENBQXBGO0lBRUQ7O0lBRUQsU0FBU1csU0FBVCxHQUFvQjtNQUNsQkMsT0FBTyxDQUFDQyxHQUFSLENBQVksU0FBWjtJQUNEOztJQUlELFNBQVNDLFdBQVQsR0FBdUI7TUFDckI3RSxLQUFLLENBQUM4RSxFQUFOLENBQVMsWUFBVCxFQUF1QixVQUFVQyxPQUFWLEVBQW1CO1FBQ3hDLElBQUlDLEVBQUUsR0FBR0QsT0FBTyxDQUFDRSxXQUFSLEVBQVQ7UUFBQSxJQUFnQ0MsRUFBRSxHQUFHRixFQUFFLENBQUNHLE9BQUgsRUFBckM7UUFDQSxJQUFJQyxFQUFFLEdBQUdMLE9BQU8sQ0FBQ00sV0FBUixFQUFUO1FBQUEsSUFBZ0NDLEVBQUUsR0FBR0YsRUFBRSxDQUFDRCxPQUFILEVBQXJDO1FBQ0EsSUFBSUksU0FBUyxHQUFHUCxFQUFFLENBQUNRLFdBQUgsT0FBcUIsTUFBckIsR0FBOEJOLEVBQTlCLEdBQW1DRSxFQUFFLENBQUNJLFdBQUgsT0FBcUIsTUFBckIsR0FBOEJGLEVBQTlCLEdBQW1DLElBQXRGO1FBQ0EsSUFBSUcsVUFBVSxHQUFHVCxFQUFFLENBQUNRLFdBQUgsT0FBcUIsUUFBckIsR0FBZ0NOLEVBQWhDLEdBQXFDRSxFQUFFLENBQUNJLFdBQUgsT0FBcUIsUUFBckIsR0FBZ0NGLEVBQWhDLEdBQXFDLElBQTNGO1FBQ0FJLFVBQVUsQ0FBQyxZQUFZO1VBQUUsSUFBSUgsU0FBUyxJQUFJRSxVQUFqQixFQUE2QjtZQUFFekYsS0FBSyxDQUFDdUIsV0FBTixDQUFrQmdFLFNBQWxCO1lBQThCWixPQUFPLENBQUNDLEdBQVIsQ0FBWSxFQUFaO1VBQWlCO1FBQUUsQ0FBL0YsRUFBaUcsQ0FBakcsQ0FBVjtRQUNBRixTQUFTO01BQ1YsQ0FQRDtJQVFEOztJQU1EcEYsT0FBTyxDQUFDcUcsSUFBUixHQUFlLFlBQVk7TUFDekI1QyxXQUFXO01BQ1hlLE9BQU87TUFDUGUsV0FBVztJQUNaLENBSkQ7O0lBTU4sT0FBTzdFLEtBQVA7RUFDSyxDQXZLRDtBQXdLRCxFQUdIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXN0LXJlcG8vLi9zcmMvc2NyaXB0cy9sZXZlbDEuanM/NmZlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL2xldmVsMXRyaWFsXG5cbmltcG9ydCAqIGFzIHBsYW5jayBmcm9tICdwbGFuY2svZGlzdC9wbGFuY2std2l0aC10ZXN0YmVkJ1xuXG5leHBvcnQgZnVuY3Rpb24gbGV2ZWwxKCkge1xuICAgIHBsYW5jay50ZXN0YmVkKCdTYW5kYm94JywgZnVuY3Rpb24gKHRlc3RiZWQpIHtcbiAgICAgIHRlc3RiZWQuYmFja2dyb3VuZCA9IFwiIzExMTExMVwiXG4gICAgICB0ZXN0YmVkLnNwZWVkID0gMlxuICAgICAgdGVzdGJlZC53aWR0aCA9IChpbm5lcldpZHRoIC8gNCk7XG4gICAgICB0ZXN0YmVkLmhlaWdodCA9IChpbm5lckhlaWdodCAvIDQpO1xuICAgICAgdGVzdGJlZC5oeiA9IDMwO1xuICAgICAgbGV0IHBsID0gcGxhbmNrLCBWZWMyID0gcGwuVmVjMjtcbiAgICAgIGxldCB3b3JsZCA9IG5ldyBwbC5Xb3JsZChWZWMyKDAsIC0xMCkpO1xuICAgICAgdGVzdGJlZC5tb3VzZUZvcmNlID0gNjAwMDsgXG4gICAgICBsZXQgbGV2ZWxzY29yZSA9IDEwMDAwIC8vIDEwSyB0ZW5hdGl2ZVxuICAgICAgLy8gdHVybnMgb24vb2ZmIGltcHVsc2VzIHRvIGFwcGx5IGxpa2Ugc2xpbmdzaG90XG5cbiAgICAgIGxldCBDT1VOVCA9IDQ7XG5cbiAgICAgIGxldCBncm91bmQgPSB3b3JsZC5jcmVhdGVCb2R5KCk7XG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoLTgwLjAsIDAuMCksIFZlYzIoNjAuMCwgMC4wKSksIDAuMCk7XG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoMTAwLjAsIDAuMCksIFZlYzIoMjAwLjAsIDIwLjApKSwgMC4wKTtcbiAgICAgIGdyb3VuZC5jcmVhdGVGaXh0dXJlKHBsLkVkZ2UoVmVjMig2MC4wLCAwLjApLCBWZWMyKDEzMC4wLCAtMzAuMCkpLCAwLjApO1xuICAgICAgZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuRWRnZShWZWMyKDIwMC4wLCAtMzAuMCksIFZlYzIoMTIwLjAsIC04MC4wKSksIDAuMCk7XG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoLTgwLjAsIC04MC4wKSwgVmVjMigyMDAuMCwgLTgwLjApKSwgMC4wKTtcbiAgICAgIGdyb3VuZC5jcmVhdGVGaXh0dXJlKHBsLkVkZ2UoVmVjMigyMDAuMCwgMTUwLjApLCBWZWMyKDIwMC4wLCAtODAuMCkpLCAwLjApO1xuICAgICAgZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuRWRnZShWZWMyKC04MC4wLCAxNTAuMCksIFZlYzIoLTgwLjAsIC04MC4wKSksIDAuMCk7XG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoLTgwLjAsIDE1MC4wKSwgVmVjMigyMDAuMCwgMTUwLjApKSwgMC4wKTtcblxuICAgICAgbGV0IGJhbGxCb2R5RGVmID0ge1xuICAgICAgICBwb3NpdGlvbjogVmVjMigtNTAsIDEwKSxcbiAgICAgICAgYnVsbGV0OiBmYWxzZSxcbiAgICAgICAgYWxsb3dTbGVlcDogdHJ1ZSxcbiAgICAgICAgbGluZWFyRGFtcGluZzogLjAxLFxuICAgICAgICBhbmd1bGFyRGFtcGluZzogLjVcbiAgICAgIH1cblxuXG4gICAgICBsZXQgYmFsbFN0YXJ0QXR0ciA9IHtcbiAgICAgICAgZnJpY3Rpb246IC4xLFxuICAgICAgICByZXN0aXR1dGlvbjogLjUsIC8vIGJvdW5jZVxuICAgICAgICBkZW5zaXR5OiAxMCxcbiAgICAgICAgdXNlckRhdGE6ICdiYWxsJ1xuICAgICAgfTtcblxuICAgICAgbGV0IGJhbGxGaW5pc2hBdHRyID0ge1xuICAgICAgICBmcmljdGlvbjogLjIsXG4gICAgICAgIHJlc3RpdHV0aW9uOiAuMSwgLy8gYm91bmNlXG4gICAgICAgIGRlbnNpdHk6IDEsXG4gICAgICAgIHVzZXJEYXRhOiAnZmluaXNoJ1xuICAgICAgfTtcblxuXG4gICAgICBsZXQgYmFsbDEgPSB3b3JsZC5jcmVhdGVEeW5hbWljQm9keShiYWxsQm9keURlZik7XG4gICAgICB3b3JsZC5kZXN0cm95Qm9keShiYWxsMSlcblxuICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVTaG90KCkge1xuICAgICAgICBpZiAoYmFsbDEubV9kZXN0cm95ZWQpIHtcbiAgICAgICAgICBiYWxsMSA9IHdvcmxkLmNyZWF0ZUR5bmFtaWNCb2R5KGJhbGxCb2R5RGVmKTtcbiAgICAgICAgICBiYWxsMS5jcmVhdGVGaXh0dXJlKHBsLkNpcmNsZSgxKSwgYmFsbFN0YXJ0QXR0cik7XG4gICAgICAgICAgYmFsbDEucmVuZGVyID0geyB0ZXh0dXJlOiBpbWcgfTtcbiAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKVxuICAgICAgICAgIGltZy5zcmMgPSBcImh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvMi8yNy9XZXlfc291cmNlX2ZhcnJpbmdkb24uanBnXCJcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZW5lcmF0ZVNob3QoKVxuXG4gICAgICBjb25zdCBiYWxsMyA9IHdvcmxkLmNyZWF0ZUR5bmFtaWNCb2R5KGJhbGxCb2R5RGVmKTtcbiAgICAgIGJhbGwzLnNldFBvc2l0aW9uKFZlYzIoMzAsIDIpKVxuICAgICAgYmFsbDMuY3JlYXRlRml4dHVyZShwbC5DaXJjbGUoMSksIGJhbGxTdGFydEF0dHIpO1xuICAgICAgYmFsbDMucmVuZGVyID0geyBmaWxsOiAnYmx1ZScsIHN0cm9rZTogJ2JsdWUnIH07XG5cblxuICAgICAgbGV0IGJhbGwyID0gd29ybGQuY3JlYXRlQm9keShWZWMyKDQwLC03OCkpO1xuICAgICAgYmFsbDIuY3JlYXRlRml4dHVyZShwbC5DaXJjbGUoMSksIGJhbGxGaW5pc2hBdHRyKTtcbiAgICAgIGJhbGwyLnJlbmRlciA9IHsgZmlsbDogJ3JlZCcsIHN0cm9rZTogJ3JlZCcgfTtcblxuICAgICAgbGV0IGEgPSAyO1xuICAgICAgbGV0IGJveCA9IHBsYW5jay5Cb3goYSwgYSk7XG5cbiAgICAgIGxldCB4ID0gVmVjMig4LjAsIDgpO1xuICAgICAgbGV0IHkgPSBWZWMyKCk7XG4gICAgICBsZXQgZGVsdGFYID0gVmVjMigwLCA0KTtcbiAgICAgIGxldCBkZWx0YVkgPSBWZWMyKDAsIDQpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENPVU5UOyArK2kpIHtcbiAgICAgICAgeS5zZXQoeCk7XG4gICAgICAgICAgd29ybGQuY3JlYXRlRHluYW1pY0JvZHkoeSkuY3JlYXRlRml4dHVyZShib3gsIDUuMCk7XG4gICAgICAgICAgeS5hZGQoZGVsdGFZKTtcbiAgICAgICAgeC5hZGQoZGVsdGFYKTtcbiAgICAgIH1cblxuXG5cblxuXG4gICAgICAvLyBiYWxsMS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4geyBpc0NsaWNrZWQoKTsgfSApXG5cblxuICAgICAgZnVuY3Rpb24ga2V5bGlzdGVuZXIoKSB7XG4gICAgICAgIC8vdGhlcmUgaXMgcHJvYmFibHkgYSB3YXkgdG8gZG8gdGhpcyB3aXRoIGEgY2FzZSBzdGF0ZW1lbnRcbiAgICAgICAgLy9jYW1lcmFcblxuICAgICAgICBpZiAodGVzdGJlZC5hY3RpdmVLZXlzLnJpZ2h0KSB7XG4gICAgICAgICAgaWYgKGNhbWVyYUxpbWl0WCh0ZXN0YmVkLngpKSB7IHRlc3RiZWQueCArPSAyIH0gZWxzZSB7IHRlc3RiZWQueCA9IGJhbGwxcG9zLnggfVxuICAgICAgICB9IGVsc2UgaWYgKHRlc3RiZWQuYWN0aXZlS2V5cy5sZWZ0KSB7XG4gICAgICAgICAgaWYgKGNhbWVyYUxpbWl0WCh0ZXN0YmVkLngpKSB7IHRlc3RiZWQueCAtPSAyIH0gZWxzZSB7IHRlc3RiZWQueCA9IGJhbGwxcG9zLnggfVxuICAgICAgICB9IGVsc2UgaWYgKHRlc3RiZWQuYWN0aXZlS2V5cy51cCkge1xuICAgICAgICAgIGlmIChjYW1lcmFMaW1pdFkodGVzdGJlZC55KSkgeyB0ZXN0YmVkLnkgLT0gMiB9IGVsc2UgeyB0ZXN0YmVkLnkgPSBiYWxsMXBvcy55IH1cbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0YmVkLmFjdGl2ZUtleXMuZG93bikge1xuICAgICAgICAgIGlmIChjYW1lcmFMaW1pdFkodGVzdGJlZC55KSkgeyB0ZXN0YmVkLnkgKz0gMiB9IGVsc2UgeyB0ZXN0YmVkLnkgPSBiYWxsMXBvcy55IH1cbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0YmVkLmFjdGl2ZUtleXMuQykge1xuICAgICAgICAgIHRlc3RiZWQudG9nZ2xlUGF1c2UoKVxuICAgICAgICB9IGVsc2UgaWYgKHRlc3RiZWQuYWN0aXZlS2V5cy5maXJlKSB7IGdlbmVyYXRlU2hvdCgpIH1cblxuICAgICAgfVxuXG4gICAgICBsZXQgYmFsbDFwb3MgPSBiYWxsMS5nZXRQb3NpdGlvbigpXG5cbiAgICAgIGZ1bmN0aW9uIGNhbWVyYUxpbWl0WCh4UG9zKSB7XG4gICAgICAgIGlmICgodGVzdGJlZC54ICsgKHRlc3RiZWQud2lkdGggKiAuNCkgPiBiYWxsMXBvcy54KSAmJiAodGVzdGJlZC54IC0gKHRlc3RiZWQud2lkdGggKiAuNCkgPCBiYWxsMXBvcy54KSkgeyByZXR1cm4gdHJ1ZSB9IGVsc2UgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW1lcmFMaW1pdFkoeVBvcykge1xuICAgICAgICBpZiAoKHRlc3RiZWQueSArICh0ZXN0YmVkLmhlaWdodCAqIC40KSA+IGJhbGwxcG9zLnkpICYmICh0ZXN0YmVkLnkgLSAoKHRlc3RiZWQuaGVpZ2h0ICkgKiAuNikgPCBiYWxsMXBvcy55KSkgeyByZXR1cm4gdHJ1ZSB9IGVsc2UgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXh0T3V0KCkge1xuICAgICAgICBsZXQgc2NhbGUgPSAyMFxuICAgICAgICBsZXQgYmFsbHBvcyA9IGJhbGwxLmdldFBvc2l0aW9uKClcbiAgICAgICAgY29udGV4dDIuY2xlYXJSZWN0KDAsIDAsIGNhbnZhczEud2lkdGgsIGNhbnZhczEuaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dDIuZm9udCA9IGAke3NjYWxlfXB4IENvdXJpZXIgTmV3YDtcbiAgICAgICAgY29udGV4dDIuZmlsbFN0eWxlID0gJ2JsdWUnO1xuICAgICAgICBjb250ZXh0Mi5maWxsVGV4dChgWCBQT1MgOiAke01hdGgucm91bmQoYmFsbHBvcy54KX1gLCAyMCwgYCR7c2NhbGV9YCk7XG4gICAgICAgIGNvbnRleHQyLmZpbGxUZXh0KGBZIFBPUyA6JHtNYXRoLnJvdW5kKGJhbGxwb3MueSl9YCwgMjAsIGAke3NjYWxlICogMn1gKTtcbiAgICAgICAgY29udGV4dDIuZmlsbFRleHQoYHRlc3RiZWQgWCBQT1MgOiAke01hdGgucm91bmQodGVzdGJlZC54KX1gLCAyMCwgYCR7c2NhbGUgKiAzfWApO1xuICAgICAgICBjb250ZXh0Mi5maWxsVGV4dChgdGVzdGJlZCBZIFBPUyA6ICR7TWF0aC5yb3VuZCh0ZXN0YmVkLnkpfWAsIDIwLCBgJHtzY2FsZSAqIDR9YCk7XG4gICAgICAgIGNvbnRleHQyLmZpbGxUZXh0KGBQYXVzZSA6ICR7dGVzdGJlZC5pc1BhdXNlZCgpfWAsIDI1MCwgYCR7c2NhbGV9YCk7XG4gICAgICAgIGNvbnRleHQyLmZpbGxUZXh0KGBTaG90IGRlc3Ryb3llZCA6ICR7YmFsbDEubV9kZXN0cm95ZWR9YCwgMjUwLCBgJHtzY2FsZSAqIDJ9YCk7XG4gICAgICAgIGNvbnRleHQyLmZpbGxUZXh0KGB0ZXN0YmVkIFkgaGVpZ2h0IDoke01hdGgucm91bmQodGVzdGJlZC5oZWlnaHQpfWAsIDIwLCBgJHtzY2FsZSAqIDV9YCk7XG5cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNDbGlja2VkKCl7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiY2xpY2tlZFwiKVxuICAgICAgfVxuXG5cblxuICAgICAgZnVuY3Rpb24gZmluaXNoVG91Y2goKSB7XG4gICAgICAgIHdvcmxkLm9uKCdwb3N0LXNvbHZlJywgZnVuY3Rpb24gKGNvbnRhY3QpIHtcbiAgICAgICAgICBsZXQgZkEgPSBjb250YWN0LmdldEZpeHR1cmVBKCksIGJBID0gZkEuZ2V0Qm9keSgpO1xuICAgICAgICAgIGxldCBmQiA9IGNvbnRhY3QuZ2V0Rml4dHVyZUIoKSwgYkIgPSBmQi5nZXRCb2R5KCk7XG4gICAgICAgICAgbGV0IHRocm93QmFsbCA9IGZBLmdldFVzZXJEYXRhKCkgPT09IFwiYmFsbFwiID8gYkEgOiBmQi5nZXRVc2VyRGF0YSgpID09PSBcImJhbGxcIiA/IGJCIDogbnVsbDtcbiAgICAgICAgICBsZXQgZmluaXNoQmFsbCA9IGZBLmdldFVzZXJEYXRhKCkgPT09IFwiZmluaXNoXCIgPyBiQSA6IGZCLmdldFVzZXJEYXRhKCkgPT09IFwiZmluaXNoXCIgPyBiQiA6IG51bGw7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGlmICh0aHJvd0JhbGwgJiYgZmluaXNoQmFsbCkgeyB3b3JsZC5kZXN0cm95Qm9keSh0aHJvd0JhbGwpOyBjb25zb2xlLmxvZyhcIlwiKSB9IH0sIDEpO1xuICAgICAgICAgIGlzQ2xpY2tlZCgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG5cblxuXG5cbiAgICAgIHRlc3RiZWQuc3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAga2V5bGlzdGVuZXIoKVxuICAgICAgICB0ZXh0T3V0KClcbiAgICAgICAgZmluaXNoVG91Y2goKVxuICAgICAgfTtcblxucmV0dXJuIHdvcmxkXG4gICAgfSk7XG4gIH1cblxuXG4vLyBleHBvcnQge2xldmVsMX07XG4vLyBleHBvcnQgZGVmYXVsdDsiXSwibmFtZXMiOlsicGxhbmNrIiwibGV2ZWwxIiwidGVzdGJlZCIsImJhY2tncm91bmQiLCJzcGVlZCIsIndpZHRoIiwiaW5uZXJXaWR0aCIsImhlaWdodCIsImlubmVySGVpZ2h0IiwiaHoiLCJwbCIsIlZlYzIiLCJ3b3JsZCIsIldvcmxkIiwibW91c2VGb3JjZSIsImxldmVsc2NvcmUiLCJDT1VOVCIsImdyb3VuZCIsImNyZWF0ZUJvZHkiLCJjcmVhdGVGaXh0dXJlIiwiRWRnZSIsImJhbGxCb2R5RGVmIiwicG9zaXRpb24iLCJidWxsZXQiLCJhbGxvd1NsZWVwIiwibGluZWFyRGFtcGluZyIsImFuZ3VsYXJEYW1waW5nIiwiYmFsbFN0YXJ0QXR0ciIsImZyaWN0aW9uIiwicmVzdGl0dXRpb24iLCJkZW5zaXR5IiwidXNlckRhdGEiLCJiYWxsRmluaXNoQXR0ciIsImJhbGwxIiwiY3JlYXRlRHluYW1pY0JvZHkiLCJkZXN0cm95Qm9keSIsImdlbmVyYXRlU2hvdCIsIm1fZGVzdHJveWVkIiwiQ2lyY2xlIiwicmVuZGVyIiwidGV4dHVyZSIsImltZyIsIkltYWdlIiwic3JjIiwiYmFsbDMiLCJzZXRQb3NpdGlvbiIsImZpbGwiLCJzdHJva2UiLCJiYWxsMiIsImEiLCJib3giLCJCb3giLCJ4IiwieSIsImRlbHRhWCIsImRlbHRhWSIsImkiLCJzZXQiLCJhZGQiLCJrZXlsaXN0ZW5lciIsImFjdGl2ZUtleXMiLCJyaWdodCIsImNhbWVyYUxpbWl0WCIsImJhbGwxcG9zIiwibGVmdCIsInVwIiwiY2FtZXJhTGltaXRZIiwiZG93biIsIkMiLCJ0b2dnbGVQYXVzZSIsImZpcmUiLCJnZXRQb3NpdGlvbiIsInhQb3MiLCJ5UG9zIiwidGV4dE91dCIsInNjYWxlIiwiYmFsbHBvcyIsImNvbnRleHQyIiwiY2xlYXJSZWN0IiwiY2FudmFzMSIsImZvbnQiLCJmaWxsU3R5bGUiLCJmaWxsVGV4dCIsIk1hdGgiLCJyb3VuZCIsImlzUGF1c2VkIiwiaXNDbGlja2VkIiwiY29uc29sZSIsImxvZyIsImZpbmlzaFRvdWNoIiwib24iLCJjb250YWN0IiwiZkEiLCJnZXRGaXh0dXJlQSIsImJBIiwiZ2V0Qm9keSIsImZCIiwiZ2V0Rml4dHVyZUIiLCJiQiIsInRocm93QmFsbCIsImdldFVzZXJEYXRhIiwiZmluaXNoQmFsbCIsInNldFRpbWVvdXQiLCJzdGVwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scripts/level1.js\n");

/***/ }),

/***/ "./src/scripts/level2.js":
/*!*******************************!*\
  !*** ./src/scripts/level2.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"level2\": function() { return /* binding */ level2; }\n/* harmony export */ });\n/* harmony import */ var planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! planck/dist/planck-with-testbed */ \"./node_modules/planck/dist/planck-with-testbed.js\");\n/* harmony import */ var planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__);\n//level1trial\n\nfunction level2() {\n  planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__.testbed('Sandbox', function (testbed) {\n    // window.canvas = canvas\n    testbed.background = \"#111111\";\n    window.planck = planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__;\n    window.testbed = testbed; //currently doesnt work\n\n    testbed.speed = 2;\n    testbed.width = innerWidth / 4;\n    testbed.height = innerHeight / 4;\n    testbed.hz = 30;\n    var pl = planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__,\n        Vec2 = pl.Vec2;\n    var world = new pl.World(Vec2(0, -10));\n    var breakout1 = false;\n    window.breakout1 = breakout1; // testbed.mouseForce = 6000; \n    // turns on/off impulses to apply like slingshot\n\n    var COUNT = 4;\n    var ground = world.createBody();\n    ground.createFixture(pl.Edge(Vec2(-80.0, -80.0), Vec2(200.0, -80.0)), 0.0);\n    ground.createFixture(pl.Edge(Vec2(200.0, 150.0), Vec2(200.0, -80.0)), 0.0);\n    ground.createFixture(pl.Edge(Vec2(-80.0, 150.0), Vec2(-80.0, -80.0)), 0.0);\n    ground.createFixture(pl.Edge(Vec2(-80.0, 150.0), Vec2(200.0, 150.0)), 0.0);\n    ground.createFixture(pl.Edge(Vec2(80.0, 30.0), Vec2(200.0, 0.0)), {\n      restitution: 60\n    }).render = {\n      fill: 'blue',\n      stroke: 'blue'\n    };\n    ;\n    ground.createFixture(pl.Edge(Vec2(80.0, 30.0), Vec2(200.0, 50.0)), {\n      restitution: 60\n    }).render = {\n      fill: 'blue',\n      stroke: 'blue'\n    };\n    ;\n    ground.createFixture(pl.Edge(Vec2(80.0, 30.0), Vec2(80.0, -40.0)), 0.0);\n    ;\n    ground.createFixture(pl.Edge(Vec2(100.0, -80.0), Vec2(200.0, -20.0)), {\n      restitution: 60\n    }).render = {\n      fill: 'blue',\n      stroke: 'blue'\n    };\n    ; // ground.createFixture(pl.Circle(Vec2(100.0, -80.0), 10), { restitution: 60 }).render = {fill: 'blue', stroke: 'blue'}; // bouncy\n    // ground.createFixture(pl.Circle(Vec2(200.0, -40.0), 10), { restitution: 60 }).render = { fill: 'blue', stroke: 'blue' }; // bouncy\n    // ground.createFixture(pl.Box(50, 5, Vec2(150, -60), 60), {restitution: 60}).render = { fill: 'blue', stroke: 'blue' };\n    // .render = { fill: 'blue', stroke: 'blue' }; // bouncy\n\n    var ballBodyDef = {\n      position: Vec2(70, -40),\n      bullet: false,\n      allowSleep: true,\n      linearDamping: .01,\n      angularDamping: .5\n    };\n    var ballStartAttr = {\n      friction: .1,\n      restitution: .5,\n      // bounce\n      density: 10,\n      userData: 'ball'\n    };\n    var ballFinishAttr = {\n      friction: .2,\n      restitution: .1,\n      // bounce\n      density: 1,\n      userData: 'finish'\n    };\n    var ball1 = world.createDynamicBody(ballBodyDef);\n    world.destroyBody(ball1);\n\n    function generateShot() {\n      if (ball1.m_destroyed) {\n        ball1 = world.createDynamicBody(ballBodyDef);\n        ball1.createFixture(pl.Circle(1), ballStartAttr);\n        ball1.render = {\n          texture: img\n        };\n        var img = new Image();\n        img.src = \"https://upload.wikimedia.org/wikipedia/commons/2/27/Wey_source_farringdon.jpg\";\n      }\n    }\n\n    generateShot();\n    var ball3 = world.createDynamicBody(ballBodyDef);\n    ball3.setPosition(Vec2(30, 2));\n    ball3.createFixture(pl.Circle(1), ballStartAttr);\n    ball3.render = {\n      fill: 'blue',\n      stroke: 'blue'\n    };\n    var ball2 = world.createBody(Vec2(82, -25));\n    ball2.createFixture(pl.Circle(1), ballFinishAttr);\n    ball2.render = {\n      fill: 'red',\n      stroke: 'red'\n    };\n    window.pl = pl;\n    window.world = world;\n    console.log(\"white ball = ball1 \", ball1);\n    window.ball1 = ball1;\n    console.log(\"red ball = ball2 \", ball2);\n    window.ball2 = ball2;\n    console.log(\"blue ball = ball3 \", ball3);\n    window.ball3 = ball3;\n    var a = 2;\n    var box = planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__.Box(a, a);\n    var x = Vec2(8.0, 8);\n    var y = Vec2();\n    var deltaX = Vec2(0, 4);\n    var deltaY = Vec2(0, 4);\n\n    for (var i = 0; i < COUNT; ++i) {\n      y.set(x);\n      world.createDynamicBody(y).createFixture(box, 5.0);\n      y.add(deltaY);\n      x.add(deltaX);\n    }\n\n    function keylistener() {\n      //there is probably a way to do this with a case statement\n      //camera\n      if (testbed.activeKeys.right) {\n        if (cameraLimitX(testbed.x)) {\n          testbed.x += 2;\n        } else {\n          testbed.x = ball1pos.x;\n        }\n      } else if (testbed.activeKeys.left) {\n        if (cameraLimitX(testbed.x)) {\n          testbed.x -= 2;\n        } else {\n          testbed.x = ball1pos.x;\n        }\n      } else if (testbed.activeKeys.up) {\n        if (cameraLimitY(testbed.y)) {\n          testbed.y -= 2;\n        } else {\n          testbed.y = ball1pos.y;\n        }\n      } else if (testbed.activeKeys.down) {\n        if (cameraLimitY(testbed.y)) {\n          testbed.y += 2;\n        } else {\n          testbed.y = ball1pos.y;\n        }\n      } else if (testbed.activeKeys.C) {\n        testbed.togglePause();\n      } else if (testbed.activeKeys.fire) {\n        generateShot();\n      }\n    }\n\n    var ball1pos = ball1.getPosition();\n\n    function cameraLimitX(xPos) {\n      if (testbed.x + testbed.width * .4 > ball1pos.x && testbed.x - testbed.width * .4 < ball1pos.x) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    function cameraLimitY(yPos) {\n      if (testbed.y + testbed.height * .4 > ball1pos.y && testbed.y - (testbed.height + canvas1.height) * .4 < ball1pos.y) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    function textOut() {\n      var scale = 20;\n      var ballpos = ball1.getPosition();\n      context2.clearRect(0, 0, canvas1.width, canvas1.height);\n      context2.font = \"\".concat(scale, \"px Courier New\");\n      context2.fillStyle = 'blue';\n      context2.fillText(\"X POS : \".concat(Math.round(ballpos.x)), 20, \"\".concat(scale));\n      context2.fillText(\"Y POS :\".concat(Math.round(ballpos.y)), 20, \"\".concat(scale * 2));\n      context2.fillText(\"testbed X POS : \".concat(Math.round(testbed.x)), 20, \"\".concat(scale * 3));\n      context2.fillText(\"testbed Y POS : \".concat(Math.round(testbed.y)), 20, \"\".concat(scale * 4));\n      context2.fillText(\"testbed Y height :\".concat(Math.round(testbed.height)), 20, \"\".concat(scale * 5));\n      context2.fillText(\"Pause : \".concat(testbed.isPaused()), 250, \"\".concat(scale));\n      context2.fillText(\"Shot destroyed : \".concat(ball1.m_destroyed), 250, \"\".concat(scale * 2));\n    }\n\n    function finishTouch() {\n      world.on('post-solve', function (contact) {\n        var fA = contact.getFixtureA(),\n            bA = fA.getBody();\n        var fB = contact.getFixtureB(),\n            bB = fB.getBody();\n        var throwBall = fA.getUserData() === \"ball\" ? bA : fB.getUserData() === \"ball\" ? bB : null;\n        var finishBall = fA.getUserData() === \"finish\" ? bA : fB.getUserData() === \"finish\" ? bB : null;\n        setTimeout(function () {\n          if (throwBall && finishBall) {\n            world.destroyBody(throwBall);\n          }\n        }, 1);\n      });\n    }\n\n    testbed.step = function () {\n      keylistener();\n      textOut();\n      finishTouch();\n    };\n\n    return world;\n  });\n} // export {level1};\n// export default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy9sZXZlbDIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFFQTtBQUVPLFNBQVNDLE1BQVQsR0FBa0I7RUFDckJELG9FQUFBLENBQWUsU0FBZixFQUEwQixVQUFVRSxPQUFWLEVBQW1CO0lBQzNDO0lBQ0FBLE9BQU8sQ0FBQ0MsVUFBUixHQUFxQixTQUFyQjtJQUNBQyxNQUFNLENBQUNKLE1BQVAsR0FBZ0JBLDREQUFoQjtJQUNBSSxNQUFNLENBQUNGLE9BQVAsR0FBaUJBLE9BQWpCLENBSjJDLENBSzNDOztJQUNBQSxPQUFPLENBQUNHLEtBQVIsR0FBZ0IsQ0FBaEI7SUFFQUgsT0FBTyxDQUFDSSxLQUFSLEdBQWlCQyxVQUFVLEdBQUcsQ0FBOUI7SUFDQUwsT0FBTyxDQUFDTSxNQUFSLEdBQWtCQyxXQUFXLEdBQUcsQ0FBaEM7SUFDQVAsT0FBTyxDQUFDUSxFQUFSLEdBQWEsRUFBYjtJQUVBLElBQUlDLEVBQUUsR0FBR1gsNERBQVQ7SUFBQSxJQUFpQlksSUFBSSxHQUFHRCxFQUFFLENBQUNDLElBQTNCO0lBQ0EsSUFBSUMsS0FBSyxHQUFHLElBQUlGLEVBQUUsQ0FBQ0csS0FBUCxDQUFhRixJQUFJLENBQUMsQ0FBRCxFQUFJLENBQUMsRUFBTCxDQUFqQixDQUFaO0lBQ0EsSUFBSUcsU0FBUyxHQUFHLEtBQWhCO0lBQ0FYLE1BQU0sQ0FBQ1csU0FBUCxHQUFtQkEsU0FBbkIsQ0FmMkMsQ0FpQjNDO0lBQ0E7O0lBRUEsSUFBSUMsS0FBSyxHQUFHLENBQVo7SUFFQSxJQUFJQyxNQUFNLEdBQUdKLEtBQUssQ0FBQ0ssVUFBTixFQUFiO0lBQ0FELE1BQU0sQ0FBQ0UsYUFBUCxDQUFxQlIsRUFBRSxDQUFDUyxJQUFILENBQVFSLElBQUksQ0FBQyxDQUFDLElBQUYsRUFBUSxDQUFDLElBQVQsQ0FBWixFQUE0QkEsSUFBSSxDQUFDLEtBQUQsRUFBUSxDQUFDLElBQVQsQ0FBaEMsQ0FBckIsRUFBc0UsR0FBdEU7SUFDQUssTUFBTSxDQUFDRSxhQUFQLENBQXFCUixFQUFFLENBQUNTLElBQUgsQ0FBUVIsSUFBSSxDQUFDLEtBQUQsRUFBUSxLQUFSLENBQVosRUFBNEJBLElBQUksQ0FBQyxLQUFELEVBQVEsQ0FBQyxJQUFULENBQWhDLENBQXJCLEVBQXNFLEdBQXRFO0lBQ0FLLE1BQU0sQ0FBQ0UsYUFBUCxDQUFxQlIsRUFBRSxDQUFDUyxJQUFILENBQVFSLElBQUksQ0FBQyxDQUFDLElBQUYsRUFBUSxLQUFSLENBQVosRUFBNEJBLElBQUksQ0FBQyxDQUFDLElBQUYsRUFBUSxDQUFDLElBQVQsQ0FBaEMsQ0FBckIsRUFBc0UsR0FBdEU7SUFDQUssTUFBTSxDQUFDRSxhQUFQLENBQXFCUixFQUFFLENBQUNTLElBQUgsQ0FBUVIsSUFBSSxDQUFDLENBQUMsSUFBRixFQUFRLEtBQVIsQ0FBWixFQUE0QkEsSUFBSSxDQUFDLEtBQUQsRUFBUSxLQUFSLENBQWhDLENBQXJCLEVBQXNFLEdBQXRFO0lBQ0FLLE1BQU0sQ0FBQ0UsYUFBUCxDQUFxQlIsRUFBRSxDQUFDUyxJQUFILENBQVFSLElBQUksQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUFaLEVBQTBCQSxJQUFJLENBQUMsS0FBRCxFQUFRLEdBQVIsQ0FBOUIsQ0FBckIsRUFBa0U7TUFBRVMsV0FBVyxFQUFFO0lBQWYsQ0FBbEUsRUFBdUZDLE1BQXZGLEdBQWdHO01BQUVDLElBQUksRUFBRSxNQUFSO01BQWdCQyxNQUFNLEVBQUU7SUFBeEIsQ0FBaEc7SUFBa0k7SUFDbElQLE1BQU0sQ0FBQ0UsYUFBUCxDQUFxQlIsRUFBRSxDQUFDUyxJQUFILENBQVFSLElBQUksQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUFaLEVBQTBCQSxJQUFJLENBQUMsS0FBRCxFQUFRLElBQVIsQ0FBOUIsQ0FBckIsRUFBbUU7TUFBRVMsV0FBVyxFQUFFO0lBQWYsQ0FBbkUsRUFBd0ZDLE1BQXhGLEdBQWlHO01BQUVDLElBQUksRUFBRSxNQUFSO01BQWdCQyxNQUFNLEVBQUU7SUFBeEIsQ0FBakc7SUFBa0k7SUFFbElQLE1BQU0sQ0FBQ0UsYUFBUCxDQUFxQlIsRUFBRSxDQUFDUyxJQUFILENBQVFSLElBQUksQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUFaLEVBQTBCQSxJQUFJLENBQUMsSUFBRCxFQUFPLENBQUMsSUFBUixDQUE5QixDQUFyQixFQUFtRSxHQUFuRTtJQUF3RTtJQUN4RUssTUFBTSxDQUFDRSxhQUFQLENBQXFCUixFQUFFLENBQUNTLElBQUgsQ0FBUVIsSUFBSSxDQUFDLEtBQUQsRUFBUSxDQUFDLElBQVQsQ0FBWixFQUE0QkEsSUFBSSxDQUFDLEtBQUQsRUFBUSxDQUFDLElBQVQsQ0FBaEMsQ0FBckIsRUFBc0U7TUFBRVMsV0FBVyxFQUFFO0lBQWYsQ0FBdEUsRUFBMkZDLE1BQTNGLEdBQW9HO01BQUVDLElBQUksRUFBRSxNQUFSO01BQWdCQyxNQUFNLEVBQUU7SUFBeEIsQ0FBcEc7SUFBcUksQ0EvQjFGLENBZ0MzQztJQUNBO0lBQ0E7SUFDQTs7SUFHQSxJQUFJQyxXQUFXLEdBQUc7TUFDaEJDLFFBQVEsRUFBRWQsSUFBSSxDQUFDLEVBQUQsRUFBSyxDQUFDLEVBQU4sQ0FERTtNQUVoQmUsTUFBTSxFQUFFLEtBRlE7TUFHaEJDLFVBQVUsRUFBRSxJQUhJO01BSWhCQyxhQUFhLEVBQUUsR0FKQztNQUtoQkMsY0FBYyxFQUFFO0lBTEEsQ0FBbEI7SUFTQSxJQUFJQyxhQUFhLEdBQUc7TUFDbEJDLFFBQVEsRUFBRSxFQURRO01BRWxCWCxXQUFXLEVBQUUsRUFGSztNQUVEO01BQ2pCWSxPQUFPLEVBQUUsRUFIUztNQUlsQkMsUUFBUSxFQUFFO0lBSlEsQ0FBcEI7SUFPQSxJQUFJQyxjQUFjLEdBQUc7TUFDbkJILFFBQVEsRUFBRSxFQURTO01BRW5CWCxXQUFXLEVBQUUsRUFGTTtNQUVGO01BQ2pCWSxPQUFPLEVBQUUsQ0FIVTtNQUluQkMsUUFBUSxFQUFFO0lBSlMsQ0FBckI7SUFRQSxJQUFJRSxLQUFLLEdBQUd2QixLQUFLLENBQUN3QixpQkFBTixDQUF3QlosV0FBeEIsQ0FBWjtJQUNBWixLQUFLLENBQUN5QixXQUFOLENBQWtCRixLQUFsQjs7SUFFQSxTQUFTRyxZQUFULEdBQXdCO01BQ3RCLElBQUlILEtBQUssQ0FBQ0ksV0FBVixFQUF1QjtRQUNyQkosS0FBSyxHQUFHdkIsS0FBSyxDQUFDd0IsaUJBQU4sQ0FBd0JaLFdBQXhCLENBQVI7UUFDQVcsS0FBSyxDQUFDakIsYUFBTixDQUFvQlIsRUFBRSxDQUFDOEIsTUFBSCxDQUFVLENBQVYsQ0FBcEIsRUFBa0NWLGFBQWxDO1FBQ0FLLEtBQUssQ0FBQ2QsTUFBTixHQUFlO1VBQUVvQixPQUFPLEVBQUVDO1FBQVgsQ0FBZjtRQUNBLElBQU1BLEdBQUcsR0FBRyxJQUFJQyxLQUFKLEVBQVo7UUFDQUQsR0FBRyxDQUFDRSxHQUFKLEdBQVUsK0VBQVY7TUFDRDtJQUNGOztJQUVETixZQUFZO0lBRVosSUFBTU8sS0FBSyxHQUFHakMsS0FBSyxDQUFDd0IsaUJBQU4sQ0FBd0JaLFdBQXhCLENBQWQ7SUFDQXFCLEtBQUssQ0FBQ0MsV0FBTixDQUFrQm5DLElBQUksQ0FBQyxFQUFELEVBQUssQ0FBTCxDQUF0QjtJQUNBa0MsS0FBSyxDQUFDM0IsYUFBTixDQUFvQlIsRUFBRSxDQUFDOEIsTUFBSCxDQUFVLENBQVYsQ0FBcEIsRUFBa0NWLGFBQWxDO0lBQ0FlLEtBQUssQ0FBQ3hCLE1BQU4sR0FBZTtNQUFFQyxJQUFJLEVBQUUsTUFBUjtNQUFnQkMsTUFBTSxFQUFFO0lBQXhCLENBQWY7SUFHQSxJQUFJd0IsS0FBSyxHQUFHbkMsS0FBSyxDQUFDSyxVQUFOLENBQWlCTixJQUFJLENBQUMsRUFBRCxFQUFJLENBQUMsRUFBTCxDQUFyQixDQUFaO0lBQ0FvQyxLQUFLLENBQUM3QixhQUFOLENBQW9CUixFQUFFLENBQUM4QixNQUFILENBQVUsQ0FBVixDQUFwQixFQUFrQ04sY0FBbEM7SUFDQWEsS0FBSyxDQUFDMUIsTUFBTixHQUFlO01BQUVDLElBQUksRUFBRSxLQUFSO01BQWVDLE1BQU0sRUFBRTtJQUF2QixDQUFmO0lBR0FwQixNQUFNLENBQUNPLEVBQVAsR0FBWUEsRUFBWjtJQUNBUCxNQUFNLENBQUNTLEtBQVAsR0FBZUEsS0FBZjtJQUNBb0MsT0FBTyxDQUFDQyxHQUFSLENBQVkscUJBQVosRUFBbUNkLEtBQW5DO0lBQ0FoQyxNQUFNLENBQUNnQyxLQUFQLEdBQWVBLEtBQWY7SUFDQWEsT0FBTyxDQUFDQyxHQUFSLENBQVksbUJBQVosRUFBaUNGLEtBQWpDO0lBQ0E1QyxNQUFNLENBQUM0QyxLQUFQLEdBQWVBLEtBQWY7SUFDQUMsT0FBTyxDQUFDQyxHQUFSLENBQVksb0JBQVosRUFBa0NKLEtBQWxDO0lBQ0ExQyxNQUFNLENBQUMwQyxLQUFQLEdBQWVBLEtBQWY7SUFHQSxJQUFJSyxDQUFDLEdBQUcsQ0FBUjtJQUNBLElBQUlDLEdBQUcsR0FBR3BELGdFQUFBLENBQVdtRCxDQUFYLEVBQWNBLENBQWQsQ0FBVjtJQUVBLElBQUlHLENBQUMsR0FBRzFDLElBQUksQ0FBQyxHQUFELEVBQU0sQ0FBTixDQUFaO0lBQ0EsSUFBSTJDLENBQUMsR0FBRzNDLElBQUksRUFBWjtJQUNBLElBQUk0QyxNQUFNLEdBQUc1QyxJQUFJLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBakI7SUFDQSxJQUFJNkMsTUFBTSxHQUFHN0MsSUFBSSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWpCOztJQUVBLEtBQUssSUFBSThDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcxQyxLQUFwQixFQUEyQixFQUFFMEMsQ0FBN0IsRUFBZ0M7TUFDOUJILENBQUMsQ0FBQ0ksR0FBRixDQUFNTCxDQUFOO01BQ0V6QyxLQUFLLENBQUN3QixpQkFBTixDQUF3QmtCLENBQXhCLEVBQTJCcEMsYUFBM0IsQ0FBeUNpQyxHQUF6QyxFQUE4QyxHQUE5QztNQUNBRyxDQUFDLENBQUNLLEdBQUYsQ0FBTUgsTUFBTjtNQUNGSCxDQUFDLENBQUNNLEdBQUYsQ0FBTUosTUFBTjtJQUNEOztJQUdELFNBQVNLLFdBQVQsR0FBdUI7TUFDckI7TUFDQTtNQUVBLElBQUkzRCxPQUFPLENBQUM0RCxVQUFSLENBQW1CQyxLQUF2QixFQUE4QjtRQUM1QixJQUFJQyxZQUFZLENBQUM5RCxPQUFPLENBQUNvRCxDQUFULENBQWhCLEVBQTZCO1VBQUVwRCxPQUFPLENBQUNvRCxDQUFSLElBQWEsQ0FBYjtRQUFnQixDQUEvQyxNQUFxRDtVQUFFcEQsT0FBTyxDQUFDb0QsQ0FBUixHQUFZVyxRQUFRLENBQUNYLENBQXJCO1FBQXdCO01BQ2hGLENBRkQsTUFFTyxJQUFJcEQsT0FBTyxDQUFDNEQsVUFBUixDQUFtQkksSUFBdkIsRUFBNkI7UUFDbEMsSUFBSUYsWUFBWSxDQUFDOUQsT0FBTyxDQUFDb0QsQ0FBVCxDQUFoQixFQUE2QjtVQUFFcEQsT0FBTyxDQUFDb0QsQ0FBUixJQUFhLENBQWI7UUFBZ0IsQ0FBL0MsTUFBcUQ7VUFBRXBELE9BQU8sQ0FBQ29ELENBQVIsR0FBWVcsUUFBUSxDQUFDWCxDQUFyQjtRQUF3QjtNQUNoRixDQUZNLE1BRUEsSUFBSXBELE9BQU8sQ0FBQzRELFVBQVIsQ0FBbUJLLEVBQXZCLEVBQTJCO1FBQ2hDLElBQUlDLFlBQVksQ0FBQ2xFLE9BQU8sQ0FBQ3FELENBQVQsQ0FBaEIsRUFBNkI7VUFBRXJELE9BQU8sQ0FBQ3FELENBQVIsSUFBYSxDQUFiO1FBQWdCLENBQS9DLE1BQXFEO1VBQUVyRCxPQUFPLENBQUNxRCxDQUFSLEdBQVlVLFFBQVEsQ0FBQ1YsQ0FBckI7UUFBd0I7TUFDaEYsQ0FGTSxNQUVBLElBQUlyRCxPQUFPLENBQUM0RCxVQUFSLENBQW1CTyxJQUF2QixFQUE2QjtRQUNsQyxJQUFJRCxZQUFZLENBQUNsRSxPQUFPLENBQUNxRCxDQUFULENBQWhCLEVBQTZCO1VBQUVyRCxPQUFPLENBQUNxRCxDQUFSLElBQWEsQ0FBYjtRQUFnQixDQUEvQyxNQUFxRDtVQUFFckQsT0FBTyxDQUFDcUQsQ0FBUixHQUFZVSxRQUFRLENBQUNWLENBQXJCO1FBQXdCO01BQ2hGLENBRk0sTUFFQSxJQUFJckQsT0FBTyxDQUFDNEQsVUFBUixDQUFtQlEsQ0FBdkIsRUFBMEI7UUFDL0JwRSxPQUFPLENBQUNxRSxXQUFSO01BQ0QsQ0FGTSxNQUVBLElBQUlyRSxPQUFPLENBQUM0RCxVQUFSLENBQW1CVSxJQUF2QixFQUE2QjtRQUNsQ2pDLFlBQVk7TUFDYjtJQUVGOztJQUVELElBQUkwQixRQUFRLEdBQUc3QixLQUFLLENBQUNxQyxXQUFOLEVBQWY7O0lBRUEsU0FBU1QsWUFBVCxDQUFzQlUsSUFBdEIsRUFBNEI7TUFDMUIsSUFBS3hFLE9BQU8sQ0FBQ29ELENBQVIsR0FBYXBELE9BQU8sQ0FBQ0ksS0FBUixHQUFnQixFQUE3QixHQUFtQzJELFFBQVEsQ0FBQ1gsQ0FBN0MsSUFBb0RwRCxPQUFPLENBQUNvRCxDQUFSLEdBQWFwRCxPQUFPLENBQUNJLEtBQVIsR0FBZ0IsRUFBN0IsR0FBbUMyRCxRQUFRLENBQUNYLENBQXBHLEVBQXdHO1FBQUUsT0FBTyxJQUFQO01BQWEsQ0FBdkgsTUFBNkg7UUFBRSxPQUFPLEtBQVA7TUFBYztJQUM5STs7SUFFRCxTQUFTYyxZQUFULENBQXNCTyxJQUF0QixFQUE0QjtNQUMxQixJQUFLekUsT0FBTyxDQUFDcUQsQ0FBUixHQUFhckQsT0FBTyxDQUFDTSxNQUFSLEdBQWlCLEVBQTlCLEdBQW9DeUQsUUFBUSxDQUFDVixDQUE5QyxJQUFzRHJELE9BQU8sQ0FBQ3FELENBQVIsR0FBWSxDQUFDckQsT0FBTyxDQUFDTSxNQUFSLEdBQWlCb0UsT0FBTyxDQUFDcEUsTUFBMUIsSUFBb0MsRUFBakQsR0FBdUR5RCxRQUFRLENBQUNWLENBQXpILEVBQTZIO1FBQUUsT0FBTyxJQUFQO01BQWEsQ0FBNUksTUFBa0o7UUFBRSxPQUFPLEtBQVA7TUFBYztJQUNuSzs7SUFFRCxTQUFTc0IsT0FBVCxHQUFtQjtNQUNqQixJQUFJQyxLQUFLLEdBQUcsRUFBWjtNQUNBLElBQUlDLE9BQU8sR0FBRzNDLEtBQUssQ0FBQ3FDLFdBQU4sRUFBZDtNQUNBTyxRQUFRLENBQUNDLFNBQVQsQ0FBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUJMLE9BQU8sQ0FBQ3RFLEtBQWpDLEVBQXdDc0UsT0FBTyxDQUFDcEUsTUFBaEQ7TUFDQXdFLFFBQVEsQ0FBQ0UsSUFBVCxhQUFtQkosS0FBbkI7TUFDQUUsUUFBUSxDQUFDRyxTQUFULEdBQXFCLE1BQXJCO01BQ0FILFFBQVEsQ0FBQ0ksUUFBVCxtQkFBNkJDLElBQUksQ0FBQ0MsS0FBTCxDQUFXUCxPQUFPLENBQUN6QixDQUFuQixDQUE3QixHQUFzRCxFQUF0RCxZQUE2RHdCLEtBQTdEO01BQ0FFLFFBQVEsQ0FBQ0ksUUFBVCxrQkFBNEJDLElBQUksQ0FBQ0MsS0FBTCxDQUFXUCxPQUFPLENBQUN4QixDQUFuQixDQUE1QixHQUFxRCxFQUFyRCxZQUE0RHVCLEtBQUssR0FBRyxDQUFwRTtNQUNBRSxRQUFRLENBQUNJLFFBQVQsMkJBQXFDQyxJQUFJLENBQUNDLEtBQUwsQ0FBV3BGLE9BQU8sQ0FBQ29ELENBQW5CLENBQXJDLEdBQThELEVBQTlELFlBQXFFd0IsS0FBSyxHQUFHLENBQTdFO01BQ0FFLFFBQVEsQ0FBQ0ksUUFBVCwyQkFBcUNDLElBQUksQ0FBQ0MsS0FBTCxDQUFXcEYsT0FBTyxDQUFDcUQsQ0FBbkIsQ0FBckMsR0FBOEQsRUFBOUQsWUFBcUV1QixLQUFLLEdBQUcsQ0FBN0U7TUFDQUUsUUFBUSxDQUFDSSxRQUFULDZCQUF1Q0MsSUFBSSxDQUFDQyxLQUFMLENBQVdwRixPQUFPLENBQUNNLE1BQW5CLENBQXZDLEdBQXFFLEVBQXJFLFlBQTRFc0UsS0FBSyxHQUFHLENBQXBGO01BQ0FFLFFBQVEsQ0FBQ0ksUUFBVCxtQkFBNkJsRixPQUFPLENBQUNxRixRQUFSLEVBQTdCLEdBQW1ELEdBQW5ELFlBQTJEVCxLQUEzRDtNQUNBRSxRQUFRLENBQUNJLFFBQVQsNEJBQXNDaEQsS0FBSyxDQUFDSSxXQUE1QyxHQUEyRCxHQUEzRCxZQUFtRXNDLEtBQUssR0FBRyxDQUEzRTtJQUVEOztJQUlELFNBQVNVLFdBQVQsR0FBdUI7TUFDckIzRSxLQUFLLENBQUM0RSxFQUFOLENBQVMsWUFBVCxFQUF1QixVQUFVQyxPQUFWLEVBQW1CO1FBQ3hDLElBQUlDLEVBQUUsR0FBR0QsT0FBTyxDQUFDRSxXQUFSLEVBQVQ7UUFBQSxJQUFnQ0MsRUFBRSxHQUFHRixFQUFFLENBQUNHLE9BQUgsRUFBckM7UUFDQSxJQUFJQyxFQUFFLEdBQUdMLE9BQU8sQ0FBQ00sV0FBUixFQUFUO1FBQUEsSUFBZ0NDLEVBQUUsR0FBR0YsRUFBRSxDQUFDRCxPQUFILEVBQXJDO1FBQ0EsSUFBSUksU0FBUyxHQUFHUCxFQUFFLENBQUNRLFdBQUgsT0FBcUIsTUFBckIsR0FBOEJOLEVBQTlCLEdBQW1DRSxFQUFFLENBQUNJLFdBQUgsT0FBcUIsTUFBckIsR0FBOEJGLEVBQTlCLEdBQW1DLElBQXRGO1FBQ0EsSUFBSUcsVUFBVSxHQUFHVCxFQUFFLENBQUNRLFdBQUgsT0FBcUIsUUFBckIsR0FBZ0NOLEVBQWhDLEdBQXFDRSxFQUFFLENBQUNJLFdBQUgsT0FBcUIsUUFBckIsR0FBZ0NGLEVBQWhDLEdBQXFDLElBQTNGO1FBQ0FJLFVBQVUsQ0FBQyxZQUFZO1VBQUUsSUFBSUgsU0FBUyxJQUFJRSxVQUFqQixFQUE2QjtZQUFFdkYsS0FBSyxDQUFDeUIsV0FBTixDQUFrQjRELFNBQWxCO1VBQStCO1FBQUUsQ0FBL0UsRUFBaUYsQ0FBakYsQ0FBVjtNQUNELENBTkQ7SUFPRDs7SUFNRGhHLE9BQU8sQ0FBQ29HLElBQVIsR0FBZSxZQUFZO01BQ3pCekMsV0FBVztNQUNYZ0IsT0FBTztNQUNQVyxXQUFXO0lBQ1osQ0FKRDs7SUFNTixPQUFPM0UsS0FBUDtFQUNLLENBdkxEO0FBd0xELEVBR0g7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Rlc3QtcmVwby8uL3NyYy9zY3JpcHRzL2xldmVsMi5qcz9jZmQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vbGV2ZWwxdHJpYWxcblxuaW1wb3J0ICogYXMgcGxhbmNrIGZyb20gJ3BsYW5jay9kaXN0L3BsYW5jay13aXRoLXRlc3RiZWQnXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXZlbDIoKSB7XG4gICAgcGxhbmNrLnRlc3RiZWQoJ1NhbmRib3gnLCBmdW5jdGlvbiAodGVzdGJlZCkge1xuICAgICAgLy8gd2luZG93LmNhbnZhcyA9IGNhbnZhc1xuICAgICAgdGVzdGJlZC5iYWNrZ3JvdW5kID0gXCIjMTExMTExXCJcbiAgICAgIHdpbmRvdy5wbGFuY2sgPSBwbGFuY2tcbiAgICAgIHdpbmRvdy50ZXN0YmVkID0gdGVzdGJlZFxuICAgICAgLy9jdXJyZW50bHkgZG9lc250IHdvcmtcbiAgICAgIHRlc3RiZWQuc3BlZWQgPSAyXG4gICAgICBcbiAgICAgIHRlc3RiZWQud2lkdGggPSAoaW5uZXJXaWR0aCAvIDQpO1xuICAgICAgdGVzdGJlZC5oZWlnaHQgPSAoaW5uZXJIZWlnaHQgLyA0KTtcbiAgICAgIHRlc3RiZWQuaHogPSAzMDtcblxuICAgICAgbGV0IHBsID0gcGxhbmNrLCBWZWMyID0gcGwuVmVjMjtcbiAgICAgIGxldCB3b3JsZCA9IG5ldyBwbC5Xb3JsZChWZWMyKDAsIC0xMCkpO1xuICAgICAgbGV0IGJyZWFrb3V0MSA9IGZhbHNlXG4gICAgICB3aW5kb3cuYnJlYWtvdXQxID0gYnJlYWtvdXQxXG5cbiAgICAgIC8vIHRlc3RiZWQubW91c2VGb3JjZSA9IDYwMDA7IFxuICAgICAgLy8gdHVybnMgb24vb2ZmIGltcHVsc2VzIHRvIGFwcGx5IGxpa2Ugc2xpbmdzaG90XG5cbiAgICAgIGxldCBDT1VOVCA9IDQ7XG5cbiAgICAgIGxldCBncm91bmQgPSB3b3JsZC5jcmVhdGVCb2R5KCk7XG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoLTgwLjAsIC04MC4wKSwgVmVjMigyMDAuMCwgLTgwLjApKSwgMC4wKTtcbiAgICAgIGdyb3VuZC5jcmVhdGVGaXh0dXJlKHBsLkVkZ2UoVmVjMigyMDAuMCwgMTUwLjApLCBWZWMyKDIwMC4wLCAtODAuMCkpLCAwLjApO1xuICAgICAgZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuRWRnZShWZWMyKC04MC4wLCAxNTAuMCksIFZlYzIoLTgwLjAsIC04MC4wKSksIDAuMCk7XG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoLTgwLjAsIDE1MC4wKSwgVmVjMigyMDAuMCwgMTUwLjApKSwgMC4wKTtcbiAgICAgIGdyb3VuZC5jcmVhdGVGaXh0dXJlKHBsLkVkZ2UoVmVjMig4MC4wLCAzMC4wKSwgVmVjMigyMDAuMCwgMC4wKSksIHsgcmVzdGl0dXRpb246IDYwIH0pLnJlbmRlciA9IHsgZmlsbDogJ2JsdWUnLCBzdHJva2U6ICdibHVlJyB9OyA7XG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoODAuMCwgMzAuMCksIFZlYzIoMjAwLjAsIDUwLjApKSwgeyByZXN0aXR1dGlvbjogNjAgfSkucmVuZGVyID0geyBmaWxsOiAnYmx1ZScsIHN0cm9rZTogJ2JsdWUnIH07O1xuICAgICAgXG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoODAuMCwgMzAuMCksIFZlYzIoODAuMCwgLTQwLjApKSwgMC4wKTs7XG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoMTAwLjAsIC04MC4wKSwgVmVjMigyMDAuMCwgLTIwLjApKSwgeyByZXN0aXR1dGlvbjogNjAgfSkucmVuZGVyID0geyBmaWxsOiAnYmx1ZScsIHN0cm9rZTogJ2JsdWUnIH07O1xuICAgICAgLy8gZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuQ2lyY2xlKFZlYzIoMTAwLjAsIC04MC4wKSwgMTApLCB7IHJlc3RpdHV0aW9uOiA2MCB9KS5yZW5kZXIgPSB7ZmlsbDogJ2JsdWUnLCBzdHJva2U6ICdibHVlJ307IC8vIGJvdW5jeVxuICAgICAgLy8gZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuQ2lyY2xlKFZlYzIoMjAwLjAsIC00MC4wKSwgMTApLCB7IHJlc3RpdHV0aW9uOiA2MCB9KS5yZW5kZXIgPSB7IGZpbGw6ICdibHVlJywgc3Ryb2tlOiAnYmx1ZScgfTsgLy8gYm91bmN5XG4gICAgICAvLyBncm91bmQuY3JlYXRlRml4dHVyZShwbC5Cb3goNTAsIDUsIFZlYzIoMTUwLCAtNjApLCA2MCksIHtyZXN0aXR1dGlvbjogNjB9KS5yZW5kZXIgPSB7IGZpbGw6ICdibHVlJywgc3Ryb2tlOiAnYmx1ZScgfTtcbiAgICAgIC8vIC5yZW5kZXIgPSB7IGZpbGw6ICdibHVlJywgc3Ryb2tlOiAnYmx1ZScgfTsgLy8gYm91bmN5XG4gICAgICBcblxuICAgICAgbGV0IGJhbGxCb2R5RGVmID0ge1xuICAgICAgICBwb3NpdGlvbjogVmVjMig3MCwgLTQwKSxcbiAgICAgICAgYnVsbGV0OiBmYWxzZSxcbiAgICAgICAgYWxsb3dTbGVlcDogdHJ1ZSxcbiAgICAgICAgbGluZWFyRGFtcGluZzogLjAxLFxuICAgICAgICBhbmd1bGFyRGFtcGluZzogLjVcbiAgICAgIH1cblxuXG4gICAgICBsZXQgYmFsbFN0YXJ0QXR0ciA9IHtcbiAgICAgICAgZnJpY3Rpb246IC4xLFxuICAgICAgICByZXN0aXR1dGlvbjogLjUsIC8vIGJvdW5jZVxuICAgICAgICBkZW5zaXR5OiAxMCxcbiAgICAgICAgdXNlckRhdGE6ICdiYWxsJ1xuICAgICAgfTtcblxuICAgICAgbGV0IGJhbGxGaW5pc2hBdHRyID0ge1xuICAgICAgICBmcmljdGlvbjogLjIsXG4gICAgICAgIHJlc3RpdHV0aW9uOiAuMSwgLy8gYm91bmNlXG4gICAgICAgIGRlbnNpdHk6IDEsXG4gICAgICAgIHVzZXJEYXRhOiAnZmluaXNoJ1xuICAgICAgfTtcblxuXG4gICAgICBsZXQgYmFsbDEgPSB3b3JsZC5jcmVhdGVEeW5hbWljQm9keShiYWxsQm9keURlZik7XG4gICAgICB3b3JsZC5kZXN0cm95Qm9keShiYWxsMSlcblxuICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVTaG90KCkge1xuICAgICAgICBpZiAoYmFsbDEubV9kZXN0cm95ZWQpIHtcbiAgICAgICAgICBiYWxsMSA9IHdvcmxkLmNyZWF0ZUR5bmFtaWNCb2R5KGJhbGxCb2R5RGVmKTtcbiAgICAgICAgICBiYWxsMS5jcmVhdGVGaXh0dXJlKHBsLkNpcmNsZSgxKSwgYmFsbFN0YXJ0QXR0cik7XG4gICAgICAgICAgYmFsbDEucmVuZGVyID0geyB0ZXh0dXJlOiBpbWcgfTtcbiAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKVxuICAgICAgICAgIGltZy5zcmMgPSBcImh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvMi8yNy9XZXlfc291cmNlX2ZhcnJpbmdkb24uanBnXCJcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZW5lcmF0ZVNob3QoKVxuXG4gICAgICBjb25zdCBiYWxsMyA9IHdvcmxkLmNyZWF0ZUR5bmFtaWNCb2R5KGJhbGxCb2R5RGVmKTtcbiAgICAgIGJhbGwzLnNldFBvc2l0aW9uKFZlYzIoMzAsIDIpKVxuICAgICAgYmFsbDMuY3JlYXRlRml4dHVyZShwbC5DaXJjbGUoMSksIGJhbGxTdGFydEF0dHIpO1xuICAgICAgYmFsbDMucmVuZGVyID0geyBmaWxsOiAnYmx1ZScsIHN0cm9rZTogJ2JsdWUnIH07XG5cblxuICAgICAgbGV0IGJhbGwyID0gd29ybGQuY3JlYXRlQm9keShWZWMyKDgyLC0yNSkpO1xuICAgICAgYmFsbDIuY3JlYXRlRml4dHVyZShwbC5DaXJjbGUoMSksIGJhbGxGaW5pc2hBdHRyKTtcbiAgICAgIGJhbGwyLnJlbmRlciA9IHsgZmlsbDogJ3JlZCcsIHN0cm9rZTogJ3JlZCcgfTtcblxuXG4gICAgICB3aW5kb3cucGwgPSBwbFxuICAgICAgd2luZG93LndvcmxkID0gd29ybGRcbiAgICAgIGNvbnNvbGUubG9nKFwid2hpdGUgYmFsbCA9IGJhbGwxIFwiLCBiYWxsMSlcbiAgICAgIHdpbmRvdy5iYWxsMSA9IGJhbGwxXG4gICAgICBjb25zb2xlLmxvZyhcInJlZCBiYWxsID0gYmFsbDIgXCIsIGJhbGwyKVxuICAgICAgd2luZG93LmJhbGwyID0gYmFsbDJcbiAgICAgIGNvbnNvbGUubG9nKFwiYmx1ZSBiYWxsID0gYmFsbDMgXCIsIGJhbGwzKVxuICAgICAgd2luZG93LmJhbGwzID0gYmFsbDNcblxuXG4gICAgICBsZXQgYSA9IDI7XG4gICAgICBsZXQgYm94ID0gcGxhbmNrLkJveChhLCBhKTtcblxuICAgICAgbGV0IHggPSBWZWMyKDguMCwgOCk7XG4gICAgICBsZXQgeSA9IFZlYzIoKTtcbiAgICAgIGxldCBkZWx0YVggPSBWZWMyKDAsIDQpO1xuICAgICAgbGV0IGRlbHRhWSA9IFZlYzIoMCwgNCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ09VTlQ7ICsraSkge1xuICAgICAgICB5LnNldCh4KTtcbiAgICAgICAgICB3b3JsZC5jcmVhdGVEeW5hbWljQm9keSh5KS5jcmVhdGVGaXh0dXJlKGJveCwgNS4wKTtcbiAgICAgICAgICB5LmFkZChkZWx0YVkpO1xuICAgICAgICB4LmFkZChkZWx0YVgpO1xuICAgICAgfVxuXG5cbiAgICAgIGZ1bmN0aW9uIGtleWxpc3RlbmVyKCkge1xuICAgICAgICAvL3RoZXJlIGlzIHByb2JhYmx5IGEgd2F5IHRvIGRvIHRoaXMgd2l0aCBhIGNhc2Ugc3RhdGVtZW50XG4gICAgICAgIC8vY2FtZXJhXG5cbiAgICAgICAgaWYgKHRlc3RiZWQuYWN0aXZlS2V5cy5yaWdodCkge1xuICAgICAgICAgIGlmIChjYW1lcmFMaW1pdFgodGVzdGJlZC54KSkgeyB0ZXN0YmVkLnggKz0gMiB9IGVsc2UgeyB0ZXN0YmVkLnggPSBiYWxsMXBvcy54IH1cbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0YmVkLmFjdGl2ZUtleXMubGVmdCkge1xuICAgICAgICAgIGlmIChjYW1lcmFMaW1pdFgodGVzdGJlZC54KSkgeyB0ZXN0YmVkLnggLT0gMiB9IGVsc2UgeyB0ZXN0YmVkLnggPSBiYWxsMXBvcy54IH1cbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0YmVkLmFjdGl2ZUtleXMudXApIHtcbiAgICAgICAgICBpZiAoY2FtZXJhTGltaXRZKHRlc3RiZWQueSkpIHsgdGVzdGJlZC55IC09IDIgfSBlbHNlIHsgdGVzdGJlZC55ID0gYmFsbDFwb3MueSB9XG4gICAgICAgIH0gZWxzZSBpZiAodGVzdGJlZC5hY3RpdmVLZXlzLmRvd24pIHtcbiAgICAgICAgICBpZiAoY2FtZXJhTGltaXRZKHRlc3RiZWQueSkpIHsgdGVzdGJlZC55ICs9IDIgfSBlbHNlIHsgdGVzdGJlZC55ID0gYmFsbDFwb3MueSB9XG4gICAgICAgIH0gZWxzZSBpZiAodGVzdGJlZC5hY3RpdmVLZXlzLkMpIHtcbiAgICAgICAgICB0ZXN0YmVkLnRvZ2dsZVBhdXNlKClcbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0YmVkLmFjdGl2ZUtleXMuZmlyZSkge1xuICAgICAgICAgIGdlbmVyYXRlU2hvdCgpXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBsZXQgYmFsbDFwb3MgPSBiYWxsMS5nZXRQb3NpdGlvbigpXG5cbiAgICAgIGZ1bmN0aW9uIGNhbWVyYUxpbWl0WCh4UG9zKSB7XG4gICAgICAgIGlmICgodGVzdGJlZC54ICsgKHRlc3RiZWQud2lkdGggKiAuNCkgPiBiYWxsMXBvcy54KSAmJiAodGVzdGJlZC54IC0gKHRlc3RiZWQud2lkdGggKiAuNCkgPCBiYWxsMXBvcy54KSkgeyByZXR1cm4gdHJ1ZSB9IGVsc2UgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW1lcmFMaW1pdFkoeVBvcykge1xuICAgICAgICBpZiAoKHRlc3RiZWQueSArICh0ZXN0YmVkLmhlaWdodCAqIC40KSA+IGJhbGwxcG9zLnkpICYmICgodGVzdGJlZC55IC0gKHRlc3RiZWQuaGVpZ2h0ICsgY2FudmFzMS5oZWlnaHQpICogLjQpIDwgYmFsbDFwb3MueSkpIHsgcmV0dXJuIHRydWUgfSBlbHNlIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGV4dE91dCgpIHtcbiAgICAgICAgbGV0IHNjYWxlID0gMjBcbiAgICAgICAgbGV0IGJhbGxwb3MgPSBiYWxsMS5nZXRQb3NpdGlvbigpXG4gICAgICAgIGNvbnRleHQyLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMxLndpZHRoLCBjYW52YXMxLmhlaWdodCk7XG4gICAgICAgIGNvbnRleHQyLmZvbnQgPSBgJHtzY2FsZX1weCBDb3VyaWVyIE5ld2A7XG4gICAgICAgIGNvbnRleHQyLmZpbGxTdHlsZSA9ICdibHVlJztcbiAgICAgICAgY29udGV4dDIuZmlsbFRleHQoYFggUE9TIDogJHtNYXRoLnJvdW5kKGJhbGxwb3MueCl9YCwgMjAsIGAke3NjYWxlfWApO1xuICAgICAgICBjb250ZXh0Mi5maWxsVGV4dChgWSBQT1MgOiR7TWF0aC5yb3VuZChiYWxscG9zLnkpfWAsIDIwLCBgJHtzY2FsZSAqIDJ9YCk7XG4gICAgICAgIGNvbnRleHQyLmZpbGxUZXh0KGB0ZXN0YmVkIFggUE9TIDogJHtNYXRoLnJvdW5kKHRlc3RiZWQueCl9YCwgMjAsIGAke3NjYWxlICogM31gKTtcbiAgICAgICAgY29udGV4dDIuZmlsbFRleHQoYHRlc3RiZWQgWSBQT1MgOiAke01hdGgucm91bmQodGVzdGJlZC55KX1gLCAyMCwgYCR7c2NhbGUgKiA0fWApO1xuICAgICAgICBjb250ZXh0Mi5maWxsVGV4dChgdGVzdGJlZCBZIGhlaWdodCA6JHtNYXRoLnJvdW5kKHRlc3RiZWQuaGVpZ2h0KX1gLCAyMCwgYCR7c2NhbGUgKiA1fWApO1xuICAgICAgICBjb250ZXh0Mi5maWxsVGV4dChgUGF1c2UgOiAke3Rlc3RiZWQuaXNQYXVzZWQoKX1gLCAyNTAsIGAke3NjYWxlfWApO1xuICAgICAgICBjb250ZXh0Mi5maWxsVGV4dChgU2hvdCBkZXN0cm95ZWQgOiAke2JhbGwxLm1fZGVzdHJveWVkfWAsIDI1MCwgYCR7c2NhbGUgKiAyfWApO1xuXG4gICAgICB9XG5cblxuXG4gICAgICBmdW5jdGlvbiBmaW5pc2hUb3VjaCgpIHtcbiAgICAgICAgd29ybGQub24oJ3Bvc3Qtc29sdmUnLCBmdW5jdGlvbiAoY29udGFjdCkge1xuICAgICAgICAgIGxldCBmQSA9IGNvbnRhY3QuZ2V0Rml4dHVyZUEoKSwgYkEgPSBmQS5nZXRCb2R5KCk7XG4gICAgICAgICAgbGV0IGZCID0gY29udGFjdC5nZXRGaXh0dXJlQigpLCBiQiA9IGZCLmdldEJvZHkoKTtcbiAgICAgICAgICBsZXQgdGhyb3dCYWxsID0gZkEuZ2V0VXNlckRhdGEoKSA9PT0gXCJiYWxsXCIgPyBiQSA6IGZCLmdldFVzZXJEYXRhKCkgPT09IFwiYmFsbFwiID8gYkIgOiBudWxsO1xuICAgICAgICAgIGxldCBmaW5pc2hCYWxsID0gZkEuZ2V0VXNlckRhdGEoKSA9PT0gXCJmaW5pc2hcIiA/IGJBIDogZkIuZ2V0VXNlckRhdGEoKSA9PT0gXCJmaW5pc2hcIiA/IGJCIDogbnVsbDtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgaWYgKHRocm93QmFsbCAmJiBmaW5pc2hCYWxsKSB7IHdvcmxkLmRlc3Ryb3lCb2R5KHRocm93QmFsbCk7IH0gfSwgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG5cblxuXG5cbiAgICAgIHRlc3RiZWQuc3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAga2V5bGlzdGVuZXIoKVxuICAgICAgICB0ZXh0T3V0KClcbiAgICAgICAgZmluaXNoVG91Y2goKVxuICAgICAgfTtcblxucmV0dXJuIHdvcmxkXG4gICAgfSk7XG4gIH1cblxuXG4vLyBleHBvcnQge2xldmVsMX07XG4vLyBleHBvcnQgZGVmYXVsdDsiXSwibmFtZXMiOlsicGxhbmNrIiwibGV2ZWwyIiwidGVzdGJlZCIsImJhY2tncm91bmQiLCJ3aW5kb3ciLCJzcGVlZCIsIndpZHRoIiwiaW5uZXJXaWR0aCIsImhlaWdodCIsImlubmVySGVpZ2h0IiwiaHoiLCJwbCIsIlZlYzIiLCJ3b3JsZCIsIldvcmxkIiwiYnJlYWtvdXQxIiwiQ09VTlQiLCJncm91bmQiLCJjcmVhdGVCb2R5IiwiY3JlYXRlRml4dHVyZSIsIkVkZ2UiLCJyZXN0aXR1dGlvbiIsInJlbmRlciIsImZpbGwiLCJzdHJva2UiLCJiYWxsQm9keURlZiIsInBvc2l0aW9uIiwiYnVsbGV0IiwiYWxsb3dTbGVlcCIsImxpbmVhckRhbXBpbmciLCJhbmd1bGFyRGFtcGluZyIsImJhbGxTdGFydEF0dHIiLCJmcmljdGlvbiIsImRlbnNpdHkiLCJ1c2VyRGF0YSIsImJhbGxGaW5pc2hBdHRyIiwiYmFsbDEiLCJjcmVhdGVEeW5hbWljQm9keSIsImRlc3Ryb3lCb2R5IiwiZ2VuZXJhdGVTaG90IiwibV9kZXN0cm95ZWQiLCJDaXJjbGUiLCJ0ZXh0dXJlIiwiaW1nIiwiSW1hZ2UiLCJzcmMiLCJiYWxsMyIsInNldFBvc2l0aW9uIiwiYmFsbDIiLCJjb25zb2xlIiwibG9nIiwiYSIsImJveCIsIkJveCIsIngiLCJ5IiwiZGVsdGFYIiwiZGVsdGFZIiwiaSIsInNldCIsImFkZCIsImtleWxpc3RlbmVyIiwiYWN0aXZlS2V5cyIsInJpZ2h0IiwiY2FtZXJhTGltaXRYIiwiYmFsbDFwb3MiLCJsZWZ0IiwidXAiLCJjYW1lcmFMaW1pdFkiLCJkb3duIiwiQyIsInRvZ2dsZVBhdXNlIiwiZmlyZSIsImdldFBvc2l0aW9uIiwieFBvcyIsInlQb3MiLCJjYW52YXMxIiwidGV4dE91dCIsInNjYWxlIiwiYmFsbHBvcyIsImNvbnRleHQyIiwiY2xlYXJSZWN0IiwiZm9udCIsImZpbGxTdHlsZSIsImZpbGxUZXh0IiwiTWF0aCIsInJvdW5kIiwiaXNQYXVzZWQiLCJmaW5pc2hUb3VjaCIsIm9uIiwiY29udGFjdCIsImZBIiwiZ2V0Rml4dHVyZUEiLCJiQSIsImdldEJvZHkiLCJmQiIsImdldEZpeHR1cmVCIiwiYkIiLCJ0aHJvd0JhbGwiLCJnZXRVc2VyRGF0YSIsImZpbmlzaEJhbGwiLCJzZXRUaW1lb3V0Iiwic3RlcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/scripts/level2.js\n");

/***/ }),

/***/ "./src/scripts/level3.js":
/*!*******************************!*\
  !*** ./src/scripts/level3.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"level3\": function() { return /* binding */ level3; }\n/* harmony export */ });\n/* harmony import */ var planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! planck/dist/planck-with-testbed */ \"./node_modules/planck/dist/planck-with-testbed.js\");\n/* harmony import */ var planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__);\n//level1trial\n\nfunction level3() {\n  planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__.testbed('Sandbox', function (testbed) {\n    testbed.background = \"#111111\";\n    testbed.speed = 2;\n    testbed.width = innerWidth / 4;\n    testbed.height = innerHeight / 4;\n    testbed.hz = 30;\n    var pl = planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__,\n        Vec2 = pl.Vec2;\n    var world = new pl.World(Vec2(0, -10)); // testbed.mouseForce = 6000; \n    // turns on/off impulses to apply like slingshot \n\n    var COUNT = 0;\n    var ground = world.createBody();\n    ground.createFixture(pl.Edge(Vec2(-80.0, -80.0), Vec2(200.0, -80.0)), 0.0); // ground\n\n    ground.createFixture(pl.Edge(Vec2(200.0, 150.0), Vec2(200.0, -80.0)), 0.0); // right\n\n    ground.createFixture(pl.Edge(Vec2(-80.0, 150.0), Vec2(-80.0, -80.0)), 0.0); // left\n\n    ground.createFixture(pl.Edge(Vec2(-80.0, 150.0), Vec2(200.0, 150.0)), 0.0); // top\n\n    ground.createFixture(pl.Edge(Vec2(-80.0, 0.0), Vec2(150.0, 0.0)), 0.0); // ground\n\n    ground.createFixture(pl.Edge(Vec2(80.0, -30.0), Vec2(170.0, -10.0)), {\n      restitution: 0,\n      friction: 0\n    }).render = {\n      fill: 'orange',\n      stroke: 'orange'\n    }; // ground slant\n\n    ground.createFixture(pl.Edge(Vec2(170.0, -10.0), Vec2(200.0, 0.0)), {\n      restitution: 0,\n      friction: 0\n    }).render = {\n      fill: 'orange',\n      stroke: 'orange'\n    }; // ground slant\n\n    ground.createFixture(pl.Edge(Vec2(80.0, -30.0), Vec2(60.0, -25.0)), {\n      restitution: 0,\n      friction: 0\n    }).render = {\n      fill: 'orange',\n      stroke: 'orange'\n    }; // ground slant\n\n    ground.createFixture(pl.Edge(Vec2(60.0, -25.0), Vec2(50.0, -20.0)), {\n      restitution: 60,\n      friction: 0\n    }).render = {\n      fill: 'blue',\n      stroke: 'blue'\n    }; // ground slant\n    // ground.createFixture(pl.Edge(Vec2(100.0, -80.0), Vec2(200.0, -20.0)), { restitution: 60 }).render = { fill: 'blue', stroke: 'blue' };;\n    // ground.createFixture(pl.Circle(Vec2(100.0, -80.0), 10), { restitution: 60 }).render = {fill: 'blue', stroke: 'blue'}; // bouncy\n    // ground.createFixture(pl.Circle(Vec2(200.0, -40.0), 10), { restitution: 60 }).render = { fill: 'blue', stroke: 'blue' }; // bouncy\n    // ground.createFixture(pl.Box(50, 5, Vec2(150, -60), 60), {restitution: 60}).render = { fill: 'blue', stroke: 'blue' };\n    // .render = { fill: 'blue', stroke: 'blue' }; // bouncy\n\n    var ballBodyDef = {\n      position: Vec2(70, 10),\n      bullet: false,\n      allowSleep: true,\n      linearDamping: .01,\n      angularDamping: .5\n    };\n    var ballStartAttr = {\n      friction: .1,\n      restitution: .5,\n      // bounce\n      density: 10,\n      userData: 'ball'\n    };\n    var ballFinishAttr = {\n      friction: .2,\n      restitution: .1,\n      // bounce\n      density: 1,\n      userData: 'finish'\n    };\n    var ball1 = world.createDynamicBody(ballBodyDef);\n    world.destroyBody(ball1);\n\n    function generateShot() {\n      if (ball1.m_destroyed) {\n        ball1 = world.createDynamicBody(ballBodyDef);\n        ball1.createFixture(pl.Circle(1), ballStartAttr);\n        ball1.render = {\n          texture: img\n        };\n        var img = new Image();\n        img.src = \"https://upload.wikimedia.org/wikipedia/commons/2/27/Wey_source_farringdon.jpg\";\n      }\n    }\n\n    generateShot();\n    var ball3 = world.createDynamicBody(ballBodyDef);\n    ball3.setPosition(Vec2(30, 2));\n    ball3.createFixture(pl.Circle(1), ballStartAttr);\n    ball3.render = {\n      fill: 'blue',\n      stroke: 'blue'\n    };\n    var ball2 = world.createBody(Vec2(82, -22));\n    ball2.createFixture(pl.Circle(1), ballFinishAttr);\n    ball2.render = {\n      fill: 'red',\n      stroke: 'red'\n    };\n    window.pl = pl;\n    window.world = world;\n    console.log(\"white ball = ball1 \", ball1);\n    window.ball1 = ball1;\n    console.log(\"red ball = ball2 \", ball2);\n    window.ball2 = ball2;\n    console.log(\"blue ball = ball3 \", ball3);\n    window.ball3 = ball3;\n    var a = COUNT;\n    var box = planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__.Box(a, a + a + a);\n    var x = Vec2(180.0, 8);\n    var y = Vec2();\n    var deltaX = Vec2(0, 4);\n    var deltaY = Vec2(0, 4);\n\n    for (var i = 0; i < COUNT; ++i) {\n      y.set(x);\n      world.createDynamicBody(y).createFixture(box, 5.0);\n      y.add(deltaY);\n      x.add(deltaX);\n    } // let spin = world.createDynamicBody(Vec2(0.0, 10.0));\n    // spin.createFixture(pl.Box(.5, 10.0), 20.0);\n    // let joint1 = world.createJoint(pl.RevoluteJoint({\n    //   motorSpeed: Math.PI,\n    //   maxMotorTorque: 20000.0,\n    //   enableMotor: true\n    // }, ground, spin, Vec2(0.0, 1.0)));\n\n\n    function keylistener() {\n      if (testbed.activeKeys.right) {\n        if (cameraLimitX(testbed.x)) {\n          testbed.x += 2;\n        } else {\n          testbed.x = ball1pos.x;\n        }\n      } else if (testbed.activeKeys.left) {\n        if (cameraLimitX(testbed.x)) {\n          testbed.x -= 2;\n        } else {\n          testbed.x = ball1pos.x;\n        }\n      } else if (testbed.activeKeys.up) {\n        if (cameraLimitY(testbed.y)) {\n          testbed.y -= 2;\n        } else {\n          testbed.y = ball1pos.y;\n        }\n      } else if (testbed.activeKeys.down) {\n        if (cameraLimitY(testbed.y)) {\n          testbed.y += 2;\n        } else {\n          testbed.y = ball1pos.y;\n        }\n      } else if (testbed.activeKeys.C) {\n        testbed.togglePause();\n      } else if (testbed.activeKeys.fire) {\n        generateShot();\n      }\n    }\n\n    var ball1pos = ball1.getPosition();\n\n    function cameraLimitX(xPos) {\n      if (testbed.x + testbed.width * .4 > ball1pos.x && testbed.x - testbed.width * .4 < ball1pos.x) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    function cameraLimitY(yPos) {\n      if (testbed.y + testbed.height * .4 > ball1pos.y && testbed.y - (testbed.height + canvas1.height) * .4 < ball1pos.y) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    function textOut() {\n      var scale = 20;\n      var ballpos = ball1.getPosition();\n      context2.clearRect(0, 0, canvas1.width, canvas1.height);\n      context2.font = \"\".concat(scale, \"px Courier New\");\n      context2.fillStyle = 'blue';\n      context2.fillText(\"X POS : \".concat(Math.round(ballpos.x)), 20, \"\".concat(scale));\n      context2.fillText(\"Y POS :\".concat(Math.round(ballpos.y)), 20, \"\".concat(scale * 2));\n      context2.fillText(\"testbed X POS : \".concat(Math.round(testbed.x)), 20, \"\".concat(scale * 3));\n      context2.fillText(\"testbed Y POS : \".concat(Math.round(testbed.y)), 20, \"\".concat(scale * 4));\n      context2.fillText(\"testbed Y height :\".concat(Math.round(testbed.height)), 20, \"\".concat(scale * 5));\n      context2.fillText(\"Pause : \".concat(testbed.isPaused()), 250, \"\".concat(scale));\n      context2.fillText(\"Shot destroyed : \".concat(ball1.m_destroyed), 250, \"\".concat(scale * 2));\n    }\n\n    function finishTouch() {\n      world.on('post-solve', function (contact) {\n        var fA = contact.getFixtureA(),\n            bA = fA.getBody();\n        var fB = contact.getFixtureB(),\n            bB = fB.getBody();\n        var throwBall = fA.getUserData() === \"ball\" ? bA : fB.getUserData() === \"ball\" ? bB : null;\n        var finishBall = fA.getUserData() === \"finish\" ? bA : fB.getUserData() === \"finish\" ? bB : null;\n        setTimeout(function () {\n          if (throwBall && finishBall) {\n            world.destroyBody(throwBall);\n          }\n        }, 1);\n      });\n    }\n\n    testbed.step = function () {\n      keylistener();\n      textOut();\n      finishTouch();\n    };\n\n    return world;\n  });\n} // export {level1};\n// export default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy9sZXZlbDMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFFQTtBQUVPLFNBQVNDLE1BQVQsR0FBa0I7RUFDckJELG9FQUFBLENBQWUsU0FBZixFQUEwQixVQUFVRSxPQUFWLEVBQW1CO0lBQzNDQSxPQUFPLENBQUNDLFVBQVIsR0FBcUIsU0FBckI7SUFDQUQsT0FBTyxDQUFDRSxLQUFSLEdBQWdCLENBQWhCO0lBRUFGLE9BQU8sQ0FBQ0csS0FBUixHQUFpQkMsVUFBVSxHQUFHLENBQTlCO0lBQ0FKLE9BQU8sQ0FBQ0ssTUFBUixHQUFrQkMsV0FBVyxHQUFHLENBQWhDO0lBQ0FOLE9BQU8sQ0FBQ08sRUFBUixHQUFhLEVBQWI7SUFFQSxJQUFJQyxFQUFFLEdBQUdWLDREQUFUO0lBQUEsSUFBaUJXLElBQUksR0FBR0QsRUFBRSxDQUFDQyxJQUEzQjtJQUNBLElBQUlDLEtBQUssR0FBRyxJQUFJRixFQUFFLENBQUNHLEtBQVAsQ0FBYUYsSUFBSSxDQUFDLENBQUQsRUFBSSxDQUFDLEVBQUwsQ0FBakIsQ0FBWixDQVQyQyxDQVUzQztJQUNBOztJQUVBLElBQUlHLEtBQUssR0FBRyxDQUFaO0lBRUEsSUFBSUMsTUFBTSxHQUFHSCxLQUFLLENBQUNJLFVBQU4sRUFBYjtJQUNBRCxNQUFNLENBQUNFLGFBQVAsQ0FBcUJQLEVBQUUsQ0FBQ1EsSUFBSCxDQUFRUCxJQUFJLENBQUMsQ0FBQyxJQUFGLEVBQVEsQ0FBQyxJQUFULENBQVosRUFBNEJBLElBQUksQ0FBQyxLQUFELEVBQVEsQ0FBQyxJQUFULENBQWhDLENBQXJCLEVBQXNFLEdBQXRFLEVBaEIyQyxDQWdCaUM7O0lBQzVFSSxNQUFNLENBQUNFLGFBQVAsQ0FBcUJQLEVBQUUsQ0FBQ1EsSUFBSCxDQUFRUCxJQUFJLENBQUMsS0FBRCxFQUFRLEtBQVIsQ0FBWixFQUE0QkEsSUFBSSxDQUFDLEtBQUQsRUFBUSxDQUFDLElBQVQsQ0FBaEMsQ0FBckIsRUFBc0UsR0FBdEUsRUFqQjJDLENBaUJpQzs7SUFDNUVJLE1BQU0sQ0FBQ0UsYUFBUCxDQUFxQlAsRUFBRSxDQUFDUSxJQUFILENBQVFQLElBQUksQ0FBQyxDQUFDLElBQUYsRUFBUSxLQUFSLENBQVosRUFBNEJBLElBQUksQ0FBQyxDQUFDLElBQUYsRUFBUSxDQUFDLElBQVQsQ0FBaEMsQ0FBckIsRUFBc0UsR0FBdEUsRUFsQjJDLENBa0JpQzs7SUFDNUVJLE1BQU0sQ0FBQ0UsYUFBUCxDQUFxQlAsRUFBRSxDQUFDUSxJQUFILENBQVFQLElBQUksQ0FBQyxDQUFDLElBQUYsRUFBUSxLQUFSLENBQVosRUFBNEJBLElBQUksQ0FBQyxLQUFELEVBQVEsS0FBUixDQUFoQyxDQUFyQixFQUFzRSxHQUF0RSxFQW5CMkMsQ0FtQmtDOztJQUU3RUksTUFBTSxDQUFDRSxhQUFQLENBQXFCUCxFQUFFLENBQUNRLElBQUgsQ0FBUVAsSUFBSSxDQUFDLENBQUMsSUFBRixFQUFRLEdBQVIsQ0FBWixFQUEwQkEsSUFBSSxDQUFDLEtBQUQsRUFBUSxHQUFSLENBQTlCLENBQXJCLEVBQWtFLEdBQWxFLEVBckIyQyxDQXFCNkI7O0lBQ3hFSSxNQUFNLENBQUNFLGFBQVAsQ0FBcUJQLEVBQUUsQ0FBQ1EsSUFBSCxDQUFRUCxJQUFJLENBQUMsSUFBRCxFQUFPLENBQUMsSUFBUixDQUFaLEVBQTJCQSxJQUFJLENBQUMsS0FBRCxFQUFRLENBQUMsSUFBVCxDQUEvQixDQUFyQixFQUFxRTtNQUFFUSxXQUFXLEVBQUUsQ0FBZjtNQUFrQkMsUUFBUSxFQUFFO0lBQTVCLENBQXJFLEVBQXNHQyxNQUF0RyxHQUErRztNQUFFQyxJQUFJLEVBQUUsUUFBUjtNQUFrQkMsTUFBTSxFQUFFO0lBQTFCLENBQS9HLENBdEIyQyxDQXNCMEc7O0lBQ3JKUixNQUFNLENBQUNFLGFBQVAsQ0FBcUJQLEVBQUUsQ0FBQ1EsSUFBSCxDQUFRUCxJQUFJLENBQUMsS0FBRCxFQUFRLENBQUMsSUFBVCxDQUFaLEVBQTRCQSxJQUFJLENBQUMsS0FBRCxFQUFRLEdBQVIsQ0FBaEMsQ0FBckIsRUFBb0U7TUFBRVEsV0FBVyxFQUFFLENBQWY7TUFBa0JDLFFBQVEsRUFBRTtJQUE1QixDQUFwRSxFQUFxR0MsTUFBckcsR0FBOEc7TUFBRUMsSUFBSSxFQUFFLFFBQVI7TUFBa0JDLE1BQU0sRUFBRTtJQUExQixDQUE5RyxDQXZCMkMsQ0F1QnlHOztJQUNwSlIsTUFBTSxDQUFDRSxhQUFQLENBQXFCUCxFQUFFLENBQUNRLElBQUgsQ0FBUVAsSUFBSSxDQUFDLElBQUQsRUFBTyxDQUFDLElBQVIsQ0FBWixFQUEyQkEsSUFBSSxDQUFDLElBQUQsRUFBTyxDQUFDLElBQVIsQ0FBL0IsQ0FBckIsRUFBb0U7TUFBRVEsV0FBVyxFQUFFLENBQWY7TUFBa0JDLFFBQVEsRUFBRTtJQUE1QixDQUFwRSxFQUFxR0MsTUFBckcsR0FBOEc7TUFBRUMsSUFBSSxFQUFFLFFBQVI7TUFBa0JDLE1BQU0sRUFBRTtJQUExQixDQUE5RyxDQXhCMkMsQ0F3QnlHOztJQUNwSlIsTUFBTSxDQUFDRSxhQUFQLENBQXFCUCxFQUFFLENBQUNRLElBQUgsQ0FBUVAsSUFBSSxDQUFDLElBQUQsRUFBTyxDQUFDLElBQVIsQ0FBWixFQUEyQkEsSUFBSSxDQUFDLElBQUQsRUFBTyxDQUFDLElBQVIsQ0FBL0IsQ0FBckIsRUFBb0U7TUFBRVEsV0FBVyxFQUFFLEVBQWY7TUFBbUJDLFFBQVEsRUFBRTtJQUE3QixDQUFwRSxFQUFzR0MsTUFBdEcsR0FBK0c7TUFBRUMsSUFBSSxFQUFFLE1BQVI7TUFBZ0JDLE1BQU0sRUFBRTtJQUF4QixDQUEvRyxDQXpCMkMsQ0F5QnNHO0lBRWpKO0lBRUE7SUFDQTtJQUNBO0lBQ0E7O0lBR0EsSUFBSUMsV0FBVyxHQUFHO01BQ2hCQyxRQUFRLEVBQUVkLElBQUksQ0FBQyxFQUFELEVBQUssRUFBTCxDQURFO01BRWhCZSxNQUFNLEVBQUUsS0FGUTtNQUdoQkMsVUFBVSxFQUFFLElBSEk7TUFJaEJDLGFBQWEsRUFBRSxHQUpDO01BS2hCQyxjQUFjLEVBQUU7SUFMQSxDQUFsQjtJQVNBLElBQUlDLGFBQWEsR0FBRztNQUNsQlYsUUFBUSxFQUFFLEVBRFE7TUFFbEJELFdBQVcsRUFBRSxFQUZLO01BRUQ7TUFDakJZLE9BQU8sRUFBRSxFQUhTO01BSWxCQyxRQUFRLEVBQUU7SUFKUSxDQUFwQjtJQU9BLElBQUlDLGNBQWMsR0FBRztNQUNuQmIsUUFBUSxFQUFFLEVBRFM7TUFFbkJELFdBQVcsRUFBRSxFQUZNO01BRUY7TUFDakJZLE9BQU8sRUFBRSxDQUhVO01BSW5CQyxRQUFRLEVBQUU7SUFKUyxDQUFyQjtJQVFBLElBQUlFLEtBQUssR0FBR3RCLEtBQUssQ0FBQ3VCLGlCQUFOLENBQXdCWCxXQUF4QixDQUFaO0lBQ0FaLEtBQUssQ0FBQ3dCLFdBQU4sQ0FBa0JGLEtBQWxCOztJQUVBLFNBQVNHLFlBQVQsR0FBd0I7TUFDdEIsSUFBSUgsS0FBSyxDQUFDSSxXQUFWLEVBQXVCO1FBQ3JCSixLQUFLLEdBQUd0QixLQUFLLENBQUN1QixpQkFBTixDQUF3QlgsV0FBeEIsQ0FBUjtRQUNBVSxLQUFLLENBQUNqQixhQUFOLENBQW9CUCxFQUFFLENBQUM2QixNQUFILENBQVUsQ0FBVixDQUFwQixFQUFrQ1QsYUFBbEM7UUFDQUksS0FBSyxDQUFDYixNQUFOLEdBQWU7VUFBRW1CLE9BQU8sRUFBRUM7UUFBWCxDQUFmO1FBQ0EsSUFBTUEsR0FBRyxHQUFHLElBQUlDLEtBQUosRUFBWjtRQUNBRCxHQUFHLENBQUNFLEdBQUosR0FBVSwrRUFBVjtNQUNEO0lBQ0Y7O0lBRUROLFlBQVk7SUFFWixJQUFNTyxLQUFLLEdBQUdoQyxLQUFLLENBQUN1QixpQkFBTixDQUF3QlgsV0FBeEIsQ0FBZDtJQUNBb0IsS0FBSyxDQUFDQyxXQUFOLENBQWtCbEMsSUFBSSxDQUFDLEVBQUQsRUFBSyxDQUFMLENBQXRCO0lBQ0FpQyxLQUFLLENBQUMzQixhQUFOLENBQW9CUCxFQUFFLENBQUM2QixNQUFILENBQVUsQ0FBVixDQUFwQixFQUFrQ1QsYUFBbEM7SUFDQWMsS0FBSyxDQUFDdkIsTUFBTixHQUFlO01BQUVDLElBQUksRUFBRSxNQUFSO01BQWdCQyxNQUFNLEVBQUU7SUFBeEIsQ0FBZjtJQUdBLElBQUl1QixLQUFLLEdBQUdsQyxLQUFLLENBQUNJLFVBQU4sQ0FBaUJMLElBQUksQ0FBQyxFQUFELEVBQUksQ0FBQyxFQUFMLENBQXJCLENBQVo7SUFDQW1DLEtBQUssQ0FBQzdCLGFBQU4sQ0FBb0JQLEVBQUUsQ0FBQzZCLE1BQUgsQ0FBVSxDQUFWLENBQXBCLEVBQWtDTixjQUFsQztJQUNBYSxLQUFLLENBQUN6QixNQUFOLEdBQWU7TUFBRUMsSUFBSSxFQUFFLEtBQVI7TUFBZUMsTUFBTSxFQUFFO0lBQXZCLENBQWY7SUFHQXdCLE1BQU0sQ0FBQ3JDLEVBQVAsR0FBWUEsRUFBWjtJQUNBcUMsTUFBTSxDQUFDbkMsS0FBUCxHQUFlQSxLQUFmO0lBQ0FvQyxPQUFPLENBQUNDLEdBQVIsQ0FBWSxxQkFBWixFQUFtQ2YsS0FBbkM7SUFDQWEsTUFBTSxDQUFDYixLQUFQLEdBQWVBLEtBQWY7SUFDQWMsT0FBTyxDQUFDQyxHQUFSLENBQVksbUJBQVosRUFBaUNILEtBQWpDO0lBQ0FDLE1BQU0sQ0FBQ0QsS0FBUCxHQUFlQSxLQUFmO0lBQ0FFLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLG9CQUFaLEVBQWtDTCxLQUFsQztJQUNBRyxNQUFNLENBQUNILEtBQVAsR0FBZUEsS0FBZjtJQUdBLElBQUlNLENBQUMsR0FBR3BDLEtBQVI7SUFDQSxJQUFJcUMsR0FBRyxHQUFHbkQsZ0VBQUEsQ0FBV2tELENBQVgsRUFBY0EsQ0FBQyxHQUFDQSxDQUFGLEdBQUlBLENBQWxCLENBQVY7SUFFQSxJQUFJRyxDQUFDLEdBQUcxQyxJQUFJLENBQUMsS0FBRCxFQUFRLENBQVIsQ0FBWjtJQUNBLElBQUkyQyxDQUFDLEdBQUczQyxJQUFJLEVBQVo7SUFDQSxJQUFJNEMsTUFBTSxHQUFHNUMsSUFBSSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWpCO0lBQ0EsSUFBSTZDLE1BQU0sR0FBRzdDLElBQUksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFqQjs7SUFFQSxLQUFLLElBQUk4QyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHM0MsS0FBcEIsRUFBMkIsRUFBRTJDLENBQTdCLEVBQWdDO01BQzlCSCxDQUFDLENBQUNJLEdBQUYsQ0FBTUwsQ0FBTjtNQUNFekMsS0FBSyxDQUFDdUIsaUJBQU4sQ0FBd0JtQixDQUF4QixFQUEyQnJDLGFBQTNCLENBQXlDa0MsR0FBekMsRUFBOEMsR0FBOUM7TUFDQUcsQ0FBQyxDQUFDSyxHQUFGLENBQU1ILE1BQU47TUFDRkgsQ0FBQyxDQUFDTSxHQUFGLENBQU1KLE1BQU47SUFDRCxDQTVHMEMsQ0E4R3JDO0lBQ047SUFFQTtJQUNBO0lBQ0E7SUFDQTtJQUNBOzs7SUFJQSxTQUFTSyxXQUFULEdBQXVCO01BRXJCLElBQUkxRCxPQUFPLENBQUMyRCxVQUFSLENBQW1CQyxLQUF2QixFQUE4QjtRQUM1QixJQUFJQyxZQUFZLENBQUM3RCxPQUFPLENBQUNtRCxDQUFULENBQWhCLEVBQTZCO1VBQUVuRCxPQUFPLENBQUNtRCxDQUFSLElBQWEsQ0FBYjtRQUFnQixDQUEvQyxNQUFxRDtVQUFFbkQsT0FBTyxDQUFDbUQsQ0FBUixHQUFZVyxRQUFRLENBQUNYLENBQXJCO1FBQXdCO01BQ2hGLENBRkQsTUFFTyxJQUFJbkQsT0FBTyxDQUFDMkQsVUFBUixDQUFtQkksSUFBdkIsRUFBNkI7UUFDbEMsSUFBSUYsWUFBWSxDQUFDN0QsT0FBTyxDQUFDbUQsQ0FBVCxDQUFoQixFQUE2QjtVQUFFbkQsT0FBTyxDQUFDbUQsQ0FBUixJQUFhLENBQWI7UUFBZ0IsQ0FBL0MsTUFBcUQ7VUFBRW5ELE9BQU8sQ0FBQ21ELENBQVIsR0FBWVcsUUFBUSxDQUFDWCxDQUFyQjtRQUF3QjtNQUNoRixDQUZNLE1BRUEsSUFBSW5ELE9BQU8sQ0FBQzJELFVBQVIsQ0FBbUJLLEVBQXZCLEVBQTJCO1FBQ2hDLElBQUlDLFlBQVksQ0FBQ2pFLE9BQU8sQ0FBQ29ELENBQVQsQ0FBaEIsRUFBNkI7VUFBRXBELE9BQU8sQ0FBQ29ELENBQVIsSUFBYSxDQUFiO1FBQWdCLENBQS9DLE1BQXFEO1VBQUVwRCxPQUFPLENBQUNvRCxDQUFSLEdBQVlVLFFBQVEsQ0FBQ1YsQ0FBckI7UUFBd0I7TUFDaEYsQ0FGTSxNQUVBLElBQUlwRCxPQUFPLENBQUMyRCxVQUFSLENBQW1CTyxJQUF2QixFQUE2QjtRQUNsQyxJQUFJRCxZQUFZLENBQUNqRSxPQUFPLENBQUNvRCxDQUFULENBQWhCLEVBQTZCO1VBQUVwRCxPQUFPLENBQUNvRCxDQUFSLElBQWEsQ0FBYjtRQUFnQixDQUEvQyxNQUFxRDtVQUFFcEQsT0FBTyxDQUFDb0QsQ0FBUixHQUFZVSxRQUFRLENBQUNWLENBQXJCO1FBQXdCO01BQ2hGLENBRk0sTUFFQSxJQUFJcEQsT0FBTyxDQUFDMkQsVUFBUixDQUFtQlEsQ0FBdkIsRUFBMEI7UUFDL0JuRSxPQUFPLENBQUNvRSxXQUFSO01BQ0QsQ0FGTSxNQUVBLElBQUlwRSxPQUFPLENBQUMyRCxVQUFSLENBQW1CVSxJQUF2QixFQUE2QjtRQUNsQ2xDLFlBQVk7TUFDYjtJQUVGOztJQUVELElBQUkyQixRQUFRLEdBQUc5QixLQUFLLENBQUNzQyxXQUFOLEVBQWY7O0lBRUEsU0FBU1QsWUFBVCxDQUFzQlUsSUFBdEIsRUFBNEI7TUFDMUIsSUFBS3ZFLE9BQU8sQ0FBQ21ELENBQVIsR0FBYW5ELE9BQU8sQ0FBQ0csS0FBUixHQUFnQixFQUE3QixHQUFtQzJELFFBQVEsQ0FBQ1gsQ0FBN0MsSUFBb0RuRCxPQUFPLENBQUNtRCxDQUFSLEdBQWFuRCxPQUFPLENBQUNHLEtBQVIsR0FBZ0IsRUFBN0IsR0FBbUMyRCxRQUFRLENBQUNYLENBQXBHLEVBQXdHO1FBQUUsT0FBTyxJQUFQO01BQWEsQ0FBdkgsTUFBNkg7UUFBRSxPQUFPLEtBQVA7TUFBYztJQUM5STs7SUFFRCxTQUFTYyxZQUFULENBQXNCTyxJQUF0QixFQUE0QjtNQUMxQixJQUFLeEUsT0FBTyxDQUFDb0QsQ0FBUixHQUFhcEQsT0FBTyxDQUFDSyxNQUFSLEdBQWlCLEVBQTlCLEdBQW9DeUQsUUFBUSxDQUFDVixDQUE5QyxJQUFzRHBELE9BQU8sQ0FBQ29ELENBQVIsR0FBWSxDQUFDcEQsT0FBTyxDQUFDSyxNQUFSLEdBQWlCb0UsT0FBTyxDQUFDcEUsTUFBMUIsSUFBb0MsRUFBakQsR0FBdUR5RCxRQUFRLENBQUNWLENBQXpILEVBQTZIO1FBQUUsT0FBTyxJQUFQO01BQWEsQ0FBNUksTUFBa0o7UUFBRSxPQUFPLEtBQVA7TUFBYztJQUNuSzs7SUFFRCxTQUFTc0IsT0FBVCxHQUFtQjtNQUNqQixJQUFJQyxLQUFLLEdBQUcsRUFBWjtNQUNBLElBQUlDLE9BQU8sR0FBRzVDLEtBQUssQ0FBQ3NDLFdBQU4sRUFBZDtNQUNBTyxRQUFRLENBQUNDLFNBQVQsQ0FBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUJMLE9BQU8sQ0FBQ3RFLEtBQWpDLEVBQXdDc0UsT0FBTyxDQUFDcEUsTUFBaEQ7TUFDQXdFLFFBQVEsQ0FBQ0UsSUFBVCxhQUFtQkosS0FBbkI7TUFDQUUsUUFBUSxDQUFDRyxTQUFULEdBQXFCLE1BQXJCO01BQ0FILFFBQVEsQ0FBQ0ksUUFBVCxtQkFBNkJDLElBQUksQ0FBQ0MsS0FBTCxDQUFXUCxPQUFPLENBQUN6QixDQUFuQixDQUE3QixHQUFzRCxFQUF0RCxZQUE2RHdCLEtBQTdEO01BQ0FFLFFBQVEsQ0FBQ0ksUUFBVCxrQkFBNEJDLElBQUksQ0FBQ0MsS0FBTCxDQUFXUCxPQUFPLENBQUN4QixDQUFuQixDQUE1QixHQUFxRCxFQUFyRCxZQUE0RHVCLEtBQUssR0FBRyxDQUFwRTtNQUNBRSxRQUFRLENBQUNJLFFBQVQsMkJBQXFDQyxJQUFJLENBQUNDLEtBQUwsQ0FBV25GLE9BQU8sQ0FBQ21ELENBQW5CLENBQXJDLEdBQThELEVBQTlELFlBQXFFd0IsS0FBSyxHQUFHLENBQTdFO01BQ0FFLFFBQVEsQ0FBQ0ksUUFBVCwyQkFBcUNDLElBQUksQ0FBQ0MsS0FBTCxDQUFXbkYsT0FBTyxDQUFDb0QsQ0FBbkIsQ0FBckMsR0FBOEQsRUFBOUQsWUFBcUV1QixLQUFLLEdBQUcsQ0FBN0U7TUFDQUUsUUFBUSxDQUFDSSxRQUFULDZCQUF1Q0MsSUFBSSxDQUFDQyxLQUFMLENBQVduRixPQUFPLENBQUNLLE1BQW5CLENBQXZDLEdBQXFFLEVBQXJFLFlBQTRFc0UsS0FBSyxHQUFHLENBQXBGO01BQ0FFLFFBQVEsQ0FBQ0ksUUFBVCxtQkFBNkJqRixPQUFPLENBQUNvRixRQUFSLEVBQTdCLEdBQW1ELEdBQW5ELFlBQTJEVCxLQUEzRDtNQUNBRSxRQUFRLENBQUNJLFFBQVQsNEJBQXNDakQsS0FBSyxDQUFDSSxXQUE1QyxHQUEyRCxHQUEzRCxZQUFtRXVDLEtBQUssR0FBRyxDQUEzRTtJQUVEOztJQUlELFNBQVNVLFdBQVQsR0FBdUI7TUFDckIzRSxLQUFLLENBQUM0RSxFQUFOLENBQVMsWUFBVCxFQUF1QixVQUFVQyxPQUFWLEVBQW1CO1FBQ3hDLElBQUlDLEVBQUUsR0FBR0QsT0FBTyxDQUFDRSxXQUFSLEVBQVQ7UUFBQSxJQUFnQ0MsRUFBRSxHQUFHRixFQUFFLENBQUNHLE9BQUgsRUFBckM7UUFDQSxJQUFJQyxFQUFFLEdBQUdMLE9BQU8sQ0FBQ00sV0FBUixFQUFUO1FBQUEsSUFBZ0NDLEVBQUUsR0FBR0YsRUFBRSxDQUFDRCxPQUFILEVBQXJDO1FBQ0EsSUFBSUksU0FBUyxHQUFHUCxFQUFFLENBQUNRLFdBQUgsT0FBcUIsTUFBckIsR0FBOEJOLEVBQTlCLEdBQW1DRSxFQUFFLENBQUNJLFdBQUgsT0FBcUIsTUFBckIsR0FBOEJGLEVBQTlCLEdBQW1DLElBQXRGO1FBQ0EsSUFBSUcsVUFBVSxHQUFHVCxFQUFFLENBQUNRLFdBQUgsT0FBcUIsUUFBckIsR0FBZ0NOLEVBQWhDLEdBQXFDRSxFQUFFLENBQUNJLFdBQUgsT0FBcUIsUUFBckIsR0FBZ0NGLEVBQWhDLEdBQXFDLElBQTNGO1FBQ0FJLFVBQVUsQ0FBQyxZQUFZO1VBQUUsSUFBSUgsU0FBUyxJQUFJRSxVQUFqQixFQUE2QjtZQUFFdkYsS0FBSyxDQUFDd0IsV0FBTixDQUFrQjZELFNBQWxCO1VBQStCO1FBQUUsQ0FBL0UsRUFBaUYsQ0FBakYsQ0FBVjtNQUNELENBTkQ7SUFPRDs7SUFNRC9GLE9BQU8sQ0FBQ21HLElBQVIsR0FBZSxZQUFZO01BQ3pCekMsV0FBVztNQUNYZ0IsT0FBTztNQUNQVyxXQUFXO0lBQ1osQ0FKRDs7SUFNTixPQUFPM0UsS0FBUDtFQUNLLENBNUxEO0FBNkxELEVBR0g7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Rlc3QtcmVwby8uL3NyYy9zY3JpcHRzL2xldmVsMy5qcz9iZjJlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vbGV2ZWwxdHJpYWxcblxuaW1wb3J0ICogYXMgcGxhbmNrIGZyb20gJ3BsYW5jay9kaXN0L3BsYW5jay13aXRoLXRlc3RiZWQnXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXZlbDMoKSB7XG4gICAgcGxhbmNrLnRlc3RiZWQoJ1NhbmRib3gnLCBmdW5jdGlvbiAodGVzdGJlZCkge1xuICAgICAgdGVzdGJlZC5iYWNrZ3JvdW5kID0gXCIjMTExMTExXCJcbiAgICAgIHRlc3RiZWQuc3BlZWQgPSAyXG4gICAgICBcbiAgICAgIHRlc3RiZWQud2lkdGggPSAoaW5uZXJXaWR0aCAvIDQpO1xuICAgICAgdGVzdGJlZC5oZWlnaHQgPSAoaW5uZXJIZWlnaHQgLyA0KTtcbiAgICAgIHRlc3RiZWQuaHogPSAzMDtcblxuICAgICAgbGV0IHBsID0gcGxhbmNrLCBWZWMyID0gcGwuVmVjMjtcbiAgICAgIGxldCB3b3JsZCA9IG5ldyBwbC5Xb3JsZChWZWMyKDAsIC0xMCkpO1xuICAgICAgLy8gdGVzdGJlZC5tb3VzZUZvcmNlID0gNjAwMDsgXG4gICAgICAvLyB0dXJucyBvbi9vZmYgaW1wdWxzZXMgdG8gYXBwbHkgbGlrZSBzbGluZ3Nob3QgXG5cbiAgICAgIGxldCBDT1VOVCA9IDA7XG5cbiAgICAgIGxldCBncm91bmQgPSB3b3JsZC5jcmVhdGVCb2R5KCk7XG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoLTgwLjAsIC04MC4wKSwgVmVjMigyMDAuMCwgLTgwLjApKSwgMC4wKTsgLy8gZ3JvdW5kXG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoMjAwLjAsIDE1MC4wKSwgVmVjMigyMDAuMCwgLTgwLjApKSwgMC4wKTsgLy8gcmlnaHRcbiAgICAgIGdyb3VuZC5jcmVhdGVGaXh0dXJlKHBsLkVkZ2UoVmVjMigtODAuMCwgMTUwLjApLCBWZWMyKC04MC4wLCAtODAuMCkpLCAwLjApOyAvLyBsZWZ0XG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoLTgwLjAsIDE1MC4wKSwgVmVjMigyMDAuMCwgMTUwLjApKSwgMC4wKTsgIC8vIHRvcFxuXG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoLTgwLjAsIDAuMCksIFZlYzIoMTUwLjAsIDAuMCkpLCAwLjApOyAvLyBncm91bmRcbiAgICAgIGdyb3VuZC5jcmVhdGVGaXh0dXJlKHBsLkVkZ2UoVmVjMig4MC4wLCAtMzAuMCksIFZlYzIoMTcwLjAsIC0xMC4wKSksIHsgcmVzdGl0dXRpb246IDAsIGZyaWN0aW9uOiAwIH0pLnJlbmRlciA9IHsgZmlsbDogJ29yYW5nZScsIHN0cm9rZTogJ29yYW5nZScgfTsgLy8gZ3JvdW5kIHNsYW50XG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoMTcwLjAsIC0xMC4wKSwgVmVjMigyMDAuMCwgMC4wKSksIHsgcmVzdGl0dXRpb246IDAsIGZyaWN0aW9uOiAwIH0pLnJlbmRlciA9IHsgZmlsbDogJ29yYW5nZScsIHN0cm9rZTogJ29yYW5nZScgfTsgLy8gZ3JvdW5kIHNsYW50XG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoODAuMCwgLTMwLjApLCBWZWMyKDYwLjAsIC0yNS4wKSksIHsgcmVzdGl0dXRpb246IDAsIGZyaWN0aW9uOiAwIH0pLnJlbmRlciA9IHsgZmlsbDogJ29yYW5nZScsIHN0cm9rZTogJ29yYW5nZScgfTsgLy8gZ3JvdW5kIHNsYW50XG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoNjAuMCwgLTI1LjApLCBWZWMyKDUwLjAsIC0yMC4wKSksIHsgcmVzdGl0dXRpb246IDYwLCBmcmljdGlvbjogMCB9KS5yZW5kZXIgPSB7IGZpbGw6ICdibHVlJywgc3Ryb2tlOiAnYmx1ZScgfTsgLy8gZ3JvdW5kIHNsYW50XG5cbiAgICAgIC8vIGdyb3VuZC5jcmVhdGVGaXh0dXJlKHBsLkVkZ2UoVmVjMigxMDAuMCwgLTgwLjApLCBWZWMyKDIwMC4wLCAtMjAuMCkpLCB7IHJlc3RpdHV0aW9uOiA2MCB9KS5yZW5kZXIgPSB7IGZpbGw6ICdibHVlJywgc3Ryb2tlOiAnYmx1ZScgfTs7XG5cbiAgICAgIC8vIGdyb3VuZC5jcmVhdGVGaXh0dXJlKHBsLkNpcmNsZShWZWMyKDEwMC4wLCAtODAuMCksIDEwKSwgeyByZXN0aXR1dGlvbjogNjAgfSkucmVuZGVyID0ge2ZpbGw6ICdibHVlJywgc3Ryb2tlOiAnYmx1ZSd9OyAvLyBib3VuY3lcbiAgICAgIC8vIGdyb3VuZC5jcmVhdGVGaXh0dXJlKHBsLkNpcmNsZShWZWMyKDIwMC4wLCAtNDAuMCksIDEwKSwgeyByZXN0aXR1dGlvbjogNjAgfSkucmVuZGVyID0geyBmaWxsOiAnYmx1ZScsIHN0cm9rZTogJ2JsdWUnIH07IC8vIGJvdW5jeVxuICAgICAgLy8gZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuQm94KDUwLCA1LCBWZWMyKDE1MCwgLTYwKSwgNjApLCB7cmVzdGl0dXRpb246IDYwfSkucmVuZGVyID0geyBmaWxsOiAnYmx1ZScsIHN0cm9rZTogJ2JsdWUnIH07XG4gICAgICAvLyAucmVuZGVyID0geyBmaWxsOiAnYmx1ZScsIHN0cm9rZTogJ2JsdWUnIH07IC8vIGJvdW5jeVxuICAgICAgXG5cbiAgICAgIGxldCBiYWxsQm9keURlZiA9IHtcbiAgICAgICAgcG9zaXRpb246IFZlYzIoNzAsIDEwKSxcbiAgICAgICAgYnVsbGV0OiBmYWxzZSxcbiAgICAgICAgYWxsb3dTbGVlcDogdHJ1ZSxcbiAgICAgICAgbGluZWFyRGFtcGluZzogLjAxLFxuICAgICAgICBhbmd1bGFyRGFtcGluZzogLjVcbiAgICAgIH1cblxuXG4gICAgICBsZXQgYmFsbFN0YXJ0QXR0ciA9IHtcbiAgICAgICAgZnJpY3Rpb246IC4xLFxuICAgICAgICByZXN0aXR1dGlvbjogLjUsIC8vIGJvdW5jZVxuICAgICAgICBkZW5zaXR5OiAxMCxcbiAgICAgICAgdXNlckRhdGE6ICdiYWxsJ1xuICAgICAgfTtcblxuICAgICAgbGV0IGJhbGxGaW5pc2hBdHRyID0ge1xuICAgICAgICBmcmljdGlvbjogLjIsXG4gICAgICAgIHJlc3RpdHV0aW9uOiAuMSwgLy8gYm91bmNlXG4gICAgICAgIGRlbnNpdHk6IDEsXG4gICAgICAgIHVzZXJEYXRhOiAnZmluaXNoJ1xuICAgICAgfTtcblxuXG4gICAgICBsZXQgYmFsbDEgPSB3b3JsZC5jcmVhdGVEeW5hbWljQm9keShiYWxsQm9keURlZik7XG4gICAgICB3b3JsZC5kZXN0cm95Qm9keShiYWxsMSlcblxuICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVTaG90KCkge1xuICAgICAgICBpZiAoYmFsbDEubV9kZXN0cm95ZWQpIHtcbiAgICAgICAgICBiYWxsMSA9IHdvcmxkLmNyZWF0ZUR5bmFtaWNCb2R5KGJhbGxCb2R5RGVmKTtcbiAgICAgICAgICBiYWxsMS5jcmVhdGVGaXh0dXJlKHBsLkNpcmNsZSgxKSwgYmFsbFN0YXJ0QXR0cik7XG4gICAgICAgICAgYmFsbDEucmVuZGVyID0geyB0ZXh0dXJlOiBpbWcgfTtcbiAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKVxuICAgICAgICAgIGltZy5zcmMgPSBcImh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvMi8yNy9XZXlfc291cmNlX2ZhcnJpbmdkb24uanBnXCJcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZW5lcmF0ZVNob3QoKVxuXG4gICAgICBjb25zdCBiYWxsMyA9IHdvcmxkLmNyZWF0ZUR5bmFtaWNCb2R5KGJhbGxCb2R5RGVmKTtcbiAgICAgIGJhbGwzLnNldFBvc2l0aW9uKFZlYzIoMzAsIDIpKVxuICAgICAgYmFsbDMuY3JlYXRlRml4dHVyZShwbC5DaXJjbGUoMSksIGJhbGxTdGFydEF0dHIpO1xuICAgICAgYmFsbDMucmVuZGVyID0geyBmaWxsOiAnYmx1ZScsIHN0cm9rZTogJ2JsdWUnIH07XG5cblxuICAgICAgbGV0IGJhbGwyID0gd29ybGQuY3JlYXRlQm9keShWZWMyKDgyLC0yMikpO1xuICAgICAgYmFsbDIuY3JlYXRlRml4dHVyZShwbC5DaXJjbGUoMSksIGJhbGxGaW5pc2hBdHRyKTtcbiAgICAgIGJhbGwyLnJlbmRlciA9IHsgZmlsbDogJ3JlZCcsIHN0cm9rZTogJ3JlZCcgfTtcblxuXG4gICAgICB3aW5kb3cucGwgPSBwbFxuICAgICAgd2luZG93LndvcmxkID0gd29ybGRcbiAgICAgIGNvbnNvbGUubG9nKFwid2hpdGUgYmFsbCA9IGJhbGwxIFwiLCBiYWxsMSlcbiAgICAgIHdpbmRvdy5iYWxsMSA9IGJhbGwxXG4gICAgICBjb25zb2xlLmxvZyhcInJlZCBiYWxsID0gYmFsbDIgXCIsIGJhbGwyKVxuICAgICAgd2luZG93LmJhbGwyID0gYmFsbDJcbiAgICAgIGNvbnNvbGUubG9nKFwiYmx1ZSBiYWxsID0gYmFsbDMgXCIsIGJhbGwzKVxuICAgICAgd2luZG93LmJhbGwzID0gYmFsbDNcblxuXG4gICAgICBsZXQgYSA9IENPVU5UO1xuICAgICAgbGV0IGJveCA9IHBsYW5jay5Cb3goYSwgYSthK2EpO1xuXG4gICAgICBsZXQgeCA9IFZlYzIoMTgwLjAsIDgpO1xuICAgICAgbGV0IHkgPSBWZWMyKCk7XG4gICAgICBsZXQgZGVsdGFYID0gVmVjMigwLCA0KTtcbiAgICAgIGxldCBkZWx0YVkgPSBWZWMyKDAsIDQpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENPVU5UOyArK2kpIHtcbiAgICAgICAgeS5zZXQoeCk7XG4gICAgICAgICAgd29ybGQuY3JlYXRlRHluYW1pY0JvZHkoeSkuY3JlYXRlRml4dHVyZShib3gsIDUuMCk7XG4gICAgICAgICAgeS5hZGQoZGVsdGFZKTtcbiAgICAgICAgeC5hZGQoZGVsdGFYKTtcbiAgICAgIH1cblxuICAgICAgICAgICAgLy8gbGV0IHNwaW4gPSB3b3JsZC5jcmVhdGVEeW5hbWljQm9keShWZWMyKDAuMCwgMTAuMCkpO1xuICAgICAgLy8gc3Bpbi5jcmVhdGVGaXh0dXJlKHBsLkJveCguNSwgMTAuMCksIDIwLjApO1xuXG4gICAgICAvLyBsZXQgam9pbnQxID0gd29ybGQuY3JlYXRlSm9pbnQocGwuUmV2b2x1dGVKb2ludCh7XG4gICAgICAvLyAgIG1vdG9yU3BlZWQ6IE1hdGguUEksXG4gICAgICAvLyAgIG1heE1vdG9yVG9ycXVlOiAyMDAwMC4wLFxuICAgICAgLy8gICBlbmFibGVNb3RvcjogdHJ1ZVxuICAgICAgLy8gfSwgZ3JvdW5kLCBzcGluLCBWZWMyKDAuMCwgMS4wKSkpO1xuXG5cblxuICAgICAgZnVuY3Rpb24ga2V5bGlzdGVuZXIoKSB7XG5cbiAgICAgICAgaWYgKHRlc3RiZWQuYWN0aXZlS2V5cy5yaWdodCkge1xuICAgICAgICAgIGlmIChjYW1lcmFMaW1pdFgodGVzdGJlZC54KSkgeyB0ZXN0YmVkLnggKz0gMiB9IGVsc2UgeyB0ZXN0YmVkLnggPSBiYWxsMXBvcy54IH1cbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0YmVkLmFjdGl2ZUtleXMubGVmdCkge1xuICAgICAgICAgIGlmIChjYW1lcmFMaW1pdFgodGVzdGJlZC54KSkgeyB0ZXN0YmVkLnggLT0gMiB9IGVsc2UgeyB0ZXN0YmVkLnggPSBiYWxsMXBvcy54IH1cbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0YmVkLmFjdGl2ZUtleXMudXApIHtcbiAgICAgICAgICBpZiAoY2FtZXJhTGltaXRZKHRlc3RiZWQueSkpIHsgdGVzdGJlZC55IC09IDIgfSBlbHNlIHsgdGVzdGJlZC55ID0gYmFsbDFwb3MueSB9XG4gICAgICAgIH0gZWxzZSBpZiAodGVzdGJlZC5hY3RpdmVLZXlzLmRvd24pIHtcbiAgICAgICAgICBpZiAoY2FtZXJhTGltaXRZKHRlc3RiZWQueSkpIHsgdGVzdGJlZC55ICs9IDIgfSBlbHNlIHsgdGVzdGJlZC55ID0gYmFsbDFwb3MueSB9XG4gICAgICAgIH0gZWxzZSBpZiAodGVzdGJlZC5hY3RpdmVLZXlzLkMpIHtcbiAgICAgICAgICB0ZXN0YmVkLnRvZ2dsZVBhdXNlKClcbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0YmVkLmFjdGl2ZUtleXMuZmlyZSkge1xuICAgICAgICAgIGdlbmVyYXRlU2hvdCgpXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBsZXQgYmFsbDFwb3MgPSBiYWxsMS5nZXRQb3NpdGlvbigpXG5cbiAgICAgIGZ1bmN0aW9uIGNhbWVyYUxpbWl0WCh4UG9zKSB7XG4gICAgICAgIGlmICgodGVzdGJlZC54ICsgKHRlc3RiZWQud2lkdGggKiAuNCkgPiBiYWxsMXBvcy54KSAmJiAodGVzdGJlZC54IC0gKHRlc3RiZWQud2lkdGggKiAuNCkgPCBiYWxsMXBvcy54KSkgeyByZXR1cm4gdHJ1ZSB9IGVsc2UgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW1lcmFMaW1pdFkoeVBvcykge1xuICAgICAgICBpZiAoKHRlc3RiZWQueSArICh0ZXN0YmVkLmhlaWdodCAqIC40KSA+IGJhbGwxcG9zLnkpICYmICgodGVzdGJlZC55IC0gKHRlc3RiZWQuaGVpZ2h0ICsgY2FudmFzMS5oZWlnaHQpICogLjQpIDwgYmFsbDFwb3MueSkpIHsgcmV0dXJuIHRydWUgfSBlbHNlIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGV4dE91dCgpIHtcbiAgICAgICAgbGV0IHNjYWxlID0gMjBcbiAgICAgICAgbGV0IGJhbGxwb3MgPSBiYWxsMS5nZXRQb3NpdGlvbigpXG4gICAgICAgIGNvbnRleHQyLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMxLndpZHRoLCBjYW52YXMxLmhlaWdodCk7XG4gICAgICAgIGNvbnRleHQyLmZvbnQgPSBgJHtzY2FsZX1weCBDb3VyaWVyIE5ld2A7XG4gICAgICAgIGNvbnRleHQyLmZpbGxTdHlsZSA9ICdibHVlJztcbiAgICAgICAgY29udGV4dDIuZmlsbFRleHQoYFggUE9TIDogJHtNYXRoLnJvdW5kKGJhbGxwb3MueCl9YCwgMjAsIGAke3NjYWxlfWApO1xuICAgICAgICBjb250ZXh0Mi5maWxsVGV4dChgWSBQT1MgOiR7TWF0aC5yb3VuZChiYWxscG9zLnkpfWAsIDIwLCBgJHtzY2FsZSAqIDJ9YCk7XG4gICAgICAgIGNvbnRleHQyLmZpbGxUZXh0KGB0ZXN0YmVkIFggUE9TIDogJHtNYXRoLnJvdW5kKHRlc3RiZWQueCl9YCwgMjAsIGAke3NjYWxlICogM31gKTtcbiAgICAgICAgY29udGV4dDIuZmlsbFRleHQoYHRlc3RiZWQgWSBQT1MgOiAke01hdGgucm91bmQodGVzdGJlZC55KX1gLCAyMCwgYCR7c2NhbGUgKiA0fWApO1xuICAgICAgICBjb250ZXh0Mi5maWxsVGV4dChgdGVzdGJlZCBZIGhlaWdodCA6JHtNYXRoLnJvdW5kKHRlc3RiZWQuaGVpZ2h0KX1gLCAyMCwgYCR7c2NhbGUgKiA1fWApO1xuICAgICAgICBjb250ZXh0Mi5maWxsVGV4dChgUGF1c2UgOiAke3Rlc3RiZWQuaXNQYXVzZWQoKX1gLCAyNTAsIGAke3NjYWxlfWApO1xuICAgICAgICBjb250ZXh0Mi5maWxsVGV4dChgU2hvdCBkZXN0cm95ZWQgOiAke2JhbGwxLm1fZGVzdHJveWVkfWAsIDI1MCwgYCR7c2NhbGUgKiAyfWApO1xuXG4gICAgICB9XG5cblxuXG4gICAgICBmdW5jdGlvbiBmaW5pc2hUb3VjaCgpIHtcbiAgICAgICAgd29ybGQub24oJ3Bvc3Qtc29sdmUnLCBmdW5jdGlvbiAoY29udGFjdCkge1xuICAgICAgICAgIGxldCBmQSA9IGNvbnRhY3QuZ2V0Rml4dHVyZUEoKSwgYkEgPSBmQS5nZXRCb2R5KCk7XG4gICAgICAgICAgbGV0IGZCID0gY29udGFjdC5nZXRGaXh0dXJlQigpLCBiQiA9IGZCLmdldEJvZHkoKTtcbiAgICAgICAgICBsZXQgdGhyb3dCYWxsID0gZkEuZ2V0VXNlckRhdGEoKSA9PT0gXCJiYWxsXCIgPyBiQSA6IGZCLmdldFVzZXJEYXRhKCkgPT09IFwiYmFsbFwiID8gYkIgOiBudWxsO1xuICAgICAgICAgIGxldCBmaW5pc2hCYWxsID0gZkEuZ2V0VXNlckRhdGEoKSA9PT0gXCJmaW5pc2hcIiA/IGJBIDogZkIuZ2V0VXNlckRhdGEoKSA9PT0gXCJmaW5pc2hcIiA/IGJCIDogbnVsbDtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgaWYgKHRocm93QmFsbCAmJiBmaW5pc2hCYWxsKSB7IHdvcmxkLmRlc3Ryb3lCb2R5KHRocm93QmFsbCk7IH0gfSwgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG5cblxuXG5cbiAgICAgIHRlc3RiZWQuc3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAga2V5bGlzdGVuZXIoKVxuICAgICAgICB0ZXh0T3V0KClcbiAgICAgICAgZmluaXNoVG91Y2goKVxuICAgICAgfTtcblxucmV0dXJuIHdvcmxkXG4gICAgfSk7XG4gIH1cblxuXG4vLyBleHBvcnQge2xldmVsMX07XG4vLyBleHBvcnQgZGVmYXVsdDsiXSwibmFtZXMiOlsicGxhbmNrIiwibGV2ZWwzIiwidGVzdGJlZCIsImJhY2tncm91bmQiLCJzcGVlZCIsIndpZHRoIiwiaW5uZXJXaWR0aCIsImhlaWdodCIsImlubmVySGVpZ2h0IiwiaHoiLCJwbCIsIlZlYzIiLCJ3b3JsZCIsIldvcmxkIiwiQ09VTlQiLCJncm91bmQiLCJjcmVhdGVCb2R5IiwiY3JlYXRlRml4dHVyZSIsIkVkZ2UiLCJyZXN0aXR1dGlvbiIsImZyaWN0aW9uIiwicmVuZGVyIiwiZmlsbCIsInN0cm9rZSIsImJhbGxCb2R5RGVmIiwicG9zaXRpb24iLCJidWxsZXQiLCJhbGxvd1NsZWVwIiwibGluZWFyRGFtcGluZyIsImFuZ3VsYXJEYW1waW5nIiwiYmFsbFN0YXJ0QXR0ciIsImRlbnNpdHkiLCJ1c2VyRGF0YSIsImJhbGxGaW5pc2hBdHRyIiwiYmFsbDEiLCJjcmVhdGVEeW5hbWljQm9keSIsImRlc3Ryb3lCb2R5IiwiZ2VuZXJhdGVTaG90IiwibV9kZXN0cm95ZWQiLCJDaXJjbGUiLCJ0ZXh0dXJlIiwiaW1nIiwiSW1hZ2UiLCJzcmMiLCJiYWxsMyIsInNldFBvc2l0aW9uIiwiYmFsbDIiLCJ3aW5kb3ciLCJjb25zb2xlIiwibG9nIiwiYSIsImJveCIsIkJveCIsIngiLCJ5IiwiZGVsdGFYIiwiZGVsdGFZIiwiaSIsInNldCIsImFkZCIsImtleWxpc3RlbmVyIiwiYWN0aXZlS2V5cyIsInJpZ2h0IiwiY2FtZXJhTGltaXRYIiwiYmFsbDFwb3MiLCJsZWZ0IiwidXAiLCJjYW1lcmFMaW1pdFkiLCJkb3duIiwiQyIsInRvZ2dsZVBhdXNlIiwiZmlyZSIsImdldFBvc2l0aW9uIiwieFBvcyIsInlQb3MiLCJjYW52YXMxIiwidGV4dE91dCIsInNjYWxlIiwiYmFsbHBvcyIsImNvbnRleHQyIiwiY2xlYXJSZWN0IiwiZm9udCIsImZpbGxTdHlsZSIsImZpbGxUZXh0IiwiTWF0aCIsInJvdW5kIiwiaXNQYXVzZWQiLCJmaW5pc2hUb3VjaCIsIm9uIiwiY29udGFjdCIsImZBIiwiZ2V0Rml4dHVyZUEiLCJiQSIsImdldEJvZHkiLCJmQiIsImdldEZpeHR1cmVCIiwiYkIiLCJ0aHJvd0JhbGwiLCJnZXRVc2VyRGF0YSIsImZpbmlzaEJhbGwiLCJzZXRUaW1lb3V0Iiwic3RlcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/scripts/level3.js\n");

/***/ }),

/***/ "./src/scripts/level4.js":
/*!*******************************!*\
  !*** ./src/scripts/level4.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"level4\": function() { return /* binding */ level4; }\n/* harmony export */ });\n/* harmony import */ var planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! planck/dist/planck-with-testbed */ \"./node_modules/planck/dist/planck-with-testbed.js\");\n/* harmony import */ var planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__);\n//level1trial\n\nfunction level4() {\n  planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__.testbed('Sandbox', function (testbed) {\n    // window.canvas = canvas\n    testbed.background = \"#111111\";\n    window.planck = planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__;\n    window.testbed = testbed; //currently doesnt work\n\n    testbed.speed = 2;\n    testbed.width = innerWidth / 4;\n    testbed.height = innerHeight / 4;\n    testbed.hz = 30;\n    var pl = planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__,\n        Vec2 = pl.Vec2;\n    var world = new pl.World(Vec2(0, -10));\n    var breakout1 = false;\n    window.breakout1 = breakout1; // testbed.mouseForce = 6000; \n    // turns on/off impulses to apply like slingshot\n\n    var COUNT = 1;\n    var ground = world.createBody();\n    ground.createFixture(pl.Edge(Vec2(-80.0, -80.0), Vec2(200.0, -80.0)), 0.0); // ground\n\n    ground.createFixture(pl.Edge(Vec2(200.0, 150.0), Vec2(200.0, -80.0)), 0.0); // right\n\n    ground.createFixture(pl.Edge(Vec2(-80.0, 150.0), Vec2(-80.0, -80.0)), 0.0); // left\n\n    ground.createFixture(pl.Edge(Vec2(-80.0, 150.0), Vec2(200.0, 150.0)), 0.0); // top\n\n    ground.createFixture(pl.Edge(Vec2(-80.0, 40.0), Vec2(150.0, 40.0)), {\n      friction: 0\n    }).render = {\n      fill: 'orange',\n      stroke: 'orange'\n    }; // ground\n\n    ground.createFixture(pl.Edge(Vec2(-60.0, 5.0), Vec2(185.0, 5.0)), {\n      restitution: 0,\n      friction: 0\n    }).render = {\n      fill: 'orange',\n      stroke: 'orange'\n    }; // ground slant\n\n    ground.createFixture(pl.Edge(Vec2(160.0, -15.0), Vec2(200.0, 0.0)), {\n      restitution: 0,\n      friction: 0\n    }).render = {\n      fill: 'orange',\n      stroke: 'orange'\n    }; // ground slant\n\n    ground.createFixture(pl.Edge(Vec2(-80.0, -70.0), Vec2(200.0, -70.0)), {\n      friction: 1\n    }); // ground slide\n\n    ground.createFixture(pl.Edge(Vec2(-80.0, -60.0), Vec2(-75.0, -70.0)), {\n      restitution: 60\n    }).render = {\n      fill: 'blue',\n      stroke: 'blue'\n    }; // ground slide\n    // ground.createFixture(pl.Edge(Vec2(100.0, -80.0), Vec2(200.0, -20.0)), { restitution: 60 }).render = { fill: 'blue', stroke: 'blue' };;\n    // ground.createFixture(pl.Circle(Vec2(100.0, -80.0), 10), { restitution: 60 }).render = {fill: 'blue', stroke: 'blue'}; // bouncy\n    // ground.createFixture(pl.Circle(Vec2(200.0, -40.0), 10), { restitution: 60 }).render = { fill: 'blue', stroke: 'blue' }; // bouncy\n    // ground.createFixture(pl.Box(50, 5, Vec2(150, -60), 60), {restitution: 60}).render = { fill: 'blue', stroke: 'blue' };\n    // .render = { fill: 'blue', stroke: 'blue' }; // bouncy\n\n    var ballBodyDef = {\n      position: Vec2(70, 30),\n      bullet: false,\n      allowSleep: true,\n      linearDamping: .01,\n      angularDamping: .5\n    };\n    var ballStartAttr = {\n      friction: .1,\n      restitution: .5,\n      // bounce\n      density: 10,\n      userData: 'ball'\n    };\n    var ballFinishAttr = {\n      friction: .2,\n      restitution: .1,\n      // bounce\n      density: 1,\n      userData: 'finish'\n    };\n    var ball1 = world.createDynamicBody(ballBodyDef);\n    world.destroyBody(ball1);\n\n    function generateShot() {\n      if (ball1.m_destroyed) {\n        ball1 = world.createDynamicBody(ballBodyDef);\n        ball1.createFixture(pl.Circle(1), ballStartAttr);\n        ball1.render = {\n          fill: \"white\"\n        }; // const img = new Image()\n        // img.src = \"https://upload.wikimedia.org/wikipedia/commons/2/27/Wey_source_farringdon.jpg\"\n      }\n    }\n\n    generateShot();\n    var ball3 = world.createDynamicBody(ballBodyDef);\n    ball3.setPosition(Vec2(30, 40));\n    ball3.createFixture(pl.Circle(1), ballStartAttr);\n    ball3.render = {\n      fill: 'blue',\n      stroke: 'blue'\n    };\n    var ball2 = world.createBody(Vec2(130, -40));\n    ball2.createFixture(pl.Circle(1), ballFinishAttr);\n    ball2.render = {\n      fill: 'red',\n      stroke: 'red'\n    };\n    window.pl = pl;\n    window.world = world;\n    console.log(\"white ball = ball1 \", ball1);\n    window.ball1 = ball1;\n    console.log(\"red ball = ball2 \", ball2);\n    window.ball2 = ball2;\n    console.log(\"blue ball = ball3 \", ball3);\n    window.ball3 = ball3;\n    var a = COUNT;\n    var box = planck_dist_planck_with_testbed__WEBPACK_IMPORTED_MODULE_0__.Box(a, a * 9, x, 0);\n    var x = Vec2(160.0, 8);\n    var y = Vec2();\n    var deltaX = Vec2(0, 4);\n    var deltaY = Vec2(0, 4);\n\n    for (var i = 0; i < COUNT; ++i) {\n      y.set(x);\n      world.createDynamicBody(y).createFixture(box, 5.0);\n      y.add(deltaY);\n      x.add(deltaX);\n    }\n\n    function keylistener() {\n      //there is probably a way to do this with a case statement\n      //camera\n      if (testbed.activeKeys.right) {\n        if (cameraLimitX(testbed.x)) {\n          testbed.x += 2;\n        } else {\n          testbed.x = ball1pos.x;\n        }\n      } else if (testbed.activeKeys.left) {\n        if (cameraLimitX(testbed.x)) {\n          testbed.x -= 2;\n        } else {\n          testbed.x = ball1pos.x;\n        }\n      } else if (testbed.activeKeys.up) {\n        if (cameraLimitY(testbed.y)) {\n          testbed.y -= 2;\n        } else {\n          testbed.y = ball1pos.y;\n        }\n      } else if (testbed.activeKeys.down) {\n        if (cameraLimitY(testbed.y)) {\n          testbed.y += 2;\n        } else {\n          testbed.y = ball1pos.y;\n        }\n      } else if (testbed.activeKeys.C) {\n        testbed.togglePause();\n      } else if (testbed.activeKeys.fire) {\n        generateShot();\n      } else if (testbed.activeKeys.z) {\n        testbed.status('/: Accelerate car, /: Change spring frequency');\n      }\n    }\n\n    var ball1pos = ball1.getPosition();\n\n    function cameraLimitX(xPos) {\n      if (testbed.x + testbed.width * .4 > ball1pos.x && testbed.x - testbed.width * .4 < ball1pos.x) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    function cameraLimitY(yPos) {\n      if (testbed.y + testbed.height * .4 > ball1pos.y && testbed.y - (testbed.height + canvas1.height) * .4 < ball1pos.y) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    function textOut() {\n      var scale = 20;\n      var ballpos = ball1.getPosition();\n      context2.clearRect(0, 0, canvas1.width, canvas1.height);\n      context2.font = \"\".concat(scale, \"px Courier New\");\n      context2.fillStyle = 'blue';\n      context2.fillText(\"X POS : \".concat(Math.round(ballpos.x)), 20, \"\".concat(scale));\n      context2.fillText(\"Y POS :\".concat(Math.round(ballpos.y)), 20, \"\".concat(scale * 2));\n      context2.fillText(\"testbed X POS : \".concat(Math.round(testbed.x)), 20, \"\".concat(scale * 3));\n      context2.fillText(\"testbed Y POS : \".concat(Math.round(testbed.y)), 20, \"\".concat(scale * 4));\n      context2.fillText(\"testbed Y height :\".concat(Math.round(testbed.height)), 20, \"\".concat(scale * 5));\n      context2.fillText(\"Pause : \".concat(testbed.isPaused()), 250, \"\".concat(scale));\n      context2.fillText(\"Shot destroyed : \".concat(ball1.m_destroyed), 250, \"\".concat(scale * 2));\n    }\n\n    function finishTouch() {\n      world.on('post-solve', function (contact) {\n        var fA = contact.getFixtureA(),\n            bA = fA.getBody();\n        var fB = contact.getFixtureB(),\n            bB = fB.getBody();\n        var throwBall = fA.getUserData() === \"ball\" ? bA : fB.getUserData() === \"ball\" ? bB : null;\n        var finishBall = fA.getUserData() === \"finish\" ? bA : fB.getUserData() === \"finish\" ? bB : null;\n        setTimeout(function () {\n          if (throwBall && finishBall) {\n            world.destroyBody(throwBall);\n          }\n        }, 1);\n      });\n    }\n\n    testbed.step = function () {\n      keylistener();\n      textOut();\n      finishTouch();\n    };\n\n    return world;\n  });\n} // export {level1};\n// export default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy9sZXZlbDQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFFQTtBQUVPLFNBQVNDLE1BQVQsR0FBa0I7RUFDckJELG9FQUFBLENBQWUsU0FBZixFQUEwQixVQUFVRSxPQUFWLEVBQW1CO0lBQzNDO0lBQ0FBLE9BQU8sQ0FBQ0MsVUFBUixHQUFxQixTQUFyQjtJQUNBQyxNQUFNLENBQUNKLE1BQVAsR0FBZ0JBLDREQUFoQjtJQUNBSSxNQUFNLENBQUNGLE9BQVAsR0FBaUJBLE9BQWpCLENBSjJDLENBSzNDOztJQUNBQSxPQUFPLENBQUNHLEtBQVIsR0FBZ0IsQ0FBaEI7SUFFQUgsT0FBTyxDQUFDSSxLQUFSLEdBQWlCQyxVQUFVLEdBQUcsQ0FBOUI7SUFDQUwsT0FBTyxDQUFDTSxNQUFSLEdBQWtCQyxXQUFXLEdBQUcsQ0FBaEM7SUFDQVAsT0FBTyxDQUFDUSxFQUFSLEdBQWEsRUFBYjtJQUVBLElBQUlDLEVBQUUsR0FBR1gsNERBQVQ7SUFBQSxJQUFpQlksSUFBSSxHQUFHRCxFQUFFLENBQUNDLElBQTNCO0lBQ0EsSUFBSUMsS0FBSyxHQUFHLElBQUlGLEVBQUUsQ0FBQ0csS0FBUCxDQUFhRixJQUFJLENBQUMsQ0FBRCxFQUFJLENBQUMsRUFBTCxDQUFqQixDQUFaO0lBQ0EsSUFBSUcsU0FBUyxHQUFHLEtBQWhCO0lBQ0FYLE1BQU0sQ0FBQ1csU0FBUCxHQUFtQkEsU0FBbkIsQ0FmMkMsQ0FpQjNDO0lBQ0E7O0lBRUEsSUFBSUMsS0FBSyxHQUFHLENBQVo7SUFFQSxJQUFJQyxNQUFNLEdBQUdKLEtBQUssQ0FBQ0ssVUFBTixFQUFiO0lBQ0FELE1BQU0sQ0FBQ0UsYUFBUCxDQUFxQlIsRUFBRSxDQUFDUyxJQUFILENBQVFSLElBQUksQ0FBQyxDQUFDLElBQUYsRUFBUSxDQUFDLElBQVQsQ0FBWixFQUE0QkEsSUFBSSxDQUFDLEtBQUQsRUFBUSxDQUFDLElBQVQsQ0FBaEMsQ0FBckIsRUFBc0UsR0FBdEUsRUF2QjJDLENBdUJpQzs7SUFDNUVLLE1BQU0sQ0FBQ0UsYUFBUCxDQUFxQlIsRUFBRSxDQUFDUyxJQUFILENBQVFSLElBQUksQ0FBQyxLQUFELEVBQVEsS0FBUixDQUFaLEVBQTRCQSxJQUFJLENBQUMsS0FBRCxFQUFRLENBQUMsSUFBVCxDQUFoQyxDQUFyQixFQUFzRSxHQUF0RSxFQXhCMkMsQ0F3QmlDOztJQUM1RUssTUFBTSxDQUFDRSxhQUFQLENBQXFCUixFQUFFLENBQUNTLElBQUgsQ0FBUVIsSUFBSSxDQUFDLENBQUMsSUFBRixFQUFRLEtBQVIsQ0FBWixFQUE0QkEsSUFBSSxDQUFDLENBQUMsSUFBRixFQUFRLENBQUMsSUFBVCxDQUFoQyxDQUFyQixFQUFzRSxHQUF0RSxFQXpCMkMsQ0F5QmlDOztJQUM1RUssTUFBTSxDQUFDRSxhQUFQLENBQXFCUixFQUFFLENBQUNTLElBQUgsQ0FBUVIsSUFBSSxDQUFDLENBQUMsSUFBRixFQUFRLEtBQVIsQ0FBWixFQUE0QkEsSUFBSSxDQUFDLEtBQUQsRUFBUSxLQUFSLENBQWhDLENBQXJCLEVBQXNFLEdBQXRFLEVBMUIyQyxDQTBCa0M7O0lBRTdFSyxNQUFNLENBQUNFLGFBQVAsQ0FBcUJSLEVBQUUsQ0FBQ1MsSUFBSCxDQUFRUixJQUFJLENBQUMsQ0FBQyxJQUFGLEVBQVEsSUFBUixDQUFaLEVBQTJCQSxJQUFJLENBQUMsS0FBRCxFQUFRLElBQVIsQ0FBL0IsQ0FBckIsRUFBb0U7TUFBRVMsUUFBUSxFQUFFO0lBQVosQ0FBcEUsRUFBcUZDLE1BQXJGLEdBQThGO01BQUVDLElBQUksRUFBRSxRQUFSO01BQWtCQyxNQUFNLEVBQUU7SUFBMUIsQ0FBOUYsQ0E1QjJDLENBNEJ5Rjs7SUFDcElQLE1BQU0sQ0FBQ0UsYUFBUCxDQUFxQlIsRUFBRSxDQUFDUyxJQUFILENBQVFSLElBQUksQ0FBQyxDQUFDLElBQUYsRUFBUSxHQUFSLENBQVosRUFBMEJBLElBQUksQ0FBQyxLQUFELEVBQVEsR0FBUixDQUE5QixDQUFyQixFQUFrRTtNQUFFYSxXQUFXLEVBQUUsQ0FBZjtNQUFrQkosUUFBUSxFQUFFO0lBQTVCLENBQWxFLEVBQW1HQyxNQUFuRyxHQUE0RztNQUFFQyxJQUFJLEVBQUUsUUFBUjtNQUFrQkMsTUFBTSxFQUFFO0lBQTFCLENBQTVHLENBN0IyQyxDQTZCdUc7O0lBQ2xKUCxNQUFNLENBQUNFLGFBQVAsQ0FBcUJSLEVBQUUsQ0FBQ1MsSUFBSCxDQUFRUixJQUFJLENBQUMsS0FBRCxFQUFRLENBQUMsSUFBVCxDQUFaLEVBQTRCQSxJQUFJLENBQUMsS0FBRCxFQUFRLEdBQVIsQ0FBaEMsQ0FBckIsRUFBb0U7TUFBRWEsV0FBVyxFQUFFLENBQWY7TUFBa0JKLFFBQVEsRUFBRTtJQUE1QixDQUFwRSxFQUFxR0MsTUFBckcsR0FBOEc7TUFBRUMsSUFBSSxFQUFFLFFBQVI7TUFBa0JDLE1BQU0sRUFBRTtJQUExQixDQUE5RyxDQTlCMkMsQ0E4QnlHOztJQUNwSlAsTUFBTSxDQUFDRSxhQUFQLENBQXFCUixFQUFFLENBQUNTLElBQUgsQ0FBUVIsSUFBSSxDQUFDLENBQUMsSUFBRixFQUFRLENBQUMsSUFBVCxDQUFaLEVBQTRCQSxJQUFJLENBQUMsS0FBRCxFQUFRLENBQUMsSUFBVCxDQUFoQyxDQUFyQixFQUFzRTtNQUFFUyxRQUFRLEVBQUU7SUFBWixDQUF0RSxFQS9CMkMsQ0ErQjZDOztJQUN4RkosTUFBTSxDQUFDRSxhQUFQLENBQXFCUixFQUFFLENBQUNTLElBQUgsQ0FBUVIsSUFBSSxDQUFDLENBQUMsSUFBRixFQUFRLENBQUMsSUFBVCxDQUFaLEVBQTRCQSxJQUFJLENBQUMsQ0FBQyxJQUFGLEVBQVEsQ0FBQyxJQUFULENBQWhDLENBQXJCLEVBQXNFO01BQUVhLFdBQVcsRUFBRTtJQUFmLENBQXRFLEVBQTJGSCxNQUEzRixHQUFvRztNQUFFQyxJQUFJLEVBQUUsTUFBUjtNQUFnQkMsTUFBTSxFQUFFO0lBQXhCLENBQXBHLENBaEMyQyxDQWdDMkY7SUFFdEk7SUFFQTtJQUNBO0lBQ0E7SUFDQTs7SUFHQSxJQUFJRSxXQUFXLEdBQUc7TUFDaEJDLFFBQVEsRUFBRWYsSUFBSSxDQUFDLEVBQUQsRUFBSyxFQUFMLENBREU7TUFFaEJnQixNQUFNLEVBQUUsS0FGUTtNQUdoQkMsVUFBVSxFQUFFLElBSEk7TUFJaEJDLGFBQWEsRUFBRSxHQUpDO01BS2hCQyxjQUFjLEVBQUU7SUFMQSxDQUFsQjtJQVNBLElBQUlDLGFBQWEsR0FBRztNQUNsQlgsUUFBUSxFQUFFLEVBRFE7TUFFbEJJLFdBQVcsRUFBRSxFQUZLO01BRUQ7TUFDakJRLE9BQU8sRUFBRSxFQUhTO01BSWxCQyxRQUFRLEVBQUU7SUFKUSxDQUFwQjtJQU9BLElBQUlDLGNBQWMsR0FBRztNQUNuQmQsUUFBUSxFQUFFLEVBRFM7TUFFbkJJLFdBQVcsRUFBRSxFQUZNO01BRUY7TUFDakJRLE9BQU8sRUFBRSxDQUhVO01BSW5CQyxRQUFRLEVBQUU7SUFKUyxDQUFyQjtJQVFBLElBQUlFLEtBQUssR0FBR3ZCLEtBQUssQ0FBQ3dCLGlCQUFOLENBQXdCWCxXQUF4QixDQUFaO0lBQ0FiLEtBQUssQ0FBQ3lCLFdBQU4sQ0FBa0JGLEtBQWxCOztJQUVBLFNBQVNHLFlBQVQsR0FBd0I7TUFDdEIsSUFBSUgsS0FBSyxDQUFDSSxXQUFWLEVBQXVCO1FBQ3JCSixLQUFLLEdBQUd2QixLQUFLLENBQUN3QixpQkFBTixDQUF3QlgsV0FBeEIsQ0FBUjtRQUNBVSxLQUFLLENBQUNqQixhQUFOLENBQW9CUixFQUFFLENBQUM4QixNQUFILENBQVUsQ0FBVixDQUFwQixFQUFrQ1QsYUFBbEM7UUFDQUksS0FBSyxDQUFDZCxNQUFOLEdBQWU7VUFBRUMsSUFBSSxFQUFFO1FBQVIsQ0FBZixDQUhxQixDQUlyQjtRQUNBO01BQ0Q7SUFDRjs7SUFFRGdCLFlBQVk7SUFFWixJQUFNRyxLQUFLLEdBQUc3QixLQUFLLENBQUN3QixpQkFBTixDQUF3QlgsV0FBeEIsQ0FBZDtJQUNBZ0IsS0FBSyxDQUFDQyxXQUFOLENBQWtCL0IsSUFBSSxDQUFDLEVBQUQsRUFBSyxFQUFMLENBQXRCO0lBQ0E4QixLQUFLLENBQUN2QixhQUFOLENBQW9CUixFQUFFLENBQUM4QixNQUFILENBQVUsQ0FBVixDQUFwQixFQUFrQ1QsYUFBbEM7SUFDQVUsS0FBSyxDQUFDcEIsTUFBTixHQUFlO01BQUVDLElBQUksRUFBRSxNQUFSO01BQWdCQyxNQUFNLEVBQUU7SUFBeEIsQ0FBZjtJQUdBLElBQUlvQixLQUFLLEdBQUcvQixLQUFLLENBQUNLLFVBQU4sQ0FBaUJOLElBQUksQ0FBQyxHQUFELEVBQUssQ0FBQyxFQUFOLENBQXJCLENBQVo7SUFDQWdDLEtBQUssQ0FBQ3pCLGFBQU4sQ0FBb0JSLEVBQUUsQ0FBQzhCLE1BQUgsQ0FBVSxDQUFWLENBQXBCLEVBQWtDTixjQUFsQztJQUNBUyxLQUFLLENBQUN0QixNQUFOLEdBQWU7TUFBRUMsSUFBSSxFQUFFLEtBQVI7TUFBZUMsTUFBTSxFQUFFO0lBQXZCLENBQWY7SUFHQXBCLE1BQU0sQ0FBQ08sRUFBUCxHQUFZQSxFQUFaO0lBQ0FQLE1BQU0sQ0FBQ1MsS0FBUCxHQUFlQSxLQUFmO0lBQ0FnQyxPQUFPLENBQUNDLEdBQVIsQ0FBWSxxQkFBWixFQUFtQ1YsS0FBbkM7SUFDQWhDLE1BQU0sQ0FBQ2dDLEtBQVAsR0FBZUEsS0FBZjtJQUNBUyxPQUFPLENBQUNDLEdBQVIsQ0FBWSxtQkFBWixFQUFpQ0YsS0FBakM7SUFDQXhDLE1BQU0sQ0FBQ3dDLEtBQVAsR0FBZUEsS0FBZjtJQUNBQyxPQUFPLENBQUNDLEdBQVIsQ0FBWSxvQkFBWixFQUFrQ0osS0FBbEM7SUFDQXRDLE1BQU0sQ0FBQ3NDLEtBQVAsR0FBZUEsS0FBZjtJQUdBLElBQUlLLENBQUMsR0FBRy9CLEtBQVI7SUFDQSxJQUFJZ0MsR0FBRyxHQUFHaEQsZ0VBQUEsQ0FBVytDLENBQVgsRUFBYUEsQ0FBQyxHQUFDLENBQWYsRUFBaUJHLENBQWpCLEVBQW1CLENBQW5CLENBQVY7SUFFQSxJQUFJQSxDQUFDLEdBQUd0QyxJQUFJLENBQUMsS0FBRCxFQUFRLENBQVIsQ0FBWjtJQUNBLElBQUl1QyxDQUFDLEdBQUd2QyxJQUFJLEVBQVo7SUFDQSxJQUFJd0MsTUFBTSxHQUFHeEMsSUFBSSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWpCO0lBQ0EsSUFBSXlDLE1BQU0sR0FBR3pDLElBQUksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFqQjs7SUFFQSxLQUFLLElBQUkwQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHdEMsS0FBcEIsRUFBMkIsRUFBRXNDLENBQTdCLEVBQWdDO01BQzlCSCxDQUFDLENBQUNJLEdBQUYsQ0FBTUwsQ0FBTjtNQUNFckMsS0FBSyxDQUFDd0IsaUJBQU4sQ0FBd0JjLENBQXhCLEVBQTJCaEMsYUFBM0IsQ0FBeUM2QixHQUF6QyxFQUE4QyxHQUE5QztNQUNBRyxDQUFDLENBQUNLLEdBQUYsQ0FBTUgsTUFBTjtNQUNGSCxDQUFDLENBQUNNLEdBQUYsQ0FBTUosTUFBTjtJQUNEOztJQUlELFNBQVNLLFdBQVQsR0FBdUI7TUFDckI7TUFDQTtNQUVBLElBQUl2RCxPQUFPLENBQUN3RCxVQUFSLENBQW1CQyxLQUF2QixFQUE4QjtRQUM1QixJQUFJQyxZQUFZLENBQUMxRCxPQUFPLENBQUNnRCxDQUFULENBQWhCLEVBQTZCO1VBQUVoRCxPQUFPLENBQUNnRCxDQUFSLElBQWEsQ0FBYjtRQUFnQixDQUEvQyxNQUFxRDtVQUFFaEQsT0FBTyxDQUFDZ0QsQ0FBUixHQUFZVyxRQUFRLENBQUNYLENBQXJCO1FBQXdCO01BQ2hGLENBRkQsTUFFTyxJQUFJaEQsT0FBTyxDQUFDd0QsVUFBUixDQUFtQkksSUFBdkIsRUFBNkI7UUFDbEMsSUFBSUYsWUFBWSxDQUFDMUQsT0FBTyxDQUFDZ0QsQ0FBVCxDQUFoQixFQUE2QjtVQUFFaEQsT0FBTyxDQUFDZ0QsQ0FBUixJQUFhLENBQWI7UUFBZ0IsQ0FBL0MsTUFBcUQ7VUFBRWhELE9BQU8sQ0FBQ2dELENBQVIsR0FBWVcsUUFBUSxDQUFDWCxDQUFyQjtRQUF3QjtNQUNoRixDQUZNLE1BRUEsSUFBSWhELE9BQU8sQ0FBQ3dELFVBQVIsQ0FBbUJLLEVBQXZCLEVBQTJCO1FBQ2hDLElBQUlDLFlBQVksQ0FBQzlELE9BQU8sQ0FBQ2lELENBQVQsQ0FBaEIsRUFBNkI7VUFBRWpELE9BQU8sQ0FBQ2lELENBQVIsSUFBYSxDQUFiO1FBQWdCLENBQS9DLE1BQXFEO1VBQUVqRCxPQUFPLENBQUNpRCxDQUFSLEdBQVlVLFFBQVEsQ0FBQ1YsQ0FBckI7UUFBd0I7TUFDaEYsQ0FGTSxNQUVBLElBQUlqRCxPQUFPLENBQUN3RCxVQUFSLENBQW1CTyxJQUF2QixFQUE2QjtRQUNsQyxJQUFJRCxZQUFZLENBQUM5RCxPQUFPLENBQUNpRCxDQUFULENBQWhCLEVBQTZCO1VBQUVqRCxPQUFPLENBQUNpRCxDQUFSLElBQWEsQ0FBYjtRQUFnQixDQUEvQyxNQUFxRDtVQUFFakQsT0FBTyxDQUFDaUQsQ0FBUixHQUFZVSxRQUFRLENBQUNWLENBQXJCO1FBQXdCO01BQ2hGLENBRk0sTUFFQSxJQUFJakQsT0FBTyxDQUFDd0QsVUFBUixDQUFtQlEsQ0FBdkIsRUFBMEI7UUFDL0JoRSxPQUFPLENBQUNpRSxXQUFSO01BQ0QsQ0FGTSxNQUVBLElBQUlqRSxPQUFPLENBQUN3RCxVQUFSLENBQW1CVSxJQUF2QixFQUE2QjtRQUNsQzdCLFlBQVk7TUFDYixDQUZNLE1BRUEsSUFBSXJDLE9BQU8sQ0FBQ3dELFVBQVIsQ0FBbUJXLENBQXZCLEVBQTBCO1FBQUVuRSxPQUFPLENBQUNvRSxNQUFSLENBQWUsbURBQWY7TUFBcUU7SUFFekc7O0lBRUQsSUFBSVQsUUFBUSxHQUFHekIsS0FBSyxDQUFDbUMsV0FBTixFQUFmOztJQUVBLFNBQVNYLFlBQVQsQ0FBc0JZLElBQXRCLEVBQTRCO01BQzFCLElBQUt0RSxPQUFPLENBQUNnRCxDQUFSLEdBQWFoRCxPQUFPLENBQUNJLEtBQVIsR0FBZ0IsRUFBN0IsR0FBbUN1RCxRQUFRLENBQUNYLENBQTdDLElBQW9EaEQsT0FBTyxDQUFDZ0QsQ0FBUixHQUFhaEQsT0FBTyxDQUFDSSxLQUFSLEdBQWdCLEVBQTdCLEdBQW1DdUQsUUFBUSxDQUFDWCxDQUFwRyxFQUF3RztRQUFFLE9BQU8sSUFBUDtNQUFhLENBQXZILE1BQTZIO1FBQUUsT0FBTyxLQUFQO01BQWM7SUFDOUk7O0lBRUQsU0FBU2MsWUFBVCxDQUFzQlMsSUFBdEIsRUFBNEI7TUFDMUIsSUFBS3ZFLE9BQU8sQ0FBQ2lELENBQVIsR0FBYWpELE9BQU8sQ0FBQ00sTUFBUixHQUFpQixFQUE5QixHQUFvQ3FELFFBQVEsQ0FBQ1YsQ0FBOUMsSUFBc0RqRCxPQUFPLENBQUNpRCxDQUFSLEdBQVksQ0FBQ2pELE9BQU8sQ0FBQ00sTUFBUixHQUFpQmtFLE9BQU8sQ0FBQ2xFLE1BQTFCLElBQW9DLEVBQWpELEdBQXVEcUQsUUFBUSxDQUFDVixDQUF6SCxFQUE2SDtRQUFFLE9BQU8sSUFBUDtNQUFhLENBQTVJLE1BQWtKO1FBQUUsT0FBTyxLQUFQO01BQWM7SUFDbks7O0lBRUQsU0FBU3dCLE9BQVQsR0FBbUI7TUFDakIsSUFBSUMsS0FBSyxHQUFHLEVBQVo7TUFDQSxJQUFJQyxPQUFPLEdBQUd6QyxLQUFLLENBQUNtQyxXQUFOLEVBQWQ7TUFDQU8sUUFBUSxDQUFDQyxTQUFULENBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCTCxPQUFPLENBQUNwRSxLQUFqQyxFQUF3Q29FLE9BQU8sQ0FBQ2xFLE1BQWhEO01BQ0FzRSxRQUFRLENBQUNFLElBQVQsYUFBbUJKLEtBQW5CO01BQ0FFLFFBQVEsQ0FBQ0csU0FBVCxHQUFxQixNQUFyQjtNQUNBSCxRQUFRLENBQUNJLFFBQVQsbUJBQTZCQyxJQUFJLENBQUNDLEtBQUwsQ0FBV1AsT0FBTyxDQUFDM0IsQ0FBbkIsQ0FBN0IsR0FBc0QsRUFBdEQsWUFBNkQwQixLQUE3RDtNQUNBRSxRQUFRLENBQUNJLFFBQVQsa0JBQTRCQyxJQUFJLENBQUNDLEtBQUwsQ0FBV1AsT0FBTyxDQUFDMUIsQ0FBbkIsQ0FBNUIsR0FBcUQsRUFBckQsWUFBNER5QixLQUFLLEdBQUcsQ0FBcEU7TUFDQUUsUUFBUSxDQUFDSSxRQUFULDJCQUFxQ0MsSUFBSSxDQUFDQyxLQUFMLENBQVdsRixPQUFPLENBQUNnRCxDQUFuQixDQUFyQyxHQUE4RCxFQUE5RCxZQUFxRTBCLEtBQUssR0FBRyxDQUE3RTtNQUNBRSxRQUFRLENBQUNJLFFBQVQsMkJBQXFDQyxJQUFJLENBQUNDLEtBQUwsQ0FBV2xGLE9BQU8sQ0FBQ2lELENBQW5CLENBQXJDLEdBQThELEVBQTlELFlBQXFFeUIsS0FBSyxHQUFHLENBQTdFO01BQ0FFLFFBQVEsQ0FBQ0ksUUFBVCw2QkFBdUNDLElBQUksQ0FBQ0MsS0FBTCxDQUFXbEYsT0FBTyxDQUFDTSxNQUFuQixDQUF2QyxHQUFxRSxFQUFyRSxZQUE0RW9FLEtBQUssR0FBRyxDQUFwRjtNQUNBRSxRQUFRLENBQUNJLFFBQVQsbUJBQTZCaEYsT0FBTyxDQUFDbUYsUUFBUixFQUE3QixHQUFtRCxHQUFuRCxZQUEyRFQsS0FBM0Q7TUFDQUUsUUFBUSxDQUFDSSxRQUFULDRCQUFzQzlDLEtBQUssQ0FBQ0ksV0FBNUMsR0FBMkQsR0FBM0QsWUFBbUVvQyxLQUFLLEdBQUcsQ0FBM0U7SUFFRDs7SUFJRCxTQUFTVSxXQUFULEdBQXVCO01BQ3JCekUsS0FBSyxDQUFDMEUsRUFBTixDQUFTLFlBQVQsRUFBdUIsVUFBVUMsT0FBVixFQUFtQjtRQUN4QyxJQUFJQyxFQUFFLEdBQUdELE9BQU8sQ0FBQ0UsV0FBUixFQUFUO1FBQUEsSUFBZ0NDLEVBQUUsR0FBR0YsRUFBRSxDQUFDRyxPQUFILEVBQXJDO1FBQ0EsSUFBSUMsRUFBRSxHQUFHTCxPQUFPLENBQUNNLFdBQVIsRUFBVDtRQUFBLElBQWdDQyxFQUFFLEdBQUdGLEVBQUUsQ0FBQ0QsT0FBSCxFQUFyQztRQUNBLElBQUlJLFNBQVMsR0FBR1AsRUFBRSxDQUFDUSxXQUFILE9BQXFCLE1BQXJCLEdBQThCTixFQUE5QixHQUFtQ0UsRUFBRSxDQUFDSSxXQUFILE9BQXFCLE1BQXJCLEdBQThCRixFQUE5QixHQUFtQyxJQUF0RjtRQUNBLElBQUlHLFVBQVUsR0FBR1QsRUFBRSxDQUFDUSxXQUFILE9BQXFCLFFBQXJCLEdBQWdDTixFQUFoQyxHQUFxQ0UsRUFBRSxDQUFDSSxXQUFILE9BQXFCLFFBQXJCLEdBQWdDRixFQUFoQyxHQUFxQyxJQUEzRjtRQUNBSSxVQUFVLENBQUMsWUFBWTtVQUFFLElBQUlILFNBQVMsSUFBSUUsVUFBakIsRUFBNkI7WUFBRXJGLEtBQUssQ0FBQ3lCLFdBQU4sQ0FBa0IwRCxTQUFsQjtVQUErQjtRQUFFLENBQS9FLEVBQWlGLENBQWpGLENBQVY7TUFDRCxDQU5EO0lBT0Q7O0lBTUQ5RixPQUFPLENBQUNrRyxJQUFSLEdBQWUsWUFBWTtNQUN6QjNDLFdBQVc7TUFDWGtCLE9BQU87TUFDUFcsV0FBVztJQUNaLENBSkQ7O0lBTU4sT0FBT3pFLEtBQVA7RUFDSyxDQTVMRDtBQTZMRCxFQUdIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXN0LXJlcG8vLi9zcmMvc2NyaXB0cy9sZXZlbDQuanM/OGUxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL2xldmVsMXRyaWFsXG5cbmltcG9ydCAqIGFzIHBsYW5jayBmcm9tICdwbGFuY2svZGlzdC9wbGFuY2std2l0aC10ZXN0YmVkJ1xuXG5leHBvcnQgZnVuY3Rpb24gbGV2ZWw0KCkge1xuICAgIHBsYW5jay50ZXN0YmVkKCdTYW5kYm94JywgZnVuY3Rpb24gKHRlc3RiZWQpIHtcbiAgICAgIC8vIHdpbmRvdy5jYW52YXMgPSBjYW52YXNcbiAgICAgIHRlc3RiZWQuYmFja2dyb3VuZCA9IFwiIzExMTExMVwiXG4gICAgICB3aW5kb3cucGxhbmNrID0gcGxhbmNrXG4gICAgICB3aW5kb3cudGVzdGJlZCA9IHRlc3RiZWRcbiAgICAgIC8vY3VycmVudGx5IGRvZXNudCB3b3JrXG4gICAgICB0ZXN0YmVkLnNwZWVkID0gMlxuICAgICAgXG4gICAgICB0ZXN0YmVkLndpZHRoID0gKGlubmVyV2lkdGggLyA0KTtcbiAgICAgIHRlc3RiZWQuaGVpZ2h0ID0gKGlubmVySGVpZ2h0IC8gNCk7XG4gICAgICB0ZXN0YmVkLmh6ID0gMzA7XG5cbiAgICAgIGxldCBwbCA9IHBsYW5jaywgVmVjMiA9IHBsLlZlYzI7XG4gICAgICBsZXQgd29ybGQgPSBuZXcgcGwuV29ybGQoVmVjMigwLCAtMTApKTtcbiAgICAgIGxldCBicmVha291dDEgPSBmYWxzZVxuICAgICAgd2luZG93LmJyZWFrb3V0MSA9IGJyZWFrb3V0MVxuXG4gICAgICAvLyB0ZXN0YmVkLm1vdXNlRm9yY2UgPSA2MDAwOyBcbiAgICAgIC8vIHR1cm5zIG9uL29mZiBpbXB1bHNlcyB0byBhcHBseSBsaWtlIHNsaW5nc2hvdFxuXG4gICAgICBsZXQgQ09VTlQgPSAxO1xuXG4gICAgICBsZXQgZ3JvdW5kID0gd29ybGQuY3JlYXRlQm9keSgpO1xuICAgICAgZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuRWRnZShWZWMyKC04MC4wLCAtODAuMCksIFZlYzIoMjAwLjAsIC04MC4wKSksIDAuMCk7IC8vIGdyb3VuZFxuICAgICAgZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuRWRnZShWZWMyKDIwMC4wLCAxNTAuMCksIFZlYzIoMjAwLjAsIC04MC4wKSksIDAuMCk7IC8vIHJpZ2h0XG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoLTgwLjAsIDE1MC4wKSwgVmVjMigtODAuMCwgLTgwLjApKSwgMC4wKTsgLy8gbGVmdFxuICAgICAgZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuRWRnZShWZWMyKC04MC4wLCAxNTAuMCksIFZlYzIoMjAwLjAsIDE1MC4wKSksIDAuMCk7ICAvLyB0b3BcblxuICAgICAgZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuRWRnZShWZWMyKC04MC4wLCA0MC4wKSwgVmVjMigxNTAuMCwgNDAuMCkpLCB7IGZyaWN0aW9uOiAwIH0pLnJlbmRlciA9IHsgZmlsbDogJ29yYW5nZScsIHN0cm9rZTogJ29yYW5nZScgfTsgLy8gZ3JvdW5kXG4gICAgICBncm91bmQuY3JlYXRlRml4dHVyZShwbC5FZGdlKFZlYzIoLTYwLjAsIDUuMCksIFZlYzIoMTg1LjAsIDUuMCkpLCB7IHJlc3RpdHV0aW9uOiAwLCBmcmljdGlvbjogMCB9KS5yZW5kZXIgPSB7IGZpbGw6ICdvcmFuZ2UnLCBzdHJva2U6ICdvcmFuZ2UnIH07IC8vIGdyb3VuZCBzbGFudFxuICAgICAgZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuRWRnZShWZWMyKDE2MC4wLCAtMTUuMCksIFZlYzIoMjAwLjAsIDAuMCkpLCB7IHJlc3RpdHV0aW9uOiAwLCBmcmljdGlvbjogMCB9KS5yZW5kZXIgPSB7IGZpbGw6ICdvcmFuZ2UnLCBzdHJva2U6ICdvcmFuZ2UnIH07IC8vIGdyb3VuZCBzbGFudFxuICAgICAgZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuRWRnZShWZWMyKC04MC4wLCAtNzAuMCksIFZlYzIoMjAwLjAsIC03MC4wKSksIHsgZnJpY3Rpb246IDEgfSk7IC8vIGdyb3VuZCBzbGlkZVxuICAgICAgZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuRWRnZShWZWMyKC04MC4wLCAtNjAuMCksIFZlYzIoLTc1LjAsIC03MC4wKSksIHsgcmVzdGl0dXRpb246IDYwIH0pLnJlbmRlciA9IHsgZmlsbDogJ2JsdWUnLCBzdHJva2U6ICdibHVlJyB9OyAvLyBncm91bmQgc2xpZGVcblxuICAgICAgLy8gZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuRWRnZShWZWMyKDEwMC4wLCAtODAuMCksIFZlYzIoMjAwLjAsIC0yMC4wKSksIHsgcmVzdGl0dXRpb246IDYwIH0pLnJlbmRlciA9IHsgZmlsbDogJ2JsdWUnLCBzdHJva2U6ICdibHVlJyB9OztcblxuICAgICAgLy8gZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuQ2lyY2xlKFZlYzIoMTAwLjAsIC04MC4wKSwgMTApLCB7IHJlc3RpdHV0aW9uOiA2MCB9KS5yZW5kZXIgPSB7ZmlsbDogJ2JsdWUnLCBzdHJva2U6ICdibHVlJ307IC8vIGJvdW5jeVxuICAgICAgLy8gZ3JvdW5kLmNyZWF0ZUZpeHR1cmUocGwuQ2lyY2xlKFZlYzIoMjAwLjAsIC00MC4wKSwgMTApLCB7IHJlc3RpdHV0aW9uOiA2MCB9KS5yZW5kZXIgPSB7IGZpbGw6ICdibHVlJywgc3Ryb2tlOiAnYmx1ZScgfTsgLy8gYm91bmN5XG4gICAgICAvLyBncm91bmQuY3JlYXRlRml4dHVyZShwbC5Cb3goNTAsIDUsIFZlYzIoMTUwLCAtNjApLCA2MCksIHtyZXN0aXR1dGlvbjogNjB9KS5yZW5kZXIgPSB7IGZpbGw6ICdibHVlJywgc3Ryb2tlOiAnYmx1ZScgfTtcbiAgICAgIC8vIC5yZW5kZXIgPSB7IGZpbGw6ICdibHVlJywgc3Ryb2tlOiAnYmx1ZScgfTsgLy8gYm91bmN5XG4gICAgICBcblxuICAgICAgbGV0IGJhbGxCb2R5RGVmID0ge1xuICAgICAgICBwb3NpdGlvbjogVmVjMig3MCwgMzApLFxuICAgICAgICBidWxsZXQ6IGZhbHNlLFxuICAgICAgICBhbGxvd1NsZWVwOiB0cnVlLFxuICAgICAgICBsaW5lYXJEYW1waW5nOiAuMDEsXG4gICAgICAgIGFuZ3VsYXJEYW1waW5nOiAuNVxuICAgICAgfVxuXG5cbiAgICAgIGxldCBiYWxsU3RhcnRBdHRyID0ge1xuICAgICAgICBmcmljdGlvbjogLjEsXG4gICAgICAgIHJlc3RpdHV0aW9uOiAuNSwgLy8gYm91bmNlXG4gICAgICAgIGRlbnNpdHk6IDEwLFxuICAgICAgICB1c2VyRGF0YTogJ2JhbGwnXG4gICAgICB9O1xuXG4gICAgICBsZXQgYmFsbEZpbmlzaEF0dHIgPSB7XG4gICAgICAgIGZyaWN0aW9uOiAuMixcbiAgICAgICAgcmVzdGl0dXRpb246IC4xLCAvLyBib3VuY2VcbiAgICAgICAgZGVuc2l0eTogMSxcbiAgICAgICAgdXNlckRhdGE6ICdmaW5pc2gnXG4gICAgICB9O1xuXG5cbiAgICAgIGxldCBiYWxsMSA9IHdvcmxkLmNyZWF0ZUR5bmFtaWNCb2R5KGJhbGxCb2R5RGVmKTtcbiAgICAgIHdvcmxkLmRlc3Ryb3lCb2R5KGJhbGwxKVxuXG4gICAgICBmdW5jdGlvbiBnZW5lcmF0ZVNob3QoKSB7XG4gICAgICAgIGlmIChiYWxsMS5tX2Rlc3Ryb3llZCkge1xuICAgICAgICAgIGJhbGwxID0gd29ybGQuY3JlYXRlRHluYW1pY0JvZHkoYmFsbEJvZHlEZWYpO1xuICAgICAgICAgIGJhbGwxLmNyZWF0ZUZpeHR1cmUocGwuQ2lyY2xlKDEpLCBiYWxsU3RhcnRBdHRyKTtcbiAgICAgICAgICBiYWxsMS5yZW5kZXIgPSB7IGZpbGw6IFwid2hpdGVcIiB9O1xuICAgICAgICAgIC8vIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpXG4gICAgICAgICAgLy8gaW1nLnNyYyA9IFwiaHR0cHM6Ly91cGxvYWQud2lraW1lZGlhLm9yZy93aWtpcGVkaWEvY29tbW9ucy8yLzI3L1dleV9zb3VyY2VfZmFycmluZ2Rvbi5qcGdcIlxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdlbmVyYXRlU2hvdCgpXG5cbiAgICAgIGNvbnN0IGJhbGwzID0gd29ybGQuY3JlYXRlRHluYW1pY0JvZHkoYmFsbEJvZHlEZWYpO1xuICAgICAgYmFsbDMuc2V0UG9zaXRpb24oVmVjMigzMCwgNDApKVxuICAgICAgYmFsbDMuY3JlYXRlRml4dHVyZShwbC5DaXJjbGUoMSksIGJhbGxTdGFydEF0dHIpO1xuICAgICAgYmFsbDMucmVuZGVyID0geyBmaWxsOiAnYmx1ZScsIHN0cm9rZTogJ2JsdWUnIH07XG5cblxuICAgICAgbGV0IGJhbGwyID0gd29ybGQuY3JlYXRlQm9keShWZWMyKDEzMCwtNDApKTtcbiAgICAgIGJhbGwyLmNyZWF0ZUZpeHR1cmUocGwuQ2lyY2xlKDEpLCBiYWxsRmluaXNoQXR0cik7XG4gICAgICBiYWxsMi5yZW5kZXIgPSB7IGZpbGw6ICdyZWQnLCBzdHJva2U6ICdyZWQnIH07XG5cblxuICAgICAgd2luZG93LnBsID0gcGxcbiAgICAgIHdpbmRvdy53b3JsZCA9IHdvcmxkXG4gICAgICBjb25zb2xlLmxvZyhcIndoaXRlIGJhbGwgPSBiYWxsMSBcIiwgYmFsbDEpXG4gICAgICB3aW5kb3cuYmFsbDEgPSBiYWxsMVxuICAgICAgY29uc29sZS5sb2coXCJyZWQgYmFsbCA9IGJhbGwyIFwiLCBiYWxsMilcbiAgICAgIHdpbmRvdy5iYWxsMiA9IGJhbGwyXG4gICAgICBjb25zb2xlLmxvZyhcImJsdWUgYmFsbCA9IGJhbGwzIFwiLCBiYWxsMylcbiAgICAgIHdpbmRvdy5iYWxsMyA9IGJhbGwzXG5cblxuICAgICAgbGV0IGEgPSBDT1VOVDtcbiAgICAgIGxldCBib3ggPSBwbGFuY2suQm94KGEsYSo5LHgsMCk7XG5cbiAgICAgIGxldCB4ID0gVmVjMigxNjAuMCwgOCk7XG4gICAgICBsZXQgeSA9IFZlYzIoKTtcbiAgICAgIGxldCBkZWx0YVggPSBWZWMyKDAsIDQpO1xuICAgICAgbGV0IGRlbHRhWSA9IFZlYzIoMCwgNCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ09VTlQ7ICsraSkge1xuICAgICAgICB5LnNldCh4KTtcbiAgICAgICAgICB3b3JsZC5jcmVhdGVEeW5hbWljQm9keSh5KS5jcmVhdGVGaXh0dXJlKGJveCwgNS4wKTtcbiAgICAgICAgICB5LmFkZChkZWx0YVkpO1xuICAgICAgICB4LmFkZChkZWx0YVgpO1xuICAgICAgfVxuXG5cblxuICAgICAgZnVuY3Rpb24ga2V5bGlzdGVuZXIoKSB7XG4gICAgICAgIC8vdGhlcmUgaXMgcHJvYmFibHkgYSB3YXkgdG8gZG8gdGhpcyB3aXRoIGEgY2FzZSBzdGF0ZW1lbnRcbiAgICAgICAgLy9jYW1lcmFcblxuICAgICAgICBpZiAodGVzdGJlZC5hY3RpdmVLZXlzLnJpZ2h0KSB7XG4gICAgICAgICAgaWYgKGNhbWVyYUxpbWl0WCh0ZXN0YmVkLngpKSB7IHRlc3RiZWQueCArPSAyIH0gZWxzZSB7IHRlc3RiZWQueCA9IGJhbGwxcG9zLnggfVxuICAgICAgICB9IGVsc2UgaWYgKHRlc3RiZWQuYWN0aXZlS2V5cy5sZWZ0KSB7XG4gICAgICAgICAgaWYgKGNhbWVyYUxpbWl0WCh0ZXN0YmVkLngpKSB7IHRlc3RiZWQueCAtPSAyIH0gZWxzZSB7IHRlc3RiZWQueCA9IGJhbGwxcG9zLnggfVxuICAgICAgICB9IGVsc2UgaWYgKHRlc3RiZWQuYWN0aXZlS2V5cy51cCkge1xuICAgICAgICAgIGlmIChjYW1lcmFMaW1pdFkodGVzdGJlZC55KSkgeyB0ZXN0YmVkLnkgLT0gMiB9IGVsc2UgeyB0ZXN0YmVkLnkgPSBiYWxsMXBvcy55IH1cbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0YmVkLmFjdGl2ZUtleXMuZG93bikge1xuICAgICAgICAgIGlmIChjYW1lcmFMaW1pdFkodGVzdGJlZC55KSkgeyB0ZXN0YmVkLnkgKz0gMiB9IGVsc2UgeyB0ZXN0YmVkLnkgPSBiYWxsMXBvcy55IH1cbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0YmVkLmFjdGl2ZUtleXMuQykge1xuICAgICAgICAgIHRlc3RiZWQudG9nZ2xlUGF1c2UoKVxuICAgICAgICB9IGVsc2UgaWYgKHRlc3RiZWQuYWN0aXZlS2V5cy5maXJlKSB7XG4gICAgICAgICAgZ2VuZXJhdGVTaG90KClcbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0YmVkLmFjdGl2ZUtleXMueikgeyB0ZXN0YmVkLnN0YXR1cygn4oaQL+KGkjogQWNjZWxlcmF0ZSBjYXIsIOKGkS/ihpM6IENoYW5nZSBzcHJpbmcgZnJlcXVlbmN5JykgfVxuXG4gICAgICB9XG5cbiAgICAgIGxldCBiYWxsMXBvcyA9IGJhbGwxLmdldFBvc2l0aW9uKClcblxuICAgICAgZnVuY3Rpb24gY2FtZXJhTGltaXRYKHhQb3MpIHtcbiAgICAgICAgaWYgKCh0ZXN0YmVkLnggKyAodGVzdGJlZC53aWR0aCAqIC40KSA+IGJhbGwxcG9zLngpICYmICh0ZXN0YmVkLnggLSAodGVzdGJlZC53aWR0aCAqIC40KSA8IGJhbGwxcG9zLngpKSB7IHJldHVybiB0cnVlIH0gZWxzZSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNhbWVyYUxpbWl0WSh5UG9zKSB7XG4gICAgICAgIGlmICgodGVzdGJlZC55ICsgKHRlc3RiZWQuaGVpZ2h0ICogLjQpID4gYmFsbDFwb3MueSkgJiYgKCh0ZXN0YmVkLnkgLSAodGVzdGJlZC5oZWlnaHQgKyBjYW52YXMxLmhlaWdodCkgKiAuNCkgPCBiYWxsMXBvcy55KSkgeyByZXR1cm4gdHJ1ZSB9IGVsc2UgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXh0T3V0KCkge1xuICAgICAgICBsZXQgc2NhbGUgPSAyMFxuICAgICAgICBsZXQgYmFsbHBvcyA9IGJhbGwxLmdldFBvc2l0aW9uKClcbiAgICAgICAgY29udGV4dDIuY2xlYXJSZWN0KDAsIDAsIGNhbnZhczEud2lkdGgsIGNhbnZhczEuaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dDIuZm9udCA9IGAke3NjYWxlfXB4IENvdXJpZXIgTmV3YDtcbiAgICAgICAgY29udGV4dDIuZmlsbFN0eWxlID0gJ2JsdWUnO1xuICAgICAgICBjb250ZXh0Mi5maWxsVGV4dChgWCBQT1MgOiAke01hdGgucm91bmQoYmFsbHBvcy54KX1gLCAyMCwgYCR7c2NhbGV9YCk7XG4gICAgICAgIGNvbnRleHQyLmZpbGxUZXh0KGBZIFBPUyA6JHtNYXRoLnJvdW5kKGJhbGxwb3MueSl9YCwgMjAsIGAke3NjYWxlICogMn1gKTtcbiAgICAgICAgY29udGV4dDIuZmlsbFRleHQoYHRlc3RiZWQgWCBQT1MgOiAke01hdGgucm91bmQodGVzdGJlZC54KX1gLCAyMCwgYCR7c2NhbGUgKiAzfWApO1xuICAgICAgICBjb250ZXh0Mi5maWxsVGV4dChgdGVzdGJlZCBZIFBPUyA6ICR7TWF0aC5yb3VuZCh0ZXN0YmVkLnkpfWAsIDIwLCBgJHtzY2FsZSAqIDR9YCk7XG4gICAgICAgIGNvbnRleHQyLmZpbGxUZXh0KGB0ZXN0YmVkIFkgaGVpZ2h0IDoke01hdGgucm91bmQodGVzdGJlZC5oZWlnaHQpfWAsIDIwLCBgJHtzY2FsZSAqIDV9YCk7XG4gICAgICAgIGNvbnRleHQyLmZpbGxUZXh0KGBQYXVzZSA6ICR7dGVzdGJlZC5pc1BhdXNlZCgpfWAsIDI1MCwgYCR7c2NhbGV9YCk7XG4gICAgICAgIGNvbnRleHQyLmZpbGxUZXh0KGBTaG90IGRlc3Ryb3llZCA6ICR7YmFsbDEubV9kZXN0cm95ZWR9YCwgMjUwLCBgJHtzY2FsZSAqIDJ9YCk7XG5cbiAgICAgIH1cblxuXG5cbiAgICAgIGZ1bmN0aW9uIGZpbmlzaFRvdWNoKCkge1xuICAgICAgICB3b3JsZC5vbigncG9zdC1zb2x2ZScsIGZ1bmN0aW9uIChjb250YWN0KSB7XG4gICAgICAgICAgbGV0IGZBID0gY29udGFjdC5nZXRGaXh0dXJlQSgpLCBiQSA9IGZBLmdldEJvZHkoKTtcbiAgICAgICAgICBsZXQgZkIgPSBjb250YWN0LmdldEZpeHR1cmVCKCksIGJCID0gZkIuZ2V0Qm9keSgpO1xuICAgICAgICAgIGxldCB0aHJvd0JhbGwgPSBmQS5nZXRVc2VyRGF0YSgpID09PSBcImJhbGxcIiA/IGJBIDogZkIuZ2V0VXNlckRhdGEoKSA9PT0gXCJiYWxsXCIgPyBiQiA6IG51bGw7XG4gICAgICAgICAgbGV0IGZpbmlzaEJhbGwgPSBmQS5nZXRVc2VyRGF0YSgpID09PSBcImZpbmlzaFwiID8gYkEgOiBmQi5nZXRVc2VyRGF0YSgpID09PSBcImZpbmlzaFwiID8gYkIgOiBudWxsO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBpZiAodGhyb3dCYWxsICYmIGZpbmlzaEJhbGwpIHsgd29ybGQuZGVzdHJveUJvZHkodGhyb3dCYWxsKTsgfSB9LCAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cblxuXG5cblxuICAgICAgdGVzdGJlZC5zdGVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBrZXlsaXN0ZW5lcigpXG4gICAgICAgIHRleHRPdXQoKVxuICAgICAgICBmaW5pc2hUb3VjaCgpXG4gICAgICB9O1xuXG5yZXR1cm4gd29ybGRcbiAgICB9KTtcbiAgfVxuXG5cbi8vIGV4cG9ydCB7bGV2ZWwxfTtcbi8vIGV4cG9ydCBkZWZhdWx0OyJdLCJuYW1lcyI6WyJwbGFuY2siLCJsZXZlbDQiLCJ0ZXN0YmVkIiwiYmFja2dyb3VuZCIsIndpbmRvdyIsInNwZWVkIiwid2lkdGgiLCJpbm5lcldpZHRoIiwiaGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJoeiIsInBsIiwiVmVjMiIsIndvcmxkIiwiV29ybGQiLCJicmVha291dDEiLCJDT1VOVCIsImdyb3VuZCIsImNyZWF0ZUJvZHkiLCJjcmVhdGVGaXh0dXJlIiwiRWRnZSIsImZyaWN0aW9uIiwicmVuZGVyIiwiZmlsbCIsInN0cm9rZSIsInJlc3RpdHV0aW9uIiwiYmFsbEJvZHlEZWYiLCJwb3NpdGlvbiIsImJ1bGxldCIsImFsbG93U2xlZXAiLCJsaW5lYXJEYW1waW5nIiwiYW5ndWxhckRhbXBpbmciLCJiYWxsU3RhcnRBdHRyIiwiZGVuc2l0eSIsInVzZXJEYXRhIiwiYmFsbEZpbmlzaEF0dHIiLCJiYWxsMSIsImNyZWF0ZUR5bmFtaWNCb2R5IiwiZGVzdHJveUJvZHkiLCJnZW5lcmF0ZVNob3QiLCJtX2Rlc3Ryb3llZCIsIkNpcmNsZSIsImJhbGwzIiwic2V0UG9zaXRpb24iLCJiYWxsMiIsImNvbnNvbGUiLCJsb2ciLCJhIiwiYm94IiwiQm94IiwieCIsInkiLCJkZWx0YVgiLCJkZWx0YVkiLCJpIiwic2V0IiwiYWRkIiwia2V5bGlzdGVuZXIiLCJhY3RpdmVLZXlzIiwicmlnaHQiLCJjYW1lcmFMaW1pdFgiLCJiYWxsMXBvcyIsImxlZnQiLCJ1cCIsImNhbWVyYUxpbWl0WSIsImRvd24iLCJDIiwidG9nZ2xlUGF1c2UiLCJmaXJlIiwieiIsInN0YXR1cyIsImdldFBvc2l0aW9uIiwieFBvcyIsInlQb3MiLCJjYW52YXMxIiwidGV4dE91dCIsInNjYWxlIiwiYmFsbHBvcyIsImNvbnRleHQyIiwiY2xlYXJSZWN0IiwiZm9udCIsImZpbGxTdHlsZSIsImZpbGxUZXh0IiwiTWF0aCIsInJvdW5kIiwiaXNQYXVzZWQiLCJmaW5pc2hUb3VjaCIsIm9uIiwiY29udGFjdCIsImZBIiwiZ2V0Rml4dHVyZUEiLCJiQSIsImdldEJvZHkiLCJmQiIsImdldEZpeHR1cmVCIiwiYkIiLCJ0aHJvd0JhbGwiLCJnZXRVc2VyRGF0YSIsImZpbmlzaEJhbGwiLCJzZXRUaW1lb3V0Iiwic3RlcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/scripts/level4.js\n");

/***/ }),

/***/ "./src/index.scss":
/*!************************!*\
  !*** ./src/index.scss ***!
  \************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguc2Nzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXN0LXJlcG8vLi9zcmMvaW5kZXguc2Nzcz85NzQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.scss\n");

/***/ }),

/***/ "./node_modules/planck/dist/planck-with-testbed.js":
/*!*********************************************************!*\
  !*** ./node_modules/planck/dist/planck-with-testbed.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * Planck.js v1.0.0-alpha.4\n * @license The MIT license\n * @copyright Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n(function (global, factory) {\n     true ? factory(exports) :\n    0;\n}(this, (function (exports) { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\n\n    function options (input, defaults) {\n        if (input === null || typeof input === 'undefined') {\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            input = {};\n        }\n        var output = __assign({}, input);\n        // tslint:disable-next-line:no-for-in\n        for (var key in defaults) {\n            if (defaults.hasOwnProperty(key) && typeof input[key] === 'undefined') {\n                output[key] = defaults[key];\n            }\n        }\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            var symbols = Object.getOwnPropertySymbols(defaults);\n            for (var i = 0; i < symbols.length; i++) {\n                var symbol = symbols[i];\n                if (defaults.propertyIsEnumerable(symbol) && typeof input[symbol] === 'undefined') {\n                    output[symbol] = defaults[symbol];\n                }\n            }\n        }\n        return output;\n    }\n\n    var debug = function () {\n        var rest = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            rest[_i] = arguments[_i];\n        }\n        return;\n    };\n    var assert = function (statement, err, log) {\n        return;\n    };\n    var common = {\n        assert: assert,\n        debug: debug,\n    };\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var math$1 = Object.create(Math);\n    // @ts-ignore\n    // noinspection JSConstantReassignment\n    math$1.EPSILON = 1e-9; // TODO\n    math$1.isFinite = function (x) {\n        return (typeof x === 'number') && isFinite(x) && !isNaN(x);\n    };\n    math$1.assert = function (x) {\n        return;\n    };\n    math$1.invSqrt = function (x) {\n        // TODO:\n        return 1 / Math.sqrt(x);\n    };\n    math$1.nextPowerOfTwo = function (x) {\n        // TODO\n        x |= (x >> 1);\n        x |= (x >> 2);\n        x |= (x >> 4);\n        x |= (x >> 8);\n        x |= (x >> 16);\n        return x + 1;\n    };\n    math$1.isPowerOfTwo = function (x) {\n        return x > 0 && (x & (x - 1)) === 0;\n    };\n    math$1.mod = function (num, min, max) {\n        if (typeof min === 'undefined') {\n            max = 1;\n            min = 0;\n        }\n        else if (typeof max === 'undefined') {\n            max = min;\n            min = 0;\n        }\n        if (max > min) {\n            num = (num - min) % (max - min);\n            return num + (num < 0 ? max : min);\n        }\n        else {\n            num = (num - max) % (min - max);\n            return num + (num <= 0 ? min : max);\n        }\n    };\n    math$1.clamp = function (num, min, max) {\n        if (num < min) {\n            return min;\n        }\n        else if (num > max) {\n            return max;\n        }\n        else {\n            return num;\n        }\n    };\n    math$1.random = function (min, max) {\n        if (typeof min === 'undefined') {\n            max = 1;\n            min = 0;\n        }\n        else if (typeof max === 'undefined') {\n            max = min;\n            min = 0;\n        }\n        return min === max ? min : Math.random() * (max - min) + min;\n    };\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var Vec2 = /** @class */ (function () {\n        // tslint:disable-next-line:typedef\n        function Vec2(x, y) {\n            if (!(this instanceof Vec2)) {\n                return new Vec2(x, y);\n            }\n            if (typeof x === 'undefined') {\n                this.x = 0;\n                this.y = 0;\n            }\n            else if (typeof x === 'object') {\n                this.x = x.x;\n                this.y = x.y;\n            }\n            else {\n                this.x = x;\n                this.y = y;\n            }\n        }\n        /** @internal */\n        Vec2.prototype._serialize = function () {\n            return {\n                x: this.x,\n                y: this.y\n            };\n        };\n        /** @internal */\n        Vec2._deserialize = function (data) {\n            var obj = Object.create(Vec2.prototype);\n            obj.x = data.x;\n            obj.y = data.y;\n            return obj;\n        };\n        Vec2.zero = function () {\n            var obj = Object.create(Vec2.prototype);\n            obj.x = 0;\n            obj.y = 0;\n            return obj;\n        };\n        /** @internal */\n        Vec2.neo = function (x, y) {\n            var obj = Object.create(Vec2.prototype);\n            obj.x = x;\n            obj.y = y;\n            return obj;\n        };\n        Vec2.clone = function (v) {\n            return Vec2.neo(v.x, v.y);\n        };\n        /** @internal */\n        Vec2.prototype.toString = function () {\n            return JSON.stringify(this);\n        };\n        /**\n         * Does this vector contain finite coordinates?\n         */\n        Vec2.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return math$1.isFinite(obj.x) && math$1.isFinite(obj.y);\n        };\n        Vec2.assert = function (o) {\n            return;\n        };\n        Vec2.prototype.clone = function () {\n            return Vec2.clone(this);\n        };\n        /**\n         * Set this vector to all zeros.\n         *\n         * @returns this\n         */\n        Vec2.prototype.setZero = function () {\n            this.x = 0.0;\n            this.y = 0.0;\n            return this;\n        };\n        /**\n         * Set this vector to some specified coordinates.\n         *\n         * @returns this\n         */\n        // tslint:disable-next-line:typedef\n        Vec2.prototype.set = function (x, y) {\n            if (typeof x === 'object') {\n                this.x = x.x;\n                this.y = x.y;\n            }\n            else {\n                this.x = x;\n                this.y = y;\n            }\n            return this;\n        };\n        /**\n         * Set this vector to some specified coordinates.\n         *\n         * @returns this\n         */\n        Vec2.prototype.setNum = function (x, y) {\n            this.x = x;\n            this.y = y;\n            return this;\n        };\n        /**\n         * Set this vector to some specified coordinates.\n         *\n         * @returns this\n         */\n        Vec2.prototype.setVec2 = function (value) {\n            this.x = value.x;\n            this.y = value.y;\n            return this;\n        };\n        /**\n         * @internal\n         * @deprecated Use setCombine or setMul\n         */\n        Vec2.prototype.wSet = function (a, v, b, w) {\n            if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n                return this.setCombine(a, v, b, w);\n            }\n            else {\n                return this.setMul(a, v);\n            }\n        };\n        /**\n         * Set linear combination of v and w: `a * v + b * w`\n         */\n        Vec2.prototype.setCombine = function (a, v, b, w) {\n            var x = a * v.x + b * w.x;\n            var y = a * v.y + b * w.y;\n            // `this` may be `w`\n            this.x = x;\n            this.y = y;\n            return this;\n        };\n        Vec2.prototype.setMul = function (a, v) {\n            var x = a * v.x;\n            var y = a * v.y;\n            this.x = x;\n            this.y = y;\n            return this;\n        };\n        /**\n         * Add a vector to this vector.\n         *\n         * @returns this\n         */\n        Vec2.prototype.add = function (w) {\n            this.x += w.x;\n            this.y += w.y;\n            return this;\n        };\n        /**\n         * @internal\n         * @deprecated Use addCombine or addMul\n         */\n        Vec2.prototype.wAdd = function (a, v, b, w) {\n            if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n                return this.addCombine(a, v, b, w);\n            }\n            else {\n                return this.addMul(a, v);\n            }\n        };\n        /**\n         * Add linear combination of v and w: `a * v + b * w`\n         */\n        Vec2.prototype.addCombine = function (a, v, b, w) {\n            var x = a * v.x + b * w.x;\n            var y = a * v.y + b * w.y;\n            // `this` may be `w`\n            this.x += x;\n            this.y += y;\n            return this;\n        };\n        Vec2.prototype.addMul = function (a, v) {\n            var x = a * v.x;\n            var y = a * v.y;\n            this.x += x;\n            this.y += y;\n            return this;\n        };\n        /**\n         * @deprecated Use subCombine or subMul\n         */\n        Vec2.prototype.wSub = function (a, v, b, w) {\n            if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n                return this.subCombine(a, v, b, w);\n            }\n            else {\n                return this.subMul(a, v);\n            }\n        };\n        /**\n         * Subtract linear combination of v and w: `a * v + b * w`\n         */\n        Vec2.prototype.subCombine = function (a, v, b, w) {\n            var x = a * v.x + b * w.x;\n            var y = a * v.y + b * w.y;\n            // `this` may be `w`\n            this.x -= x;\n            this.y -= y;\n            return this;\n        };\n        Vec2.prototype.subMul = function (a, v) {\n            var x = a * v.x;\n            var y = a * v.y;\n            this.x -= x;\n            this.y -= y;\n            return this;\n        };\n        /**\n         * Subtract a vector from this vector\n         *\n         * @returns this\n         */\n        Vec2.prototype.sub = function (w) {\n            this.x -= w.x;\n            this.y -= w.y;\n            return this;\n        };\n        /**\n         * Multiply this vector by a scalar.\n         *\n         * @returns this\n         */\n        Vec2.prototype.mul = function (m) {\n            this.x *= m;\n            this.y *= m;\n            return this;\n        };\n        /**\n         * Get the length of this vector (the norm).\n         *\n         * For performance, use this instead of lengthSquared (if possible).\n         */\n        Vec2.prototype.length = function () {\n            return Vec2.lengthOf(this);\n        };\n        /**\n         * Get the length squared.\n         */\n        Vec2.prototype.lengthSquared = function () {\n            return Vec2.lengthSquared(this);\n        };\n        /**\n         * Convert this vector into a unit vector.\n         *\n         * @returns old length\n         */\n        Vec2.prototype.normalize = function () {\n            var length = this.length();\n            if (length < math$1.EPSILON) {\n                return 0.0;\n            }\n            var invLength = 1.0 / length;\n            this.x *= invLength;\n            this.y *= invLength;\n            return length;\n        };\n        /**\n         * Get the length of this vector (the norm).\n         *\n         * For performance, use this instead of lengthSquared (if possible).\n         */\n        Vec2.lengthOf = function (v) {\n            return math$1.sqrt(v.x * v.x + v.y * v.y);\n        };\n        /**\n         * Get the length squared.\n         */\n        Vec2.lengthSquared = function (v) {\n            return v.x * v.x + v.y * v.y;\n        };\n        Vec2.distance = function (v, w) {\n            var dx = v.x - w.x;\n            var dy = v.y - w.y;\n            return math$1.sqrt(dx * dx + dy * dy);\n        };\n        Vec2.distanceSquared = function (v, w) {\n            var dx = v.x - w.x;\n            var dy = v.y - w.y;\n            return dx * dx + dy * dy;\n        };\n        Vec2.areEqual = function (v, w) {\n            return v === w || typeof w === 'object' && w !== null && v.x === w.x && v.y === w.y;\n        };\n        /**\n         * Get the skew vector such that dot(skew_vec, other) == cross(vec, other)\n         */\n        Vec2.skew = function (v) {\n            return Vec2.neo(-v.y, v.x);\n        };\n        /**\n         * Perform the dot product on two vectors.\n         */\n        Vec2.dot = function (v, w) {\n            return v.x * w.x + v.y * w.y;\n        };\n        /**\n         * Perform the cross product on two vectors. In 2D this produces a scalar.\n         *\n         * Perform the cross product on a vector and a scalar. In 2D this produces a\n         * vector.\n         */\n        // tslint:disable-next-line:typedef\n        Vec2.cross = function (v, w) {\n            if (typeof w === 'number') {\n                return Vec2.neo(w * v.y, -w * v.x);\n            }\n            else if (typeof v === 'number') {\n                return Vec2.neo(-v * w.y, v * w.x);\n            }\n            else {\n                return v.x * w.y - v.y * w.x;\n            }\n        };\n        /**\n         * Perform the cross product on two vectors. In 2D this produces a scalar.\n         */\n        Vec2.crossVec2Vec2 = function (v, w) {\n            return v.x * w.y - v.y * w.x;\n        };\n        /**\n         * Perform the cross product on a vector and a scalar. In 2D this produces a\n         * vector.\n         */\n        Vec2.crossVec2Num = function (v, w) {\n            return Vec2.neo(w * v.y, -w * v.x);\n        };\n        /**\n         * Perform the cross product on a vector and a scalar. In 2D this produces a\n         * vector.\n         */\n        Vec2.crossNumVec2 = function (v, w) {\n            return Vec2.neo(-v * w.y, v * w.x);\n        };\n        /**\n         * Returns `a + (v x w)`\n         */\n        // tslint:disable-next-line:typedef\n        Vec2.addCross = function (a, v, w) {\n            if (typeof w === 'number') {\n                return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n            }\n            else if (typeof v === 'number') {\n                return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n            }\n        };\n        /**\n         * Returns `a + (v x w)`\n         */\n        Vec2.addCrossVec2Num = function (a, v, w) {\n            return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n        };\n        /**\n         * Returns `a + (v x w)`\n         */\n        Vec2.addCrossNumVec2 = function (a, v, w) {\n            return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n        };\n        Vec2.add = function (v, w) {\n            return Vec2.neo(v.x + w.x, v.y + w.y);\n        };\n        /** @internal @deprecated */\n        Vec2.wAdd = function (a, v, b, w) {\n            if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n                return Vec2.combine(a, v, b, w);\n            }\n            else {\n                return Vec2.mulNumVec2(a, v);\n            }\n        };\n        Vec2.combine = function (a, v, b, w) {\n            return Vec2.zero().setCombine(a, v, b, w);\n        };\n        Vec2.sub = function (v, w) {\n            return Vec2.neo(v.x - w.x, v.y - w.y);\n        };\n        // tslint:disable-next-line:typedef\n        Vec2.mul = function (a, b) {\n            if (typeof a === 'object') {\n                return Vec2.neo(a.x * b, a.y * b);\n            }\n            else if (typeof b === 'object') {\n                return Vec2.neo(a * b.x, a * b.y);\n            }\n        };\n        Vec2.mulVec2Num = function (a, b) {\n            return Vec2.neo(a.x * b, a.y * b);\n        };\n        Vec2.mulNumVec2 = function (a, b) {\n            return Vec2.neo(a * b.x, a * b.y);\n        };\n        Vec2.prototype.neg = function () {\n            this.x = -this.x;\n            this.y = -this.y;\n            return this;\n        };\n        Vec2.neg = function (v) {\n            return Vec2.neo(-v.x, -v.y);\n        };\n        Vec2.abs = function (v) {\n            return Vec2.neo(math$1.abs(v.x), math$1.abs(v.y));\n        };\n        Vec2.mid = function (v, w) {\n            return Vec2.neo((v.x + w.x) * 0.5, (v.y + w.y) * 0.5);\n        };\n        Vec2.upper = function (v, w) {\n            return Vec2.neo(math$1.max(v.x, w.x), math$1.max(v.y, w.y));\n        };\n        Vec2.lower = function (v, w) {\n            return Vec2.neo(math$1.min(v.x, w.x), math$1.min(v.y, w.y));\n        };\n        Vec2.prototype.clamp = function (max) {\n            var lengthSqr = this.x * this.x + this.y * this.y;\n            if (lengthSqr > max * max) {\n                var invLength = math$1.invSqrt(lengthSqr);\n                this.x *= invLength * max;\n                this.y *= invLength * max;\n            }\n            return this;\n        };\n        Vec2.clamp = function (v, max) {\n            v = Vec2.neo(v.x, v.y);\n            v.clamp(max);\n            return v;\n        };\n        /**  @internal @deprecated */\n        // tslint:disable-next-line:typedef\n        Vec2.scaleFn = function (x, y) {\n            return function (v) {\n                return Vec2.neo(v.x * x, v.y * y);\n            };\n        };\n        /**  @internal @deprecated */\n        // tslint:disable-next-line:typedef\n        Vec2.translateFn = function (x, y) {\n            return function (v) {\n                return Vec2.neo(v.x + x, v.y + y);\n            };\n        };\n        return Vec2;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var AABB = /** @class */ (function () {\n        function AABB(lower, upper) {\n            if (!(this instanceof AABB)) {\n                return new AABB(lower, upper);\n            }\n            this.lowerBound = Vec2.zero();\n            this.upperBound = Vec2.zero();\n            if (typeof lower === 'object') {\n                this.lowerBound.setVec2(lower);\n            }\n            if (typeof upper === 'object') {\n                this.upperBound.setVec2(upper);\n            }\n            else if (typeof lower === 'object') {\n                this.upperBound.setVec2(lower);\n            }\n        }\n        /**\n         * Verify that the bounds are sorted.\n         */\n        AABB.prototype.isValid = function () {\n            return AABB.isValid(this);\n        };\n        AABB.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return Vec2.isValid(obj.lowerBound) && Vec2.isValid(obj.upperBound) && Vec2.sub(obj.upperBound, obj.lowerBound).lengthSquared() >= 0;\n        };\n        AABB.assert = function (o) {\n            return;\n        };\n        /**\n         * Get the center of the AABB.\n         */\n        AABB.prototype.getCenter = function () {\n            return Vec2.neo((this.lowerBound.x + this.upperBound.x) * 0.5, (this.lowerBound.y + this.upperBound.y) * 0.5);\n        };\n        /**\n         * Get the extents of the AABB (half-widths).\n         */\n        AABB.prototype.getExtents = function () {\n            return Vec2.neo((this.upperBound.x - this.lowerBound.x) * 0.5, (this.upperBound.y - this.lowerBound.y) * 0.5);\n        };\n        /**\n         * Get the perimeter length.\n         */\n        AABB.prototype.getPerimeter = function () {\n            return 2.0 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);\n        };\n        /**\n         * Combine one or two AABB into this one.\n         */\n        AABB.prototype.combine = function (a, b) {\n            b = b || this;\n            var lowerA = a.lowerBound;\n            var upperA = a.upperBound;\n            var lowerB = b.lowerBound;\n            var upperB = b.upperBound;\n            var lowerX = math$1.min(lowerA.x, lowerB.x);\n            var lowerY = math$1.min(lowerA.y, lowerB.y);\n            var upperX = math$1.max(upperB.x, upperA.x);\n            var upperY = math$1.max(upperB.y, upperA.y);\n            this.lowerBound.setNum(lowerX, lowerY);\n            this.upperBound.setNum(upperX, upperY);\n        };\n        AABB.prototype.combinePoints = function (a, b) {\n            this.lowerBound.setNum(math$1.min(a.x, b.x), math$1.min(a.y, b.y));\n            this.upperBound.setNum(math$1.max(a.x, b.x), math$1.max(a.y, b.y));\n        };\n        AABB.prototype.set = function (aabb) {\n            this.lowerBound.setNum(aabb.lowerBound.x, aabb.lowerBound.y);\n            this.upperBound.setNum(aabb.upperBound.x, aabb.upperBound.y);\n        };\n        AABB.prototype.contains = function (aabb) {\n            var result = true;\n            result = result && this.lowerBound.x <= aabb.lowerBound.x;\n            result = result && this.lowerBound.y <= aabb.lowerBound.y;\n            result = result && aabb.upperBound.x <= this.upperBound.x;\n            result = result && aabb.upperBound.y <= this.upperBound.y;\n            return result;\n        };\n        AABB.prototype.extend = function (value) {\n            AABB.extend(this, value);\n            return this;\n        };\n        AABB.extend = function (aabb, value) {\n            aabb.lowerBound.x -= value;\n            aabb.lowerBound.y -= value;\n            aabb.upperBound.x += value;\n            aabb.upperBound.y += value;\n        };\n        AABB.testOverlap = function (a, b) {\n            var d1x = b.lowerBound.x - a.upperBound.x;\n            var d2x = a.lowerBound.x - b.upperBound.x;\n            var d1y = b.lowerBound.y - a.upperBound.y;\n            var d2y = a.lowerBound.y - b.upperBound.y;\n            if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) {\n                return false;\n            }\n            return true;\n        };\n        AABB.areEqual = function (a, b) {\n            return Vec2.areEqual(a.lowerBound, b.lowerBound) && Vec2.areEqual(a.upperBound, b.upperBound);\n        };\n        AABB.diff = function (a, b) {\n            var wD = math$1.max(0, math$1.min(a.upperBound.x, b.upperBound.x) - math$1.max(b.lowerBound.x, a.lowerBound.x));\n            var hD = math$1.max(0, math$1.min(a.upperBound.y, b.upperBound.y) - math$1.max(b.lowerBound.y, a.lowerBound.y));\n            var wA = a.upperBound.x - a.lowerBound.x;\n            var hA = a.upperBound.y - a.lowerBound.y;\n            var wB = b.upperBound.x - b.lowerBound.x;\n            var hB = b.upperBound.y - b.lowerBound.y;\n            return wA * hA + wB * hB - wD * hD;\n        };\n        AABB.prototype.rayCast = function (output, input) {\n            // From Real-time Collision Detection, p179.\n            var tmin = -Infinity;\n            var tmax = Infinity;\n            var p = input.p1;\n            var d = Vec2.sub(input.p2, input.p1);\n            var absD = Vec2.abs(d);\n            var normal = Vec2.zero();\n            for (var f = 'x'; f !== null; f = (f === 'x' ? 'y' : null)) {\n                if (absD.x < math$1.EPSILON) {\n                    // Parallel.\n                    if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) {\n                        return false;\n                    }\n                }\n                else {\n                    var inv_d = 1.0 / d[f];\n                    var t1 = (this.lowerBound[f] - p[f]) * inv_d;\n                    var t2 = (this.upperBound[f] - p[f]) * inv_d;\n                    // Sign of the normal vector.\n                    var s = -1.0;\n                    if (t1 > t2) {\n                        var temp = t1;\n                        t1 = t2;\n                        t2 = temp;\n                        s = 1.0;\n                    }\n                    // Push the min up\n                    if (t1 > tmin) {\n                        normal.setZero();\n                        normal[f] = s;\n                        tmin = t1;\n                    }\n                    // Pull the max down\n                    tmax = math$1.min(tmax, t2);\n                    if (tmin > tmax) {\n                        return false;\n                    }\n                }\n            }\n            // Does the ray start inside the box?\n            // Does the ray intersect beyond the max fraction?\n            if (tmin < 0.0 || input.maxFraction < tmin) {\n                return false;\n            }\n            // Intersection.\n            output.fraction = tmin;\n            output.normal = normal;\n            return true;\n        };\n        /** @internal */\n        AABB.prototype.toString = function () {\n            return JSON.stringify(this);\n        };\n        return AABB;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    // TODO merge with World options?\n    /**\n     * Tuning constants based on meters-kilograms-seconds (MKS) units.\n     */\n    // tslint:disable-next-line:no-unnecessary-class\n    var Settings = /** @class */ (function () {\n        function Settings() {\n        }\n        Object.defineProperty(Settings, \"linearSlopSquared\", {\n            get: function () { return Settings.linearSlop * Settings.linearSlop; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Settings, \"polygonRadius\", {\n            /**\n             * The radius of the polygon/edge shape skin. This should not be modified.\n             * Making this smaller means polygons will have an insufficient buffer for\n             * continuous collision. Making it larger may create artifacts for vertex\n             * collision.\n             */\n            get: function () { return 2.0 * Settings.linearSlop; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Settings, \"maxTranslationSquared\", {\n            get: function () { return Settings.maxTranslation * Settings.maxTranslation; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Settings, \"maxRotationSquared\", {\n            get: function () { return Settings.maxRotation * Settings.maxRotation; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Settings, \"linearSleepToleranceSqr\", {\n            get: function () { return Math.pow(Settings.linearSleepTolerance, 2); },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Settings, \"angularSleepToleranceSqr\", {\n            get: function () { return Math.pow(Settings.angularSleepTolerance, 2); },\n            enumerable: false,\n            configurable: true\n        });\n        // Collision\n        /**\n         * The maximum number of contact points between two convex shapes. Do not change\n         * this value.\n         */\n        Settings.maxManifoldPoints = 2;\n        /**\n         * The maximum number of vertices on a convex polygon. You cannot increase this\n         * too much because BlockAllocator has a maximum object size.\n         */\n        Settings.maxPolygonVertices = 12;\n        /**\n         * This is used to fatten AABBs in the dynamic tree. This allows proxies to move\n         * by a small amount without triggering a tree adjustment. This is in meters.\n         */\n        Settings.aabbExtension = 0.1;\n        /**\n         * This is used to fatten AABBs in the dynamic tree. This is used to predict the\n         * future position based on the current displacement. This is a dimensionless\n         * multiplier.\n         */\n        Settings.aabbMultiplier = 2.0;\n        /**\n         * A small length used as a collision and constraint tolerance. Usually it is\n         * chosen to be numerically significant, but visually insignificant.\n         */\n        Settings.linearSlop = 0.005;\n        /**\n         * A small angle used as a collision and constraint tolerance. Usually it is\n         * chosen to be numerically significant, but visually insignificant.\n         */\n        Settings.angularSlop = (2.0 / 180.0 * Math.PI);\n        /**\n         * Maximum number of sub-steps per contact in continuous physics simulation.\n         */\n        Settings.maxSubSteps = 8;\n        // Dynamics\n        /**\n         * Maximum number of contacts to be handled to solve a TOI impact.\n         */\n        Settings.maxTOIContacts = 32;\n        /**\n         * Maximum iterations to solve a TOI.\n         */\n        Settings.maxTOIIterations = 20;\n        /**\n         * Maximum iterations to find Distance.\n         */\n        Settings.maxDistnceIterations = 20;\n        /**\n         * A velocity threshold for elastic collisions. Any collision with a relative\n         * linear velocity below this threshold will be treated as inelastic.\n         */\n        Settings.velocityThreshold = 1.0;\n        /**\n         * The maximum linear position correction used when solving constraints. This\n         * helps to prevent overshoot.\n         */\n        Settings.maxLinearCorrection = 0.2;\n        /**\n         * The maximum angular position correction used when solving constraints. This\n         * helps to prevent overshoot.\n         */\n        Settings.maxAngularCorrection = (8.0 / 180.0 * Math.PI);\n        /**\n         * The maximum linear velocity of a body. This limit is very large and is used\n         * to prevent numerical problems. You shouldn't need to adjust Settings.\n         */\n        Settings.maxTranslation = 2.0;\n        /**\n         * The maximum angular velocity of a body. This limit is very large and is used\n         * to prevent numerical problems. You shouldn't need to adjust Settings.\n         */\n        Settings.maxRotation = (0.5 * Math.PI);\n        /**\n         * This scale factor controls how fast overlap is resolved. Ideally this would\n         * be 1 so that overlap is removed in one time step. However using values close\n         * to 1 often lead to overshoot.\n         */\n        Settings.baumgarte = 0.2;\n        Settings.toiBaugarte = 0.75;\n        // Sleep\n        /**\n         * The time that a body must be still before it will go to sleep.\n         */\n        Settings.timeToSleep = 0.5;\n        /**\n         * A body cannot sleep if its linear velocity is above this tolerance.\n         */\n        Settings.linearSleepTolerance = 0.01;\n        /**\n         * A body cannot sleep if its angular velocity is above this tolerance.\n         */\n        Settings.angularSleepTolerance = (2.0 / 180.0 * Math.PI);\n        return Settings;\n    }());\n\n    /*\n     * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js\n     *\n     * This software is provided 'as-is', without any express or implied\n     * warranty.  In no event will the authors be held liable for any damages\n     * arising from the use of this software.\n     * Permission is granted to anyone to use this software for any purpose,\n     * including commercial applications, and to alter it and redistribute it\n     * freely, subject to the following restrictions:\n     * 1. The origin of this software must not be misrepresented; you must not\n     * claim that you wrote the original software. If you use this software\n     * in a product, an acknowledgment in the product documentation would be\n     * appreciated but is not required.\n     * 2. Altered source versions must be plainly marked as such, and must not be\n     * misrepresented as being the original software.\n     * 3. This notice may not be removed or altered from any source distribution.\n     */\n    var Pool = /** @class */ (function () {\n        function Pool(opts) {\n            this._list = [];\n            this._max = Infinity;\n            this._createCount = 0;\n            this._outCount = 0;\n            this._inCount = 0;\n            this._discardCount = 0;\n            this._list = [];\n            this._max = opts.max || this._max;\n            this._createFn = opts.create;\n            this._outFn = opts.allocate;\n            this._inFn = opts.release;\n            this._discardFn = opts.discard;\n        }\n        Pool.prototype.max = function (n) {\n            if (typeof n === 'number') {\n                this._max = n;\n                return this;\n            }\n            return this._max;\n        };\n        Pool.prototype.size = function () {\n            return this._list.length;\n        };\n        Pool.prototype.allocate = function () {\n            var item;\n            if (this._list.length > 0) {\n                item = this._list.shift();\n            }\n            else {\n                this._createCount++;\n                if (typeof this._createFn === 'function') {\n                    item = this._createFn();\n                }\n                else {\n                    // tslint:disable-next-line:no-object-literal-type-assertion\n                    item = {};\n                }\n            }\n            this._outCount++;\n            if (typeof this._outFn === 'function') {\n                this._outFn(item);\n            }\n            return item;\n        };\n        Pool.prototype.release = function (item) {\n            if (this._list.length < this._max) {\n                this._inCount++;\n                if (typeof this._inFn === 'function') {\n                    this._inFn(item);\n                }\n                this._list.push(item);\n            }\n            else {\n                this._discardCount++;\n                if (typeof this._discardFn === 'function') {\n                    item = this._discardFn(item);\n                }\n            }\n        };\n        /** @internal */\n        Pool.prototype.toString = function () {\n            return \" +\" + this._createCount + \" >\" + this._outCount + \" <\" + this._inCount + \" -\"\n                + this._discardCount + \" =\" + this._list.length + \"/\" + this._max;\n        };\n        return Pool;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A node in the dynamic tree. The client does not interact with this directly.\n     */\n    var TreeNode = /** @class */ (function () {\n        function TreeNode(id) {\n            /** Enlarged AABB */\n            this.aabb = new AABB();\n            this.userData = null;\n            this.parent = null;\n            this.child1 = null;\n            this.child2 = null;\n            /** 0: leaf, -1: free node */\n            this.height = -1;\n            this.id = id;\n        }\n        /** @internal */\n        TreeNode.prototype.toString = function () {\n            return this.id + \": \" + this.userData;\n        };\n        TreeNode.prototype.isLeaf = function () {\n            return this.child1 == null;\n        };\n        return TreeNode;\n    }());\n    /**\n     * A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt. A\n     * dynamic tree arranges data in a binary tree to accelerate queries such as\n     * volume queries and ray casts. Leafs are proxies with an AABB. In the tree we\n     * expand the proxy AABB by `aabbExtension` so that the proxy AABB is bigger\n     * than the client object. This allows the client object to move by small\n     * amounts without triggering a tree update.\n     *\n     * Nodes are pooled and relocatable, so we use node indices rather than\n     * pointers.\n     */\n    var DynamicTree = /** @class */ (function () {\n        function DynamicTree() {\n            this.inputPool = new Pool({\n                create: function () {\n                    // tslint:disable-next-line:no-object-literal-type-assertion\n                    return {};\n                },\n                release: function (stack) {\n                }\n            });\n            this.stackPool = new Pool({\n                create: function () {\n                    return [];\n                },\n                release: function (stack) {\n                    stack.length = 0;\n                }\n            });\n            this.iteratorPool = new Pool({\n                create: function () {\n                    return new Iterator();\n                },\n                release: function (iterator) {\n                    iterator.close();\n                }\n            });\n            this.m_root = null;\n            this.m_nodes = {};\n            this.m_lastProxyId = 0;\n            this.m_pool = new Pool({\n                create: function () {\n                    return new TreeNode();\n                }\n            });\n        }\n        /**\n         * Get proxy user data.\n         *\n         * @return the proxy user data or 0 if the id is invalid.\n         */\n        DynamicTree.prototype.getUserData = function (id) {\n            var node = this.m_nodes[id];\n            return node.userData;\n        };\n        /**\n         * Get the fat AABB for a node id.\n         *\n         * @return the proxy user data or 0 if the id is invalid.\n         */\n        DynamicTree.prototype.getFatAABB = function (id) {\n            var node = this.m_nodes[id];\n            return node.aabb;\n        };\n        DynamicTree.prototype.allocateNode = function () {\n            var node = this.m_pool.allocate();\n            node.id = ++this.m_lastProxyId;\n            node.userData = null;\n            node.parent = null;\n            node.child1 = null;\n            node.child2 = null;\n            node.height = -1;\n            this.m_nodes[node.id] = node;\n            return node;\n        };\n        DynamicTree.prototype.freeNode = function (node) {\n            this.m_pool.release(node);\n            node.height = -1;\n            // tslint:disable-next-line:no-dynamic-delete\n            delete this.m_nodes[node.id];\n        };\n        /**\n         * Create a proxy in the tree as a leaf node. We return the index of the node\n         * instead of a pointer so that we can grow the node pool.\n         *\n         * Create a proxy. Provide a tight fitting AABB and a userData pointer.\n         */\n        DynamicTree.prototype.createProxy = function (aabb, userData) {\n            var node = this.allocateNode();\n            node.aabb.set(aabb);\n            // Fatten the aabb.\n            AABB.extend(node.aabb, Settings.aabbExtension);\n            node.userData = userData;\n            node.height = 0;\n            this.insertLeaf(node);\n            return node.id;\n        };\n        /**\n         * Destroy a proxy. This asserts if the id is invalid.\n         */\n        DynamicTree.prototype.destroyProxy = function (id) {\n            var node = this.m_nodes[id];\n            this.removeLeaf(node);\n            this.freeNode(node);\n        };\n        /**\n         * Move a proxy with a swepted AABB. If the proxy has moved outside of its\n         * fattened AABB, then the proxy is removed from the tree and re-inserted.\n         * Otherwise the function returns immediately.\n         *\n         * @param d Displacement\n         *\n         * @return true if the proxy was re-inserted.\n         */\n        DynamicTree.prototype.moveProxy = function (id, aabb, d) {\n            var node = this.m_nodes[id];\n            if (node.aabb.contains(aabb)) {\n                return false;\n            }\n            this.removeLeaf(node);\n            node.aabb.set(aabb);\n            // Extend AABB.\n            aabb = node.aabb;\n            AABB.extend(aabb, Settings.aabbExtension);\n            // Predict AABB displacement.\n            // const d = Vec2.mul(Settings.aabbMultiplier, displacement);\n            if (d.x < 0.0) {\n                aabb.lowerBound.x += d.x * Settings.aabbMultiplier;\n            }\n            else {\n                aabb.upperBound.x += d.x * Settings.aabbMultiplier;\n            }\n            if (d.y < 0.0) {\n                aabb.lowerBound.y += d.y * Settings.aabbMultiplier;\n            }\n            else {\n                aabb.upperBound.y += d.y * Settings.aabbMultiplier;\n            }\n            this.insertLeaf(node);\n            return true;\n        };\n        DynamicTree.prototype.insertLeaf = function (leaf) {\n            if (this.m_root == null) {\n                this.m_root = leaf;\n                this.m_root.parent = null;\n                return;\n            }\n            // Find the best sibling for this node\n            var leafAABB = leaf.aabb;\n            var index = this.m_root;\n            while (!index.isLeaf()) {\n                var child1 = index.child1;\n                var child2 = index.child2;\n                var area = index.aabb.getPerimeter();\n                var combinedAABB = new AABB();\n                combinedAABB.combine(index.aabb, leafAABB);\n                var combinedArea = combinedAABB.getPerimeter();\n                // Cost of creating a new parent for this node and the new leaf\n                var cost = 2.0 * combinedArea;\n                // Minimum cost of pushing the leaf further down the tree\n                var inheritanceCost = 2.0 * (combinedArea - area);\n                // Cost of descending into child1\n                var cost1 = void 0;\n                if (child1.isLeaf()) {\n                    var aabb = new AABB();\n                    aabb.combine(leafAABB, child1.aabb);\n                    cost1 = aabb.getPerimeter() + inheritanceCost;\n                }\n                else {\n                    var aabb = new AABB();\n                    aabb.combine(leafAABB, child1.aabb);\n                    var oldArea = child1.aabb.getPerimeter();\n                    var newArea = aabb.getPerimeter();\n                    cost1 = (newArea - oldArea) + inheritanceCost;\n                }\n                // Cost of descending into child2\n                var cost2 = void 0;\n                if (child2.isLeaf()) {\n                    var aabb = new AABB();\n                    aabb.combine(leafAABB, child2.aabb);\n                    cost2 = aabb.getPerimeter() + inheritanceCost;\n                }\n                else {\n                    var aabb = new AABB();\n                    aabb.combine(leafAABB, child2.aabb);\n                    var oldArea = child2.aabb.getPerimeter();\n                    var newArea = aabb.getPerimeter();\n                    cost2 = newArea - oldArea + inheritanceCost;\n                }\n                // Descend according to the minimum cost.\n                if (cost < cost1 && cost < cost2) {\n                    break;\n                }\n                // Descend\n                if (cost1 < cost2) {\n                    index = child1;\n                }\n                else {\n                    index = child2;\n                }\n            }\n            var sibling = index;\n            // Create a new parent.\n            var oldParent = sibling.parent;\n            var newParent = this.allocateNode();\n            newParent.parent = oldParent;\n            newParent.userData = null;\n            newParent.aabb.combine(leafAABB, sibling.aabb);\n            newParent.height = sibling.height + 1;\n            if (oldParent != null) {\n                // The sibling was not the root.\n                if (oldParent.child1 === sibling) {\n                    oldParent.child1 = newParent;\n                }\n                else {\n                    oldParent.child2 = newParent;\n                }\n                newParent.child1 = sibling;\n                newParent.child2 = leaf;\n                sibling.parent = newParent;\n                leaf.parent = newParent;\n            }\n            else {\n                // The sibling was the root.\n                newParent.child1 = sibling;\n                newParent.child2 = leaf;\n                sibling.parent = newParent;\n                leaf.parent = newParent;\n                this.m_root = newParent;\n            }\n            // Walk back up the tree fixing heights and AABBs\n            index = leaf.parent;\n            while (index != null) {\n                index = this.balance(index);\n                var child1 = index.child1;\n                var child2 = index.child2;\n                index.height = 1 + math$1.max(child1.height, child2.height);\n                index.aabb.combine(child1.aabb, child2.aabb);\n                index = index.parent;\n            }\n            // validate();\n        };\n        DynamicTree.prototype.removeLeaf = function (leaf) {\n            if (leaf === this.m_root) {\n                this.m_root = null;\n                return;\n            }\n            var parent = leaf.parent;\n            var grandParent = parent.parent;\n            var sibling;\n            if (parent.child1 === leaf) {\n                sibling = parent.child2;\n            }\n            else {\n                sibling = parent.child1;\n            }\n            if (grandParent != null) {\n                // Destroy parent and connect sibling to grandParent.\n                if (grandParent.child1 === parent) {\n                    grandParent.child1 = sibling;\n                }\n                else {\n                    grandParent.child2 = sibling;\n                }\n                sibling.parent = grandParent;\n                this.freeNode(parent);\n                // Adjust ancestor bounds.\n                var index = grandParent;\n                while (index != null) {\n                    index = this.balance(index);\n                    var child1 = index.child1;\n                    var child2 = index.child2;\n                    index.aabb.combine(child1.aabb, child2.aabb);\n                    index.height = 1 + math$1.max(child1.height, child2.height);\n                    index = index.parent;\n                }\n            }\n            else {\n                this.m_root = sibling;\n                sibling.parent = null;\n                this.freeNode(parent);\n            }\n            // validate();\n        };\n        /**\n         * Perform a left or right rotation if node A is imbalanced. Returns the new\n         * root index.\n         */\n        DynamicTree.prototype.balance = function (iA) {\n            var A = iA;\n            if (A.isLeaf() || A.height < 2) {\n                return iA;\n            }\n            var B = A.child1;\n            var C = A.child2;\n            var balance = C.height - B.height;\n            // Rotate C up\n            if (balance > 1) {\n                var F = C.child1;\n                var G = C.child2;\n                // Swap A and C\n                C.child1 = A;\n                C.parent = A.parent;\n                A.parent = C;\n                // A's old parent should point to C\n                if (C.parent != null) {\n                    if (C.parent.child1 === iA) {\n                        C.parent.child1 = C;\n                    }\n                    else {\n                        C.parent.child2 = C;\n                    }\n                }\n                else {\n                    this.m_root = C;\n                }\n                // Rotate\n                if (F.height > G.height) {\n                    C.child2 = F;\n                    A.child2 = G;\n                    G.parent = A;\n                    A.aabb.combine(B.aabb, G.aabb);\n                    C.aabb.combine(A.aabb, F.aabb);\n                    A.height = 1 + math$1.max(B.height, G.height);\n                    C.height = 1 + math$1.max(A.height, F.height);\n                }\n                else {\n                    C.child2 = G;\n                    A.child2 = F;\n                    F.parent = A;\n                    A.aabb.combine(B.aabb, F.aabb);\n                    C.aabb.combine(A.aabb, G.aabb);\n                    A.height = 1 + math$1.max(B.height, F.height);\n                    C.height = 1 + math$1.max(A.height, G.height);\n                }\n                return C;\n            }\n            // Rotate B up\n            if (balance < -1) {\n                var D = B.child1;\n                var E = B.child2;\n                // Swap A and B\n                B.child1 = A;\n                B.parent = A.parent;\n                A.parent = B;\n                // A's old parent should point to B\n                if (B.parent != null) {\n                    if (B.parent.child1 === A) {\n                        B.parent.child1 = B;\n                    }\n                    else {\n                        B.parent.child2 = B;\n                    }\n                }\n                else {\n                    this.m_root = B;\n                }\n                // Rotate\n                if (D.height > E.height) {\n                    B.child2 = D;\n                    A.child1 = E;\n                    E.parent = A;\n                    A.aabb.combine(C.aabb, E.aabb);\n                    B.aabb.combine(A.aabb, D.aabb);\n                    A.height = 1 + math$1.max(C.height, E.height);\n                    B.height = 1 + math$1.max(A.height, D.height);\n                }\n                else {\n                    B.child2 = E;\n                    A.child1 = D;\n                    D.parent = A;\n                    A.aabb.combine(C.aabb, D.aabb);\n                    B.aabb.combine(A.aabb, E.aabb);\n                    A.height = 1 + math$1.max(C.height, D.height);\n                    B.height = 1 + math$1.max(A.height, E.height);\n                }\n                return B;\n            }\n            return A;\n        };\n        /**\n         * Compute the height of the binary tree in O(N) time. Should not be called\n         * often.\n         */\n        DynamicTree.prototype.getHeight = function () {\n            if (this.m_root == null) {\n                return 0;\n            }\n            return this.m_root.height;\n        };\n        /**\n         * Get the ratio of the sum of the node areas to the root area.\n         */\n        DynamicTree.prototype.getAreaRatio = function () {\n            if (this.m_root == null) {\n                return 0.0;\n            }\n            var root = this.m_root;\n            var rootArea = root.aabb.getPerimeter();\n            var totalArea = 0.0;\n            var node;\n            var it = this.iteratorPool.allocate().preorder(this.m_root);\n            while (node = it.next()) {\n                if (node.height < 0) {\n                    // Free node in pool\n                    continue;\n                }\n                totalArea += node.aabb.getPerimeter();\n            }\n            this.iteratorPool.release(it);\n            return totalArea / rootArea;\n        };\n        /**\n         * Compute the height of a sub-tree.\n         */\n        DynamicTree.prototype.computeHeight = function (id) {\n            var node;\n            if (typeof id !== 'undefined') {\n                node = this.m_nodes[id];\n            }\n            else {\n                node = this.m_root;\n            }\n            // _ASSERT && common.assert(0 <= id && id < this.m_nodeCapacity);\n            if (node.isLeaf()) {\n                return 0;\n            }\n            var height1 = this.computeHeight(node.child1.id);\n            var height2 = this.computeHeight(node.child2.id);\n            return 1 + math$1.max(height1, height2);\n        };\n        DynamicTree.prototype.validateStructure = function (node) {\n            if (node == null) {\n                return;\n            }\n            if (node === this.m_root) ;\n            var child1 = node.child1;\n            var child2 = node.child2;\n            if (node.isLeaf()) {\n                return;\n            }\n            this.validateStructure(child1);\n            this.validateStructure(child2);\n        };\n        DynamicTree.prototype.validateMetrics = function (node) {\n            if (node == null) {\n                return;\n            }\n            var child1 = node.child1;\n            var child2 = node.child2;\n            if (node.isLeaf()) {\n                return;\n            }\n            // _ASSERT && common.assert(0 <= child1 && child1 < this.m_nodeCapacity);\n            // _ASSERT && common.assert(0 <= child2 && child2 < this.m_nodeCapacity);\n            var height1 = child1.height;\n            var height2 = child2.height;\n            1 + math$1.max(height1, height2);\n            var aabb = new AABB();\n            aabb.combine(child1.aabb, child2.aabb);\n            this.validateMetrics(child1);\n            this.validateMetrics(child2);\n        };\n        /**\n         * Validate this tree. For testing.\n         */\n        DynamicTree.prototype.validate = function () {\n            this.validateStructure(this.m_root);\n            this.validateMetrics(this.m_root);\n        };\n        /**\n         * Get the maximum balance of an node in the tree. The balance is the difference\n         * in height of the two children of a node.\n         */\n        DynamicTree.prototype.getMaxBalance = function () {\n            var maxBalance = 0;\n            var node;\n            var it = this.iteratorPool.allocate().preorder(this.m_root);\n            while (node = it.next()) {\n                if (node.height <= 1) {\n                    continue;\n                }\n                var balance = math$1.abs(node.child2.height - node.child1.height);\n                maxBalance = math$1.max(maxBalance, balance);\n            }\n            this.iteratorPool.release(it);\n            return maxBalance;\n        };\n        /**\n         * Build an optimal tree. Very expensive. For testing.\n         */\n        DynamicTree.prototype.rebuildBottomUp = function () {\n            var nodes = [];\n            var count = 0;\n            // Build array of leaves. Free the rest.\n            var node;\n            var it = this.iteratorPool.allocate().preorder(this.m_root);\n            while (node = it.next()) {\n                if (node.height < 0) {\n                    // free node in pool\n                    continue;\n                }\n                if (node.isLeaf()) {\n                    node.parent = null;\n                    nodes[count] = node;\n                    ++count;\n                }\n                else {\n                    this.freeNode(node);\n                }\n            }\n            this.iteratorPool.release(it);\n            while (count > 1) {\n                var minCost = Infinity;\n                var iMin = -1;\n                var jMin = -1;\n                for (var i = 0; i < count; ++i) {\n                    var aabbi = nodes[i].aabb;\n                    for (var j = i + 1; j < count; ++j) {\n                        var aabbj = nodes[j].aabb;\n                        var b = new AABB();\n                        b.combine(aabbi, aabbj);\n                        var cost = b.getPerimeter();\n                        if (cost < minCost) {\n                            iMin = i;\n                            jMin = j;\n                            minCost = cost;\n                        }\n                    }\n                }\n                var child1 = nodes[iMin];\n                var child2 = nodes[jMin];\n                var parent_1 = this.allocateNode();\n                parent_1.child1 = child1;\n                parent_1.child2 = child2;\n                parent_1.height = 1 + math$1.max(child1.height, child2.height);\n                parent_1.aabb.combine(child1.aabb, child2.aabb);\n                parent_1.parent = null;\n                child1.parent = parent_1;\n                child2.parent = parent_1;\n                nodes[jMin] = nodes[count - 1];\n                nodes[iMin] = parent_1;\n                --count;\n            }\n            this.m_root = nodes[0];\n            this.validate();\n        };\n        /**\n         * Shift the world origin. Useful for large worlds. The shift formula is:\n         * position -= newOrigin\n         *\n         * @param newOrigin The new origin with respect to the old origin\n         */\n        DynamicTree.prototype.shiftOrigin = function (newOrigin) {\n            // Build array of leaves. Free the rest.\n            var node;\n            var it = this.iteratorPool.allocate().preorder(this.m_root);\n            while (node = it.next()) {\n                var aabb = node.aabb;\n                aabb.lowerBound.x -= newOrigin.x;\n                aabb.lowerBound.y -= newOrigin.y;\n                aabb.upperBound.x -= newOrigin.x;\n                aabb.upperBound.y -= newOrigin.y;\n            }\n            this.iteratorPool.release(it);\n        };\n        /**\n         * Query an AABB for overlapping proxies. The callback class is called for each\n         * proxy that overlaps the supplied AABB.\n         */\n        DynamicTree.prototype.query = function (aabb, queryCallback) {\n            var stack = this.stackPool.allocate();\n            stack.push(this.m_root);\n            while (stack.length > 0) {\n                var node = stack.pop();\n                if (node == null) {\n                    continue;\n                }\n                if (AABB.testOverlap(node.aabb, aabb)) {\n                    if (node.isLeaf()) {\n                        var proceed = queryCallback(node.id);\n                        if (proceed === false) {\n                            return;\n                        }\n                    }\n                    else {\n                        stack.push(node.child1);\n                        stack.push(node.child2);\n                    }\n                }\n            }\n            this.stackPool.release(stack);\n        };\n        /**\n         * Ray-cast against the proxies in the tree. This relies on the callback to\n         * perform a exact ray-cast in the case were the proxy contains a shape. The\n         * callback also performs the any collision filtering. This has performance\n         * roughly equal to k * log(n), where k is the number of collisions and n is the\n         * number of proxies in the tree.\n         *\n         * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n         * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n         */\n        DynamicTree.prototype.rayCast = function (input, rayCastCallback) {\n            var p1 = input.p1;\n            var p2 = input.p2;\n            var r = Vec2.sub(p2, p1);\n            r.normalize();\n            // v is perpendicular to the segment.\n            var v = Vec2.crossNumVec2(1.0, r);\n            var abs_v = Vec2.abs(v);\n            // Separating axis for segment (Gino, p80).\n            // |dot(v, p1 - c)| > dot(|v|, h)\n            var maxFraction = input.maxFraction;\n            // Build a bounding box for the segment.\n            var segmentAABB = new AABB();\n            var t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);\n            segmentAABB.combinePoints(p1, t);\n            var stack = this.stackPool.allocate();\n            var subInput = this.inputPool.allocate();\n            stack.push(this.m_root);\n            while (stack.length > 0) {\n                var node = stack.pop();\n                if (node == null) {\n                    continue;\n                }\n                if (AABB.testOverlap(node.aabb, segmentAABB) === false) {\n                    continue;\n                }\n                // Separating axis for segment (Gino, p80).\n                // |dot(v, p1 - c)| > dot(|v|, h)\n                var c = node.aabb.getCenter();\n                var h = node.aabb.getExtents();\n                var separation = math$1.abs(Vec2.dot(v, Vec2.sub(p1, c))) - Vec2.dot(abs_v, h);\n                if (separation > 0.0) {\n                    continue;\n                }\n                if (node.isLeaf()) {\n                    subInput.p1 = Vec2.clone(input.p1);\n                    subInput.p2 = Vec2.clone(input.p2);\n                    subInput.maxFraction = maxFraction;\n                    var value = rayCastCallback(subInput, node.id);\n                    if (value === 0.0) {\n                        // The client has terminated the ray cast.\n                        return;\n                    }\n                    if (value > 0.0) {\n                        // update segment bounding box.\n                        maxFraction = value;\n                        t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);\n                        segmentAABB.combinePoints(p1, t);\n                    }\n                }\n                else {\n                    stack.push(node.child1);\n                    stack.push(node.child2);\n                }\n            }\n            this.stackPool.release(stack);\n            this.inputPool.release(subInput);\n        };\n        return DynamicTree;\n    }());\n    var Iterator = /** @class */ (function () {\n        function Iterator() {\n            this.parents = [];\n            this.states = [];\n        }\n        Iterator.prototype.preorder = function (root) {\n            this.parents.length = 0;\n            this.parents.push(root);\n            this.states.length = 0;\n            this.states.push(0);\n            return this;\n        };\n        Iterator.prototype.next = function () {\n            while (this.parents.length > 0) {\n                var i = this.parents.length - 1;\n                var node = this.parents[i];\n                if (this.states[i] === 0) {\n                    this.states[i] = 1;\n                    return node;\n                }\n                if (this.states[i] === 1) {\n                    this.states[i] = 2;\n                    if (node.child1) {\n                        this.parents.push(node.child1);\n                        this.states.push(1);\n                        return node.child1;\n                    }\n                }\n                if (this.states[i] === 2) {\n                    this.states[i] = 3;\n                    if (node.child2) {\n                        this.parents.push(node.child2);\n                        this.states.push(1);\n                        return node.child2;\n                    }\n                }\n                this.parents.pop();\n                this.states.pop();\n            }\n        };\n        Iterator.prototype.close = function () {\n            this.parents.length = 0;\n        };\n        return Iterator;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * The broad-phase wraps and extends a dynamic-tree to keep track of moved\n     * objects and query them on update.\n     */\n    var BroadPhase = /** @class */ (function () {\n        function BroadPhase() {\n            var _this = this;\n            this.m_tree = new DynamicTree();\n            this.m_proxyCount = 0;\n            this.m_moveBuffer = [];\n            /**\n             * Query an AABB for overlapping proxies. The callback class is called for each\n             * proxy that overlaps the supplied AABB.\n             */\n            this.query = function (aabb, queryCallback) {\n                _this.m_tree.query(aabb, queryCallback);\n            };\n            this.queryCallback = function (proxyId) {\n                // A proxy cannot form a pair with itself.\n                if (proxyId === _this.m_queryProxyId) {\n                    return true;\n                }\n                var proxyIdA = math$1.min(proxyId, _this.m_queryProxyId);\n                var proxyIdB = math$1.max(proxyId, _this.m_queryProxyId);\n                // TODO: Skip any duplicate pairs.\n                var userDataA = _this.m_tree.getUserData(proxyIdA);\n                var userDataB = _this.m_tree.getUserData(proxyIdB);\n                // Send the pairs back to the client.\n                _this.m_callback(userDataA, userDataB);\n                return true;\n            };\n        }\n        /**\n         * Get user data from a proxy. Returns null if the id is invalid.\n         */\n        BroadPhase.prototype.getUserData = function (proxyId) {\n            return this.m_tree.getUserData(proxyId);\n        };\n        /**\n         * Test overlap of fat AABBs.\n         */\n        BroadPhase.prototype.testOverlap = function (proxyIdA, proxyIdB) {\n            var aabbA = this.m_tree.getFatAABB(proxyIdA);\n            var aabbB = this.m_tree.getFatAABB(proxyIdB);\n            return AABB.testOverlap(aabbA, aabbB);\n        };\n        /**\n         * Get the fat AABB for a proxy.\n         */\n        BroadPhase.prototype.getFatAABB = function (proxyId) {\n            return this.m_tree.getFatAABB(proxyId);\n        };\n        /**\n         * Get the number of proxies.\n         */\n        BroadPhase.prototype.getProxyCount = function () {\n            return this.m_proxyCount;\n        };\n        /**\n         * Get the height of the embedded tree.\n         */\n        BroadPhase.prototype.getTreeHeight = function () {\n            return this.m_tree.getHeight();\n        };\n        /**\n         * Get the balance (integer) of the embedded tree.\n         */\n        BroadPhase.prototype.getTreeBalance = function () {\n            return this.m_tree.getMaxBalance();\n        };\n        /**\n         * Get the quality metric of the embedded tree.\n         */\n        BroadPhase.prototype.getTreeQuality = function () {\n            return this.m_tree.getAreaRatio();\n        };\n        /**\n         * Ray-cast against the proxies in the tree. This relies on the callback to\n         * perform a exact ray-cast in the case were the proxy contains a shape. The\n         * callback also performs the any collision filtering. This has performance\n         * roughly equal to k * log(n), where k is the number of collisions and n is the\n         * number of proxies in the tree.\n         *\n         * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n         * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n         */\n        BroadPhase.prototype.rayCast = function (input, rayCastCallback) {\n            this.m_tree.rayCast(input, rayCastCallback);\n        };\n        /**\n         * Shift the world origin. Useful for large worlds. The shift formula is:\n         * position -= newOrigin\n         *\n         * @param newOrigin The new origin with respect to the old origin\n         */\n        BroadPhase.prototype.shiftOrigin = function (newOrigin) {\n            this.m_tree.shiftOrigin(newOrigin);\n        };\n        /**\n         * Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs\n         * is called.\n         */\n        BroadPhase.prototype.createProxy = function (aabb, userData) {\n            var proxyId = this.m_tree.createProxy(aabb, userData);\n            this.m_proxyCount++;\n            this.bufferMove(proxyId);\n            return proxyId;\n        };\n        /**\n         * Destroy a proxy. It is up to the client to remove any pairs.\n         */\n        BroadPhase.prototype.destroyProxy = function (proxyId) {\n            this.unbufferMove(proxyId);\n            this.m_proxyCount--;\n            this.m_tree.destroyProxy(proxyId);\n        };\n        /**\n         * Call moveProxy as many times as you like, then when you are done call\n         * UpdatePairs to finalized the proxy pairs (for your time step).\n         */\n        BroadPhase.prototype.moveProxy = function (proxyId, aabb, displacement) {\n            var changed = this.m_tree.moveProxy(proxyId, aabb, displacement);\n            if (changed) {\n                this.bufferMove(proxyId);\n            }\n        };\n        /**\n         * Call to trigger a re-processing of it's pairs on the next call to\n         * UpdatePairs.\n         */\n        BroadPhase.prototype.touchProxy = function (proxyId) {\n            this.bufferMove(proxyId);\n        };\n        BroadPhase.prototype.bufferMove = function (proxyId) {\n            this.m_moveBuffer.push(proxyId);\n        };\n        BroadPhase.prototype.unbufferMove = function (proxyId) {\n            for (var i = 0; i < this.m_moveBuffer.length; ++i) {\n                if (this.m_moveBuffer[i] === proxyId) {\n                    this.m_moveBuffer[i] = null;\n                }\n            }\n        };\n        /**\n         * Update the pairs. This results in pair callbacks. This can only add pairs.\n         */\n        BroadPhase.prototype.updatePairs = function (addPairCallback) {\n            this.m_callback = addPairCallback;\n            // Perform tree queries for all moving proxies.\n            while (this.m_moveBuffer.length > 0) {\n                this.m_queryProxyId = this.m_moveBuffer.pop();\n                if (this.m_queryProxyId === null) {\n                    continue;\n                }\n                // We have to query the tree with the fat AABB so that\n                // we don't fail to create a pair that may touch later.\n                var fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);\n                // Query tree, create pairs and add them pair buffer.\n                this.m_tree.query(fatAABB, this.queryCallback);\n            }\n            // Try to keep the tree balanced.\n            // this.m_tree.rebalance(4);\n        };\n        return BroadPhase;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var Rot = /** @class */ (function () {\n        /** Initialize from an angle in radians. */\n        function Rot(angle) {\n            if (!(this instanceof Rot)) {\n                return new Rot(angle);\n            }\n            if (typeof angle === 'number') {\n                this.setAngle(angle);\n            }\n            else if (typeof angle === 'object') {\n                this.setRot(angle);\n            }\n            else {\n                this.setIdentity();\n            }\n        }\n        /** @internal */\n        Rot.neo = function (angle) {\n            var obj = Object.create(Rot.prototype);\n            obj.setAngle(angle);\n            return obj;\n        };\n        Rot.clone = function (rot) {\n            var obj = Object.create(Rot.prototype);\n            obj.s = rot.s;\n            obj.c = rot.c;\n            return obj;\n        };\n        Rot.identity = function () {\n            var obj = Object.create(Rot.prototype);\n            obj.s = 0.0;\n            obj.c = 1.0;\n            return obj;\n        };\n        Rot.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return math$1.isFinite(obj.s) && math$1.isFinite(obj.c);\n        };\n        Rot.assert = function (o) {\n            return;\n        };\n        /** Set to the identity rotation. */\n        Rot.prototype.setIdentity = function () {\n            this.s = 0.0;\n            this.c = 1.0;\n        };\n        Rot.prototype.set = function (angle) {\n            if (typeof angle === 'object') {\n                this.s = angle.s;\n                this.c = angle.c;\n            }\n            else {\n                // TODO_ERIN optimize\n                this.s = math$1.sin(angle);\n                this.c = math$1.cos(angle);\n            }\n        };\n        Rot.prototype.setRot = function (angle) {\n            this.s = angle.s;\n            this.c = angle.c;\n        };\n        /** Set using an angle in radians. */\n        Rot.prototype.setAngle = function (angle) {\n            // TODO_ERIN optimize\n            this.s = math$1.sin(angle);\n            this.c = math$1.cos(angle);\n        };\n        /** Get the angle in radians. */\n        Rot.prototype.getAngle = function () {\n            return math$1.atan2(this.s, this.c);\n        };\n        /** Get the x-axis. */\n        Rot.prototype.getXAxis = function () {\n            return Vec2.neo(this.c, this.s);\n        };\n        /** Get the u-axis. */\n        Rot.prototype.getYAxis = function () {\n            return Vec2.neo(-this.s, this.c);\n        };\n        // tslint:disable-next-line:typedef\n        Rot.mul = function (rot, m) {\n            if ('c' in m && 's' in m) {\n                // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n                // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n                // s = qs * rc + qc * rs\n                // c = qc * rc - qs * rs\n                var qr = Rot.identity();\n                qr.s = rot.s * m.c + rot.c * m.s;\n                qr.c = rot.c * m.c - rot.s * m.s;\n                return qr;\n            }\n            else if ('x' in m && 'y' in m) {\n                return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n            }\n        };\n        /** Multiply two rotations: q * r */\n        Rot.mulRot = function (rot, m) {\n            // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n            // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n            // s = qs * rc + qc * rs\n            // c = qc * rc - qs * rs\n            var qr = Rot.identity();\n            qr.s = rot.s * m.c + rot.c * m.s;\n            qr.c = rot.c * m.c - rot.s * m.s;\n            return qr;\n        };\n        /** Rotate a vector */\n        Rot.mulVec2 = function (rot, m) {\n            return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n        };\n        Rot.mulSub = function (rot, v, w) {\n            var x = rot.c * (v.x - w.x) - rot.s * (v.y - w.y);\n            var y = rot.s * (v.x - w.x) + rot.c * (v.y - w.y);\n            return Vec2.neo(x, y);\n        };\n        // tslint:disable-next-line:typedef\n        Rot.mulT = function (rot, m) {\n            if ('c' in m && 's' in m) {\n                // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n                // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n                // s = qc * rs - qs * rc\n                // c = qc * rc + qs * rs\n                var qr = Rot.identity();\n                qr.s = rot.c * m.s - rot.s * m.c;\n                qr.c = rot.c * m.c + rot.s * m.s;\n                return qr;\n            }\n            else if ('x' in m && 'y' in m) {\n                return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n            }\n        };\n        /** Transpose multiply two rotations: qT * r */\n        Rot.mulTRot = function (rot, m) {\n            // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n            // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n            // s = qc * rs - qs * rc\n            // c = qc * rc + qs * rs\n            var qr = Rot.identity();\n            qr.s = rot.c * m.s - rot.s * m.c;\n            qr.c = rot.c * m.c + rot.s * m.s;\n            return qr;\n        };\n        /** Inverse rotate a vector */\n        Rot.mulTVec2 = function (rot, m) {\n            return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n        };\n        return Rot;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A transform contains translation and rotation. It is used to represent the\n     * position and orientation of rigid frames. Initialize using a position vector\n     * and a rotation.\n     */\n    var Transform = /** @class */ (function () {\n        function Transform(position, rotation) {\n            if (!(this instanceof Transform)) {\n                return new Transform(position, rotation);\n            }\n            this.p = Vec2.zero();\n            this.q = Rot.identity();\n            if (typeof position !== 'undefined') {\n                this.p.setVec2(position);\n            }\n            if (typeof rotation !== 'undefined') {\n                this.q.setAngle(rotation);\n            }\n        }\n        Transform.clone = function (xf) {\n            var obj = Object.create(Transform.prototype);\n            obj.p = Vec2.clone(xf.p);\n            obj.q = Rot.clone(xf.q);\n            return obj;\n        };\n        /** @internal */\n        Transform.neo = function (position, rotation) {\n            var obj = Object.create(Transform.prototype);\n            obj.p = Vec2.clone(position);\n            obj.q = Rot.clone(rotation);\n            return obj;\n        };\n        Transform.identity = function () {\n            var obj = Object.create(Transform.prototype);\n            obj.p = Vec2.zero();\n            obj.q = Rot.identity();\n            return obj;\n        };\n        /**\n         * Set this to the identity transform.\n         */\n        Transform.prototype.setIdentity = function () {\n            this.p.setZero();\n            this.q.setIdentity();\n        };\n        /**\n         * Set this based on the position and angle.\n         */\n        // tslint:disable-next-line:typedef\n        Transform.prototype.set = function (a, b) {\n            if (typeof b === 'undefined') {\n                this.p.set(a.p);\n                this.q.set(a.q);\n            }\n            else {\n                this.p.set(a);\n                this.q.set(b);\n            }\n        };\n        /**\n         * Set this based on the position and angle.\n         */\n        Transform.prototype.setNum = function (position, rotation) {\n            this.p.setVec2(position);\n            this.q.setAngle(rotation);\n        };\n        Transform.prototype.setTransform = function (xf) {\n            this.p.setVec2(xf.p);\n            this.q.setRot(xf.q);\n        };\n        Transform.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return Vec2.isValid(obj.p) && Rot.isValid(obj.q);\n        };\n        Transform.assert = function (o) {\n            return;\n        };\n        // static mul(a: Transform, b: Vec2[]): Vec2[];\n        // static mul(a: Transform, b: Transform[]): Transform[];\n        // tslint:disable-next-line:typedef\n        Transform.mul = function (a, b) {\n            if (Array.isArray(b)) {\n                var arr = [];\n                for (var i = 0; i < b.length; i++) {\n                    arr[i] = Transform.mul(a, b[i]);\n                }\n                return arr;\n            }\n            else if ('x' in b && 'y' in b) {\n                return Transform.mulVec2(a, b);\n            }\n            else if ('p' in b && 'q' in b) {\n                return Transform.mulXf(a, b);\n            }\n        };\n        // tslint:disable-next-line:typedef\n        Transform.mulAll = function (a, b) {\n            var arr = [];\n            for (var i = 0; i < b.length; i++) {\n                arr[i] = Transform.mul(a, b[i]);\n            }\n            return arr;\n        };\n        /** @internal @deprecated */\n        // tslint:disable-next-line:typedef\n        Transform.mulFn = function (a) {\n            return function (b) {\n                return Transform.mul(a, b);\n            };\n        };\n        Transform.mulVec2 = function (a, b) {\n            var x = (a.q.c * b.x - a.q.s * b.y) + a.p.x;\n            var y = (a.q.s * b.x + a.q.c * b.y) + a.p.y;\n            return Vec2.neo(x, y);\n        };\n        Transform.mulXf = function (a, b) {\n            // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p\n            // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p\n            var xf = Transform.identity();\n            xf.q = Rot.mulRot(a.q, b.q);\n            xf.p = Vec2.add(Rot.mulVec2(a.q, b.p), a.p);\n            return xf;\n        };\n        // tslint:disable-next-line:typedef\n        Transform.mulT = function (a, b) {\n            if ('x' in b && 'y' in b) {\n                return Transform.mulTVec2(a, b);\n            }\n            else if ('p' in b && 'q' in b) {\n                return Transform.mulTXf(a, b);\n            }\n        };\n        Transform.mulTVec2 = function (a, b) {\n            var px = b.x - a.p.x;\n            var py = b.y - a.p.y;\n            var x = (a.q.c * px + a.q.s * py);\n            var y = (-a.q.s * px + a.q.c * py);\n            return Vec2.neo(x, y);\n        };\n        Transform.mulTXf = function (a, b) {\n            // v2 = A.q' * (B.q * v1 + B.p - A.p)\n            // = A.q' * B.q * v1 + A.q' * (B.p - A.p)\n            var xf = Transform.identity();\n            xf.q.setRot(Rot.mulTRot(a.q, b.q));\n            xf.p.setVec2(Rot.mulTVec2(a.q, Vec2.sub(b.p, a.p)));\n            return xf;\n        };\n        return Transform;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * This describes the motion of a body/shape for TOI computation. Shapes are\n     * defined with respect to the body origin, which may not coincide with the\n     * center of mass. However, to support dynamics we must interpolate the center\n     * of mass position.\n     */\n    var Sweep = /** @class */ (function () {\n        function Sweep(c, a) {\n            this.localCenter = Vec2.zero();\n            this.c = Vec2.zero();\n            this.a = 0;\n            this.alpha0 = 0;\n            this.c0 = Vec2.zero();\n            this.a0 = 0;\n        }\n        Sweep.prototype.setTransform = function (xf) {\n            var c = Transform.mulVec2(xf, this.localCenter);\n            this.c.setVec2(c);\n            this.c0.setVec2(c);\n            this.a = xf.q.getAngle();\n            this.a0 = xf.q.getAngle();\n        };\n        Sweep.prototype.setLocalCenter = function (localCenter, xf) {\n            this.localCenter.setVec2(localCenter);\n            var c = Transform.mulVec2(xf, this.localCenter);\n            this.c.setVec2(c);\n            this.c0.setVec2(c);\n        };\n        /**\n         * Get the interpolated transform at a specific time.\n         *\n         * @param xf\n         * @param beta A factor in [0,1], where 0 indicates alpha0\n         */\n        Sweep.prototype.getTransform = function (xf, beta) {\n            if (beta === void 0) { beta = 0; }\n            xf.q.setAngle((1.0 - beta) * this.a0 + beta * this.a);\n            xf.p.setCombine((1.0 - beta), this.c0, beta, this.c);\n            // shift to origin\n            xf.p.sub(Rot.mulVec2(xf.q, this.localCenter));\n        };\n        /**\n         * Advance the sweep forward, yielding a new initial state.\n         *\n         * @param alpha The new initial time\n         */\n        Sweep.prototype.advance = function (alpha) {\n            var beta = (alpha - this.alpha0) / (1.0 - this.alpha0);\n            this.c0.setCombine(beta, this.c, 1 - beta, this.c0);\n            this.a0 = beta * this.a + (1 - beta) * this.a0;\n            this.alpha0 = alpha;\n        };\n        Sweep.prototype.forward = function () {\n            this.a0 = this.a;\n            this.c0.setVec2(this.c);\n        };\n        /**\n         * normalize the angles in radians to be between -pi and pi.\n         */\n        Sweep.prototype.normalize = function () {\n            var a0 = math$1.mod(this.a0, -math$1.PI, +math$1.PI);\n            this.a -= this.a0 - a0;\n            this.a0 = a0;\n        };\n        Sweep.prototype.clone = function () {\n            var clone = new Sweep();\n            clone.localCenter.setVec2(this.localCenter);\n            clone.alpha0 = this.alpha0;\n            clone.a0 = this.a0;\n            clone.a = this.a;\n            clone.c0.setVec2(this.c0);\n            clone.c.setVec2(this.c);\n            return clone;\n        };\n        Sweep.prototype.set = function (that) {\n            this.localCenter.setVec2(that.localCenter);\n            this.alpha0 = that.alpha0;\n            this.a0 = that.a0;\n            this.a = that.a;\n            this.c0.setVec2(that.c0);\n            this.c.setVec2(that.c);\n        };\n        return Sweep;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var Velocity = /** @class */ (function () {\n        function Velocity() {\n            this.v = Vec2.zero();\n            this.w = 0;\n        }\n        return Velocity;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var Position = /** @class */ (function () {\n        function Position() {\n            this.c = Vec2.zero();\n            this.a = 0;\n        }\n        Position.prototype.getTransform = function (xf, p) {\n            xf.q.setAngle(this.a);\n            xf.p.setVec2(Vec2.sub(this.c, Rot.mulVec2(xf.q, p)));\n            return xf;\n        };\n        return Position;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A shape is used for collision detection. You can create a shape however you\n     * like. Shapes used for simulation in World are created automatically when a\n     * Fixture is created. Shapes may encapsulate one or more child shapes.\n     */\n    var Shape = /** @class */ (function () {\n        function Shape() {\n        }\n        /** @internal */\n        Shape.prototype._reset = function () {\n        };\n        Shape.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return typeof obj.m_type === 'string' && typeof obj.m_radius === 'number';\n        };\n        Shape.prototype.getRadius = function () {\n            return this.m_radius;\n        };\n        /**\n         * Get the type of this shape. You can use this to down cast to the concrete\n         * shape.\n         *\n         * @return the shape type.\n         */\n        Shape.prototype.getType = function () {\n            return this.m_type;\n        };\n        return Shape;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var FixtureDefDefault = {\n        userData: null,\n        friction: 0.2,\n        restitution: 0.0,\n        density: 0.0,\n        isSensor: false,\n        filterGroupIndex: 0,\n        filterCategoryBits: 0x0001,\n        filterMaskBits: 0xFFFF\n    };\n    /**\n     * This proxy is used internally to connect shape children to the broad-phase.\n     */\n    var FixtureProxy = /** @class */ (function () {\n        function FixtureProxy(fixture, childIndex) {\n            this.aabb = new AABB();\n            this.fixture = fixture;\n            this.childIndex = childIndex;\n            this.proxyId;\n        }\n        return FixtureProxy;\n    }());\n    /**\n     * A fixture is used to attach a shape to a body for collision detection. A\n     * fixture inherits its transform from its parent. Fixtures hold additional\n     * non-geometric data such as friction, collision filters, etc.\n     *\n     * To create a new Fixture use {@link Body.createFixture}.\n     */\n    var Fixture = /** @class */ (function () {\n        // tslint:disable-next-line:typedef\n        /** @internal */ function Fixture(body, shape, def) {\n            if (shape.shape) {\n                def = shape;\n                shape = shape.shape;\n            }\n            else if (typeof def === 'number') {\n                def = { density: def };\n            }\n            def = options(def, FixtureDefDefault);\n            this.m_body = body;\n            this.m_friction = def.friction;\n            this.m_restitution = def.restitution;\n            this.m_density = def.density;\n            this.m_isSensor = def.isSensor;\n            this.m_filterGroupIndex = def.filterGroupIndex;\n            this.m_filterCategoryBits = def.filterCategoryBits;\n            this.m_filterMaskBits = def.filterMaskBits;\n            // TODO validate shape\n            this.m_shape = shape; // .clone();\n            this.m_next = null;\n            this.m_proxies = [];\n            this.m_proxyCount = 0;\n            var childCount = this.m_shape.getChildCount();\n            for (var i = 0; i < childCount; ++i) {\n                this.m_proxies[i] = new FixtureProxy(this, i);\n            }\n            this.m_userData = def.userData;\n        }\n        /**\n         * Re-setup fixture.\n         * @internal\n         */\n        Fixture.prototype._reset = function () {\n            var body = this.getBody();\n            var broadPhase = body.m_world.m_broadPhase;\n            this.destroyProxies(broadPhase);\n            if (this.m_shape._reset) {\n                this.m_shape._reset();\n            }\n            var childCount = this.m_shape.getChildCount();\n            for (var i = 0; i < childCount; ++i) {\n                this.m_proxies[i] = new FixtureProxy(this, i);\n            }\n            this.createProxies(broadPhase, body.m_xf);\n            body.resetMassData();\n        };\n        /** @internal */\n        Fixture.prototype._serialize = function () {\n            return {\n                friction: this.m_friction,\n                restitution: this.m_restitution,\n                density: this.m_density,\n                isSensor: this.m_isSensor,\n                filterGroupIndex: this.m_filterGroupIndex,\n                filterCategoryBits: this.m_filterCategoryBits,\n                filterMaskBits: this.m_filterMaskBits,\n                shape: this.m_shape,\n            };\n        };\n        /** @internal */\n        Fixture._deserialize = function (data, body, restore) {\n            var shape = restore(Shape, data.shape);\n            var fixture = shape && new Fixture(body, shape, data);\n            return fixture;\n        };\n        /**\n         * Get the type of the child shape. You can use this to down cast to the\n         * concrete shape.\n         */\n        Fixture.prototype.getType = function () {\n            return this.m_shape.getType();\n        };\n        /**\n         * Get the child shape. You can modify the child shape, however you should not\n         * change the number of vertices because this will crash some collision caching\n         * mechanisms. Manipulating the shape may lead to non-physical behavior.\n         */\n        Fixture.prototype.getShape = function () {\n            return this.m_shape;\n        };\n        /**\n         * A sensor shape collects contact information but never generates a collision\n         * response.\n         */\n        Fixture.prototype.isSensor = function () {\n            return this.m_isSensor;\n        };\n        /**\n         * Set if this fixture is a sensor.\n         */\n        Fixture.prototype.setSensor = function (sensor) {\n            if (sensor != this.m_isSensor) {\n                this.m_body.setAwake(true);\n                this.m_isSensor = sensor;\n            }\n        };\n        // /**\n        //  * Get the contact filtering data.\n        //  */\n        // getFilterData() {\n        //   return this.m_filter;\n        // }\n        /**\n         * Get the user data that was assigned in the fixture definition. Use this to\n         * store your application specific data.\n         */\n        Fixture.prototype.getUserData = function () {\n            return this.m_userData;\n        };\n        /**\n         * Set the user data. Use this to store your application specific data.\n         */\n        Fixture.prototype.setUserData = function (data) {\n            this.m_userData = data;\n        };\n        /**\n         * Get the parent body of this fixture. This is null if the fixture is not\n         * attached.\n         */\n        Fixture.prototype.getBody = function () {\n            return this.m_body;\n        };\n        /**\n         * Get the next fixture in the parent body's fixture list.\n         */\n        Fixture.prototype.getNext = function () {\n            return this.m_next;\n        };\n        /**\n         * Get the density of this fixture.\n         */\n        Fixture.prototype.getDensity = function () {\n            return this.m_density;\n        };\n        /**\n         * Set the density of this fixture. This will _not_ automatically adjust the\n         * mass of the body. You must call Body.resetMassData to update the body's mass.\n         */\n        Fixture.prototype.setDensity = function (density) {\n            this.m_density = density;\n        };\n        /**\n         * Get the coefficient of friction, usually in the range [0,1].\n         */\n        Fixture.prototype.getFriction = function () {\n            return this.m_friction;\n        };\n        /**\n         * Set the coefficient of friction. This will not change the friction of\n         * existing contacts.\n         */\n        Fixture.prototype.setFriction = function (friction) {\n            this.m_friction = friction;\n        };\n        /**\n         * Get the coefficient of restitution.\n         */\n        Fixture.prototype.getRestitution = function () {\n            return this.m_restitution;\n        };\n        /**\n         * Set the coefficient of restitution. This will not change the restitution of\n         * existing contacts.\n         */\n        Fixture.prototype.setRestitution = function (restitution) {\n            this.m_restitution = restitution;\n        };\n        /**\n         * Test a point in world coordinates for containment in this fixture.\n         */\n        Fixture.prototype.testPoint = function (p) {\n            return this.m_shape.testPoint(this.m_body.getTransform(), p);\n        };\n        /**\n         * Cast a ray against this shape.\n         */\n        Fixture.prototype.rayCast = function (output, input, childIndex) {\n            return this.m_shape.rayCast(output, input, this.m_body.getTransform(), childIndex);\n        };\n        /**\n         * Get the mass data for this fixture. The mass data is based on the density and\n         * the shape. The rotational inertia is about the shape's origin. This operation\n         * may be expensive.\n         */\n        Fixture.prototype.getMassData = function (massData) {\n            this.m_shape.computeMass(massData, this.m_density);\n        };\n        /**\n         * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a\n         * more accurate AABB, compute it using the shape and the body transform.\n         */\n        Fixture.prototype.getAABB = function (childIndex) {\n            return this.m_proxies[childIndex].aabb;\n        };\n        /**\n         * These support body activation/deactivation.\n         */\n        Fixture.prototype.createProxies = function (broadPhase, xf) {\n            // Create proxies in the broad-phase.\n            this.m_proxyCount = this.m_shape.getChildCount();\n            for (var i = 0; i < this.m_proxyCount; ++i) {\n                var proxy = this.m_proxies[i];\n                this.m_shape.computeAABB(proxy.aabb, xf, i);\n                proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);\n            }\n        };\n        Fixture.prototype.destroyProxies = function (broadPhase) {\n            // Destroy proxies in the broad-phase.\n            for (var i = 0; i < this.m_proxyCount; ++i) {\n                var proxy = this.m_proxies[i];\n                broadPhase.destroyProxy(proxy.proxyId);\n                proxy.proxyId = null;\n            }\n            this.m_proxyCount = 0;\n        };\n        /**\n         * Updates this fixture proxy in broad-phase (with combined AABB of current and\n         * next transformation).\n         */\n        Fixture.prototype.synchronize = function (broadPhase, xf1, xf2) {\n            for (var i = 0; i < this.m_proxyCount; ++i) {\n                var proxy = this.m_proxies[i];\n                // Compute an AABB that covers the swept shape (may miss some rotation\n                // effect).\n                var aabb1 = new AABB();\n                var aabb2 = new AABB();\n                this.m_shape.computeAABB(aabb1, xf1, proxy.childIndex);\n                this.m_shape.computeAABB(aabb2, xf2, proxy.childIndex);\n                proxy.aabb.combine(aabb1, aabb2);\n                var displacement = Vec2.sub(xf2.p, xf1.p);\n                broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);\n            }\n        };\n        /**\n         * Set the contact filtering data. This will not update contacts until the next\n         * time step when either parent body is active and awake. This automatically\n         * calls refilter.\n         */\n        Fixture.prototype.setFilterData = function (filter) {\n            this.m_filterGroupIndex = filter.groupIndex;\n            this.m_filterCategoryBits = filter.categoryBits;\n            this.m_filterMaskBits = filter.maskBits;\n            this.refilter();\n        };\n        Fixture.prototype.getFilterGroupIndex = function () {\n            return this.m_filterGroupIndex;\n        };\n        Fixture.prototype.setFilterGroupIndex = function (groupIndex) {\n            this.m_filterGroupIndex = groupIndex;\n        };\n        Fixture.prototype.getFilterCategoryBits = function () {\n            return this.m_filterCategoryBits;\n        };\n        Fixture.prototype.setFilterCategoryBits = function (categoryBits) {\n            this.m_filterCategoryBits = categoryBits;\n        };\n        Fixture.prototype.getFilterMaskBits = function () {\n            return this.m_filterMaskBits;\n        };\n        Fixture.prototype.setFilterMaskBits = function (maskBits) {\n            this.m_filterMaskBits = maskBits;\n        };\n        /**\n         * Call this if you want to establish collision that was previously disabled by\n         * ContactFilter.\n         */\n        Fixture.prototype.refilter = function () {\n            if (this.m_body == null) {\n                return;\n            }\n            // Flag associated contacts for filtering.\n            var edge = this.m_body.getContactList();\n            while (edge) {\n                var contact = edge.contact;\n                var fixtureA = contact.getFixtureA();\n                var fixtureB = contact.getFixtureB();\n                if (fixtureA == this || fixtureB == this) {\n                    contact.flagForFiltering();\n                }\n                edge = edge.next;\n            }\n            var world = this.m_body.getWorld();\n            if (world == null) {\n                return;\n            }\n            // Touch each proxy so that new pairs may be created\n            var broadPhase = world.m_broadPhase;\n            for (var i = 0; i < this.m_proxyCount; ++i) {\n                broadPhase.touchProxy(this.m_proxies[i].proxyId);\n            }\n        };\n        /**\n         * Implement this method to provide collision filtering, if you want finer\n         * control over contact creation.\n         *\n         * Return true if contact calculations should be performed between these two\n         * fixtures.\n         *\n         * Warning: for performance reasons this is only called when the AABBs begin to\n         * overlap.\n         */\n        Fixture.prototype.shouldCollide = function (that) {\n            if (that.m_filterGroupIndex === this.m_filterGroupIndex && that.m_filterGroupIndex !== 0) {\n                return that.m_filterGroupIndex > 0;\n            }\n            var collideA = (that.m_filterMaskBits & this.m_filterCategoryBits) !== 0;\n            var collideB = (that.m_filterCategoryBits & this.m_filterMaskBits) !== 0;\n            var collide = collideA && collideB;\n            return collide;\n        };\n        return Fixture;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var STATIC = 'static';\n    var KINEMATIC = 'kinematic';\n    var DYNAMIC = 'dynamic';\n    var BodyDefDefault = {\n        type: STATIC,\n        position: Vec2.zero(),\n        angle: 0.0,\n        linearVelocity: Vec2.zero(),\n        angularVelocity: 0.0,\n        linearDamping: 0.0,\n        angularDamping: 0.0,\n        fixedRotation: false,\n        bullet: false,\n        gravityScale: 1.0,\n        allowSleep: true,\n        awake: true,\n        active: true,\n        userData: null\n    };\n    /**\n     * MassData This holds the mass data computed for a shape.\n     */\n    var MassData = /** @class */ (function () {\n        function MassData() {\n            /** The mass of the shape, usually in kilograms. */\n            this.mass = 0;\n            /** The position of the shape's centroid relative to the shape's origin. */\n            this.center = Vec2.zero();\n            /** The rotational inertia of the shape about the local origin. */\n            this.I = 0;\n        }\n        return MassData;\n    }());\n    /**\n     * A rigid body composed of one or more fixtures.\n     *\n     * To create a new Body use {@link World.createBody}.\n     */\n    var Body = /** @class */ (function () {\n        /** @internal */\n        function Body(world, def) {\n            def = options(def, BodyDefDefault);\n            this.m_world = world;\n            this.m_awakeFlag = def.awake;\n            this.m_autoSleepFlag = def.allowSleep;\n            this.m_bulletFlag = def.bullet;\n            this.m_fixedRotationFlag = def.fixedRotation;\n            this.m_activeFlag = def.active;\n            this.m_islandFlag = false;\n            this.m_toiFlag = false;\n            this.m_userData = def.userData;\n            this.m_type = def.type;\n            if (this.m_type == DYNAMIC) {\n                this.m_mass = 1.0;\n                this.m_invMass = 1.0;\n            }\n            else {\n                this.m_mass = 0.0;\n                this.m_invMass = 0.0;\n            }\n            // Rotational inertia about the center of mass.\n            this.m_I = 0.0;\n            this.m_invI = 0.0;\n            // the body origin transform\n            this.m_xf = Transform.identity();\n            this.m_xf.p = Vec2.clone(def.position);\n            this.m_xf.q.setAngle(def.angle);\n            // the swept motion for CCD\n            this.m_sweep = new Sweep();\n            this.m_sweep.setTransform(this.m_xf);\n            // position and velocity correction\n            this.c_velocity = new Velocity();\n            this.c_position = new Position();\n            this.m_force = Vec2.zero();\n            this.m_torque = 0.0;\n            this.m_linearVelocity = Vec2.clone(def.linearVelocity);\n            this.m_angularVelocity = def.angularVelocity;\n            this.m_linearDamping = def.linearDamping;\n            this.m_angularDamping = def.angularDamping;\n            this.m_gravityScale = def.gravityScale;\n            this.m_sleepTime = 0.0;\n            this.m_jointList = null;\n            this.m_contactList = null;\n            this.m_fixtureList = null;\n            this.m_prev = null;\n            this.m_next = null;\n            this.m_destroyed = false;\n        }\n        /** @internal */\n        Body.prototype._serialize = function () {\n            var fixtures = [];\n            for (var f = this.m_fixtureList; f; f = f.m_next) {\n                fixtures.push(f);\n            }\n            return {\n                type: this.m_type,\n                bullet: this.m_bulletFlag,\n                position: this.m_xf.p,\n                angle: this.m_xf.q.getAngle(),\n                linearVelocity: this.m_linearVelocity,\n                angularVelocity: this.m_angularVelocity,\n                fixtures: fixtures,\n            };\n        };\n        /** @internal */\n        Body._deserialize = function (data, world, restore) {\n            var body = new Body(world, data);\n            if (data.fixtures) {\n                for (var i = data.fixtures.length - 1; i >= 0; i--) {\n                    var fixture = restore(Fixture, data.fixtures[i], body);\n                    body._addFixture(fixture);\n                }\n            }\n            return body;\n        };\n        Body.prototype.isWorldLocked = function () {\n            return this.m_world && this.m_world.isLocked() ? true : false;\n        };\n        Body.prototype.getWorld = function () {\n            return this.m_world;\n        };\n        Body.prototype.getNext = function () {\n            return this.m_next;\n        };\n        Body.prototype.setUserData = function (data) {\n            this.m_userData = data;\n        };\n        Body.prototype.getUserData = function () {\n            return this.m_userData;\n        };\n        Body.prototype.getFixtureList = function () {\n            return this.m_fixtureList;\n        };\n        Body.prototype.getJointList = function () {\n            return this.m_jointList;\n        };\n        /**\n         * Warning: this list changes during the time step and you may miss some\n         * collisions if you don't use ContactListener.\n         */\n        Body.prototype.getContactList = function () {\n            return this.m_contactList;\n        };\n        Body.prototype.isStatic = function () {\n            return this.m_type == STATIC;\n        };\n        Body.prototype.isDynamic = function () {\n            return this.m_type == DYNAMIC;\n        };\n        Body.prototype.isKinematic = function () {\n            return this.m_type == KINEMATIC;\n        };\n        /**\n         * This will alter the mass and velocity.\n         */\n        Body.prototype.setStatic = function () {\n            this.setType(STATIC);\n            return this;\n        };\n        Body.prototype.setDynamic = function () {\n            this.setType(DYNAMIC);\n            return this;\n        };\n        Body.prototype.setKinematic = function () {\n            this.setType(KINEMATIC);\n            return this;\n        };\n        /**\n         * @internal\n         */\n        Body.prototype.getType = function () {\n            return this.m_type;\n        };\n        /**\n         * @internal\n         */\n        Body.prototype.setType = function (type) {\n            if (this.isWorldLocked() == true) {\n                return;\n            }\n            if (this.m_type == type) {\n                return;\n            }\n            this.m_type = type;\n            this.resetMassData();\n            if (this.m_type == STATIC) {\n                this.m_linearVelocity.setZero();\n                this.m_angularVelocity = 0.0;\n                this.m_sweep.forward();\n                this.synchronizeFixtures();\n            }\n            this.setAwake(true);\n            this.m_force.setZero();\n            this.m_torque = 0.0;\n            // Delete the attached contacts.\n            var ce = this.m_contactList;\n            while (ce) {\n                var ce0 = ce;\n                ce = ce.next;\n                this.m_world.destroyContact(ce0.contact);\n            }\n            this.m_contactList = null;\n            // Touch the proxies so that new contacts will be created (when appropriate)\n            var broadPhase = this.m_world.m_broadPhase;\n            for (var f = this.m_fixtureList; f; f = f.m_next) {\n                var proxyCount = f.m_proxyCount;\n                for (var i = 0; i < proxyCount; ++i) {\n                    broadPhase.touchProxy(f.m_proxies[i].proxyId);\n                }\n            }\n        };\n        Body.prototype.isBullet = function () {\n            return this.m_bulletFlag;\n        };\n        /**\n         * Should this body be treated like a bullet for continuous collision detection?\n         */\n        Body.prototype.setBullet = function (flag) {\n            this.m_bulletFlag = !!flag;\n        };\n        Body.prototype.isSleepingAllowed = function () {\n            return this.m_autoSleepFlag;\n        };\n        Body.prototype.setSleepingAllowed = function (flag) {\n            this.m_autoSleepFlag = !!flag;\n            if (this.m_autoSleepFlag == false) {\n                this.setAwake(true);\n            }\n        };\n        Body.prototype.isAwake = function () {\n            return this.m_awakeFlag;\n        };\n        /**\n         * Set the sleep state of the body. A sleeping body has very low CPU cost.\n         *\n         * @param flag Set to true to wake the body, false to put it to sleep.\n         */\n        Body.prototype.setAwake = function (flag) {\n            if (flag) {\n                if (this.m_awakeFlag == false) {\n                    this.m_awakeFlag = true;\n                    this.m_sleepTime = 0.0;\n                }\n            }\n            else {\n                this.m_awakeFlag = false;\n                this.m_sleepTime = 0.0;\n                this.m_linearVelocity.setZero();\n                this.m_angularVelocity = 0.0;\n                this.m_force.setZero();\n                this.m_torque = 0.0;\n            }\n        };\n        Body.prototype.isActive = function () {\n            return this.m_activeFlag;\n        };\n        /**\n         * Set the active state of the body. An inactive body is not simulated and\n         * cannot be collided with or woken up. If you pass a flag of true, all fixtures\n         * will be added to the broad-phase. If you pass a flag of false, all fixtures\n         * will be removed from the broad-phase and all contacts will be destroyed.\n         * Fixtures and joints are otherwise unaffected.\n         *\n         * You may continue to create/destroy fixtures and joints on inactive bodies.\n         * Fixtures on an inactive body are implicitly inactive and will not participate\n         * in collisions, ray-casts, or queries. Joints connected to an inactive body\n         * are implicitly inactive. An inactive body is still owned by a World object\n         * and remains\n         */\n        Body.prototype.setActive = function (flag) {\n            if (flag == this.m_activeFlag) {\n                return;\n            }\n            this.m_activeFlag = !!flag;\n            if (this.m_activeFlag) {\n                // Create all proxies.\n                var broadPhase = this.m_world.m_broadPhase;\n                for (var f = this.m_fixtureList; f; f = f.m_next) {\n                    f.createProxies(broadPhase, this.m_xf);\n                }\n                // Contacts are created the next time step.\n            }\n            else {\n                // Destroy all proxies.\n                var broadPhase = this.m_world.m_broadPhase;\n                for (var f = this.m_fixtureList; f; f = f.m_next) {\n                    f.destroyProxies(broadPhase);\n                }\n                // Destroy the attached contacts.\n                var ce = this.m_contactList;\n                while (ce) {\n                    var ce0 = ce;\n                    ce = ce.next;\n                    this.m_world.destroyContact(ce0.contact);\n                }\n                this.m_contactList = null;\n            }\n        };\n        Body.prototype.isFixedRotation = function () {\n            return this.m_fixedRotationFlag;\n        };\n        /**\n         * Set this body to have fixed rotation. This causes the mass to be reset.\n         */\n        Body.prototype.setFixedRotation = function (flag) {\n            if (this.m_fixedRotationFlag == flag) {\n                return;\n            }\n            this.m_fixedRotationFlag = !!flag;\n            this.m_angularVelocity = 0.0;\n            this.resetMassData();\n        };\n        /**\n         * Get the world transform for the body's origin.\n         */\n        Body.prototype.getTransform = function () {\n            return this.m_xf;\n        };\n        /**\n         * Set the position of the body's origin and rotation. Manipulating a body's\n         * transform may cause non-physical behavior. Note: contacts are updated on the\n         * next call to World.step.\n         *\n         * @param position The world position of the body's local origin.\n         * @param angle The world rotation in radians.\n         */\n        Body.prototype.setTransform = function (position, angle) {\n            if (this.isWorldLocked() == true) {\n                return;\n            }\n            this.m_xf.setNum(position, angle);\n            this.m_sweep.setTransform(this.m_xf);\n            var broadPhase = this.m_world.m_broadPhase;\n            for (var f = this.m_fixtureList; f; f = f.m_next) {\n                f.synchronize(broadPhase, this.m_xf, this.m_xf);\n            }\n        };\n        Body.prototype.synchronizeTransform = function () {\n            this.m_sweep.getTransform(this.m_xf, 1);\n        };\n        /**\n         * Update fixtures in broad-phase.\n         */\n        Body.prototype.synchronizeFixtures = function () {\n            var xf = Transform.identity();\n            this.m_sweep.getTransform(xf, 0);\n            var broadPhase = this.m_world.m_broadPhase;\n            for (var f = this.m_fixtureList; f; f = f.m_next) {\n                f.synchronize(broadPhase, xf, this.m_xf);\n            }\n        };\n        /**\n         * Used in TOI.\n         */\n        Body.prototype.advance = function (alpha) {\n            // Advance to the new safe time. This doesn't sync the broad-phase.\n            this.m_sweep.advance(alpha);\n            this.m_sweep.c.setVec2(this.m_sweep.c0);\n            this.m_sweep.a = this.m_sweep.a0;\n            this.m_sweep.getTransform(this.m_xf, 1);\n        };\n        /**\n         * Get the world position for the body's origin.\n         */\n        Body.prototype.getPosition = function () {\n            return this.m_xf.p;\n        };\n        Body.prototype.setPosition = function (p) {\n            this.setTransform(p, this.m_sweep.a);\n        };\n        /**\n         * Get the current world rotation angle in radians.\n         */\n        Body.prototype.getAngle = function () {\n            return this.m_sweep.a;\n        };\n        Body.prototype.setAngle = function (angle) {\n            this.setTransform(this.m_xf.p, angle);\n        };\n        /**\n         * Get the world position of the center of mass.\n         */\n        Body.prototype.getWorldCenter = function () {\n            return this.m_sweep.c;\n        };\n        /**\n         * Get the local position of the center of mass.\n         */\n        Body.prototype.getLocalCenter = function () {\n            return this.m_sweep.localCenter;\n        };\n        /**\n         * Get the linear velocity of the center of mass.\n         *\n         * @return the linear velocity of the center of mass.\n         */\n        Body.prototype.getLinearVelocity = function () {\n            return this.m_linearVelocity;\n        };\n        /**\n         * Get the world linear velocity of a world point attached to this body.\n         *\n         * @param worldPoint A point in world coordinates.\n         */\n        Body.prototype.getLinearVelocityFromWorldPoint = function (worldPoint) {\n            var localCenter = Vec2.sub(worldPoint, this.m_sweep.c);\n            return Vec2.add(this.m_linearVelocity, Vec2.crossNumVec2(this.m_angularVelocity, localCenter));\n        };\n        /**\n         * Get the world velocity of a local point.\n         *\n         * @param localPoint A point in local coordinates.\n         */\n        Body.prototype.getLinearVelocityFromLocalPoint = function (localPoint) {\n            return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));\n        };\n        /**\n         * Set the linear velocity of the center of mass.\n         *\n         * @param v The new linear velocity of the center of mass.\n         */\n        Body.prototype.setLinearVelocity = function (v) {\n            if (this.m_type == STATIC) {\n                return;\n            }\n            if (Vec2.dot(v, v) > 0.0) {\n                this.setAwake(true);\n            }\n            this.m_linearVelocity.setVec2(v);\n        };\n        /**\n         * Get the angular velocity.\n         *\n         * @returns the angular velocity in radians/second.\n         */\n        Body.prototype.getAngularVelocity = function () {\n            return this.m_angularVelocity;\n        };\n        /**\n         * Set the angular velocity.\n         *\n         * @param omega The new angular velocity in radians/second.\n         */\n        Body.prototype.setAngularVelocity = function (w) {\n            if (this.m_type == STATIC) {\n                return;\n            }\n            if (w * w > 0.0) {\n                this.setAwake(true);\n            }\n            this.m_angularVelocity = w;\n        };\n        Body.prototype.getLinearDamping = function () {\n            return this.m_linearDamping;\n        };\n        Body.prototype.setLinearDamping = function (linearDamping) {\n            this.m_linearDamping = linearDamping;\n        };\n        Body.prototype.getAngularDamping = function () {\n            return this.m_angularDamping;\n        };\n        Body.prototype.setAngularDamping = function (angularDamping) {\n            this.m_angularDamping = angularDamping;\n        };\n        Body.prototype.getGravityScale = function () {\n            return this.m_gravityScale;\n        };\n        /**\n         * Scale the gravity applied to this body.\n         */\n        Body.prototype.setGravityScale = function (scale) {\n            this.m_gravityScale = scale;\n        };\n        /**\n         * Get the total mass of the body.\n         *\n         * @returns The mass, usually in kilograms (kg).\n         */\n        Body.prototype.getMass = function () {\n            return this.m_mass;\n        };\n        /**\n         * Get the rotational inertia of the body about the local origin.\n         *\n         * @return the rotational inertia, usually in kg-m^2.\n         */\n        Body.prototype.getInertia = function () {\n            return this.m_I + this.m_mass\n                * Vec2.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);\n        };\n        /**\n         * Copy the mass data of the body to data.\n         */\n        Body.prototype.getMassData = function (data) {\n            data.mass = this.m_mass;\n            data.I = this.getInertia();\n            data.center.setVec2(this.m_sweep.localCenter);\n        };\n        /**\n         * This resets the mass properties to the sum of the mass properties of the\n         * fixtures. This normally does not need to be called unless you called\n         * SetMassData to override the mass and you later want to reset the mass.\n         */\n        Body.prototype.resetMassData = function () {\n            // Compute mass data from shapes. Each shape has its own density.\n            this.m_mass = 0.0;\n            this.m_invMass = 0.0;\n            this.m_I = 0.0;\n            this.m_invI = 0.0;\n            this.m_sweep.localCenter.setZero();\n            // Static and kinematic bodies have zero mass.\n            if (this.isStatic() || this.isKinematic()) {\n                this.m_sweep.c0.setVec2(this.m_xf.p);\n                this.m_sweep.c.setVec2(this.m_xf.p);\n                this.m_sweep.a0 = this.m_sweep.a;\n                return;\n            }\n            // Accumulate mass over all fixtures.\n            var localCenter = Vec2.zero();\n            for (var f = this.m_fixtureList; f; f = f.m_next) {\n                if (f.m_density == 0.0) {\n                    continue;\n                }\n                var massData = new MassData();\n                f.getMassData(massData);\n                this.m_mass += massData.mass;\n                localCenter.addMul(massData.mass, massData.center);\n                this.m_I += massData.I;\n            }\n            // Compute center of mass.\n            if (this.m_mass > 0.0) {\n                this.m_invMass = 1.0 / this.m_mass;\n                localCenter.mul(this.m_invMass);\n            }\n            else {\n                // Force all dynamic bodies to have a positive mass.\n                this.m_mass = 1.0;\n                this.m_invMass = 1.0;\n            }\n            if (this.m_I > 0.0 && this.m_fixedRotationFlag == false) {\n                // Center the inertia about the center of mass.\n                this.m_I -= this.m_mass * Vec2.dot(localCenter, localCenter);\n                this.m_invI = 1.0 / this.m_I;\n            }\n            else {\n                this.m_I = 0.0;\n                this.m_invI = 0.0;\n            }\n            // Move center of mass.\n            var oldCenter = Vec2.clone(this.m_sweep.c);\n            this.m_sweep.setLocalCenter(localCenter, this.m_xf);\n            // Update center of mass velocity.\n            this.m_linearVelocity.add(Vec2.crossNumVec2(this.m_angularVelocity, Vec2.sub(this.m_sweep.c, oldCenter)));\n        };\n        /**\n         * Set the mass properties to override the mass properties of the fixtures. Note\n         * that this changes the center of mass position. Note that creating or\n         * destroying fixtures can also alter the mass. This function has no effect if\n         * the body isn't dynamic.\n         *\n         * @param massData The mass properties.\n         */\n        Body.prototype.setMassData = function (massData) {\n            if (this.isWorldLocked() == true) {\n                return;\n            }\n            if (this.m_type != DYNAMIC) {\n                return;\n            }\n            this.m_invMass = 0.0;\n            this.m_I = 0.0;\n            this.m_invI = 0.0;\n            this.m_mass = massData.mass;\n            if (this.m_mass <= 0.0) {\n                this.m_mass = 1.0;\n            }\n            this.m_invMass = 1.0 / this.m_mass;\n            if (massData.I > 0.0 && this.m_fixedRotationFlag == false) {\n                this.m_I = massData.I - this.m_mass\n                    * Vec2.dot(massData.center, massData.center);\n                this.m_invI = 1.0 / this.m_I;\n            }\n            // Move center of mass.\n            var oldCenter = Vec2.clone(this.m_sweep.c);\n            this.m_sweep.setLocalCenter(massData.center, this.m_xf);\n            // Update center of mass velocity.\n            this.m_linearVelocity.add(Vec2.crossNumVec2(this.m_angularVelocity, Vec2.sub(this.m_sweep.c, oldCenter)));\n        };\n        /**\n         * Apply a force at a world point. If the force is not applied at the center of\n         * mass, it will generate a torque and affect the angular velocity. This wakes\n         * up the body.\n         *\n         * @param force The world force vector, usually in Newtons (N).\n         * @param point The world position of the point of application.\n         * @param wake Also wake up the body\n         */\n        Body.prototype.applyForce = function (force, point, wake) {\n            if (wake === void 0) { wake = true; }\n            if (this.m_type != DYNAMIC) {\n                return;\n            }\n            if (wake && this.m_awakeFlag == false) {\n                this.setAwake(true);\n            }\n            // Don't accumulate a force if the body is sleeping.\n            if (this.m_awakeFlag) {\n                this.m_force.add(force);\n                this.m_torque += Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), force);\n            }\n        };\n        /**\n         * Apply a force to the center of mass. This wakes up the body.\n         *\n         * @param force The world force vector, usually in Newtons (N).\n         * @param wake Also wake up the body\n         */\n        Body.prototype.applyForceToCenter = function (force, wake) {\n            if (wake === void 0) { wake = true; }\n            if (this.m_type != DYNAMIC) {\n                return;\n            }\n            if (wake && this.m_awakeFlag == false) {\n                this.setAwake(true);\n            }\n            // Don't accumulate a force if the body is sleeping\n            if (this.m_awakeFlag) {\n                this.m_force.add(force);\n            }\n        };\n        /**\n         * Apply a torque. This affects the angular velocity without affecting the\n         * linear velocity of the center of mass. This wakes up the body.\n         *\n         * @param torque About the z-axis (out of the screen), usually in N-m.\n         * @param wake Also wake up the body\n         */\n        Body.prototype.applyTorque = function (torque, wake) {\n            if (wake === void 0) { wake = true; }\n            if (this.m_type != DYNAMIC) {\n                return;\n            }\n            if (wake && this.m_awakeFlag == false) {\n                this.setAwake(true);\n            }\n            // Don't accumulate a force if the body is sleeping\n            if (this.m_awakeFlag) {\n                this.m_torque += torque;\n            }\n        };\n        /**\n         * Apply an impulse at a point. This immediately modifies the velocity. It also\n         * modifies the angular velocity if the point of application is not at the\n         * center of mass. This wakes up the body.\n         *\n         * @param impulse The world impulse vector, usually in N-seconds or kg-m/s.\n         * @param point The world position of the point of application.\n         * @param wake Also wake up the body\n         */\n        Body.prototype.applyLinearImpulse = function (impulse, point, wake) {\n            if (wake === void 0) { wake = true; }\n            if (this.m_type != DYNAMIC) {\n                return;\n            }\n            if (wake && this.m_awakeFlag == false) {\n                this.setAwake(true);\n            }\n            // Don't accumulate velocity if the body is sleeping\n            if (this.m_awakeFlag) {\n                this.m_linearVelocity.addMul(this.m_invMass, impulse);\n                this.m_angularVelocity += this.m_invI * Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), impulse);\n            }\n        };\n        /**\n         * Apply an angular impulse.\n         *\n         * @param impulse The angular impulse in units of kg*m*m/s\n         * @param wake Also wake up the body\n         */\n        Body.prototype.applyAngularImpulse = function (impulse, wake) {\n            if (wake === void 0) { wake = true; }\n            if (this.m_type != DYNAMIC) {\n                return;\n            }\n            if (wake && this.m_awakeFlag == false) {\n                this.setAwake(true);\n            }\n            // Don't accumulate velocity if the body is sleeping\n            if (this.m_awakeFlag) {\n                this.m_angularVelocity += this.m_invI * impulse;\n            }\n        };\n        /**\n         * This is used to prevent connected bodies (by joints) from colliding,\n         * depending on the joint's collideConnected flag.\n         */\n        Body.prototype.shouldCollide = function (that) {\n            // At least one body should be dynamic.\n            if (this.m_type != DYNAMIC && that.m_type != DYNAMIC) {\n                return false;\n            }\n            // Does a joint prevent collision?\n            for (var jn = this.m_jointList; jn; jn = jn.next) {\n                if (jn.other == that) {\n                    if (jn.joint.m_collideConnected == false) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        /**\n         * @internal Used for deserialize.\n         */\n        Body.prototype._addFixture = function (fixture) {\n            if (this.isWorldLocked() == true) {\n                return null;\n            }\n            if (this.m_activeFlag) {\n                var broadPhase = this.m_world.m_broadPhase;\n                fixture.createProxies(broadPhase, this.m_xf);\n            }\n            fixture.m_next = this.m_fixtureList;\n            this.m_fixtureList = fixture;\n            // Adjust mass properties if needed.\n            if (fixture.m_density > 0.0) {\n                this.resetMassData();\n            }\n            // Let the world know we have a new fixture. This will cause new contacts\n            // to be created at the beginning of the next time step.\n            this.m_world.m_newFixture = true;\n            return fixture;\n        };\n        // tslint:disable-next-line:typedef\n        Body.prototype.createFixture = function (shape, fixdef) {\n            if (this.isWorldLocked() == true) {\n                return null;\n            }\n            var fixture = new Fixture(this, shape, fixdef);\n            this._addFixture(fixture);\n            return fixture;\n        };\n        /**\n         * Destroy a fixture. This removes the fixture from the broad-phase and destroys\n         * all contacts associated with this fixture. This will automatically adjust the\n         * mass of the body if the body is dynamic and the fixture has positive density.\n         * All fixtures attached to a body are implicitly destroyed when the body is\n         * destroyed.\n         *\n         * Warning: This function is locked during callbacks.\n         *\n         * @param fixture The fixture to be removed.\n         */\n        Body.prototype.destroyFixture = function (fixture) {\n            if (this.isWorldLocked() == true) {\n                return;\n            }\n            if (this.m_fixtureList === fixture) {\n                this.m_fixtureList = fixture.m_next;\n            }\n            else {\n                var node = this.m_fixtureList;\n                while (node != null) {\n                    if (node.m_next === fixture) {\n                        node.m_next = fixture.m_next;\n                        break;\n                    }\n                    node = node.m_next;\n                }\n            }\n            // Destroy any contacts associated with the fixture.\n            var edge = this.m_contactList;\n            while (edge) {\n                var c = edge.contact;\n                edge = edge.next;\n                var fixtureA = c.getFixtureA();\n                var fixtureB = c.getFixtureB();\n                if (fixture == fixtureA || fixture == fixtureB) {\n                    // This destroys the contact and removes it from\n                    // this body's contact list.\n                    this.m_world.destroyContact(c);\n                }\n            }\n            if (this.m_activeFlag) {\n                var broadPhase = this.m_world.m_broadPhase;\n                fixture.destroyProxies(broadPhase);\n            }\n            fixture.m_body = null;\n            fixture.m_next = null;\n            this.m_world.publish('remove-fixture', fixture);\n            // Reset the mass data.\n            this.resetMassData();\n        };\n        /**\n         * Get the corresponding world point of a local point.\n         */\n        Body.prototype.getWorldPoint = function (localPoint) {\n            return Transform.mulVec2(this.m_xf, localPoint);\n        };\n        /**\n         * Get the corresponding world vector of a local vector.\n         */\n        Body.prototype.getWorldVector = function (localVector) {\n            return Rot.mulVec2(this.m_xf.q, localVector);\n        };\n        /**\n         * Gets the corresponding local point of a world point.\n         */\n        Body.prototype.getLocalPoint = function (worldPoint) {\n            return Transform.mulTVec2(this.m_xf, worldPoint);\n        };\n        /**\n         * Gets the corresponding local vector of a world vector.\n         */\n        Body.prototype.getLocalVector = function (worldVector) {\n            return Rot.mulTVec2(this.m_xf.q, worldVector);\n        };\n        /**\n         * A static body does not move under simulation and behaves as if it has infinite mass.\n         * Internally, zero is stored for the mass and the inverse mass.\n         * Static bodies can be moved manually by the user.\n         * A static body has zero velocity.\n         * Static bodies do not collide with other static or kinematic bodies.\n         */\n        Body.STATIC = 'static';\n        /**\n         * A kinematic body moves under simulation according to its velocity.\n         * Kinematic bodies do not respond to forces.\n         * They can be moved manually by the user, but normally a kinematic body is moved by setting its velocity.\n         * A kinematic body behaves as if it has infinite mass, however, zero is stored for the mass and the inverse mass.\n         * Kinematic bodies do not collide with other kinematic or static bodies.\n         */\n        Body.KINEMATIC = 'kinematic';\n        /**\n         * A dynamic body is fully simulated.\n         * They can be moved manually by the user, but normally they move according to forces.\n         * A dynamic body can collide with all body types.\n         * A dynamic body always has finite, non-zero mass.\n         * If you try to set the mass of a dynamic body to zero, it will automatically acquire a mass of one kilogram and it won't rotate.\n         */\n        Body.DYNAMIC = 'dynamic';\n        return Body;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A 2-by-2 matrix. Stored in column-major order.\n     */\n    var Mat22 = /** @class */ (function () {\n        // tslint:disable-next-line:typedef\n        function Mat22(a, b, c, d) {\n            if (typeof a === 'object' && a !== null) {\n                this.ex = Vec2.clone(a);\n                this.ey = Vec2.clone(b);\n            }\n            else if (typeof a === 'number') {\n                this.ex = Vec2.neo(a, c);\n                this.ey = Vec2.neo(b, d);\n            }\n            else {\n                this.ex = Vec2.zero();\n                this.ey = Vec2.zero();\n            }\n        }\n        /** @internal */\n        Mat22.prototype.toString = function () {\n            return JSON.stringify(this);\n        };\n        Mat22.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return Vec2.isValid(obj.ex) && Vec2.isValid(obj.ey);\n        };\n        Mat22.assert = function (o) {\n            return;\n        };\n        // tslint:disable-next-line:typedef\n        Mat22.prototype.set = function (a, b, c, d) {\n            if (typeof a === 'number' && typeof b === 'number' && typeof c === 'number'\n                && typeof d === 'number') {\n                this.ex.setNum(a, c);\n                this.ey.setNum(b, d);\n            }\n            else if (typeof a === 'object' && typeof b === 'object') {\n                this.ex.setVec2(a);\n                this.ey.setVec2(b);\n            }\n            else if (typeof a === 'object') {\n                this.ex.setVec2(a.ex);\n                this.ey.setVec2(a.ey);\n            }\n            else ;\n        };\n        Mat22.prototype.setIdentity = function () {\n            this.ex.x = 1.0;\n            this.ey.x = 0.0;\n            this.ex.y = 0.0;\n            this.ey.y = 1.0;\n        };\n        Mat22.prototype.setZero = function () {\n            this.ex.x = 0.0;\n            this.ey.x = 0.0;\n            this.ex.y = 0.0;\n            this.ey.y = 0.0;\n        };\n        Mat22.prototype.getInverse = function () {\n            var a = this.ex.x;\n            var b = this.ey.x;\n            var c = this.ex.y;\n            var d = this.ey.y;\n            var det = a * d - b * c;\n            if (det !== 0.0) {\n                det = 1.0 / det;\n            }\n            var imx = new Mat22();\n            imx.ex.x = det * d;\n            imx.ey.x = -det * b;\n            imx.ex.y = -det * c;\n            imx.ey.y = det * a;\n            return imx;\n        };\n        /**\n         * Solve A * x = b, where b is a column vector. This is more efficient than\n         * computing the inverse in one-shot cases.\n         */\n        Mat22.prototype.solve = function (v) {\n            var a = this.ex.x;\n            var b = this.ey.x;\n            var c = this.ex.y;\n            var d = this.ey.y;\n            var det = a * d - b * c;\n            if (det !== 0.0) {\n                det = 1.0 / det;\n            }\n            var w = Vec2.zero();\n            w.x = det * (d * v.x - b * v.y);\n            w.y = det * (a * v.y - c * v.x);\n            return w;\n        };\n        // tslint:disable-next-line:typedef\n        Mat22.mul = function (mx, v) {\n            if (v && 'x' in v && 'y' in v) {\n                var x = mx.ex.x * v.x + mx.ey.x * v.y;\n                var y = mx.ex.y * v.x + mx.ey.y * v.y;\n                return Vec2.neo(x, y);\n            }\n            else if (v && 'ex' in v && 'ey' in v) { // Mat22\n                // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n                var a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n                var b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n                var c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n                var d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n                return new Mat22(a, b, c, d);\n            }\n        };\n        Mat22.mulVec2 = function (mx, v) {\n            var x = mx.ex.x * v.x + mx.ey.x * v.y;\n            var y = mx.ex.y * v.x + mx.ey.y * v.y;\n            return Vec2.neo(x, y);\n        };\n        Mat22.mulMat22 = function (mx, v) {\n            // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n            var a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n            var b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n            var c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n            var d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n            return new Mat22(a, b, c, d);\n        };\n        // tslint:disable-next-line:typedef\n        Mat22.mulT = function (mx, v) {\n            if (v && 'x' in v && 'y' in v) { // Vec2\n                return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n            }\n            else if (v && 'ex' in v && 'ey' in v) { // Mat22\n                var c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n                var c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n                return new Mat22(c1, c2);\n            }\n        };\n        Mat22.mulTVec2 = function (mx, v) {\n            return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n        };\n        Mat22.mulTMat22 = function (mx, v) {\n            var c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n            var c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n            return new Mat22(c1, c2);\n        };\n        Mat22.abs = function (mx) {\n            return new Mat22(Vec2.abs(mx.ex), Vec2.abs(mx.ey));\n        };\n        Mat22.add = function (mx1, mx2) {\n            return new Mat22(Vec2.add(mx1.ex, mx2.ex), Vec2.add(mx1.ey, mx2.ey));\n        };\n        return Mat22;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var ManifoldType;\n    (function (ManifoldType) {\n        ManifoldType[ManifoldType[\"e_circles\"] = 0] = \"e_circles\";\n        ManifoldType[ManifoldType[\"e_faceA\"] = 1] = \"e_faceA\";\n        ManifoldType[ManifoldType[\"e_faceB\"] = 2] = \"e_faceB\";\n    })(ManifoldType || (ManifoldType = {}));\n    var ContactFeatureType;\n    (function (ContactFeatureType) {\n        ContactFeatureType[ContactFeatureType[\"e_vertex\"] = 0] = \"e_vertex\";\n        ContactFeatureType[ContactFeatureType[\"e_face\"] = 1] = \"e_face\";\n    })(ContactFeatureType || (ContactFeatureType = {}));\n    /**\n     * This is used for determining the state of contact points.\n     */\n    var PointState;\n    (function (PointState) {\n        /** Point does not exist */\n        PointState[PointState[\"nullState\"] = 0] = \"nullState\";\n        /** Point was added in the update */\n        PointState[PointState[\"addState\"] = 1] = \"addState\";\n        /** Point persisted across the update */\n        PointState[PointState[\"persistState\"] = 2] = \"persistState\";\n        /** Point was removed in the update */\n        PointState[PointState[\"removeState\"] = 3] = \"removeState\";\n    })(PointState || (PointState = {}));\n    /**\n     * Used for computing contact manifolds.\n     */\n    var ClipVertex = /** @class */ (function () {\n        function ClipVertex() {\n            this.v = Vec2.zero();\n            this.id = new ContactID();\n        }\n        ClipVertex.prototype.set = function (o) {\n            this.v.setVec2(o.v);\n            this.id.set(o.id);\n        };\n        return ClipVertex;\n    }());\n    /**\n     * A manifold for two touching convex shapes. Manifolds are created in `evaluate`\n     * method of Contact subclasses.\n     *\n     * Supported manifold types are e_faceA or e_faceB for clip point versus plane\n     * with radius and e_circles point versus point with radius.\n     *\n     * We store contacts in this way so that position correction can account for\n     * movement, which is critical for continuous physics. All contact scenarios\n     * must be expressed in one of these types. This structure is stored across time\n     * steps, so we keep it small.\n     *\n     * @prop type e_circle, e_faceA, e_faceB\n     * @prop localPoint Usage depends on manifold type:<br>\n     *       e_circles: the local center of circleA <br>\n     *       e_faceA: the center of faceA <br>\n     *       e_faceB: the center of faceB\n     * @prop localNormal Usage depends on manifold type:<br>\n     *       e_circles: not used <br>\n     *       e_faceA: the normal on polygonA <br>\n     *       e_faceB: the normal on polygonB\n     * @prop points The points of contact {ManifoldPoint[]}\n     * @prop pointCount The number of manifold points\n     */\n    var Manifold = /** @class */ (function () {\n        function Manifold() {\n            this.localNormal = Vec2.zero();\n            this.localPoint = Vec2.zero();\n            this.points = [new ManifoldPoint(), new ManifoldPoint()];\n            this.pointCount = 0;\n        }\n        /**\n         * Evaluate the manifold with supplied transforms. This assumes modest motion\n         * from the original state. This does not change the point count, impulses, etc.\n         * The radii must come from the shapes that generated the manifold.\n         */\n        Manifold.prototype.getWorldManifold = function (wm, xfA, radiusA, xfB, radiusB) {\n            if (this.pointCount == 0) {\n                return;\n            }\n            wm = wm || new WorldManifold();\n            var normal = wm.normal;\n            var points = wm.points;\n            var separations = wm.separations;\n            // TODO: improve\n            switch (this.type) {\n                case ManifoldType.e_circles: {\n                    normal = Vec2.neo(1.0, 0.0);\n                    var pointA = Transform.mulVec2(xfA, this.localPoint);\n                    var pointB = Transform.mulVec2(xfB, this.points[0].localPoint);\n                    var dist = Vec2.sub(pointB, pointA);\n                    if (Vec2.lengthSquared(dist) > math$1.EPSILON * math$1.EPSILON) {\n                        normal.setVec2(dist);\n                        normal.normalize();\n                    }\n                    var cA = pointA.clone().addMul(radiusA, normal);\n                    var cB = pointB.clone().addMul(-radiusB, normal);\n                    points[0] = Vec2.mid(cA, cB);\n                    separations[0] = Vec2.dot(Vec2.sub(cB, cA), normal);\n                    points.length = 1;\n                    separations.length = 1;\n                    break;\n                }\n                case ManifoldType.e_faceA: {\n                    normal = Rot.mulVec2(xfA.q, this.localNormal);\n                    var planePoint = Transform.mulVec2(xfA, this.localPoint);\n                    for (var i = 0; i < this.pointCount; ++i) {\n                        var clipPoint = Transform.mulVec2(xfB, this.points[i].localPoint);\n                        var cA = Vec2.clone(clipPoint).addMul(radiusA - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);\n                        var cB = Vec2.clone(clipPoint).subMul(radiusB, normal);\n                        points[i] = Vec2.mid(cA, cB);\n                        separations[i] = Vec2.dot(Vec2.sub(cB, cA), normal);\n                    }\n                    points.length = this.pointCount;\n                    separations.length = this.pointCount;\n                    break;\n                }\n                case ManifoldType.e_faceB: {\n                    normal = Rot.mulVec2(xfB.q, this.localNormal);\n                    var planePoint = Transform.mulVec2(xfB, this.localPoint);\n                    for (var i = 0; i < this.pointCount; ++i) {\n                        var clipPoint = Transform.mulVec2(xfA, this.points[i].localPoint);\n                        var cB = Vec2.combine(1, clipPoint, radiusB - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);\n                        var cA = Vec2.combine(1, clipPoint, -radiusA, normal);\n                        points[i] = Vec2.mid(cA, cB);\n                        separations[i] = Vec2.dot(Vec2.sub(cA, cB), normal);\n                    }\n                    points.length = this.pointCount;\n                    separations.length = this.pointCount;\n                    // Ensure normal points from A to B.\n                    normal.mul(-1);\n                    break;\n                }\n            }\n            wm.normal = normal;\n            wm.points = points;\n            wm.separations = separations;\n            return wm;\n        };\n        Manifold.clipSegmentToLine = clipSegmentToLine;\n        Manifold.ClipVertex = ClipVertex;\n        Manifold.getPointStates = getPointStates;\n        Manifold.PointState = PointState;\n        return Manifold;\n    }());\n    /**\n     * A manifold point is a contact point belonging to a contact manifold. It holds\n     * details related to the geometry and dynamics of the contact points.\n     *\n     * This structure is stored across time steps, so we keep it small.\n     *\n     * Note: impulses are used for internal caching and may not provide reliable\n     * contact forces, especially for high speed collisions.\n     */\n    var ManifoldPoint = /** @class */ (function () {\n        function ManifoldPoint() {\n            /**\n             * Usage depends on manifold type.\n             *       e_circles: the local center of circleB,\n             *       e_faceA: the local center of cirlceB or the clip point of polygonB,\n             *       e_faceB: the clip point of polygonA.\n             */\n            this.localPoint = Vec2.zero();\n            /**\n             * The non-penetration impulse\n             */\n            this.normalImpulse = 0;\n            /**\n             * The friction impulse\n             */\n            this.tangentImpulse = 0;\n            /**\n             * Uniquely identifies a contact point between two shapes to facilatate warm starting\n             */\n            this.id = new ContactID();\n        }\n        return ManifoldPoint;\n    }());\n    /**\n     * Contact ids to facilitate warm starting.\n     */\n    var ContactID = /** @class */ (function () {\n        function ContactID() {\n            this.cf = new ContactFeature();\n        }\n        Object.defineProperty(ContactID.prototype, \"key\", {\n            /**\n             * Used to quickly compare contact ids.\n             */\n            get: function () {\n                return this.cf.indexA + this.cf.indexB * 4 + this.cf.typeA * 16 + this.cf.typeB * 64;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        ContactID.prototype.set = function (o) {\n            // this.key = o.key;\n            this.cf.set(o.cf);\n        };\n        return ContactID;\n    }());\n    /**\n     * The features that intersect to form the contact point.\n     */\n    var ContactFeature = /** @class */ (function () {\n        function ContactFeature() {\n        }\n        ContactFeature.prototype.set = function (o) {\n            this.indexA = o.indexA;\n            this.indexB = o.indexB;\n            this.typeA = o.typeA;\n            this.typeB = o.typeB;\n        };\n        return ContactFeature;\n    }());\n    /**\n     * This is used to compute the current state of a contact manifold.\n     */\n    var WorldManifold = /** @class */ (function () {\n        function WorldManifold() {\n            /**\n             * World contact point (point of intersection)\n             */\n            this.points = []; // [maxManifoldPoints]\n            /**\n             * A negative value indicates overlap, in meters\n             */\n            this.separations = []; // [maxManifoldPoints]\n        }\n        return WorldManifold;\n    }());\n    /**\n     * Compute the point states given two manifolds. The states pertain to the\n     * transition from manifold1 to manifold2. So state1 is either persist or remove\n     * while state2 is either add or persist.\n     */\n    function getPointStates(state1, state2, manifold1, manifold2) {\n        // state1, state2: PointState[Settings.maxManifoldPoints]\n        // for (var i = 0; i < Settings.maxManifoldPoints; ++i) {\n        // state1[i] = PointState.nullState;\n        // state2[i] = PointState.nullState;\n        // }\n        // Detect persists and removes.\n        for (var i = 0; i < manifold1.pointCount; ++i) {\n            var id = manifold1.points[i].id;\n            state1[i] = PointState.removeState;\n            for (var j = 0; j < manifold2.pointCount; ++j) {\n                if (manifold2.points[j].id.key == id.key) {\n                    state1[i] = PointState.persistState;\n                    break;\n                }\n            }\n        }\n        // Detect persists and adds.\n        for (var i = 0; i < manifold2.pointCount; ++i) {\n            var id = manifold2.points[i].id;\n            state2[i] = PointState.addState;\n            for (var j = 0; j < manifold1.pointCount; ++j) {\n                if (manifold1.points[j].id.key == id.key) {\n                    state2[i] = PointState.persistState;\n                    break;\n                }\n            }\n        }\n    }\n    /**\n     * Clipping for contact manifolds. Sutherland-Hodgman clipping.\n     */\n    function clipSegmentToLine(vOut, vIn, normal, offset, vertexIndexA) {\n        // Start with no output points\n        var numOut = 0;\n        // Calculate the distance of end points to the line\n        var distance0 = Vec2.dot(normal, vIn[0].v) - offset;\n        var distance1 = Vec2.dot(normal, vIn[1].v) - offset;\n        // If the points are behind the plane\n        if (distance0 <= 0.0)\n            vOut[numOut++].set(vIn[0]);\n        if (distance1 <= 0.0)\n            vOut[numOut++].set(vIn[1]);\n        // If the points are on different sides of the plane\n        if (distance0 * distance1 < 0.0) {\n            // Find intersection point of edge and plane\n            var interp = distance0 / (distance0 - distance1);\n            vOut[numOut].v.setCombine(1 - interp, vIn[0].v, interp, vIn[1].v);\n            // VertexA is hitting edgeB.\n            vOut[numOut].id.cf.indexA = vertexIndexA;\n            vOut[numOut].id.cf.indexB = vIn[0].id.cf.indexB;\n            vOut[numOut].id.cf.typeA = ContactFeatureType.e_vertex;\n            vOut[numOut].id.cf.typeB = ContactFeatureType.e_face;\n            ++numOut;\n        }\n        return numOut;\n    }\n\n    var stats$1 = {\n        gjkCalls: 0,\n        gjkIters: 0,\n        gjkMaxIters: 0,\n        toiTime: 0,\n        toiMaxTime: 0,\n        toiCalls: 0,\n        toiIters: 0,\n        toiMaxIters: 0,\n        toiRootIters: 0,\n        toiMaxRootIters: 0,\n        toString: function (newline) {\n            newline = typeof newline === 'string' ? newline : '\\n';\n            var string = \"\";\n            // tslint:disable-next-line:no-for-in\n            for (var name_1 in this) {\n                if (typeof this[name_1] !== 'function' && typeof this[name_1] !== 'object') {\n                    string += name_1 + ': ' + this[name_1] + newline;\n                }\n            }\n            return string;\n        }\n    };\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.\n     */\n    stats$1.gjkCalls = 0;\n    stats$1.gjkIters = 0;\n    stats$1.gjkMaxIters = 0;\n    /**\n     * Input for Distance. You have to option to use the shape radii in the\n     * computation. Even\n     */\n    var DistanceInput = /** @class */ (function () {\n        function DistanceInput() {\n            this.proxyA = new DistanceProxy();\n            this.proxyB = new DistanceProxy();\n            this.transformA = null;\n            this.transformB = null;\n            this.useRadii = false;\n        }\n        return DistanceInput;\n    }());\n    /**\n     * Output for Distance.\n     *\n     * @prop {Vec2} pointA closest point on shapeA\n     * @prop {Vec2} pointB closest point on shapeB\n     * @prop distance\n     * @prop iterations number of GJK iterations used\n     */\n    var DistanceOutput = /** @class */ (function () {\n        function DistanceOutput() {\n            this.pointA = Vec2.zero();\n            this.pointB = Vec2.zero();\n        }\n        return DistanceOutput;\n    }());\n    /**\n     * Used to warm start Distance. Set count to zero on first call.\n     *\n     * @prop {number} metric length or area\n     * @prop {array} indexA vertices on shape A\n     * @prop {array} indexB vertices on shape B\n     * @prop {number} count\n     */\n    var SimplexCache = /** @class */ (function () {\n        function SimplexCache() {\n            this.metric = 0;\n            this.indexA = [];\n            this.indexB = [];\n            this.count = 0;\n        }\n        return SimplexCache;\n    }());\n    /**\n     * Compute the closest points between two shapes. Supports any combination of:\n     * CircleShape, PolygonShape, EdgeShape. The simplex cache is input/output. On\n     * the first call set SimplexCache.count to zero.\n     */\n    function Distance(output, cache, input) {\n        ++stats$1.gjkCalls;\n        var proxyA = input.proxyA;\n        var proxyB = input.proxyB;\n        var xfA = input.transformA;\n        var xfB = input.transformB;\n        // Initialize the simplex.\n        var simplex = new Simplex();\n        simplex.readCache(cache, proxyA, xfA, proxyB, xfB);\n        // Get simplex vertices as an array.\n        var vertices = simplex.m_v;\n        var k_maxIters = Settings.maxDistnceIterations;\n        // These store the vertices of the last simplex so that we\n        // can check for duplicates and prevent cycling.\n        var saveA = [];\n        var saveB = []; // int[3]\n        var saveCount = 0;\n        // Main iteration loop.\n        var iter = 0;\n        while (iter < k_maxIters) {\n            // Copy simplex so we can identify duplicates.\n            saveCount = simplex.m_count;\n            for (var i = 0; i < saveCount; ++i) {\n                saveA[i] = vertices[i].indexA;\n                saveB[i] = vertices[i].indexB;\n            }\n            simplex.solve();\n            // If we have 3 points, then the origin is in the corresponding triangle.\n            if (simplex.m_count === 3) {\n                break;\n            }\n            // Compute closest point.\n            var p = simplex.getClosestPoint();\n            p.lengthSquared();\n            // Get search direction.\n            var d = simplex.getSearchDirection();\n            // Ensure the search direction is numerically fit.\n            if (d.lengthSquared() < math$1.EPSILON * math$1.EPSILON) {\n                // The origin is probably contained by a line segment\n                // or triangle. Thus the shapes are overlapped.\n                // We can't return zero here even though there may be overlap.\n                // In case the simplex is a point, segment, or triangle it is difficult\n                // to determine if the origin is contained in the CSO or very close to it.\n                break;\n            }\n            // Compute a tentative new simplex vertex using support points.\n            var vertex = vertices[simplex.m_count]; // SimplexVertex\n            vertex.indexA = proxyA.getSupport(Rot.mulTVec2(xfA.q, Vec2.neg(d)));\n            vertex.wA = Transform.mulVec2(xfA, proxyA.getVertex(vertex.indexA));\n            vertex.indexB = proxyB.getSupport(Rot.mulTVec2(xfB.q, d));\n            vertex.wB = Transform.mulVec2(xfB, proxyB.getVertex(vertex.indexB));\n            vertex.w = Vec2.sub(vertex.wB, vertex.wA);\n            // Iteration count is equated to the number of support point calls.\n            ++iter;\n            ++stats$1.gjkIters;\n            // Check for duplicate support points. This is the main termination\n            // criteria.\n            var duplicate = false;\n            for (var i = 0; i < saveCount; ++i) {\n                if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {\n                    duplicate = true;\n                    break;\n                }\n            }\n            // If we found a duplicate support point we must exit to avoid cycling.\n            if (duplicate) {\n                break;\n            }\n            // New vertex is ok and needed.\n            ++simplex.m_count;\n        }\n        stats$1.gjkMaxIters = math$1.max(stats$1.gjkMaxIters, iter);\n        // Prepare output.\n        simplex.getWitnessPoints(output.pointA, output.pointB);\n        output.distance = Vec2.distance(output.pointA, output.pointB);\n        output.iterations = iter;\n        // Cache the simplex.\n        simplex.writeCache(cache);\n        // Apply radii if requested.\n        if (input.useRadii) {\n            var rA = proxyA.m_radius;\n            var rB = proxyB.m_radius;\n            if (output.distance > rA + rB && output.distance > math$1.EPSILON) {\n                // Shapes are still no overlapped.\n                // Move the witness points to the outer surface.\n                output.distance -= rA + rB;\n                var normal = Vec2.sub(output.pointB, output.pointA);\n                normal.normalize();\n                output.pointA.addMul(rA, normal);\n                output.pointB.subMul(rB, normal);\n            }\n            else {\n                // Shapes are overlapped when radii are considered.\n                // Move the witness points to the middle.\n                var p = Vec2.mid(output.pointA, output.pointB);\n                output.pointA.setVec2(p);\n                output.pointB.setVec2(p);\n                output.distance = 0.0;\n            }\n        }\n    }\n    /**\n     * A distance proxy is used by the GJK algorithm. It encapsulates any shape.\n     */\n    var DistanceProxy = /** @class */ (function () {\n        function DistanceProxy() {\n            this.m_buffer = []; // Vec2[2]\n            this.m_vertices = []; // Vec2[]\n            this.m_count = 0;\n            this.m_radius = 0;\n        }\n        /**\n         * Get the vertex count.\n         */\n        DistanceProxy.prototype.getVertexCount = function () {\n            return this.m_count;\n        };\n        /**\n         * Get a vertex by index. Used by Distance.\n         */\n        DistanceProxy.prototype.getVertex = function (index) {\n            return this.m_vertices[index];\n        };\n        /**\n         * Get the supporting vertex index in the given direction.\n         */\n        DistanceProxy.prototype.getSupport = function (d) {\n            var bestIndex = 0;\n            var bestValue = Vec2.dot(this.m_vertices[0], d);\n            for (var i = 0; i < this.m_count; ++i) {\n                var value = Vec2.dot(this.m_vertices[i], d);\n                if (value > bestValue) {\n                    bestIndex = i;\n                    bestValue = value;\n                }\n            }\n            return bestIndex;\n        };\n        /**\n         * Get the supporting vertex in the given direction.\n         */\n        DistanceProxy.prototype.getSupportVertex = function (d) {\n            return this.m_vertices[this.getSupport(d)];\n        };\n        /**\n         * Initialize the proxy using the given shape. The shape must remain in scope\n         * while the proxy is in use.\n         */\n        DistanceProxy.prototype.set = function (shape, index) {\n            shape.computeDistanceProxy(this, index);\n        };\n        return DistanceProxy;\n    }());\n    var SimplexVertex = /** @class */ (function () {\n        function SimplexVertex() {\n            /** support point in proxyA */\n            this.wA = Vec2.zero();\n            /** support point in proxyB */\n            this.wB = Vec2.zero();\n            /** wB - wA; */\n            this.w = Vec2.zero();\n        }\n        SimplexVertex.prototype.set = function (v) {\n            this.indexA = v.indexA;\n            this.indexB = v.indexB;\n            this.wA = Vec2.clone(v.wA);\n            this.wB = Vec2.clone(v.wB);\n            this.w = Vec2.clone(v.w);\n            this.a = v.a;\n        };\n        return SimplexVertex;\n    }());\n    var Simplex = /** @class */ (function () {\n        function Simplex() {\n            this.m_v1 = new SimplexVertex();\n            this.m_v2 = new SimplexVertex();\n            this.m_v3 = new SimplexVertex();\n            this.m_v = [this.m_v1, this.m_v2, this.m_v3];\n            this.m_count;\n        }\n        /** @internal */\n        Simplex.prototype.toString = function () {\n            if (this.m_count === 3) {\n                return [\"+\" + this.m_count,\n                    this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,\n                    this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y,\n                    this.m_v3.a, this.m_v3.wA.x, this.m_v3.wA.y, this.m_v3.wB.x, this.m_v3.wB.y\n                ].toString();\n            }\n            else if (this.m_count === 2) {\n                return [\"+\" + this.m_count,\n                    this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,\n                    this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y\n                ].toString();\n            }\n            else if (this.m_count === 1) {\n                return [\"+\" + this.m_count,\n                    this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y\n                ].toString();\n            }\n            else {\n                return \"+\" + this.m_count;\n            }\n        };\n        Simplex.prototype.readCache = function (cache, proxyA, transformA, proxyB, transformB) {\n            // Copy data from cache.\n            this.m_count = cache.count;\n            for (var i = 0; i < this.m_count; ++i) {\n                var v = this.m_v[i];\n                v.indexA = cache.indexA[i];\n                v.indexB = cache.indexB[i];\n                var wALocal = proxyA.getVertex(v.indexA);\n                var wBLocal = proxyB.getVertex(v.indexB);\n                v.wA = Transform.mulVec2(transformA, wALocal);\n                v.wB = Transform.mulVec2(transformB, wBLocal);\n                v.w = Vec2.sub(v.wB, v.wA);\n                v.a = 0.0;\n            }\n            // Compute the new simplex metric, if it is substantially different than\n            // old metric then flush the simplex.\n            if (this.m_count > 1) {\n                var metric1 = cache.metric;\n                var metric2 = this.getMetric();\n                if (metric2 < 0.5 * metric1 || 2.0 * metric1 < metric2\n                    || metric2 < math$1.EPSILON) {\n                    // Reset the simplex.\n                    this.m_count = 0;\n                }\n            }\n            // If the cache is empty or invalid...\n            if (this.m_count === 0) {\n                var v = this.m_v[0];\n                v.indexA = 0;\n                v.indexB = 0;\n                var wALocal = proxyA.getVertex(0);\n                var wBLocal = proxyB.getVertex(0);\n                v.wA = Transform.mulVec2(transformA, wALocal);\n                v.wB = Transform.mulVec2(transformB, wBLocal);\n                v.w = Vec2.sub(v.wB, v.wA);\n                v.a = 1.0;\n                this.m_count = 1;\n            }\n        };\n        Simplex.prototype.writeCache = function (cache) {\n            cache.metric = this.getMetric();\n            cache.count = this.m_count;\n            for (var i = 0; i < this.m_count; ++i) {\n                cache.indexA[i] = this.m_v[i].indexA;\n                cache.indexB[i] = this.m_v[i].indexB;\n            }\n        };\n        Simplex.prototype.getSearchDirection = function () {\n            switch (this.m_count) {\n                case 1:\n                    return Vec2.neg(this.m_v1.w);\n                case 2: {\n                    var e12 = Vec2.sub(this.m_v2.w, this.m_v1.w);\n                    var sgn = Vec2.crossVec2Vec2(e12, Vec2.neg(this.m_v1.w));\n                    if (sgn > 0.0) {\n                        // Origin is left of e12.\n                        return Vec2.crossNumVec2(1.0, e12);\n                    }\n                    else {\n                        // Origin is right of e12.\n                        return Vec2.crossVec2Num(e12, 1.0);\n                    }\n                }\n                default:\n                    return Vec2.zero();\n            }\n        };\n        Simplex.prototype.getClosestPoint = function () {\n            switch (this.m_count) {\n                case 0:\n                    return Vec2.zero();\n                case 1:\n                    return Vec2.clone(this.m_v1.w);\n                case 2:\n                    return Vec2.combine(this.m_v1.a, this.m_v1.w, this.m_v2.a, this.m_v2.w);\n                case 3:\n                    return Vec2.zero();\n                default:\n                    return Vec2.zero();\n            }\n        };\n        Simplex.prototype.getWitnessPoints = function (pA, pB) {\n            switch (this.m_count) {\n                case 0:\n                    break;\n                case 1:\n                    pA.setVec2(this.m_v1.wA);\n                    pB.setVec2(this.m_v1.wB);\n                    break;\n                case 2:\n                    pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);\n                    pB.setCombine(this.m_v1.a, this.m_v1.wB, this.m_v2.a, this.m_v2.wB);\n                    break;\n                case 3:\n                    pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);\n                    pA.addMul(this.m_v3.a, this.m_v3.wA);\n                    pB.setVec2(pA);\n                    break;\n            }\n        };\n        Simplex.prototype.getMetric = function () {\n            switch (this.m_count) {\n                case 0:\n                    return 0.0;\n                case 1:\n                    return 0.0;\n                case 2:\n                    return Vec2.distance(this.m_v1.w, this.m_v2.w);\n                case 3:\n                    return Vec2.crossVec2Vec2(Vec2.sub(this.m_v2.w, this.m_v1.w), Vec2.sub(this.m_v3.w, this.m_v1.w));\n                default:\n                    return 0.0;\n            }\n        };\n        Simplex.prototype.solve = function () {\n            switch (this.m_count) {\n                case 1:\n                    break;\n                case 2:\n                    this.solve2();\n                    break;\n                case 3:\n                    this.solve3();\n                    break;\n            }\n        };\n        // Solve a line segment using barycentric coordinates.\n        //\n        // p = a1 * w1 + a2 * w2\n        // a1 + a2 = 1\n        //\n        // The vector from the origin to the closest point on the line is\n        // perpendicular to the line.\n        // e12 = w2 - w1\n        // dot(p, e) = 0\n        // a1 * dot(w1, e) + a2 * dot(w2, e) = 0\n        //\n        // 2-by-2 linear system\n        // [1 1 ][a1] = [1]\n        // [w1.e12 w2.e12][a2] = [0]\n        //\n        // Define\n        // d12_1 = dot(w2, e12)\n        // d12_2 = -dot(w1, e12)\n        // d12 = d12_1 + d12_2\n        //\n        // Solution\n        // a1 = d12_1 / d12\n        // a2 = d12_2 / d12\n        Simplex.prototype.solve2 = function () {\n            var w1 = this.m_v1.w;\n            var w2 = this.m_v2.w;\n            var e12 = Vec2.sub(w2, w1);\n            // w1 region\n            var d12_2 = -Vec2.dot(w1, e12);\n            if (d12_2 <= 0.0) {\n                // a2 <= 0, so we clamp it to 0\n                this.m_v1.a = 1.0;\n                this.m_count = 1;\n                return;\n            }\n            // w2 region\n            var d12_1 = Vec2.dot(w2, e12);\n            if (d12_1 <= 0.0) {\n                // a1 <= 0, so we clamp it to 0\n                this.m_v2.a = 1.0;\n                this.m_count = 1;\n                this.m_v1.set(this.m_v2);\n                return;\n            }\n            // Must be in e12 region.\n            var inv_d12 = 1.0 / (d12_1 + d12_2);\n            this.m_v1.a = d12_1 * inv_d12;\n            this.m_v2.a = d12_2 * inv_d12;\n            this.m_count = 2;\n        };\n        // Possible regions:\n        // - points[2]\n        // - edge points[0]-points[2]\n        // - edge points[1]-points[2]\n        // - inside the triangle\n        Simplex.prototype.solve3 = function () {\n            var w1 = this.m_v1.w;\n            var w2 = this.m_v2.w;\n            var w3 = this.m_v3.w;\n            // Edge12\n            // [1 1 ][a1] = [1]\n            // [w1.e12 w2.e12][a2] = [0]\n            // a3 = 0\n            var e12 = Vec2.sub(w2, w1);\n            var w1e12 = Vec2.dot(w1, e12);\n            var w2e12 = Vec2.dot(w2, e12);\n            var d12_1 = w2e12;\n            var d12_2 = -w1e12;\n            // Edge13\n            // [1 1 ][a1] = [1]\n            // [w1.e13 w3.e13][a3] = [0]\n            // a2 = 0\n            var e13 = Vec2.sub(w3, w1);\n            var w1e13 = Vec2.dot(w1, e13);\n            var w3e13 = Vec2.dot(w3, e13);\n            var d13_1 = w3e13;\n            var d13_2 = -w1e13;\n            // Edge23\n            // [1 1 ][a2] = [1]\n            // [w2.e23 w3.e23][a3] = [0]\n            // a1 = 0\n            var e23 = Vec2.sub(w3, w2);\n            var w2e23 = Vec2.dot(w2, e23);\n            var w3e23 = Vec2.dot(w3, e23);\n            var d23_1 = w3e23;\n            var d23_2 = -w2e23;\n            // Triangle123\n            var n123 = Vec2.crossVec2Vec2(e12, e13);\n            var d123_1 = n123 * Vec2.crossVec2Vec2(w2, w3);\n            var d123_2 = n123 * Vec2.crossVec2Vec2(w3, w1);\n            var d123_3 = n123 * Vec2.crossVec2Vec2(w1, w2);\n            // w1 region\n            if (d12_2 <= 0.0 && d13_2 <= 0.0) {\n                this.m_v1.a = 1.0;\n                this.m_count = 1;\n                return;\n            }\n            // e12\n            if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {\n                var inv_d12 = 1.0 / (d12_1 + d12_2);\n                this.m_v1.a = d12_1 * inv_d12;\n                this.m_v2.a = d12_2 * inv_d12;\n                this.m_count = 2;\n                return;\n            }\n            // e13\n            if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {\n                var inv_d13 = 1.0 / (d13_1 + d13_2);\n                this.m_v1.a = d13_1 * inv_d13;\n                this.m_v3.a = d13_2 * inv_d13;\n                this.m_count = 2;\n                this.m_v2.set(this.m_v3);\n                return;\n            }\n            // w2 region\n            if (d12_1 <= 0.0 && d23_2 <= 0.0) {\n                this.m_v2.a = 1.0;\n                this.m_count = 1;\n                this.m_v1.set(this.m_v2);\n                return;\n            }\n            // w3 region\n            if (d13_1 <= 0.0 && d23_1 <= 0.0) {\n                this.m_v3.a = 1.0;\n                this.m_count = 1;\n                this.m_v1.set(this.m_v3);\n                return;\n            }\n            // e23\n            if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {\n                var inv_d23 = 1.0 / (d23_1 + d23_2);\n                this.m_v2.a = d23_1 * inv_d23;\n                this.m_v3.a = d23_2 * inv_d23;\n                this.m_count = 2;\n                this.m_v1.set(this.m_v3);\n                return;\n            }\n            // Must be in triangle123\n            var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);\n            this.m_v1.a = d123_1 * inv_d123;\n            this.m_v2.a = d123_2 * inv_d123;\n            this.m_v3.a = d123_3 * inv_d123;\n            this.m_count = 3;\n        };\n        return Simplex;\n    }());\n    /**\n     * Determine if two generic shapes overlap.\n     */\n    function testOverlap(shapeA, indexA, shapeB, indexB, xfA, xfB) {\n        var input = new DistanceInput();\n        input.proxyA.set(shapeA, indexA);\n        input.proxyB.set(shapeB, indexB);\n        input.transformA = xfA;\n        input.transformB = xfB;\n        input.useRadii = true;\n        var cache = new SimplexCache();\n        var output = new DistanceOutput();\n        Distance(output, cache, input);\n        return output.distance < 10.0 * math$1.EPSILON;\n    }\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A contact edge is used to connect bodies and contacts together in a contact\n     * graph where each body is a node and each contact is an edge. A contact edge\n     * belongs to a doubly linked list maintained in each attached body. Each\n     * contact has two contact nodes, one for each attached body.\n     *\n     * @prop {Contact} contact The contact\n     * @prop {ContactEdge} prev The previous contact edge in the body's contact list\n     * @prop {ContactEdge} next The next contact edge in the body's contact list\n     * @prop {Body} other Provides quick access to the other body attached.\n     */\n    var ContactEdge = /** @class */ (function () {\n        function ContactEdge(contact) {\n            this.contact = contact;\n        }\n        return ContactEdge;\n    }());\n    /**\n     * Friction mixing law. The idea is to allow either fixture to drive the\n     * restitution to zero. For example, anything slides on ice.\n     */\n    function mixFriction(friction1, friction2) {\n        return math$1.sqrt(friction1 * friction2);\n    }\n    /**\n     * Restitution mixing law. The idea is allow for anything to bounce off an\n     * inelastic surface. For example, a superball bounces on anything.\n     */\n    function mixRestitution(restitution1, restitution2) {\n        return restitution1 > restitution2 ? restitution1 : restitution2;\n    }\n    // TODO: move this to Settings?\n    var s_registers = [];\n    // TODO: merge with ManifoldPoint?\n    var VelocityConstraintPoint = /** @class */ (function () {\n        function VelocityConstraintPoint() {\n            this.rA = Vec2.zero();\n            this.rB = Vec2.zero();\n            this.normalImpulse = 0;\n            this.tangentImpulse = 0;\n            this.normalMass = 0;\n            this.tangentMass = 0;\n            this.velocityBias = 0;\n        }\n        return VelocityConstraintPoint;\n    }());\n    /**\n     * The class manages contact between two shapes. A contact exists for each\n     * overlapping AABB in the broad-phase (except if filtered). Therefore a contact\n     * object may exist that has no contact points.\n     */\n    var Contact = /** @class */ (function () {\n        function Contact(fA, indexA, fB, indexB, evaluateFcn) {\n            /** @internal */\n            this.m_manifold = new Manifold();\n            /** @internal */\n            this.m_prev = null;\n            /** @internal */\n            this.m_next = null;\n            /** @internal */\n            this.m_toi = 1.0;\n            /** @internal */\n            this.m_toiCount = 0;\n            /** @internal This contact has a valid TOI in m_toi */\n            this.m_toiFlag = false;\n            /** @internal */\n            this.m_tangentSpeed = 0.0;\n            /** @internal This contact can be disabled (by user) */\n            this.m_enabledFlag = true;\n            /** @internal Used when crawling contact graph when forming islands. */\n            this.m_islandFlag = false;\n            /** @internal Set when the shapes are touching. */\n            this.m_touchingFlag = false;\n            /** @internal This contact needs filtering because a fixture filter was changed. */\n            this.m_filterFlag = false;\n            /** @internal This bullet contact had a TOI event */\n            this.m_bulletHitFlag = false;\n            /** @internal Contact reporting impulse object cache */\n            this.m_impulse = new ContactImpulse(this);\n            // VelocityConstraint\n            /** @internal */ this.v_points = []; // [maxManifoldPoints];\n            /** @internal */ this.v_normal = Vec2.zero();\n            /** @internal */ this.v_normalMass = new Mat22();\n            /** @internal */ this.v_K = new Mat22();\n            // PositionConstraint\n            /** @internal */ this.p_localPoints = []; // [maxManifoldPoints];\n            /** @internal */ this.p_localNormal = Vec2.zero();\n            /** @internal */ this.p_localPoint = Vec2.zero();\n            /** @internal */ this.p_localCenterA = Vec2.zero();\n            /** @internal */ this.p_localCenterB = Vec2.zero();\n            // Nodes for connecting bodies.\n            this.m_nodeA = new ContactEdge(this);\n            this.m_nodeB = new ContactEdge(this);\n            this.m_fixtureA = fA;\n            this.m_fixtureB = fB;\n            this.m_indexA = indexA;\n            this.m_indexB = indexB;\n            this.m_evaluateFcn = evaluateFcn;\n            this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\n            this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\n        }\n        Contact.prototype.initConstraint = function (step) {\n            var fixtureA = this.m_fixtureA;\n            var fixtureB = this.m_fixtureB;\n            var shapeA = fixtureA.getShape();\n            var shapeB = fixtureB.getShape();\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            var manifold = this.getManifold();\n            var pointCount = manifold.pointCount;\n            this.v_invMassA = bodyA.m_invMass;\n            this.v_invMassB = bodyB.m_invMass;\n            this.v_invIA = bodyA.m_invI;\n            this.v_invIB = bodyB.m_invI;\n            this.v_friction = this.m_friction;\n            this.v_restitution = this.m_restitution;\n            this.v_tangentSpeed = this.m_tangentSpeed;\n            this.v_pointCount = pointCount;\n            this.v_K.setZero();\n            this.v_normalMass.setZero();\n            this.p_invMassA = bodyA.m_invMass;\n            this.p_invMassB = bodyB.m_invMass;\n            this.p_invIA = bodyA.m_invI;\n            this.p_invIB = bodyB.m_invI;\n            this.p_localCenterA = Vec2.clone(bodyA.m_sweep.localCenter);\n            this.p_localCenterB = Vec2.clone(bodyB.m_sweep.localCenter);\n            this.p_radiusA = shapeA.m_radius;\n            this.p_radiusB = shapeB.m_radius;\n            this.p_type = manifold.type;\n            this.p_localNormal = Vec2.clone(manifold.localNormal);\n            this.p_localPoint = Vec2.clone(manifold.localPoint);\n            this.p_pointCount = pointCount;\n            for (var j = 0; j < pointCount; ++j) {\n                var cp = manifold.points[j];\n                var vcp = this.v_points[j] = new VelocityConstraintPoint();\n                if (step.warmStarting) {\n                    vcp.normalImpulse = step.dtRatio * cp.normalImpulse;\n                    vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;\n                }\n                else {\n                    vcp.normalImpulse = 0.0;\n                    vcp.tangentImpulse = 0.0;\n                }\n                vcp.rA.setZero();\n                vcp.rB.setZero();\n                vcp.normalMass = 0.0;\n                vcp.tangentMass = 0.0;\n                vcp.velocityBias = 0.0;\n                this.p_localPoints[j] = Vec2.clone(cp.localPoint);\n            }\n        };\n        /**\n         * Get the contact manifold. Do not modify the manifold unless you understand\n         * the internals of the library.\n         */\n        Contact.prototype.getManifold = function () {\n            return this.m_manifold;\n        };\n        /**\n         * Get the world manifold.\n         */\n        Contact.prototype.getWorldManifold = function (worldManifold) {\n            var bodyA = this.m_fixtureA.getBody();\n            var bodyB = this.m_fixtureB.getBody();\n            var shapeA = this.m_fixtureA.getShape();\n            var shapeB = this.m_fixtureB.getShape();\n            return this.m_manifold.getWorldManifold(worldManifold, bodyA.getTransform(), shapeA.m_radius, bodyB.getTransform(), shapeB.m_radius);\n        };\n        /**\n         * Enable/disable this contact. This can be used inside the pre-solve contact\n         * listener. The contact is only disabled for the current time step (or sub-step\n         * in continuous collisions).\n         */\n        Contact.prototype.setEnabled = function (flag) {\n            this.m_enabledFlag = !!flag;\n        };\n        /**\n         * Has this contact been disabled?\n         */\n        Contact.prototype.isEnabled = function () {\n            return this.m_enabledFlag;\n        };\n        /**\n         * Is this contact touching?\n         */\n        Contact.prototype.isTouching = function () {\n            return this.m_touchingFlag;\n        };\n        /**\n         * Get the next contact in the world's contact list.\n         */\n        Contact.prototype.getNext = function () {\n            return this.m_next;\n        };\n        /**\n         * Get fixture A in this contact.\n         */\n        Contact.prototype.getFixtureA = function () {\n            return this.m_fixtureA;\n        };\n        /**\n         * Get fixture B in this contact.\n         */\n        Contact.prototype.getFixtureB = function () {\n            return this.m_fixtureB;\n        };\n        /**\n         * Get the child primitive index for fixture A.\n         */\n        Contact.prototype.getChildIndexA = function () {\n            return this.m_indexA;\n        };\n        /**\n         * Get the child primitive index for fixture B.\n         */\n        Contact.prototype.getChildIndexB = function () {\n            return this.m_indexB;\n        };\n        /**\n         * Flag this contact for filtering. Filtering will occur the next time step.\n         */\n        Contact.prototype.flagForFiltering = function () {\n            this.m_filterFlag = true;\n        };\n        /**\n         * Override the default friction mixture. You can call this in\n         * ContactListener.preSolve. This value persists until set or reset.\n         */\n        Contact.prototype.setFriction = function (friction) {\n            this.m_friction = friction;\n        };\n        /**\n         * Get the friction.\n         */\n        Contact.prototype.getFriction = function () {\n            return this.m_friction;\n        };\n        /**\n         * Reset the friction mixture to the default value.\n         */\n        Contact.prototype.resetFriction = function () {\n            this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\n        };\n        /**\n         * Override the default restitution mixture. You can call this in\n         * ContactListener.preSolve. The value persists until you set or reset.\n         */\n        Contact.prototype.setRestitution = function (restitution) {\n            this.m_restitution = restitution;\n        };\n        /**\n         * Get the restitution.\n         */\n        Contact.prototype.getRestitution = function () {\n            return this.m_restitution;\n        };\n        /**\n         * Reset the restitution to the default value.\n         */\n        Contact.prototype.resetRestitution = function () {\n            this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\n        };\n        /**\n         * Set the desired tangent speed for a conveyor belt behavior. In meters per\n         * second.\n         */\n        Contact.prototype.setTangentSpeed = function (speed) {\n            this.m_tangentSpeed = speed;\n        };\n        /**\n         * Get the desired tangent speed. In meters per second.\n         */\n        Contact.prototype.getTangentSpeed = function () {\n            return this.m_tangentSpeed;\n        };\n        /**\n         * Called by Update method, and implemented by subclasses.\n         */\n        Contact.prototype.evaluate = function (manifold, xfA, xfB) {\n            this.m_evaluateFcn(manifold, xfA, this.m_fixtureA, this.m_indexA, xfB, this.m_fixtureB, this.m_indexB);\n        };\n        /**\n         * Updates the contact manifold and touching status.\n         *\n         * Note: do not assume the fixture AABBs are overlapping or are valid.\n         *\n         * @param listener.beginContact\n         * @param listener.endContact\n         * @param listener.preSolve\n         */\n        Contact.prototype.update = function (listener) {\n            // Re-enable this contact.\n            this.m_enabledFlag = true;\n            var touching = false;\n            var wasTouching = this.m_touchingFlag;\n            var sensorA = this.m_fixtureA.isSensor();\n            var sensorB = this.m_fixtureB.isSensor();\n            var sensor = sensorA || sensorB;\n            var bodyA = this.m_fixtureA.getBody();\n            var bodyB = this.m_fixtureB.getBody();\n            var xfA = bodyA.getTransform();\n            var xfB = bodyB.getTransform();\n            var oldManifold;\n            // Is this contact a sensor?\n            if (sensor) {\n                var shapeA = this.m_fixtureA.getShape();\n                var shapeB = this.m_fixtureB.getShape();\n                touching = testOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);\n                // Sensors don't generate manifolds.\n                this.m_manifold.pointCount = 0;\n            }\n            else {\n                // TODO reuse manifold\n                oldManifold = this.m_manifold;\n                this.m_manifold = new Manifold();\n                this.evaluate(this.m_manifold, xfA, xfB);\n                touching = this.m_manifold.pointCount > 0;\n                // Match old contact ids to new contact ids and copy the\n                // stored impulses to warm start the solver.\n                for (var i = 0; i < this.m_manifold.pointCount; ++i) {\n                    var nmp = this.m_manifold.points[i];\n                    nmp.normalImpulse = 0.0;\n                    nmp.tangentImpulse = 0.0;\n                    for (var j = 0; j < oldManifold.pointCount; ++j) {\n                        var omp = oldManifold.points[j];\n                        if (omp.id.key == nmp.id.key) {\n                            nmp.normalImpulse = omp.normalImpulse;\n                            nmp.tangentImpulse = omp.tangentImpulse;\n                            break;\n                        }\n                    }\n                }\n                if (touching != wasTouching) {\n                    bodyA.setAwake(true);\n                    bodyB.setAwake(true);\n                }\n            }\n            this.m_touchingFlag = touching;\n            if (!wasTouching && touching && listener) {\n                listener.beginContact(this);\n            }\n            if (wasTouching && !touching && listener) {\n                listener.endContact(this);\n            }\n            if (!sensor && touching && listener) {\n                listener.preSolve(this, oldManifold);\n            }\n        };\n        Contact.prototype.solvePositionConstraint = function (step) {\n            return this._solvePositionConstraint(step);\n        };\n        Contact.prototype.solvePositionConstraintTOI = function (step, toiA, toiB) {\n            return this._solvePositionConstraint(step, toiA, toiB);\n        };\n        Contact.prototype._solvePositionConstraint = function (step, toiA, toiB) {\n            var toi = !!toiA && !!toiB;\n            var fixtureA = this.m_fixtureA;\n            var fixtureB = this.m_fixtureB;\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            bodyA.c_velocity;\n            bodyB.c_velocity;\n            var positionA = bodyA.c_position;\n            var positionB = bodyB.c_position;\n            var localCenterA = Vec2.clone(this.p_localCenterA);\n            var localCenterB = Vec2.clone(this.p_localCenterB);\n            var mA = 0.0;\n            var iA = 0.0;\n            if (!toi || (bodyA == toiA || bodyA == toiB)) {\n                mA = this.p_invMassA;\n                iA = this.p_invIA;\n            }\n            var mB = 0.0;\n            var iB = 0.0;\n            if (!toi || (bodyB == toiA || bodyB == toiB)) {\n                mB = this.p_invMassB;\n                iB = this.p_invIB;\n            }\n            var cA = Vec2.clone(positionA.c);\n            var aA = positionA.a;\n            var cB = Vec2.clone(positionB.c);\n            var aB = positionB.a;\n            var minSeparation = 0.0;\n            // Solve normal constraints\n            for (var j = 0; j < this.p_pointCount; ++j) {\n                var xfA = Transform.identity();\n                var xfB = Transform.identity();\n                xfA.q.setAngle(aA);\n                xfB.q.setAngle(aB);\n                xfA.p = Vec2.sub(cA, Rot.mulVec2(xfA.q, localCenterA));\n                xfB.p = Vec2.sub(cB, Rot.mulVec2(xfB.q, localCenterB));\n                // PositionSolverManifold\n                var normal = void 0;\n                var point = void 0;\n                var separation = void 0;\n                switch (this.p_type) {\n                    case ManifoldType.e_circles: {\n                        var pointA = Transform.mulVec2(xfA, this.p_localPoint);\n                        var pointB = Transform.mulVec2(xfB, this.p_localPoints[0]);\n                        normal = Vec2.sub(pointB, pointA);\n                        normal.normalize();\n                        point = Vec2.combine(0.5, pointA, 0.5, pointB);\n                        separation = Vec2.dot(Vec2.sub(pointB, pointA), normal) - this.p_radiusA - this.p_radiusB;\n                        break;\n                    }\n                    case ManifoldType.e_faceA: {\n                        normal = Rot.mulVec2(xfA.q, this.p_localNormal);\n                        var planePoint = Transform.mulVec2(xfA, this.p_localPoint);\n                        var clipPoint = Transform.mulVec2(xfB, this.p_localPoints[j]);\n                        separation = Vec2.dot(Vec2.sub(clipPoint, planePoint), normal) - this.p_radiusA - this.p_radiusB;\n                        point = clipPoint;\n                        break;\n                    }\n                    case ManifoldType.e_faceB: {\n                        normal = Rot.mulVec2(xfB.q, this.p_localNormal);\n                        var planePoint = Transform.mulVec2(xfB, this.p_localPoint);\n                        var clipPoint = Transform.mulVec2(xfA, this.p_localPoints[j]);\n                        separation = Vec2.dot(Vec2.sub(clipPoint, planePoint), normal) - this.p_radiusA - this.p_radiusB;\n                        point = clipPoint;\n                        // Ensure normal points from A to B\n                        normal.mul(-1);\n                        break;\n                    }\n                }\n                var rA = Vec2.sub(point, cA);\n                var rB = Vec2.sub(point, cB);\n                // Track max constraint error.\n                minSeparation = math$1.min(minSeparation, separation);\n                var baumgarte = toi ? Settings.toiBaugarte : Settings.baumgarte;\n                var linearSlop = Settings.linearSlop;\n                var maxLinearCorrection = Settings.maxLinearCorrection;\n                // Prevent large corrections and allow slop.\n                var C = math$1.clamp(baumgarte * (separation + linearSlop), -maxLinearCorrection, 0.0);\n                // Compute the effective mass.\n                var rnA = Vec2.crossVec2Vec2(rA, normal);\n                var rnB = Vec2.crossVec2Vec2(rB, normal);\n                var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n                // Compute normal impulse\n                var impulse = K > 0.0 ? -C / K : 0.0;\n                var P = Vec2.mulNumVec2(impulse, normal);\n                cA.subMul(mA, P);\n                aA -= iA * Vec2.crossVec2Vec2(rA, P);\n                cB.addMul(mB, P);\n                aB += iB * Vec2.crossVec2Vec2(rB, P);\n            }\n            positionA.c.setVec2(cA);\n            positionA.a = aA;\n            positionB.c.setVec2(cB);\n            positionB.a = aB;\n            return minSeparation;\n        };\n        Contact.prototype.initVelocityConstraint = function (step) {\n            var fixtureA = this.m_fixtureA;\n            var fixtureB = this.m_fixtureB;\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            var velocityA = bodyA.c_velocity;\n            var velocityB = bodyB.c_velocity;\n            var positionA = bodyA.c_position;\n            var positionB = bodyB.c_position;\n            var radiusA = this.p_radiusA;\n            var radiusB = this.p_radiusB;\n            var manifold = this.getManifold();\n            var mA = this.v_invMassA;\n            var mB = this.v_invMassB;\n            var iA = this.v_invIA;\n            var iB = this.v_invIB;\n            var localCenterA = Vec2.clone(this.p_localCenterA);\n            var localCenterB = Vec2.clone(this.p_localCenterB);\n            var cA = Vec2.clone(positionA.c);\n            var aA = positionA.a;\n            var vA = Vec2.clone(velocityA.v);\n            var wA = velocityA.w;\n            var cB = Vec2.clone(positionB.c);\n            var aB = positionB.a;\n            var vB = Vec2.clone(velocityB.v);\n            var wB = velocityB.w;\n            var xfA = Transform.identity();\n            var xfB = Transform.identity();\n            xfA.q.setAngle(aA);\n            xfB.q.setAngle(aB);\n            xfA.p.setCombine(1, cA, -1, Rot.mulVec2(xfA.q, localCenterA));\n            xfB.p.setCombine(1, cB, -1, Rot.mulVec2(xfB.q, localCenterB));\n            var worldManifold = manifold.getWorldManifold(null, xfA, radiusA, xfB, radiusB);\n            this.v_normal.setVec2(worldManifold.normal);\n            for (var j = 0; j < this.v_pointCount; ++j) {\n                var vcp = this.v_points[j]; // VelocityConstraintPoint\n                vcp.rA.setVec2(Vec2.sub(worldManifold.points[j], cA));\n                vcp.rB.setVec2(Vec2.sub(worldManifold.points[j], cB));\n                var rnA = Vec2.crossVec2Vec2(vcp.rA, this.v_normal);\n                var rnB = Vec2.crossVec2Vec2(vcp.rB, this.v_normal);\n                var kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n                vcp.normalMass = kNormal > 0.0 ? 1.0 / kNormal : 0.0;\n                var tangent = Vec2.crossVec2Num(this.v_normal, 1.0);\n                var rtA = Vec2.crossVec2Vec2(vcp.rA, tangent);\n                var rtB = Vec2.crossVec2Vec2(vcp.rB, tangent);\n                var kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;\n                vcp.tangentMass = kTangent > 0.0 ? 1.0 / kTangent : 0.0;\n                // Setup a velocity bias for restitution.\n                vcp.velocityBias = 0.0;\n                var vRel = Vec2.dot(this.v_normal, vB)\n                    + Vec2.dot(this.v_normal, Vec2.crossNumVec2(wB, vcp.rB))\n                    - Vec2.dot(this.v_normal, vA)\n                    - Vec2.dot(this.v_normal, Vec2.crossNumVec2(wA, vcp.rA));\n                if (vRel < -Settings.velocityThreshold) {\n                    vcp.velocityBias = -this.v_restitution * vRel;\n                }\n            }\n            // If we have two points, then prepare the block solver.\n            if (this.v_pointCount == 2 && step.blockSolve) {\n                var vcp1 = this.v_points[0]; // VelocityConstraintPoint\n                var vcp2 = this.v_points[1]; // VelocityConstraintPoint\n                var rn1A = Vec2.crossVec2Vec2(vcp1.rA, this.v_normal);\n                var rn1B = Vec2.crossVec2Vec2(vcp1.rB, this.v_normal);\n                var rn2A = Vec2.crossVec2Vec2(vcp2.rA, this.v_normal);\n                var rn2B = Vec2.crossVec2Vec2(vcp2.rB, this.v_normal);\n                var k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;\n                var k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;\n                var k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;\n                // Ensure a reasonable condition number.\n                var k_maxConditionNumber = 1000.0;\n                if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {\n                    // K is safe to invert.\n                    this.v_K.ex.setNum(k11, k12);\n                    this.v_K.ey.setNum(k12, k22);\n                    this.v_normalMass.set(this.v_K.getInverse());\n                }\n                else {\n                    // The constraints are redundant, just use one.\n                    // TODO_ERIN use deepest?\n                    this.v_pointCount = 1;\n                }\n            }\n            positionA.c.setVec2(cA);\n            positionA.a = aA;\n            velocityA.v.setVec2(vA);\n            velocityA.w = wA;\n            positionB.c.setVec2(cB);\n            positionB.a = aB;\n            velocityB.v.setVec2(vB);\n            velocityB.w = wB;\n        };\n        Contact.prototype.warmStartConstraint = function (step) {\n            var fixtureA = this.m_fixtureA;\n            var fixtureB = this.m_fixtureB;\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            var velocityA = bodyA.c_velocity;\n            var velocityB = bodyB.c_velocity;\n            bodyA.c_position;\n            bodyB.c_position;\n            var mA = this.v_invMassA;\n            var iA = this.v_invIA;\n            var mB = this.v_invMassB;\n            var iB = this.v_invIB;\n            var vA = Vec2.clone(velocityA.v);\n            var wA = velocityA.w;\n            var vB = Vec2.clone(velocityB.v);\n            var wB = velocityB.w;\n            var normal = this.v_normal;\n            var tangent = Vec2.crossVec2Num(normal, 1.0);\n            for (var j = 0; j < this.v_pointCount; ++j) {\n                var vcp = this.v_points[j]; // VelocityConstraintPoint\n                var P = Vec2.combine(vcp.normalImpulse, normal, vcp.tangentImpulse, tangent);\n                wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);\n                vA.subMul(mA, P);\n                wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);\n                vB.addMul(mB, P);\n            }\n            velocityA.v.setVec2(vA);\n            velocityA.w = wA;\n            velocityB.v.setVec2(vB);\n            velocityB.w = wB;\n        };\n        Contact.prototype.storeConstraintImpulses = function (step) {\n            var manifold = this.m_manifold;\n            for (var j = 0; j < this.v_pointCount; ++j) {\n                manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;\n                manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;\n            }\n        };\n        Contact.prototype.solveVelocityConstraint = function (step) {\n            var bodyA = this.m_fixtureA.m_body;\n            var bodyB = this.m_fixtureB.m_body;\n            var velocityA = bodyA.c_velocity;\n            bodyA.c_position;\n            var velocityB = bodyB.c_velocity;\n            bodyB.c_position;\n            var mA = this.v_invMassA;\n            var iA = this.v_invIA;\n            var mB = this.v_invMassB;\n            var iB = this.v_invIB;\n            var vA = Vec2.clone(velocityA.v);\n            var wA = velocityA.w;\n            var vB = Vec2.clone(velocityB.v);\n            var wB = velocityB.w;\n            var normal = this.v_normal;\n            var tangent = Vec2.crossVec2Num(normal, 1.0);\n            var friction = this.v_friction;\n            // Solve tangent constraints first because non-penetration is more important\n            // than friction.\n            for (var j = 0; j < this.v_pointCount; ++j) {\n                var vcp = this.v_points[j]; // VelocityConstraintPoint\n                // Relative velocity at contact\n                var dv = Vec2.zero();\n                dv.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, vcp.rB));\n                dv.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, vcp.rA));\n                // Compute tangent force\n                var vt = Vec2.dot(dv, tangent) - this.v_tangentSpeed;\n                var lambda = vcp.tangentMass * (-vt);\n                // Clamp the accumulated force\n                var maxFriction = friction * vcp.normalImpulse;\n                var newImpulse = math$1.clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);\n                lambda = newImpulse - vcp.tangentImpulse;\n                vcp.tangentImpulse = newImpulse;\n                // Apply contact impulse\n                var P = Vec2.mulNumVec2(lambda, tangent);\n                vA.subMul(mA, P);\n                wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);\n                vB.addMul(mB, P);\n                wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);\n            }\n            // Solve normal constraints\n            if (this.v_pointCount == 1 || step.blockSolve == false) {\n                for (var i = 0; i < this.v_pointCount; ++i) {\n                    var vcp = this.v_points[i]; // VelocityConstraintPoint\n                    // Relative velocity at contact\n                    var dv = Vec2.zero();\n                    dv.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, vcp.rB));\n                    dv.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, vcp.rA));\n                    // Compute normal impulse\n                    var vn = Vec2.dot(dv, normal);\n                    var lambda = -vcp.normalMass * (vn - vcp.velocityBias);\n                    // Clamp the accumulated impulse\n                    var newImpulse = math$1.max(vcp.normalImpulse + lambda, 0.0);\n                    lambda = newImpulse - vcp.normalImpulse;\n                    vcp.normalImpulse = newImpulse;\n                    // Apply contact impulse\n                    var P = Vec2.mulNumVec2(lambda, normal);\n                    vA.subMul(mA, P);\n                    wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);\n                    vB.addMul(mB, P);\n                    wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);\n                }\n            }\n            else {\n                // Block solver developed in collaboration with Dirk Gregorius (back in\n                // 01/07 on Box2D_Lite).\n                // Build the mini LCP for this contact patch\n                //\n                // vn = A * x + b, vn >= 0, , vn >= 0, x >= 0 and vn_i * x_i = 0 with i =\n                // 1..2\n                //\n                // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )\n                // b = vn0 - velocityBias\n                //\n                // The system is solved using the \"Total enumeration method\" (s. Murty).\n                // The complementary constraint vn_i * x_i\n                // implies that we must have in any solution either vn_i = 0 or x_i = 0.\n                // So for the 2D contact problem the cases\n                // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and\n                // vn1 = 0 need to be tested. The first valid\n                // solution that satisfies the problem is chosen.\n                //\n                // In order to account of the accumulated impulse 'a' (because of the\n                // iterative nature of the solver which only requires\n                // that the accumulated impulse is clamped and not the incremental\n                // impulse) we change the impulse variable (x_i).\n                //\n                // Substitute:\n                //\n                // x = a + d\n                //\n                // a := old total impulse\n                // x := new total impulse\n                // d := incremental impulse\n                //\n                // For the current iteration we extend the formula for the incremental\n                // impulse\n                // to compute the new total impulse:\n                //\n                // vn = A * d + b\n                // = A * (x - a) + b\n                // = A * x + b - A * a\n                // = A * x + b'\n                // b' = b - A * a;\n                var vcp1 = this.v_points[0]; // VelocityConstraintPoint\n                var vcp2 = this.v_points[1]; // VelocityConstraintPoint\n                var a = Vec2.neo(vcp1.normalImpulse, vcp2.normalImpulse);\n                // Relative velocity at contact\n                var dv1 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp1.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp1.rA));\n                var dv2 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp2.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp2.rA));\n                // Compute normal velocity\n                var vn1 = Vec2.dot(dv1, normal);\n                var vn2 = Vec2.dot(dv2, normal);\n                var b = Vec2.neo(vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);\n                // Compute b'\n                b.sub(Mat22.mulVec2(this.v_K, a));\n                // NOT_USED(k_errorTol);\n                while (true) {\n                    //\n                    // Case 1: vn = 0\n                    //\n                    // 0 = A * x + b'\n                    //\n                    // Solve for x:\n                    //\n                    // x = - inv(A) * b'\n                    //\n                    var x = Mat22.mulVec2(this.v_normalMass, b).neg();\n                    if (x.x >= 0.0 && x.y >= 0.0) {\n                        // Get the incremental impulse\n                        var d = Vec2.sub(x, a);\n                        // Apply incremental impulse\n                        var P1 = Vec2.mulNumVec2(d.x, normal);\n                        var P2 = Vec2.mulNumVec2(d.y, normal);\n                        vA.subCombine(mA, P1, mA, P2);\n                        wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n                        vB.addCombine(mB, P1, mB, P2);\n                        wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n                        // Accumulate\n                        vcp1.normalImpulse = x.x;\n                        vcp2.normalImpulse = x.y;\n                        break;\n                    }\n                    //\n                    // Case 2: vn1 = 0 and x2 = 0\n                    //\n                    // 0 = a11 * x1 + a12 * 0 + b1'\n                    // vn2 = a21 * x1 + a22 * 0 + b2'\n                    //\n                    x.x = -vcp1.normalMass * b.x;\n                    x.y = 0.0;\n                    vn1 = 0.0;\n                    vn2 = this.v_K.ex.y * x.x + b.y;\n                    if (x.x >= 0.0 && vn2 >= 0.0) {\n                        // Get the incremental impulse\n                        var d = Vec2.sub(x, a);\n                        // Apply incremental impulse\n                        var P1 = Vec2.mulNumVec2(d.x, normal);\n                        var P2 = Vec2.mulNumVec2(d.y, normal);\n                        vA.subCombine(mA, P1, mA, P2);\n                        wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n                        vB.addCombine(mB, P1, mB, P2);\n                        wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n                        // Accumulate\n                        vcp1.normalImpulse = x.x;\n                        vcp2.normalImpulse = x.y;\n                        break;\n                    }\n                    //\n                    // Case 3: vn2 = 0 and x1 = 0\n                    //\n                    // vn1 = a11 * 0 + a12 * x2 + b1'\n                    // 0 = a21 * 0 + a22 * x2 + b2'\n                    //\n                    x.x = 0.0;\n                    x.y = -vcp2.normalMass * b.y;\n                    vn1 = this.v_K.ey.x * x.y + b.x;\n                    vn2 = 0.0;\n                    if (x.y >= 0.0 && vn1 >= 0.0) {\n                        // Resubstitute for the incremental impulse\n                        var d = Vec2.sub(x, a);\n                        // Apply incremental impulse\n                        var P1 = Vec2.mulNumVec2(d.x, normal);\n                        var P2 = Vec2.mulNumVec2(d.y, normal);\n                        vA.subCombine(mA, P1, mA, P2);\n                        wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n                        vB.addCombine(mB, P1, mB, P2);\n                        wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n                        // Accumulate\n                        vcp1.normalImpulse = x.x;\n                        vcp2.normalImpulse = x.y;\n                        break;\n                    }\n                    //\n                    // Case 4: x1 = 0 and x2 = 0\n                    //\n                    // vn1 = b1\n                    // vn2 = b2;\n                    //\n                    x.x = 0.0;\n                    x.y = 0.0;\n                    vn1 = b.x;\n                    vn2 = b.y;\n                    if (vn1 >= 0.0 && vn2 >= 0.0) {\n                        // Resubstitute for the incremental impulse\n                        var d = Vec2.sub(x, a);\n                        // Apply incremental impulse\n                        var P1 = Vec2.mulNumVec2(d.x, normal);\n                        var P2 = Vec2.mulNumVec2(d.y, normal);\n                        vA.subCombine(mA, P1, mA, P2);\n                        wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n                        vB.addCombine(mB, P1, mB, P2);\n                        wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n                        // Accumulate\n                        vcp1.normalImpulse = x.x;\n                        vcp2.normalImpulse = x.y;\n                        break;\n                    }\n                    // No solution, give up. This is hit sometimes, but it doesn't seem to\n                    // matter.\n                    break;\n                }\n            }\n            velocityA.v.setVec2(vA);\n            velocityA.w = wA;\n            velocityB.v.setVec2(vB);\n            velocityB.w = wB;\n        };\n        /**\n         * @internal\n         */\n        Contact.addType = function (type1, type2, callback) {\n            s_registers[type1] = s_registers[type1] || {};\n            s_registers[type1][type2] = callback;\n        };\n        /**\n         * @internal\n         */\n        Contact.create = function (fixtureA, indexA, fixtureB, indexB) {\n            var typeA = fixtureA.getType();\n            var typeB = fixtureB.getType();\n            // TODO: pool contacts\n            var contact;\n            var evaluateFcn;\n            if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) {\n                contact = new Contact(fixtureA, indexA, fixtureB, indexB, evaluateFcn);\n            }\n            else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) {\n                contact = new Contact(fixtureB, indexB, fixtureA, indexA, evaluateFcn);\n            }\n            else {\n                return null;\n            }\n            // Contact creation may swap fixtures.\n            fixtureA = contact.getFixtureA();\n            fixtureB = contact.getFixtureB();\n            indexA = contact.getChildIndexA();\n            indexB = contact.getChildIndexB();\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            // Connect to body A\n            contact.m_nodeA.contact = contact;\n            contact.m_nodeA.other = bodyB;\n            contact.m_nodeA.prev = null;\n            contact.m_nodeA.next = bodyA.m_contactList;\n            if (bodyA.m_contactList != null) {\n                bodyA.m_contactList.prev = contact.m_nodeA;\n            }\n            bodyA.m_contactList = contact.m_nodeA;\n            // Connect to body B\n            contact.m_nodeB.contact = contact;\n            contact.m_nodeB.other = bodyA;\n            contact.m_nodeB.prev = null;\n            contact.m_nodeB.next = bodyB.m_contactList;\n            if (bodyB.m_contactList != null) {\n                bodyB.m_contactList.prev = contact.m_nodeB;\n            }\n            bodyB.m_contactList = contact.m_nodeB;\n            // Wake up the bodies\n            if (fixtureA.isSensor() == false && fixtureB.isSensor() == false) {\n                bodyA.setAwake(true);\n                bodyB.setAwake(true);\n            }\n            return contact;\n        };\n        /**\n         * @internal\n         */\n        Contact.destroy = function (contact, listener) {\n            var fixtureA = contact.m_fixtureA;\n            var fixtureB = contact.m_fixtureB;\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            if (contact.isTouching()) {\n                listener.endContact(contact);\n            }\n            // Remove from body 1\n            if (contact.m_nodeA.prev) {\n                contact.m_nodeA.prev.next = contact.m_nodeA.next;\n            }\n            if (contact.m_nodeA.next) {\n                contact.m_nodeA.next.prev = contact.m_nodeA.prev;\n            }\n            if (contact.m_nodeA == bodyA.m_contactList) {\n                bodyA.m_contactList = contact.m_nodeA.next;\n            }\n            // Remove from body 2\n            if (contact.m_nodeB.prev) {\n                contact.m_nodeB.prev.next = contact.m_nodeB.next;\n            }\n            if (contact.m_nodeB.next) {\n                contact.m_nodeB.next.prev = contact.m_nodeB.prev;\n            }\n            if (contact.m_nodeB == bodyB.m_contactList) {\n                bodyB.m_contactList = contact.m_nodeB.next;\n            }\n            if (contact.m_manifold.pointCount > 0 && fixtureA.isSensor() == false\n                && fixtureB.isSensor() == false) {\n                bodyA.setAwake(true);\n                bodyB.setAwake(true);\n            }\n            fixtureA.getType();\n            fixtureB.getType();\n            // const destroyFcn = s_registers[typeA][typeB].destroyFcn;\n            // if (typeof destroyFcn === 'function') {\n            //   destroyFcn(contact);\n            // }\n        };\n        return Contact;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A joint edge is used to connect bodies and joints together in a joint graph\n     * where each body is a node and each joint is an edge. A joint edge belongs to\n     * a doubly linked list maintained in each attached body. Each joint has two\n     * joint nodes, one for each attached body.\n     */\n    var JointEdge = /** @class */ (function () {\n        function JointEdge() {\n            /**\n             * provides quick access to the other body attached.\n             */\n            this.other = null;\n            /**\n             * the joint\n             */\n            this.joint = null;\n            /**\n             * prev the previous joint edge in the body's joint list\n             */\n            this.prev = null;\n            /**\n             * the next joint edge in the body's joint list\n             */\n            this.next = null;\n        }\n        return JointEdge;\n    }());\n    /**\n     * The base joint class. Joints are used to constraint two bodies together in\n     * various fashions. Some joints also feature limits and motors.\n     */\n    var Joint = /** @class */ (function () {\n        function Joint(def, bodyA, bodyB) {\n            /** @internal */ this.m_type = 'unknown-joint';\n            /** @internal */ this.m_prev = null;\n            /** @internal */ this.m_next = null;\n            /** @internal */ this.m_edgeA = new JointEdge();\n            /** @internal */ this.m_edgeB = new JointEdge();\n            /** @internal */ this.m_islandFlag = false;\n            bodyA = 'bodyA' in def ? def.bodyA : bodyA;\n            bodyB = 'bodyB' in def ? def.bodyB : bodyB;\n            this.m_bodyA = bodyA;\n            this.m_bodyB = bodyB;\n            this.m_collideConnected = !!def.collideConnected;\n            this.m_userData = def.userData;\n        }\n        /**\n         * Short-cut function to determine if either body is inactive.\n         */\n        Joint.prototype.isActive = function () {\n            return this.m_bodyA.isActive() && this.m_bodyB.isActive();\n        };\n        /**\n         * Get the type of the concrete joint.\n         */\n        Joint.prototype.getType = function () {\n            return this.m_type;\n        };\n        /**\n         * Get the first body attached to this joint.\n         */\n        Joint.prototype.getBodyA = function () {\n            return this.m_bodyA;\n        };\n        /**\n         * Get the second body attached to this joint.\n         */\n        Joint.prototype.getBodyB = function () {\n            return this.m_bodyB;\n        };\n        /**\n         * Get the next joint the world joint list.\n         */\n        Joint.prototype.getNext = function () {\n            return this.m_next;\n        };\n        Joint.prototype.getUserData = function () {\n            return this.m_userData;\n        };\n        Joint.prototype.setUserData = function (data) {\n            this.m_userData = data;\n        };\n        /**\n         * Get collide connected. Note: modifying the collide connect flag won't work\n         * correctly because the flag is only checked when fixture AABBs begin to\n         * overlap.\n         */\n        Joint.prototype.getCollideConnected = function () {\n            return this.m_collideConnected;\n        };\n        /**\n         * Shift the origin for any points stored in world coordinates.\n         */\n        Joint.prototype.shiftOrigin = function (newOrigin) { };\n        return Joint;\n    }());\n\n    var now = function () {\n        return Date.now();\n    };\n    var diff = function (time) {\n        return Date.now() - time;\n    };\n    var Timer = {\n        now: now,\n        diff: diff,\n    };\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * Input parameters for TimeOfImpact.\n     */\n    var TOIInput = /** @class */ (function () {\n        function TOIInput() {\n            this.proxyA = new DistanceProxy();\n            this.proxyB = new DistanceProxy();\n            this.sweepA = new Sweep();\n            this.sweepB = new Sweep();\n        }\n        return TOIInput;\n    }());\n    var TOIOutputState;\n    (function (TOIOutputState) {\n        TOIOutputState[TOIOutputState[\"e_unknown\"] = 0] = \"e_unknown\";\n        TOIOutputState[TOIOutputState[\"e_failed\"] = 1] = \"e_failed\";\n        TOIOutputState[TOIOutputState[\"e_overlapped\"] = 2] = \"e_overlapped\";\n        TOIOutputState[TOIOutputState[\"e_touching\"] = 3] = \"e_touching\";\n        TOIOutputState[TOIOutputState[\"e_separated\"] = 4] = \"e_separated\";\n    })(TOIOutputState || (TOIOutputState = {}));\n    /**\n     * Output parameters for TimeOfImpact.\n     */\n    var TOIOutput = /** @class */ (function () {\n        function TOIOutput() {\n        }\n        return TOIOutput;\n    }());\n    stats$1.toiTime = 0;\n    stats$1.toiMaxTime = 0;\n    stats$1.toiCalls = 0;\n    stats$1.toiIters = 0;\n    stats$1.toiMaxIters = 0;\n    stats$1.toiRootIters = 0;\n    stats$1.toiMaxRootIters = 0;\n    /**\n     * Compute the upper bound on time before two shapes penetrate. Time is\n     * represented as a fraction between [0,tMax]. This uses a swept separating axis\n     * and may miss some intermediate, non-tunneling collision. If you change the\n     * time interval, you should call this function again.\n     *\n     * Note: use Distance to compute the contact point and normal at the time of\n     * impact.\n     *\n     * CCD via the local separating axis method. This seeks progression by computing\n     * the largest time at which separation is maintained.\n     */\n    function TimeOfImpact(output, input) {\n        var timer = Timer.now();\n        ++stats$1.toiCalls;\n        output.state = TOIOutputState.e_unknown;\n        output.t = input.tMax;\n        var proxyA = input.proxyA; // DistanceProxy\n        var proxyB = input.proxyB; // DistanceProxy\n        var sweepA = input.sweepA; // Sweep\n        var sweepB = input.sweepB; // Sweep\n        // Large rotations can make the root finder fail, so we normalize the\n        // sweep angles.\n        sweepA.normalize();\n        sweepB.normalize();\n        var tMax = input.tMax;\n        var totalRadius = proxyA.m_radius + proxyB.m_radius;\n        var target = math$1.max(Settings.linearSlop, totalRadius - 3.0 * Settings.linearSlop);\n        var tolerance = 0.25 * Settings.linearSlop;\n        var t1 = 0.0;\n        var k_maxIterations = Settings.maxTOIIterations;\n        var iter = 0;\n        // Prepare input for distance query.\n        var cache = new SimplexCache();\n        var distanceInput = new DistanceInput();\n        distanceInput.proxyA = input.proxyA;\n        distanceInput.proxyB = input.proxyB;\n        distanceInput.useRadii = false;\n        // The outer loop progressively attempts to compute new separating axes.\n        // This loop terminates when an axis is repeated (no progress is made).\n        while (true) {\n            var xfA = Transform.identity();\n            var xfB = Transform.identity();\n            sweepA.getTransform(xfA, t1);\n            sweepB.getTransform(xfB, t1);\n            // Get the distance between shapes. We can also use the results\n            // to get a separating axis.\n            distanceInput.transformA = xfA;\n            distanceInput.transformB = xfB;\n            var distanceOutput = new DistanceOutput();\n            Distance(distanceOutput, cache, distanceInput);\n            // If the shapes are overlapped, we give up on continuous collision.\n            if (distanceOutput.distance <= 0.0) {\n                // Failure!\n                output.state = TOIOutputState.e_overlapped;\n                output.t = 0.0;\n                break;\n            }\n            if (distanceOutput.distance < target + tolerance) {\n                // Victory!\n                output.state = TOIOutputState.e_touching;\n                output.t = t1;\n                break;\n            }\n            // Initialize the separating axis.\n            var fcn = new SeparationFunction();\n            fcn.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);\n            // if (false) {\n            //   // Dump the curve seen by the root finder\n            //   const N = 100;\n            //   const dx = 1.0 / N;\n            //   const xs = []; // [ N + 1 ];\n            //   const fs = []; // [ N + 1 ];\n            //   const x = 0.0;\n            //   for (const i = 0; i <= N; ++i) {\n            //     sweepA.getTransform(xfA, x);\n            //     sweepB.getTransform(xfB, x);\n            //     const f = fcn.evaluate(xfA, xfB) - target;\n            //     printf(\"%g %g\\n\", x, f);\n            //     xs[i] = x;\n            //     fs[i] = f;\n            //     x += dx;\n            //   }\n            // }\n            // Compute the TOI on the separating axis. We do this by successively\n            // resolving the deepest point. This loop is bounded by the number of\n            // vertices.\n            var done = false;\n            var t2 = tMax;\n            var pushBackIter = 0;\n            while (true) {\n                // Find the deepest point at t2. Store the witness point indices.\n                var s2 = fcn.findMinSeparation(t2);\n                // const indexA = fcn.indexA;\n                // const indexB = fcn.indexB;\n                // Is the final configuration separated?\n                if (s2 > target + tolerance) {\n                    // Victory!\n                    output.state = TOIOutputState.e_separated;\n                    output.t = tMax;\n                    done = true;\n                    break;\n                }\n                // Has the separation reached tolerance?\n                if (s2 > target - tolerance) {\n                    // Advance the sweeps\n                    t1 = t2;\n                    break;\n                }\n                // Compute the initial separation of the witness points.\n                var s1 = fcn.evaluate(t1);\n                // const indexA = fcn.indexA;\n                // const indexB = fcn.indexB;\n                // Check for initial overlap. This might happen if the root finder\n                // runs out of iterations.\n                if (s1 < target - tolerance) {\n                    output.state = TOIOutputState.e_failed;\n                    output.t = t1;\n                    done = true;\n                    break;\n                }\n                // Check for touching\n                if (s1 <= target + tolerance) {\n                    // Victory! t1 should hold the TOI (could be 0.0).\n                    output.state = TOIOutputState.e_touching;\n                    output.t = t1;\n                    done = true;\n                    break;\n                }\n                // Compute 1D root of: f(x) - target = 0\n                var rootIterCount = 0;\n                var a1 = t1;\n                var a2 = t2;\n                while (true) {\n                    // Use a mix of the secant rule and bisection.\n                    var t = void 0;\n                    if (rootIterCount & 1) {\n                        // Secant rule to improve convergence.\n                        t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);\n                    }\n                    else {\n                        // Bisection to guarantee progress.\n                        t = 0.5 * (a1 + a2);\n                    }\n                    ++rootIterCount;\n                    ++stats$1.toiRootIters;\n                    var s = fcn.evaluate(t);\n                    fcn.indexA;\n                    fcn.indexB;\n                    if (math$1.abs(s - target) < tolerance) {\n                        // t2 holds a tentative value for t1\n                        t2 = t;\n                        break;\n                    }\n                    // Ensure we continue to bracket the root.\n                    if (s > target) {\n                        a1 = t;\n                        s1 = s;\n                    }\n                    else {\n                        a2 = t;\n                        s2 = s;\n                    }\n                    if (rootIterCount === 50) {\n                        break;\n                    }\n                }\n                stats$1.toiMaxRootIters = math$1.max(stats$1.toiMaxRootIters, rootIterCount);\n                ++pushBackIter;\n                if (pushBackIter === Settings.maxPolygonVertices) {\n                    break;\n                }\n            }\n            ++iter;\n            ++stats$1.toiIters;\n            if (done) {\n                break;\n            }\n            if (iter === k_maxIterations) {\n                // Root finder got stuck. Semi-victory.\n                output.state = TOIOutputState.e_failed;\n                output.t = t1;\n                break;\n            }\n        }\n        stats$1.toiMaxIters = math$1.max(stats$1.toiMaxIters, iter);\n        var time = Timer.diff(timer);\n        stats$1.toiMaxTime = math$1.max(stats$1.toiMaxTime, time);\n        stats$1.toiTime += time;\n    }\n    var SeparationFunctionType;\n    (function (SeparationFunctionType) {\n        SeparationFunctionType[SeparationFunctionType[\"e_points\"] = 1] = \"e_points\";\n        SeparationFunctionType[SeparationFunctionType[\"e_faceA\"] = 2] = \"e_faceA\";\n        SeparationFunctionType[SeparationFunctionType[\"e_faceB\"] = 3] = \"e_faceB\";\n    })(SeparationFunctionType || (SeparationFunctionType = {}));\n    var SeparationFunction = /** @class */ (function () {\n        function SeparationFunction() {\n            this.m_proxyA = new DistanceProxy();\n            this.m_proxyB = new DistanceProxy();\n            this.m_localPoint = Vec2.zero();\n            this.m_axis = Vec2.zero();\n        }\n        // TODO_ERIN might not need to return the separation\n        SeparationFunction.prototype.initialize = function (cache, proxyA, sweepA, proxyB, sweepB, t1) {\n            this.m_proxyA = proxyA;\n            this.m_proxyB = proxyB;\n            var count = cache.count;\n            this.m_sweepA = sweepA;\n            this.m_sweepB = sweepB;\n            var xfA = Transform.identity();\n            var xfB = Transform.identity();\n            this.m_sweepA.getTransform(xfA, t1);\n            this.m_sweepB.getTransform(xfB, t1);\n            if (count === 1) {\n                this.m_type = SeparationFunctionType.e_points;\n                var localPointA = this.m_proxyA.getVertex(cache.indexA[0]);\n                var localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n                var pointA = Transform.mulVec2(xfA, localPointA);\n                var pointB = Transform.mulVec2(xfB, localPointB);\n                this.m_axis.setCombine(1, pointB, -1, pointA);\n                var s = this.m_axis.normalize();\n                return s;\n            }\n            else if (cache.indexA[0] === cache.indexA[1]) {\n                // Two points on B and one on A.\n                this.m_type = SeparationFunctionType.e_faceB;\n                var localPointB1 = proxyB.getVertex(cache.indexB[0]);\n                var localPointB2 = proxyB.getVertex(cache.indexB[1]);\n                this.m_axis = Vec2.crossVec2Num(Vec2.sub(localPointB2, localPointB1), 1.0);\n                this.m_axis.normalize();\n                var normal = Rot.mulVec2(xfB.q, this.m_axis);\n                this.m_localPoint = Vec2.mid(localPointB1, localPointB2);\n                var pointB = Transform.mulVec2(xfB, this.m_localPoint);\n                var localPointA = proxyA.getVertex(cache.indexA[0]);\n                var pointA = Transform.mulVec2(xfA, localPointA);\n                var s = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);\n                if (s < 0.0) {\n                    this.m_axis = Vec2.neg(this.m_axis);\n                    s = -s;\n                }\n                return s;\n            }\n            else {\n                // Two points on A and one or two points on B.\n                this.m_type = SeparationFunctionType.e_faceA;\n                var localPointA1 = this.m_proxyA.getVertex(cache.indexA[0]);\n                var localPointA2 = this.m_proxyA.getVertex(cache.indexA[1]);\n                this.m_axis = Vec2.crossVec2Num(Vec2.sub(localPointA2, localPointA1), 1.0);\n                this.m_axis.normalize();\n                var normal = Rot.mulVec2(xfA.q, this.m_axis);\n                this.m_localPoint = Vec2.mid(localPointA1, localPointA2);\n                var pointA = Transform.mulVec2(xfA, this.m_localPoint);\n                var localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n                var pointB = Transform.mulVec2(xfB, localPointB);\n                var s = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);\n                if (s < 0.0) {\n                    this.m_axis = Vec2.neg(this.m_axis);\n                    s = -s;\n                }\n                return s;\n            }\n        };\n        SeparationFunction.prototype.compute = function (find, t) {\n            // It was findMinSeparation and evaluate\n            var xfA = Transform.identity();\n            var xfB = Transform.identity();\n            this.m_sweepA.getTransform(xfA, t);\n            this.m_sweepB.getTransform(xfB, t);\n            switch (this.m_type) {\n                case SeparationFunctionType.e_points: {\n                    if (find) {\n                        var axisA = Rot.mulTVec2(xfA.q, this.m_axis);\n                        var axisB = Rot.mulTVec2(xfB.q, Vec2.neg(this.m_axis));\n                        this.indexA = this.m_proxyA.getSupport(axisA);\n                        this.indexB = this.m_proxyB.getSupport(axisB);\n                    }\n                    var localPointA = this.m_proxyA.getVertex(this.indexA);\n                    var localPointB = this.m_proxyB.getVertex(this.indexB);\n                    var pointA = Transform.mulVec2(xfA, localPointA);\n                    var pointB = Transform.mulVec2(xfB, localPointB);\n                    var sep = Vec2.dot(pointB, this.m_axis) - Vec2.dot(pointA, this.m_axis);\n                    return sep;\n                }\n                case SeparationFunctionType.e_faceA: {\n                    var normal = Rot.mulVec2(xfA.q, this.m_axis);\n                    var pointA = Transform.mulVec2(xfA, this.m_localPoint);\n                    if (find) {\n                        var axisB = Rot.mulTVec2(xfB.q, Vec2.neg(normal));\n                        this.indexA = -1;\n                        this.indexB = this.m_proxyB.getSupport(axisB);\n                    }\n                    var localPointB = this.m_proxyB.getVertex(this.indexB);\n                    var pointB = Transform.mulVec2(xfB, localPointB);\n                    var sep = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);\n                    return sep;\n                }\n                case SeparationFunctionType.e_faceB: {\n                    var normal = Rot.mulVec2(xfB.q, this.m_axis);\n                    var pointB = Transform.mulVec2(xfB, this.m_localPoint);\n                    if (find) {\n                        var axisA = Rot.mulTVec2(xfA.q, Vec2.neg(normal));\n                        this.indexB = -1;\n                        this.indexA = this.m_proxyA.getSupport(axisA);\n                    }\n                    var localPointA = this.m_proxyA.getVertex(this.indexA);\n                    var pointA = Transform.mulVec2(xfA, localPointA);\n                    var sep = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);\n                    return sep;\n                }\n                default:\n                    if (find) {\n                        this.indexA = -1;\n                        this.indexB = -1;\n                    }\n                    return 0.0;\n            }\n        };\n        SeparationFunction.prototype.findMinSeparation = function (t) {\n            return this.compute(true, t);\n        };\n        SeparationFunction.prototype.evaluate = function (t) {\n            return this.compute(false, t);\n        };\n        return SeparationFunction;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var TimeStep = /** @class */ (function () {\n        function TimeStep() {\n            /** time step */\n            this.dt = 0;\n            /** inverse time step (0 if dt == 0) */\n            this.inv_dt = 0;\n            this.velocityIterations = 0;\n            this.positionIterations = 0;\n            this.warmStarting = false;\n            this.blockSolve = true;\n            /** timestep ratio for variable timestep */\n            this.inv_dt0 = 0.0;\n            /** dt * inv_dt0 */\n            this.dtRatio = 1;\n        }\n        TimeStep.prototype.reset = function (dt) {\n            if (this.dt > 0.0) {\n                this.inv_dt0 = this.inv_dt;\n            }\n            this.dt = dt;\n            this.inv_dt = dt == 0 ? 0 : 1 / dt;\n            this.dtRatio = dt * this.inv_dt0;\n        };\n        return TimeStep;\n    }());\n    // reuse\n    var s_subStep = new TimeStep();\n    /**\n     * Contact impulses for reporting. Impulses are used instead of forces because\n     * sub-step forces may approach infinity for rigid body collisions. These match\n     * up one-to-one with the contact points in Manifold.\n     */\n    var ContactImpulse = /** @class */ (function () {\n        function ContactImpulse(contact) {\n            this.contact = contact;\n            this.normals = [];\n            this.tangents = [];\n        }\n        Object.defineProperty(ContactImpulse.prototype, \"normalImpulses\", {\n            get: function () {\n                var contact = this.contact;\n                var normals = this.normals;\n                normals.length = 0;\n                for (var p = 0; p < contact.v_points.length; ++p) {\n                    normals.push(contact.v_points[p].normalImpulse);\n                }\n                return normals;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(ContactImpulse.prototype, \"tangentImpulses\", {\n            get: function () {\n                var contact = this.contact;\n                var tangents = this.tangents;\n                tangents.length = 0;\n                for (var p = 0; p < contact.v_points.length; ++p) {\n                    tangents.push(contact.v_points[p].tangentImpulse);\n                }\n                return tangents;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        return ContactImpulse;\n    }());\n    /**\n     * Finds and solves islands. An island is a connected subset of the world.\n     */\n    var Solver = /** @class */ (function () {\n        function Solver(world) {\n            this.m_world = world;\n            this.m_stack = [];\n            this.m_bodies = [];\n            this.m_contacts = [];\n            this.m_joints = [];\n        }\n        Solver.prototype.clear = function () {\n            this.m_stack.length = 0;\n            this.m_bodies.length = 0;\n            this.m_contacts.length = 0;\n            this.m_joints.length = 0;\n        };\n        Solver.prototype.addBody = function (body) {\n            this.m_bodies.push(body);\n            // why?\n            // body.c_position.c.setZero();\n            // body.c_position.a = 0;\n            // body.c_velocity.v.setZero();\n            // body.c_velocity.w = 0;\n        };\n        Solver.prototype.addContact = function (contact) {\n            this.m_contacts.push(contact);\n        };\n        Solver.prototype.addJoint = function (joint) {\n            this.m_joints.push(joint);\n        };\n        Solver.prototype.solveWorld = function (step) {\n            var world = this.m_world;\n            // Clear all the island flags.\n            for (var b = world.m_bodyList; b; b = b.m_next) {\n                b.m_islandFlag = false;\n            }\n            for (var c = world.m_contactList; c; c = c.m_next) {\n                c.m_islandFlag = false;\n            }\n            for (var j = world.m_jointList; j; j = j.m_next) {\n                j.m_islandFlag = false;\n            }\n            // Build and simulate all awake islands.\n            var stack = this.m_stack;\n            for (var seed = world.m_bodyList; seed; seed = seed.m_next) {\n                if (seed.m_islandFlag) {\n                    continue;\n                }\n                if (seed.isAwake() == false || seed.isActive() == false) {\n                    continue;\n                }\n                // The seed can be dynamic or kinematic.\n                if (seed.isStatic()) {\n                    continue;\n                }\n                // Reset island and stack.\n                this.clear();\n                stack.push(seed);\n                seed.m_islandFlag = true;\n                // Perform a depth first search (DFS) on the constraint graph.\n                while (stack.length > 0) {\n                    // Grab the next body off the stack and add it to the island.\n                    var b = stack.pop();\n                    this.addBody(b);\n                    // Make sure the body is awake.\n                    b.setAwake(true);\n                    // To keep islands as small as possible, we don't\n                    // propagate islands across static bodies.\n                    if (b.isStatic()) {\n                        continue;\n                    }\n                    // Search all contacts connected to this body.\n                    for (var ce = b.m_contactList; ce; ce = ce.next) {\n                        var contact = ce.contact;\n                        // Has this contact already been added to an island?\n                        if (contact.m_islandFlag) {\n                            continue;\n                        }\n                        // Is this contact solid and touching?\n                        if (contact.isEnabled() == false || contact.isTouching() == false) {\n                            continue;\n                        }\n                        // Skip sensors.\n                        var sensorA = contact.m_fixtureA.m_isSensor;\n                        var sensorB = contact.m_fixtureB.m_isSensor;\n                        if (sensorA || sensorB) {\n                            continue;\n                        }\n                        this.addContact(contact);\n                        contact.m_islandFlag = true;\n                        var other = ce.other;\n                        // Was the other body already added to this island?\n                        if (other.m_islandFlag) {\n                            continue;\n                        }\n                        // _ASSERT && common.assert(stack.length < world.m_bodyCount);\n                        stack.push(other);\n                        other.m_islandFlag = true;\n                    }\n                    // Search all joints connect to this body.\n                    for (var je = b.m_jointList; je; je = je.next) {\n                        if (je.joint.m_islandFlag == true) {\n                            continue;\n                        }\n                        var other = je.other;\n                        // Don't simulate joints connected to inactive bodies.\n                        if (other.isActive() == false) {\n                            continue;\n                        }\n                        this.addJoint(je.joint);\n                        je.joint.m_islandFlag = true;\n                        if (other.m_islandFlag) {\n                            continue;\n                        }\n                        // _ASSERT && common.assert(stack.length < world.m_bodyCount);\n                        stack.push(other);\n                        other.m_islandFlag = true;\n                    }\n                }\n                this.solveIsland(step);\n                // Post solve cleanup.\n                for (var i = 0; i < this.m_bodies.length; ++i) {\n                    // Allow static bodies to participate in other islands.\n                    // TODO: are they added at all?\n                    var b = this.m_bodies[i];\n                    if (b.isStatic()) {\n                        b.m_islandFlag = false;\n                    }\n                }\n            }\n        };\n        Solver.prototype.solveIsland = function (step) {\n            // B2: Island Solve\n            var world = this.m_world;\n            var gravity = world.m_gravity;\n            var allowSleep = world.m_allowSleep;\n            var h = step.dt;\n            // Integrate velocities and apply damping. Initialize the body state.\n            for (var i = 0; i < this.m_bodies.length; ++i) {\n                var body = this.m_bodies[i];\n                var c = Vec2.clone(body.m_sweep.c);\n                var a = body.m_sweep.a;\n                var v = Vec2.clone(body.m_linearVelocity);\n                var w = body.m_angularVelocity;\n                // Store positions for continuous collision.\n                body.m_sweep.c0.setVec2(body.m_sweep.c);\n                body.m_sweep.a0 = body.m_sweep.a;\n                if (body.isDynamic()) {\n                    // Integrate velocities.\n                    v.addMul(h * body.m_gravityScale, gravity);\n                    v.addMul(h * body.m_invMass, body.m_force);\n                    w += h * body.m_invI * body.m_torque;\n                    /**\n                     * <pre>\n                     * Apply damping.\n                     * ODE: dv/dt + c * v = 0\n                     * Solution: v(t) = v0 * exp(-c * t)\n                     * Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)\n                     * v2 = exp(-c * dt) * v1\n                     * Pade approximation:\n                     * v2 = v1 * 1 / (1 + c * dt)\n                     * </pre>\n                     */\n                    v.mul(1.0 / (1.0 + h * body.m_linearDamping));\n                    w *= 1.0 / (1.0 + h * body.m_angularDamping);\n                }\n                body.c_position.c = c;\n                body.c_position.a = a;\n                body.c_velocity.v = v;\n                body.c_velocity.w = w;\n            }\n            for (var i = 0; i < this.m_contacts.length; ++i) {\n                var contact = this.m_contacts[i];\n                contact.initConstraint(step);\n            }\n            for (var i = 0; i < this.m_contacts.length; ++i) {\n                var contact = this.m_contacts[i];\n                contact.initVelocityConstraint(step);\n            }\n            if (step.warmStarting) {\n                // Warm start.\n                for (var i = 0; i < this.m_contacts.length; ++i) {\n                    var contact = this.m_contacts[i];\n                    contact.warmStartConstraint(step);\n                }\n            }\n            for (var i = 0; i < this.m_joints.length; ++i) {\n                var joint = this.m_joints[i];\n                joint.initVelocityConstraints(step);\n            }\n            // Solve velocity constraints\n            for (var i = 0; i < step.velocityIterations; ++i) {\n                for (var j = 0; j < this.m_joints.length; ++j) {\n                    var joint = this.m_joints[j];\n                    joint.solveVelocityConstraints(step);\n                }\n                for (var j = 0; j < this.m_contacts.length; ++j) {\n                    var contact = this.m_contacts[j];\n                    contact.solveVelocityConstraint(step);\n                }\n            }\n            // Store impulses for warm starting\n            for (var i = 0; i < this.m_contacts.length; ++i) {\n                var contact = this.m_contacts[i];\n                contact.storeConstraintImpulses(step);\n            }\n            // Integrate positions\n            for (var i = 0; i < this.m_bodies.length; ++i) {\n                var body = this.m_bodies[i];\n                var c = Vec2.clone(body.c_position.c);\n                var a = body.c_position.a;\n                var v = Vec2.clone(body.c_velocity.v);\n                var w = body.c_velocity.w;\n                // Check for large velocities\n                var translation = Vec2.mulNumVec2(h, v);\n                if (Vec2.lengthSquared(translation) > Settings.maxTranslationSquared) {\n                    var ratio = Settings.maxTranslation / translation.length();\n                    v.mul(ratio);\n                }\n                var rotation = h * w;\n                if (rotation * rotation > Settings.maxRotationSquared) {\n                    var ratio = Settings.maxRotation / math$1.abs(rotation);\n                    w *= ratio;\n                }\n                // Integrate\n                c.addMul(h, v);\n                a += h * w;\n                body.c_position.c.setVec2(c);\n                body.c_position.a = a;\n                body.c_velocity.v.setVec2(v);\n                body.c_velocity.w = w;\n            }\n            // Solve position constraints\n            var positionSolved = false;\n            for (var i = 0; i < step.positionIterations; ++i) {\n                var minSeparation = 0.0;\n                for (var j = 0; j < this.m_contacts.length; ++j) {\n                    var contact = this.m_contacts[j];\n                    var separation = contact.solvePositionConstraint(step);\n                    minSeparation = math$1.min(minSeparation, separation);\n                }\n                // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n                // push the separation above -Settings.linearSlop.\n                var contactsOkay = minSeparation >= -3.0 * Settings.linearSlop;\n                var jointsOkay = true;\n                for (var j = 0; j < this.m_joints.length; ++j) {\n                    var joint = this.m_joints[j];\n                    var jointOkay = joint.solvePositionConstraints(step);\n                    jointsOkay = jointsOkay && jointOkay;\n                }\n                if (contactsOkay && jointsOkay) {\n                    // Exit early if the position errors are small.\n                    positionSolved = true;\n                    break;\n                }\n            }\n            // Copy state buffers back to the bodies\n            for (var i = 0; i < this.m_bodies.length; ++i) {\n                var body = this.m_bodies[i];\n                body.m_sweep.c.setVec2(body.c_position.c);\n                body.m_sweep.a = body.c_position.a;\n                body.m_linearVelocity.setVec2(body.c_velocity.v);\n                body.m_angularVelocity = body.c_velocity.w;\n                body.synchronizeTransform();\n            }\n            this.postSolveIsland();\n            if (allowSleep) {\n                var minSleepTime = Infinity;\n                var linTolSqr = Settings.linearSleepToleranceSqr;\n                var angTolSqr = Settings.angularSleepToleranceSqr;\n                for (var i = 0; i < this.m_bodies.length; ++i) {\n                    var body = this.m_bodies[i];\n                    if (body.isStatic()) {\n                        continue;\n                    }\n                    if ((body.m_autoSleepFlag == false)\n                        || (body.m_angularVelocity * body.m_angularVelocity > angTolSqr)\n                        || (Vec2.lengthSquared(body.m_linearVelocity) > linTolSqr)) {\n                        body.m_sleepTime = 0.0;\n                        minSleepTime = 0.0;\n                    }\n                    else {\n                        body.m_sleepTime += h;\n                        minSleepTime = math$1.min(minSleepTime, body.m_sleepTime);\n                    }\n                }\n                if (minSleepTime >= Settings.timeToSleep && positionSolved) {\n                    for (var i = 0; i < this.m_bodies.length; ++i) {\n                        var body = this.m_bodies[i];\n                        body.setAwake(false);\n                    }\n                }\n            }\n        };\n        /** @internal */\n        Solver.prototype.printBodies = function (tag) {\n            for (var i = 0; i < this.m_bodies.length; ++i) {\n                var b = this.m_bodies[i];\n                common.debug(tag, b.c_position.a, b.c_position.c.x, b.c_position.c.y, b.c_velocity.w, b.c_velocity.v.x, b.c_velocity.v.y);\n            }\n        };\n        /**\n         * Find TOI contacts and solve them.\n         */\n        Solver.prototype.solveWorldTOI = function (step) {\n            var world = this.m_world;\n            if (world.m_stepComplete) {\n                for (var b = world.m_bodyList; b; b = b.m_next) {\n                    b.m_islandFlag = false;\n                    b.m_sweep.alpha0 = 0.0;\n                }\n                for (var c = world.m_contactList; c; c = c.m_next) {\n                    // Invalidate TOI\n                    c.m_toiFlag = false;\n                    c.m_islandFlag = false;\n                    c.m_toiCount = 0;\n                    c.m_toi = 1.0;\n                }\n            }\n            // Find TOI events and solve them.\n            while (true) {\n                // Find the first TOI.\n                var minContact = null; // Contact\n                var minAlpha = 1.0;\n                for (var c = world.m_contactList; c; c = c.m_next) {\n                    // Is this contact disabled?\n                    if (c.isEnabled() == false) {\n                        continue;\n                    }\n                    // Prevent excessive sub-stepping.\n                    if (c.m_toiCount > Settings.maxSubSteps) {\n                        continue;\n                    }\n                    var alpha = 1.0;\n                    if (c.m_toiFlag) {\n                        // This contact has a valid cached TOI.\n                        alpha = c.m_toi;\n                    }\n                    else {\n                        var fA_1 = c.getFixtureA();\n                        var fB_1 = c.getFixtureB();\n                        // Is there a sensor?\n                        if (fA_1.isSensor() || fB_1.isSensor()) {\n                            continue;\n                        }\n                        var bA_1 = fA_1.getBody();\n                        var bB_1 = fB_1.getBody();\n                        var activeA = bA_1.isAwake() && !bA_1.isStatic();\n                        var activeB = bB_1.isAwake() && !bB_1.isStatic();\n                        // Is at least one body active (awake and dynamic or kinematic)?\n                        if (activeA == false && activeB == false) {\n                            continue;\n                        }\n                        var collideA = bA_1.isBullet() || !bA_1.isDynamic();\n                        var collideB = bB_1.isBullet() || !bB_1.isDynamic();\n                        // Are these two non-bullet dynamic bodies?\n                        if (collideA == false && collideB == false) {\n                            continue;\n                        }\n                        // Compute the TOI for this contact.\n                        // Put the sweeps onto the same time interval.\n                        var alpha0 = bA_1.m_sweep.alpha0;\n                        if (bA_1.m_sweep.alpha0 < bB_1.m_sweep.alpha0) {\n                            alpha0 = bB_1.m_sweep.alpha0;\n                            bA_1.m_sweep.advance(alpha0);\n                        }\n                        else if (bB_1.m_sweep.alpha0 < bA_1.m_sweep.alpha0) {\n                            alpha0 = bA_1.m_sweep.alpha0;\n                            bB_1.m_sweep.advance(alpha0);\n                        }\n                        var indexA = c.getChildIndexA();\n                        var indexB = c.getChildIndexB();\n                        bA_1.m_sweep;\n                        bB_1.m_sweep;\n                        // Compute the time of impact in interval [0, minTOI]\n                        var input = new TOIInput(); // TODO: reuse\n                        input.proxyA.set(fA_1.getShape(), indexA);\n                        input.proxyB.set(fB_1.getShape(), indexB);\n                        input.sweepA.set(bA_1.m_sweep);\n                        input.sweepB.set(bB_1.m_sweep);\n                        input.tMax = 1.0;\n                        var output = new TOIOutput(); // TODO: reuse\n                        TimeOfImpact(output, input);\n                        // Beta is the fraction of the remaining portion of the [time?].\n                        var beta = output.t;\n                        if (output.state == TOIOutputState.e_touching) {\n                            alpha = math$1.min(alpha0 + (1.0 - alpha0) * beta, 1.0);\n                        }\n                        else {\n                            alpha = 1.0;\n                        }\n                        c.m_toi = alpha;\n                        c.m_toiFlag = true;\n                    }\n                    if (alpha < minAlpha) {\n                        // This is the minimum TOI found so far.\n                        minContact = c;\n                        minAlpha = alpha;\n                    }\n                }\n                if (minContact == null || 1.0 - 10.0 * math$1.EPSILON < minAlpha) {\n                    // No more TOI events. Done!\n                    world.m_stepComplete = true;\n                    break;\n                }\n                // Advance the bodies to the TOI.\n                var fA = minContact.getFixtureA();\n                var fB = minContact.getFixtureB();\n                var bA = fA.getBody();\n                var bB = fB.getBody();\n                var backup1 = bA.m_sweep.clone();\n                var backup2 = bB.m_sweep.clone();\n                bA.advance(minAlpha);\n                bB.advance(minAlpha);\n                // The TOI contact likely has some new contact points.\n                minContact.update(world);\n                minContact.m_toiFlag = false;\n                ++minContact.m_toiCount;\n                // Is the contact solid?\n                if (minContact.isEnabled() == false || minContact.isTouching() == false) {\n                    // Restore the sweeps.\n                    minContact.setEnabled(false);\n                    bA.m_sweep.set(backup1);\n                    bB.m_sweep.set(backup2);\n                    bA.synchronizeTransform();\n                    bB.synchronizeTransform();\n                    continue;\n                }\n                bA.setAwake(true);\n                bB.setAwake(true);\n                // Build the island\n                this.clear();\n                this.addBody(bA);\n                this.addBody(bB);\n                this.addContact(minContact);\n                bA.m_islandFlag = true;\n                bB.m_islandFlag = true;\n                minContact.m_islandFlag = true;\n                // Get contacts on bodyA and bodyB.\n                var bodies = [bA, bB];\n                for (var i = 0; i < bodies.length; ++i) {\n                    var body = bodies[i];\n                    if (body.isDynamic()) {\n                        for (var ce = body.m_contactList; ce; ce = ce.next) {\n                            // if (this.m_bodyCount == this.m_bodyCapacity) { break; }\n                            // if (this.m_contactCount == this.m_contactCapacity) { break; }\n                            var contact = ce.contact;\n                            // Has this contact already been added to the island?\n                            if (contact.m_islandFlag) {\n                                continue;\n                            }\n                            // Only add if either is static, kinematic or bullet.\n                            var other = ce.other;\n                            if (other.isDynamic() && !body.isBullet() && !other.isBullet()) {\n                                continue;\n                            }\n                            // Skip sensors.\n                            var sensorA = contact.m_fixtureA.m_isSensor;\n                            var sensorB = contact.m_fixtureB.m_isSensor;\n                            if (sensorA || sensorB) {\n                                continue;\n                            }\n                            // Tentatively advance the body to the TOI.\n                            var backup = other.m_sweep.clone();\n                            if (other.m_islandFlag == false) {\n                                other.advance(minAlpha);\n                            }\n                            // Update the contact points\n                            contact.update(world);\n                            // Was the contact disabled by the user?\n                            // Are there contact points?\n                            if (contact.isEnabled() == false || contact.isTouching() == false) {\n                                other.m_sweep.set(backup);\n                                other.synchronizeTransform();\n                                continue;\n                            }\n                            // Add the contact to the island\n                            contact.m_islandFlag = true;\n                            this.addContact(contact);\n                            // Has the other body already been added to the island?\n                            if (other.m_islandFlag) {\n                                continue;\n                            }\n                            // Add the other body to the island.\n                            other.m_islandFlag = true;\n                            if (!other.isStatic()) {\n                                other.setAwake(true);\n                            }\n                            this.addBody(other);\n                        }\n                    }\n                }\n                s_subStep.reset((1.0 - minAlpha) * step.dt);\n                s_subStep.dtRatio = 1.0;\n                s_subStep.positionIterations = 20;\n                s_subStep.velocityIterations = step.velocityIterations;\n                s_subStep.warmStarting = false;\n                this.solveIslandTOI(s_subStep, bA, bB);\n                // Reset island flags and synchronize broad-phase proxies.\n                for (var i = 0; i < this.m_bodies.length; ++i) {\n                    var body = this.m_bodies[i];\n                    body.m_islandFlag = false;\n                    if (!body.isDynamic()) {\n                        continue;\n                    }\n                    body.synchronizeFixtures();\n                    // Invalidate all contact TOIs on this displaced body.\n                    for (var ce = body.m_contactList; ce; ce = ce.next) {\n                        ce.contact.m_toiFlag = false;\n                        ce.contact.m_islandFlag = false;\n                    }\n                }\n                // Commit fixture proxy movements to the broad-phase so that new contacts\n                // are created.\n                // Also, some contacts can be destroyed.\n                world.findNewContacts();\n                if (world.m_subStepping) {\n                    world.m_stepComplete = false;\n                    break;\n                }\n            }\n            var b, c; \n        };\n        Solver.prototype.solveIslandTOI = function (subStep, toiA, toiB) {\n            this.m_world;\n            // Initialize the body state.\n            for (var i = 0; i < this.m_bodies.length; ++i) {\n                var body = this.m_bodies[i];\n                body.c_position.c.setVec2(body.m_sweep.c);\n                body.c_position.a = body.m_sweep.a;\n                body.c_velocity.v.setVec2(body.m_linearVelocity);\n                body.c_velocity.w = body.m_angularVelocity;\n            }\n            for (var i = 0; i < this.m_contacts.length; ++i) {\n                var contact = this.m_contacts[i];\n                contact.initConstraint(subStep);\n            }\n            // Solve position constraints.\n            for (var i = 0; i < subStep.positionIterations; ++i) {\n                var minSeparation = 0.0;\n                for (var j = 0; j < this.m_contacts.length; ++j) {\n                    var contact = this.m_contacts[j];\n                    var separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);\n                    minSeparation = math$1.min(minSeparation, separation);\n                }\n                // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n                // push the separation above -Settings.linearSlop.\n                var contactsOkay = minSeparation >= -1.5 * Settings.linearSlop;\n                if (contactsOkay) {\n                    break;\n                }\n            }\n            var i, c; \n            // Leap of faith to new safe state.\n            toiA.m_sweep.c0.setVec2(toiA.c_position.c);\n            toiA.m_sweep.a0 = toiA.c_position.a;\n            toiB.m_sweep.c0.setVec2(toiB.c_position.c);\n            toiB.m_sweep.a0 = toiB.c_position.a;\n            // No warm starting is needed for TOI events because warm\n            // starting impulses were applied in the discrete solver.\n            for (var i = 0; i < this.m_contacts.length; ++i) {\n                var contact = this.m_contacts[i];\n                contact.initVelocityConstraint(subStep);\n            }\n            // Solve velocity constraints.\n            for (var i = 0; i < subStep.velocityIterations; ++i) {\n                for (var j = 0; j < this.m_contacts.length; ++j) {\n                    var contact = this.m_contacts[j];\n                    contact.solveVelocityConstraint(subStep);\n                }\n            }\n            // Don't store the TOI contact forces for warm starting\n            // because they can be quite large.\n            var h = subStep.dt;\n            // Integrate positions\n            for (var i = 0; i < this.m_bodies.length; ++i) {\n                var body = this.m_bodies[i];\n                var c = Vec2.clone(body.c_position.c);\n                var a = body.c_position.a;\n                var v = Vec2.clone(body.c_velocity.v);\n                var w = body.c_velocity.w;\n                // Check for large velocities\n                var translation = Vec2.mulNumVec2(h, v);\n                if (Vec2.dot(translation, translation) > Settings.maxTranslationSquared) {\n                    var ratio = Settings.maxTranslation / translation.length();\n                    v.mul(ratio);\n                }\n                var rotation = h * w;\n                if (rotation * rotation > Settings.maxRotationSquared) {\n                    var ratio = Settings.maxRotation / math$1.abs(rotation);\n                    w *= ratio;\n                }\n                // Integrate\n                c.addMul(h, v);\n                a += h * w;\n                body.c_position.c = c;\n                body.c_position.a = a;\n                body.c_velocity.v = v;\n                body.c_velocity.w = w;\n                // Sync bodies\n                body.m_sweep.c = c;\n                body.m_sweep.a = a;\n                body.m_linearVelocity = v;\n                body.m_angularVelocity = w;\n                body.synchronizeTransform();\n            }\n            this.postSolveIsland();\n        };\n        /** @internal */\n        Solver.prototype.postSolveIsland = function () {\n            for (var c = 0; c < this.m_contacts.length; ++c) {\n                var contact = this.m_contacts[c];\n                this.m_world.postSolve(contact, contact.m_impulse);\n            }\n        };\n        return Solver;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var WorldDefDefault = {\n        gravity: Vec2.zero(),\n        allowSleep: true,\n        warmStarting: true,\n        continuousPhysics: true,\n        subStepping: false,\n        blockSolve: true,\n        velocityIterations: 8,\n        positionIterations: 3\n    };\n    var World = /** @class */ (function () {\n        /**\n         * @param def World definition or gravity vector.\n         */\n        function World(def) {\n            var _this = this;\n            /** @internal */\n            this.s_step = new TimeStep(); // reuse\n            /**\n             * @internal\n             * Callback for broad-phase.\n             */\n            this.createContact = function (proxyA, proxyB) {\n                var fixtureA = proxyA.fixture;\n                var fixtureB = proxyB.fixture;\n                var indexA = proxyA.childIndex;\n                var indexB = proxyB.childIndex;\n                var bodyA = fixtureA.getBody();\n                var bodyB = fixtureB.getBody();\n                // Are the fixtures on the same body?\n                if (bodyA == bodyB) {\n                    return;\n                }\n                // TODO_ERIN use a hash table to remove a potential bottleneck when both\n                // bodies have a lot of contacts.\n                // Does a contact already exist?\n                var edge = bodyB.getContactList(); // ContactEdge\n                while (edge) {\n                    if (edge.other == bodyA) {\n                        var fA = edge.contact.getFixtureA();\n                        var fB = edge.contact.getFixtureB();\n                        var iA = edge.contact.getChildIndexA();\n                        var iB = edge.contact.getChildIndexB();\n                        if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) {\n                            // A contact already exists.\n                            return;\n                        }\n                        if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) {\n                            // A contact already exists.\n                            return;\n                        }\n                    }\n                    edge = edge.next;\n                }\n                if (bodyB.shouldCollide(bodyA) == false) {\n                    return;\n                }\n                if (fixtureB.shouldCollide(fixtureA) == false) {\n                    return;\n                }\n                // Call the factory.\n                var contact = Contact.create(fixtureA, indexA, fixtureB, indexB);\n                if (contact == null) {\n                    return;\n                }\n                // Insert into the world.\n                contact.m_prev = null;\n                if (_this.m_contactList != null) {\n                    contact.m_next = _this.m_contactList;\n                    _this.m_contactList.m_prev = contact;\n                }\n                _this.m_contactList = contact;\n                ++_this.m_contactCount;\n            };\n            if (!(this instanceof World)) {\n                return new World(def);\n            }\n            if (def && Vec2.isValid(def)) {\n                def = { gravity: def };\n            }\n            def = options(def, WorldDefDefault);\n            this.m_solver = new Solver(this);\n            this.m_broadPhase = new BroadPhase();\n            this.m_contactList = null;\n            this.m_contactCount = 0;\n            this.m_bodyList = null;\n            this.m_bodyCount = 0;\n            this.m_jointList = null;\n            this.m_jointCount = 0;\n            this.m_stepComplete = true;\n            this.m_allowSleep = def.allowSleep;\n            this.m_gravity = Vec2.clone(def.gravity);\n            this.m_clearForces = true;\n            this.m_newFixture = false;\n            this.m_locked = false;\n            // These are for debugging the solver.\n            this.m_warmStarting = def.warmStarting;\n            this.m_continuousPhysics = def.continuousPhysics;\n            this.m_subStepping = def.subStepping;\n            this.m_blockSolve = def.blockSolve;\n            this.m_velocityIterations = def.velocityIterations;\n            this.m_positionIterations = def.positionIterations;\n            this.m_t = 0;\n        }\n        /** @internal */\n        World.prototype._serialize = function () {\n            var bodies = [];\n            var joints = [];\n            for (var b = this.getBodyList(); b; b = b.getNext()) {\n                bodies.push(b);\n            }\n            for (var j = this.getJointList(); j; j = j.getNext()) {\n                // @ts-ignore\n                if (typeof j._serialize === 'function') {\n                    joints.push(j);\n                }\n            }\n            return {\n                gravity: this.m_gravity,\n                bodies: bodies,\n                joints: joints,\n            };\n        };\n        /** @internal */\n        World._deserialize = function (data, context, restore) {\n            if (!data) {\n                return new World();\n            }\n            var world = new World(data.gravity);\n            if (data.bodies) {\n                for (var i = data.bodies.length - 1; i >= 0; i -= 1) {\n                    world._addBody(restore(Body, data.bodies[i], world));\n                }\n            }\n            if (data.joints) {\n                for (var i = data.joints.length - 1; i >= 0; i--) {\n                    world.createJoint(restore(Joint, data.joints[i], world));\n                }\n            }\n            return world;\n        };\n        /**\n         * Get the world body list. With the returned body, use Body.getNext to get the\n         * next body in the world list. A null body indicates the end of the list.\n         *\n         * @return the head of the world body list.\n         */\n        World.prototype.getBodyList = function () {\n            return this.m_bodyList;\n        };\n        /**\n         * Get the world joint list. With the returned joint, use Joint.getNext to get\n         * the next joint in the world list. A null joint indicates the end of the list.\n         *\n         * @return the head of the world joint list.\n         */\n        World.prototype.getJointList = function () {\n            return this.m_jointList;\n        };\n        /**\n         * Get the world contact list. With the returned contact, use Contact.getNext to\n         * get the next contact in the world list. A null contact indicates the end of\n         * the list.\n         *\n         * Warning: contacts are created and destroyed in the middle of a time step.\n         * Use ContactListener to avoid missing contacts.\n         *\n         * @return the head of the world contact list.\n         */\n        World.prototype.getContactList = function () {\n            return this.m_contactList;\n        };\n        World.prototype.getBodyCount = function () {\n            return this.m_bodyCount;\n        };\n        World.prototype.getJointCount = function () {\n            return this.m_jointCount;\n        };\n        /**\n         * Get the number of contacts (each may have 0 or more contact points).\n         */\n        World.prototype.getContactCount = function () {\n            return this.m_contactCount;\n        };\n        /**\n         * Change the global gravity vector.\n         */\n        World.prototype.setGravity = function (gravity) {\n            this.m_gravity = gravity;\n        };\n        /**\n         * Get the global gravity vector.\n         */\n        World.prototype.getGravity = function () {\n            return this.m_gravity;\n        };\n        /**\n         * Is the world locked (in the middle of a time step).\n         */\n        World.prototype.isLocked = function () {\n            return this.m_locked;\n        };\n        /**\n         * Enable/disable sleep.\n         */\n        World.prototype.setAllowSleeping = function (flag) {\n            if (flag == this.m_allowSleep) {\n                return;\n            }\n            this.m_allowSleep = flag;\n            if (this.m_allowSleep == false) {\n                for (var b = this.m_bodyList; b; b = b.m_next) {\n                    b.setAwake(true);\n                }\n            }\n        };\n        World.prototype.getAllowSleeping = function () {\n            return this.m_allowSleep;\n        };\n        /**\n         * Enable/disable warm starting. For testing.\n         */\n        World.prototype.setWarmStarting = function (flag) {\n            this.m_warmStarting = flag;\n        };\n        World.prototype.getWarmStarting = function () {\n            return this.m_warmStarting;\n        };\n        /**\n         * Enable/disable continuous physics. For testing.\n         */\n        World.prototype.setContinuousPhysics = function (flag) {\n            this.m_continuousPhysics = flag;\n        };\n        World.prototype.getContinuousPhysics = function () {\n            return this.m_continuousPhysics;\n        };\n        /**\n         * Enable/disable single stepped continuous physics. For testing.\n         */\n        World.prototype.setSubStepping = function (flag) {\n            this.m_subStepping = flag;\n        };\n        World.prototype.getSubStepping = function () {\n            return this.m_subStepping;\n        };\n        /**\n         * Set flag to control automatic clearing of forces after each time step.\n         */\n        World.prototype.setAutoClearForces = function (flag) {\n            this.m_clearForces = flag;\n        };\n        /**\n         * Get the flag that controls automatic clearing of forces after each time step.\n         */\n        World.prototype.getAutoClearForces = function () {\n            return this.m_clearForces;\n        };\n        /**\n         * Manually clear the force buffer on all bodies. By default, forces are cleared\n         * automatically after each call to step. The default behavior is modified by\n         * calling setAutoClearForces. The purpose of this function is to support\n         * sub-stepping. Sub-stepping is often used to maintain a fixed sized time step\n         * under a variable frame-rate. When you perform sub-stepping you will disable\n         * auto clearing of forces and instead call clearForces after all sub-steps are\n         * complete in one pass of your game loop.\n         *\n         * See {@link World.setAutoClearForces}\n         */\n        World.prototype.clearForces = function () {\n            for (var body = this.m_bodyList; body; body = body.getNext()) {\n                body.m_force.setZero();\n                body.m_torque = 0.0;\n            }\n        };\n        /**\n         * Query the world for all fixtures that potentially overlap the provided AABB.\n         *\n         * @param aabb The query box.\n         * @param callback Called for each fixture found in the query AABB. It may return `false` to terminate the query.\n         */\n        World.prototype.queryAABB = function (aabb, callback) {\n            var broadPhase = this.m_broadPhase;\n            this.m_broadPhase.query(aabb, function (proxyId) {\n                var proxy = broadPhase.getUserData(proxyId);\n                return callback(proxy.fixture);\n            });\n        };\n        /**\n         * Ray-cast the world for all fixtures in the path of the ray. Your callback\n         * controls whether you get the closest point, any point, or n-points. The\n         * ray-cast ignores shapes that contain the starting point.\n         *\n         * @param point1 The ray starting point\n         * @param point2 The ray ending point\n         * @param callback A user implemented callback function.\n         */\n        World.prototype.rayCast = function (point1, point2, callback) {\n            var broadPhase = this.m_broadPhase;\n            this.m_broadPhase.rayCast({\n                maxFraction: 1.0,\n                p1: point1,\n                p2: point2\n            }, function (input, proxyId) {\n                var proxy = broadPhase.getUserData(proxyId);\n                var fixture = proxy.fixture;\n                var index = proxy.childIndex;\n                // @ts-ignore\n                var output = {}; // TODO GC\n                var hit = fixture.rayCast(output, input, index);\n                if (hit) {\n                    var fraction = output.fraction;\n                    var point = Vec2.add(Vec2.mulNumVec2((1.0 - fraction), input.p1), Vec2.mulNumVec2(fraction, input.p2));\n                    return callback(fixture, point, output.normal, fraction);\n                }\n                return input.maxFraction;\n            });\n        };\n        /**\n         * Get the number of broad-phase proxies.\n         */\n        World.prototype.getProxyCount = function () {\n            return this.m_broadPhase.getProxyCount();\n        };\n        /**\n         * Get the height of broad-phase dynamic tree.\n         */\n        World.prototype.getTreeHeight = function () {\n            return this.m_broadPhase.getTreeHeight();\n        };\n        /**\n         * Get the balance of broad-phase dynamic tree.\n         */\n        World.prototype.getTreeBalance = function () {\n            return this.m_broadPhase.getTreeBalance();\n        };\n        /**\n         * Get the quality metric of broad-phase dynamic tree. The smaller the better.\n         * The minimum is 1.\n         */\n        World.prototype.getTreeQuality = function () {\n            return this.m_broadPhase.getTreeQuality();\n        };\n        /**\n         * Shift the world origin. Useful for large worlds. The body shift formula is:\n         * position -= newOrigin\n         *\n         * @param newOrigin The new origin with respect to the old origin\n         */\n        World.prototype.shiftOrigin = function (newOrigin) {\n            if (this.m_locked) {\n                return;\n            }\n            for (var b = this.m_bodyList; b; b = b.m_next) {\n                b.m_xf.p.sub(newOrigin);\n                b.m_sweep.c0.sub(newOrigin);\n                b.m_sweep.c.sub(newOrigin);\n            }\n            for (var j = this.m_jointList; j; j = j.m_next) {\n                j.shiftOrigin(newOrigin);\n            }\n            this.m_broadPhase.shiftOrigin(newOrigin);\n        };\n        /**\n         * @internal Used for deserialize.\n         */\n        World.prototype._addBody = function (body) {\n            if (this.isLocked()) {\n                return;\n            }\n            // Add to world doubly linked list.\n            body.m_prev = null;\n            body.m_next = this.m_bodyList;\n            if (this.m_bodyList) {\n                this.m_bodyList.m_prev = body;\n            }\n            this.m_bodyList = body;\n            ++this.m_bodyCount;\n        };\n        // tslint:disable-next-line:typedef\n        World.prototype.createBody = function (arg1, arg2) {\n            if (this.isLocked()) {\n                return null;\n            }\n            var def = {};\n            if (!arg1) ;\n            else if (Vec2.isValid(arg1)) {\n                def = { position: arg1, angle: arg2 };\n            }\n            else if (typeof arg1 === 'object') {\n                def = arg1;\n            }\n            var body = new Body(this, def);\n            this._addBody(body);\n            return body;\n        };\n        // tslint:disable-next-line:typedef\n        World.prototype.createDynamicBody = function (arg1, arg2) {\n            var def = {};\n            if (!arg1) ;\n            else if (Vec2.isValid(arg1)) {\n                def = { position: arg1, angle: arg2 };\n            }\n            else if (typeof arg1 === 'object') {\n                def = arg1;\n            }\n            def.type = 'dynamic';\n            return this.createBody(def);\n        };\n        // tslint:disable-next-line:typedef\n        World.prototype.createKinematicBody = function (arg1, arg2) {\n            var def = {};\n            if (!arg1) ;\n            else if (Vec2.isValid(arg1)) {\n                def = { position: arg1, angle: arg2 };\n            }\n            else if (typeof arg1 === 'object') {\n                def = arg1;\n            }\n            def.type = 'kinematic';\n            return this.createBody(def);\n        };\n        /**\n         * Destroy a rigid body given a definition. No reference to the definition is\n         * retained.\n         *\n         * Warning: This automatically deletes all associated shapes and joints.\n         *\n         * Warning: This function is locked during callbacks.\n         */\n        World.prototype.destroyBody = function (b) {\n            if (this.isLocked()) {\n                return;\n            }\n            if (b.m_destroyed) {\n                return false;\n            }\n            // Delete the attached joints.\n            var je = b.m_jointList;\n            while (je) {\n                var je0 = je;\n                je = je.next;\n                this.publish('remove-joint', je0.joint);\n                this.destroyJoint(je0.joint);\n                b.m_jointList = je;\n            }\n            b.m_jointList = null;\n            // Delete the attached contacts.\n            var ce = b.m_contactList;\n            while (ce) {\n                var ce0 = ce;\n                ce = ce.next;\n                this.destroyContact(ce0.contact);\n                b.m_contactList = ce;\n            }\n            b.m_contactList = null;\n            // Delete the attached fixtures. This destroys broad-phase proxies.\n            var f = b.m_fixtureList;\n            while (f) {\n                var f0 = f;\n                f = f.m_next;\n                this.publish('remove-fixture', f0);\n                f0.destroyProxies(this.m_broadPhase);\n                b.m_fixtureList = f;\n            }\n            b.m_fixtureList = null;\n            // Remove world body list.\n            if (b.m_prev) {\n                b.m_prev.m_next = b.m_next;\n            }\n            if (b.m_next) {\n                b.m_next.m_prev = b.m_prev;\n            }\n            if (b == this.m_bodyList) {\n                this.m_bodyList = b.m_next;\n            }\n            b.m_destroyed = true;\n            --this.m_bodyCount;\n            this.publish('remove-body', b);\n            return true;\n        };\n        /**\n         * Create a joint to constrain bodies together. No reference to the definition\n         * is retained. This may cause the connected bodies to cease colliding.\n         *\n         * Warning: This function is locked during callbacks.\n         */\n        World.prototype.createJoint = function (joint) {\n            if (this.isLocked()) {\n                return null;\n            }\n            // Connect to the world list.\n            joint.m_prev = null;\n            joint.m_next = this.m_jointList;\n            if (this.m_jointList) {\n                this.m_jointList.m_prev = joint;\n            }\n            this.m_jointList = joint;\n            ++this.m_jointCount;\n            // Connect to the bodies' doubly linked lists.\n            joint.m_edgeA.joint = joint;\n            joint.m_edgeA.other = joint.m_bodyB;\n            joint.m_edgeA.prev = null;\n            joint.m_edgeA.next = joint.m_bodyA.m_jointList;\n            if (joint.m_bodyA.m_jointList)\n                joint.m_bodyA.m_jointList.prev = joint.m_edgeA;\n            joint.m_bodyA.m_jointList = joint.m_edgeA;\n            joint.m_edgeB.joint = joint;\n            joint.m_edgeB.other = joint.m_bodyA;\n            joint.m_edgeB.prev = null;\n            joint.m_edgeB.next = joint.m_bodyB.m_jointList;\n            if (joint.m_bodyB.m_jointList)\n                joint.m_bodyB.m_jointList.prev = joint.m_edgeB;\n            joint.m_bodyB.m_jointList = joint.m_edgeB;\n            // If the joint prevents collisions, then flag any contacts for filtering.\n            if (joint.m_collideConnected == false) {\n                for (var edge = joint.m_bodyB.getContactList(); edge; edge = edge.next) {\n                    if (edge.other == joint.m_bodyA) {\n                        // Flag the contact for filtering at the next time step (where either\n                        // body is awake).\n                        edge.contact.flagForFiltering();\n                    }\n                }\n            }\n            // Note: creating a joint doesn't wake the bodies.\n            return joint;\n        };\n        /**\n         * Destroy a joint. This may cause the connected bodies to begin colliding.\n         * Warning: This function is locked during callbacks.\n         */\n        World.prototype.destroyJoint = function (joint) {\n            if (this.isLocked()) {\n                return;\n            }\n            // Remove from the doubly linked list.\n            if (joint.m_prev) {\n                joint.m_prev.m_next = joint.m_next;\n            }\n            if (joint.m_next) {\n                joint.m_next.m_prev = joint.m_prev;\n            }\n            if (joint == this.m_jointList) {\n                this.m_jointList = joint.m_next;\n            }\n            // Disconnect from bodies.\n            var bodyA = joint.m_bodyA;\n            var bodyB = joint.m_bodyB;\n            // Wake up connected bodies.\n            bodyA.setAwake(true);\n            bodyB.setAwake(true);\n            // Remove from body 1.\n            if (joint.m_edgeA.prev) {\n                joint.m_edgeA.prev.next = joint.m_edgeA.next;\n            }\n            if (joint.m_edgeA.next) {\n                joint.m_edgeA.next.prev = joint.m_edgeA.prev;\n            }\n            if (joint.m_edgeA == bodyA.m_jointList) {\n                bodyA.m_jointList = joint.m_edgeA.next;\n            }\n            joint.m_edgeA.prev = null;\n            joint.m_edgeA.next = null;\n            // Remove from body 2\n            if (joint.m_edgeB.prev) {\n                joint.m_edgeB.prev.next = joint.m_edgeB.next;\n            }\n            if (joint.m_edgeB.next) {\n                joint.m_edgeB.next.prev = joint.m_edgeB.prev;\n            }\n            if (joint.m_edgeB == bodyB.m_jointList) {\n                bodyB.m_jointList = joint.m_edgeB.next;\n            }\n            joint.m_edgeB.prev = null;\n            joint.m_edgeB.next = null;\n            --this.m_jointCount;\n            // If the joint prevents collisions, then flag any contacts for filtering.\n            if (joint.m_collideConnected == false) {\n                var edge = bodyB.getContactList();\n                while (edge) {\n                    if (edge.other == bodyA) {\n                        // Flag the contact for filtering at the next time step (where either\n                        // body is awake).\n                        edge.contact.flagForFiltering();\n                    }\n                    edge = edge.next;\n                }\n            }\n            this.publish('remove-joint', joint);\n        };\n        /**\n         * Take a time step. This performs collision detection, integration, and\n         * constraint solution.\n         *\n         * Broad-phase, narrow-phase, solve and solve time of impacts.\n         *\n         * @param timeStep Time step, this should not vary.\n         */\n        World.prototype.step = function (timeStep, velocityIterations, positionIterations) {\n            this.publish('pre-step', timeStep);\n            if ((velocityIterations | 0) !== velocityIterations) {\n                // TODO: remove this in future\n                velocityIterations = 0;\n            }\n            velocityIterations = velocityIterations || this.m_velocityIterations;\n            positionIterations = positionIterations || this.m_positionIterations;\n            // If new fixtures were added, we need to find the new contacts.\n            if (this.m_newFixture) {\n                this.findNewContacts();\n                this.m_newFixture = false;\n            }\n            this.m_locked = true;\n            this.s_step.reset(timeStep);\n            this.s_step.velocityIterations = velocityIterations;\n            this.s_step.positionIterations = positionIterations;\n            this.s_step.warmStarting = this.m_warmStarting;\n            this.s_step.blockSolve = this.m_blockSolve;\n            // Update contacts. This is where some contacts are destroyed.\n            this.updateContacts();\n            // Integrate velocities, solve velocity constraints, and integrate positions.\n            if (this.m_stepComplete && timeStep > 0.0) {\n                this.m_solver.solveWorld(this.s_step);\n                // Synchronize fixtures, check for out of range bodies.\n                for (var b = this.m_bodyList; b; b = b.getNext()) {\n                    // If a body was not in an island then it did not move.\n                    if (b.m_islandFlag == false) {\n                        continue;\n                    }\n                    if (b.isStatic()) {\n                        continue;\n                    }\n                    // Update fixtures (for broad-phase).\n                    b.synchronizeFixtures();\n                }\n                // Look for new contacts.\n                this.findNewContacts();\n            }\n            // Handle TOI events.\n            if (this.m_continuousPhysics && timeStep > 0.0) {\n                this.m_solver.solveWorldTOI(this.s_step);\n            }\n            if (this.m_clearForces) {\n                this.clearForces();\n            }\n            this.m_locked = false;\n            this.publish('post-step', timeStep);\n        };\n        /**\n         * @internal\n         * Call this method to find new contacts.\n         */\n        World.prototype.findNewContacts = function () {\n            this.m_broadPhase.updatePairs(this.createContact);\n        };\n        /**\n         * @internal\n         * Removes old non-overlapping contacts, applies filters and updates contacts.\n         */\n        World.prototype.updateContacts = function () {\n            // Update awake contacts.\n            var c;\n            var next_c = this.m_contactList;\n            while (c = next_c) {\n                next_c = c.getNext();\n                var fixtureA = c.getFixtureA();\n                var fixtureB = c.getFixtureB();\n                var indexA = c.getChildIndexA();\n                var indexB = c.getChildIndexB();\n                var bodyA = fixtureA.getBody();\n                var bodyB = fixtureB.getBody();\n                // Is this contact flagged for filtering?\n                if (c.m_filterFlag) {\n                    if (bodyB.shouldCollide(bodyA) == false) {\n                        this.destroyContact(c);\n                        continue;\n                    }\n                    if (fixtureB.shouldCollide(fixtureA) == false) {\n                        this.destroyContact(c);\n                        continue;\n                    }\n                    // Clear the filtering flag.\n                    c.m_filterFlag = false;\n                }\n                var activeA = bodyA.isAwake() && !bodyA.isStatic();\n                var activeB = bodyB.isAwake() && !bodyB.isStatic();\n                // At least one body must be awake and it must be dynamic or kinematic.\n                if (activeA == false && activeB == false) {\n                    continue;\n                }\n                var proxyIdA = fixtureA.m_proxies[indexA].proxyId;\n                var proxyIdB = fixtureB.m_proxies[indexB].proxyId;\n                var overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);\n                // Here we destroy contacts that cease to overlap in the broad-phase.\n                if (overlap == false) {\n                    this.destroyContact(c);\n                    continue;\n                }\n                // The contact persists.\n                c.update(this);\n            }\n        };\n        /**\n         * @internal\n         */\n        World.prototype.destroyContact = function (contact) {\n            Contact.destroy(contact, this);\n            // Remove from the world.\n            if (contact.m_prev) {\n                contact.m_prev.m_next = contact.m_next;\n            }\n            if (contact.m_next) {\n                contact.m_next.m_prev = contact.m_prev;\n            }\n            if (contact == this.m_contactList) {\n                this.m_contactList = contact.m_next;\n            }\n            --this.m_contactCount;\n        };\n        /**\n         * Register an event listener.\n         */\n        // tslint:disable-next-line:typedef\n        World.prototype.on = function (name, listener) {\n            if (typeof name !== 'string' || typeof listener !== 'function') {\n                return this;\n            }\n            if (!this._listeners) {\n                this._listeners = {};\n            }\n            if (!this._listeners[name]) {\n                this._listeners[name] = [];\n            }\n            this._listeners[name].push(listener);\n            return this;\n        };\n        /**\n         * Remove an event listener.\n         */\n        // tslint:disable-next-line:typedef\n        World.prototype.off = function (name, listener) {\n            if (typeof name !== 'string' || typeof listener !== 'function') {\n                return this;\n            }\n            var listeners = this._listeners && this._listeners[name];\n            if (!listeners || !listeners.length) {\n                return this;\n            }\n            var index = listeners.indexOf(listener);\n            if (index >= 0) {\n                listeners.splice(index, 1);\n            }\n            return this;\n        };\n        World.prototype.publish = function (name, arg1, arg2, arg3) {\n            var listeners = this._listeners && this._listeners[name];\n            if (!listeners || !listeners.length) {\n                return 0;\n            }\n            for (var l = 0; l < listeners.length; l++) {\n                listeners[l].call(this, arg1, arg2, arg3);\n            }\n            return listeners.length;\n        };\n        /**\n         * @internal\n         */\n        World.prototype.beginContact = function (contact) {\n            this.publish('begin-contact', contact);\n        };\n        /**\n         * @internal\n         */\n        World.prototype.endContact = function (contact) {\n            this.publish('end-contact', contact);\n        };\n        /**\n         * @internal\n         */\n        World.prototype.preSolve = function (contact, oldManifold) {\n            this.publish('pre-solve', contact, oldManifold);\n        };\n        /**\n         * @internal\n         */\n        World.prototype.postSolve = function (contact, impulse) {\n            this.publish('post-solve', contact, impulse);\n        };\n        return World;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var Vec3 = /** @class */ (function () {\n        // tslint:disable-next-line:typedef\n        function Vec3(x, y, z) {\n            if (!(this instanceof Vec3)) {\n                return new Vec3(x, y, z);\n            }\n            if (typeof x === 'undefined') {\n                this.x = 0;\n                this.y = 0;\n                this.z = 0;\n            }\n            else if (typeof x === 'object') {\n                this.x = x.x;\n                this.y = x.y;\n                this.z = x.z;\n            }\n            else {\n                this.x = x;\n                this.y = y;\n                this.z = z;\n            }\n        }\n        /** @internal */\n        Vec3.prototype._serialize = function () {\n            return {\n                x: this.x,\n                y: this.y,\n                z: this.z\n            };\n        };\n        /** @internal */\n        Vec3._deserialize = function (data) {\n            var obj = Object.create(Vec3.prototype);\n            obj.x = data.x;\n            obj.y = data.y;\n            obj.z = data.z;\n            return obj;\n        };\n        /** @internal */\n        Vec3.neo = function (x, y, z) {\n            var obj = Object.create(Vec3.prototype);\n            obj.x = x;\n            obj.y = y;\n            obj.z = z;\n            return obj;\n        };\n        Vec3.zero = function () {\n            var obj = Object.create(Vec3.prototype);\n            obj.x = 0;\n            obj.y = 0;\n            obj.z = 0;\n            return obj;\n        };\n        Vec3.clone = function (v) {\n            return Vec3.neo(v.x, v.y, v.z);\n        };\n        /** @internal */\n        Vec3.prototype.toString = function () {\n            return JSON.stringify(this);\n        };\n        /**\n         * Does this vector contain finite coordinates?\n         */\n        Vec3.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return math$1.isFinite(obj.x) && math$1.isFinite(obj.y) && math$1.isFinite(obj.z);\n        };\n        Vec3.assert = function (o) {\n            return;\n        };\n        Vec3.prototype.setZero = function () {\n            this.x = 0.0;\n            this.y = 0.0;\n            this.z = 0.0;\n            return this;\n        };\n        Vec3.prototype.set = function (x, y, z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            return this;\n        };\n        Vec3.prototype.add = function (w) {\n            this.x += w.x;\n            this.y += w.y;\n            this.z += w.z;\n            return this;\n        };\n        Vec3.prototype.sub = function (w) {\n            this.x -= w.x;\n            this.y -= w.y;\n            this.z -= w.z;\n            return this;\n        };\n        Vec3.prototype.mul = function (m) {\n            this.x *= m;\n            this.y *= m;\n            this.z *= m;\n            return this;\n        };\n        Vec3.areEqual = function (v, w) {\n            return v === w ||\n                typeof v === 'object' && v !== null &&\n                    typeof w === 'object' && w !== null &&\n                    v.x === w.x && v.y === w.y && v.z === w.z;\n        };\n        /**\n         * Perform the dot product on two vectors.\n         */\n        Vec3.dot = function (v, w) {\n            return v.x * w.x + v.y * w.y + v.z * w.z;\n        };\n        /**\n         * Perform the cross product on two vectors. In 2D this produces a scalar.\n         */\n        Vec3.cross = function (v, w) {\n            return new Vec3(v.y * w.z - v.z * w.y, v.z * w.x - v.x * w.z, v.x * w.y - v.y * w.x);\n        };\n        Vec3.add = function (v, w) {\n            return new Vec3(v.x + w.x, v.y + w.y, v.z + w.z);\n        };\n        Vec3.sub = function (v, w) {\n            return new Vec3(v.x - w.x, v.y - w.y, v.z - w.z);\n        };\n        Vec3.mul = function (v, m) {\n            return new Vec3(m * v.x, m * v.y, m * v.z);\n        };\n        Vec3.prototype.neg = function () {\n            this.x = -this.x;\n            this.y = -this.y;\n            this.z = -this.z;\n            return this;\n        };\n        Vec3.neg = function (v) {\n            return new Vec3(-v.x, -v.y, -v.z);\n        };\n        return Vec3;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A line segment (edge) shape. These can be connected in chains or loops to\n     * other edge shapes. The connectivity information is used to ensure correct\n     * contact normals.\n     */\n    var EdgeShape = /** @class */ (function (_super) {\n        __extends(EdgeShape, _super);\n        function EdgeShape(v1, v2) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof EdgeShape)) {\n                return new EdgeShape(v1, v2);\n            }\n            _this = _super.call(this) || this;\n            _this.m_type = EdgeShape.TYPE;\n            _this.m_radius = Settings.polygonRadius;\n            _this.m_vertex1 = v1 ? Vec2.clone(v1) : Vec2.zero();\n            _this.m_vertex2 = v2 ? Vec2.clone(v2) : Vec2.zero();\n            _this.m_vertex0 = Vec2.zero();\n            _this.m_vertex3 = Vec2.zero();\n            _this.m_hasVertex0 = false;\n            _this.m_hasVertex3 = false;\n            return _this;\n        }\n        /** @internal */\n        EdgeShape.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                vertex1: this.m_vertex1,\n                vertex2: this.m_vertex2,\n                vertex0: this.m_vertex0,\n                vertex3: this.m_vertex3,\n                hasVertex0: this.m_hasVertex0,\n                hasVertex3: this.m_hasVertex3,\n            };\n        };\n        /** @internal */\n        EdgeShape._deserialize = function (data) {\n            var shape = new EdgeShape(data.vertex1, data.vertex2);\n            if (shape.m_hasVertex0) {\n                shape.setPrevVertex(data.vertex0);\n            }\n            if (shape.m_hasVertex3) {\n                shape.setNextVertex(data.vertex3);\n            }\n            return shape;\n        };\n        /** @internal @deprecated */\n        EdgeShape.prototype.setNext = function (v) {\n            return this.setNextVertex(v);\n        };\n        /**\n         * Optional next vertex, used for smooth collision.\n         */\n        EdgeShape.prototype.setNextVertex = function (v) {\n            if (v) {\n                this.m_vertex3.setVec2(v);\n                this.m_hasVertex3 = true;\n            }\n            else {\n                this.m_vertex3.setZero();\n                this.m_hasVertex3 = false;\n            }\n            return this;\n        };\n        /**\n         * Optional next vertex, used for smooth collision.\n         */\n        EdgeShape.prototype.getNextVertex = function () {\n            return this.m_vertex3;\n        };\n        /** @internal @deprecated */\n        EdgeShape.prototype.setPrev = function (v) {\n            return this.setPrevVertex(v);\n        };\n        /**\n         * Optional prev vertex, used for smooth collision.\n         */\n        EdgeShape.prototype.setPrevVertex = function (v) {\n            if (v) {\n                this.m_vertex0.setVec2(v);\n                this.m_hasVertex0 = true;\n            }\n            else {\n                this.m_vertex0.setZero();\n                this.m_hasVertex0 = false;\n            }\n            return this;\n        };\n        /**\n         * Optional prev vertex, used for smooth collision.\n         */\n        EdgeShape.prototype.getPrevVertex = function () {\n            return this.m_vertex0;\n        };\n        /**\n         * Set this as an isolated edge.\n         */\n        EdgeShape.prototype._set = function (v1, v2) {\n            this.m_vertex1.setVec2(v1);\n            this.m_vertex2.setVec2(v2);\n            this.m_hasVertex0 = false;\n            this.m_hasVertex3 = false;\n            return this;\n        };\n        /**\n         * @internal\n         * @deprecated Shapes should be treated as immutable.\n         *\n         * clone the concrete shape.\n         */\n        EdgeShape.prototype._clone = function () {\n            var clone = new EdgeShape();\n            clone.m_type = this.m_type;\n            clone.m_radius = this.m_radius;\n            clone.m_vertex1.setVec2(this.m_vertex1);\n            clone.m_vertex2.setVec2(this.m_vertex2);\n            clone.m_vertex0.setVec2(this.m_vertex0);\n            clone.m_vertex3.setVec2(this.m_vertex3);\n            clone.m_hasVertex0 = this.m_hasVertex0;\n            clone.m_hasVertex3 = this.m_hasVertex3;\n            return clone;\n        };\n        /**\n         * Get the number of child primitives.\n         */\n        EdgeShape.prototype.getChildCount = function () {\n            return 1;\n        };\n        /**\n         * Test a point for containment in this shape. This only works for convex\n         * shapes.\n         *\n         * @param xf The shape world transform.\n         * @param p A point in world coordinates.\n         */\n        EdgeShape.prototype.testPoint = function (xf, p) {\n            return false;\n        };\n        /**\n         * Cast a ray against a child shape.\n         *\n         * @param output The ray-cast results.\n         * @param input The ray-cast input parameters.\n         * @param xf The transform to be applied to the shape.\n         * @param childIndex The child shape index\n         */\n        EdgeShape.prototype.rayCast = function (output, input, xf, childIndex) {\n            // p = p1 + t * d\n            // v = v1 + s * e\n            // p1 + t * d = v1 + s * e\n            // s * e - t * d = p1 - v1\n            // NOT_USED(childIndex);\n            // Put the ray into the edge's frame of reference.\n            var p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n            var p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n            var d = Vec2.sub(p2, p1);\n            var v1 = this.m_vertex1;\n            var v2 = this.m_vertex2;\n            var e = Vec2.sub(v2, v1);\n            var normal = Vec2.neo(e.y, -e.x);\n            normal.normalize();\n            // q = p1 + t * d\n            // dot(normal, q - v1) = 0\n            // dot(normal, p1 - v1) + t * dot(normal, d) = 0\n            var numerator = Vec2.dot(normal, Vec2.sub(v1, p1));\n            var denominator = Vec2.dot(normal, d);\n            if (denominator == 0.0) {\n                return false;\n            }\n            var t = numerator / denominator;\n            if (t < 0.0 || input.maxFraction < t) {\n                return false;\n            }\n            var q = Vec2.add(p1, Vec2.mulNumVec2(t, d));\n            // q = v1 + s * r\n            // s = dot(q - v1, r) / dot(r, r)\n            var r = Vec2.sub(v2, v1);\n            var rr = Vec2.dot(r, r);\n            if (rr == 0.0) {\n                return false;\n            }\n            var s = Vec2.dot(Vec2.sub(q, v1), r) / rr;\n            if (s < 0.0 || 1.0 < s) {\n                return false;\n            }\n            output.fraction = t;\n            if (numerator > 0.0) {\n                output.normal = Rot.mulVec2(xf.q, normal).neg();\n            }\n            else {\n                output.normal = Rot.mulVec2(xf.q, normal);\n            }\n            return true;\n        };\n        /**\n         * Given a transform, compute the associated axis aligned bounding box for a\n         * child shape.\n         *\n         * @param aabb Returns the axis aligned box.\n         * @param xf The world transform of the shape.\n         * @param childIndex The child shape\n         */\n        EdgeShape.prototype.computeAABB = function (aabb, xf, childIndex) {\n            var v1 = Transform.mulVec2(xf, this.m_vertex1);\n            var v2 = Transform.mulVec2(xf, this.m_vertex2);\n            aabb.combinePoints(v1, v2);\n            aabb.extend(this.m_radius);\n        };\n        /**\n         * Compute the mass properties of this shape using its dimensions and density.\n         * The inertia tensor is computed about the local origin.\n         *\n         * @param massData Returns the mass data for this shape.\n         * @param density The density in kilograms per meter squared.\n         */\n        EdgeShape.prototype.computeMass = function (massData, density) {\n            massData.mass = 0.0;\n            massData.center.setCombine(0.5, this.m_vertex1, 0.5, this.m_vertex2);\n            massData.I = 0.0;\n        };\n        EdgeShape.prototype.computeDistanceProxy = function (proxy) {\n            proxy.m_vertices.push(this.m_vertex1);\n            proxy.m_vertices.push(this.m_vertex2);\n            proxy.m_count = 2;\n            proxy.m_radius = this.m_radius;\n        };\n        EdgeShape.TYPE = 'edge';\n        return EdgeShape;\n    }(Shape));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A chain shape is a free form sequence of line segments. The chain has\n     * two-sided collision, so you can use inside and outside collision. Therefore,\n     * you may use any winding order. Connectivity information is used to create\n     * smooth collisions.\n     *\n     * WARNING: The chain will not collide properly if there are self-intersections.\n     */\n    var ChainShape = /** @class */ (function (_super) {\n        __extends(ChainShape, _super);\n        function ChainShape(vertices, loop) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof ChainShape)) {\n                return new ChainShape(vertices, loop);\n            }\n            _this = _super.call(this) || this;\n            _this.m_type = ChainShape.TYPE;\n            _this.m_radius = Settings.polygonRadius;\n            _this.m_vertices = [];\n            _this.m_count = 0;\n            _this.m_prevVertex = null;\n            _this.m_nextVertex = null;\n            _this.m_hasPrevVertex = false;\n            _this.m_hasNextVertex = false;\n            _this.m_isLoop = !!loop;\n            if (vertices && vertices.length) {\n                if (loop) {\n                    _this._createLoop(vertices);\n                }\n                else {\n                    _this._createChain(vertices);\n                }\n            }\n            return _this;\n        }\n        /** @internal */\n        ChainShape.prototype._serialize = function () {\n            var data = {\n                type: this.m_type,\n                vertices: this.m_vertices,\n                isLoop: this.m_isLoop,\n                hasPrevVertex: this.m_hasPrevVertex,\n                hasNextVertex: this.m_hasNextVertex,\n                prevVertex: null,\n                nextVertex: null,\n            };\n            if (this.m_prevVertex) {\n                data.prevVertex = this.m_prevVertex;\n            }\n            if (this.m_nextVertex) {\n                data.nextVertex = this.m_nextVertex;\n            }\n            return data;\n        };\n        /** @internal */\n        ChainShape._deserialize = function (data, fixture, restore) {\n            var vertices = [];\n            if (data.vertices) {\n                for (var i = 0; i < data.vertices.length; i++) {\n                    vertices.push(restore(Vec2, data.vertices[i]));\n                }\n            }\n            var shape = new ChainShape(vertices, data.isLoop);\n            if (data.prevVertex) {\n                shape.setPrevVertex(data.prevVertex);\n            }\n            if (data.nextVertex) {\n                shape.setNextVertex(data.nextVertex);\n            }\n            return shape;\n        };\n        // clear() {\n        //   this.m_vertices.length = 0;\n        //   this.m_count = 0;\n        // }\n        /**\n         * @internal\n         * Create a loop. This automatically adjusts connectivity.\n         *\n         * @param vertices an array of vertices, these are copied\n         * @param count the vertex count\n         */\n        ChainShape.prototype._createLoop = function (vertices) {\n            for (var i = 1; i < vertices.length; ++i) {\n                vertices[i - 1];\n                vertices[i];\n            }\n            this.m_vertices = [];\n            this.m_count = vertices.length + 1;\n            for (var i = 0; i < vertices.length; ++i) {\n                this.m_vertices[i] = Vec2.clone(vertices[i]);\n            }\n            this.m_vertices[vertices.length] = Vec2.clone(vertices[0]);\n            this.m_prevVertex = this.m_vertices[this.m_count - 2];\n            this.m_nextVertex = this.m_vertices[1];\n            this.m_hasPrevVertex = true;\n            this.m_hasNextVertex = true;\n            return this;\n        };\n        /**\n         * @internal\n         * Create a chain with isolated end vertices.\n         *\n         * @param vertices an array of vertices, these are copied\n         * @param count the vertex count\n         */\n        ChainShape.prototype._createChain = function (vertices) {\n            for (var i = 1; i < vertices.length; ++i) {\n                // If the code crashes here, it means your vertices are too close together.\n                vertices[i - 1];\n                vertices[i];\n            }\n            this.m_count = vertices.length;\n            for (var i = 0; i < vertices.length; ++i) {\n                this.m_vertices[i] = Vec2.clone(vertices[i]);\n            }\n            this.m_hasPrevVertex = false;\n            this.m_hasNextVertex = false;\n            this.m_prevVertex = null;\n            this.m_nextVertex = null;\n            return this;\n        };\n        /** @internal */\n        ChainShape.prototype._reset = function () {\n            if (this.m_isLoop) {\n                this._createLoop(this.m_vertices);\n            }\n            else {\n                this._createChain(this.m_vertices);\n            }\n        };\n        /**\n         * Establish connectivity to a vertex that precedes the first vertex. Don't call\n         * this for loops.\n         */\n        ChainShape.prototype.setPrevVertex = function (prevVertex) {\n            this.m_prevVertex = prevVertex;\n            this.m_hasPrevVertex = true;\n        };\n        ChainShape.prototype.getPrevVertex = function () {\n            return this.m_prevVertex;\n        };\n        /**\n         * Establish connectivity to a vertex that follows the last vertex. Don't call\n         * this for loops.\n         */\n        ChainShape.prototype.setNextVertex = function (nextVertex) {\n            this.m_nextVertex = nextVertex;\n            this.m_hasNextVertex = true;\n        };\n        ChainShape.prototype.getNextVertex = function () {\n            return this.m_nextVertex;\n        };\n        /**\n         * @internal\n         * @deprecated Shapes should be treated as immutable.\n         *\n         * clone the concrete shape.\n         */\n        ChainShape.prototype._clone = function () {\n            var clone = new ChainShape();\n            clone._createChain(this.m_vertices);\n            clone.m_type = this.m_type;\n            clone.m_radius = this.m_radius;\n            clone.m_prevVertex = this.m_prevVertex;\n            clone.m_nextVertex = this.m_nextVertex;\n            clone.m_hasPrevVertex = this.m_hasPrevVertex;\n            clone.m_hasNextVertex = this.m_hasNextVertex;\n            return clone;\n        };\n        /**\n         * Get the number of child primitives.\n         */\n        ChainShape.prototype.getChildCount = function () {\n            // edge count = vertex count - 1\n            return this.m_count - 1;\n        };\n        // Get a child edge.\n        ChainShape.prototype.getChildEdge = function (edge, childIndex) {\n            edge.m_type = EdgeShape.TYPE;\n            edge.m_radius = this.m_radius;\n            edge.m_vertex1 = this.m_vertices[childIndex];\n            edge.m_vertex2 = this.m_vertices[childIndex + 1];\n            if (childIndex > 0) {\n                edge.m_vertex0 = this.m_vertices[childIndex - 1];\n                edge.m_hasVertex0 = true;\n            }\n            else {\n                edge.m_vertex0 = this.m_prevVertex;\n                edge.m_hasVertex0 = this.m_hasPrevVertex;\n            }\n            if (childIndex < this.m_count - 2) {\n                edge.m_vertex3 = this.m_vertices[childIndex + 2];\n                edge.m_hasVertex3 = true;\n            }\n            else {\n                edge.m_vertex3 = this.m_nextVertex;\n                edge.m_hasVertex3 = this.m_hasNextVertex;\n            }\n        };\n        ChainShape.prototype.getVertex = function (index) {\n            if (index < this.m_count) {\n                return this.m_vertices[index];\n            }\n            else {\n                return this.m_vertices[0];\n            }\n        };\n        ChainShape.prototype.isLoop = function () {\n            return this.m_isLoop;\n        };\n        /**\n         * Test a point for containment in this shape. This only works for convex\n         * shapes.\n         *\n         * This always return false.\n         *\n         * @param xf The shape world transform.\n         * @param p A point in world coordinates.\n         */\n        ChainShape.prototype.testPoint = function (xf, p) {\n            return false;\n        };\n        /**\n         * Cast a ray against a child shape.\n         *\n         * @param output The ray-cast results.\n         * @param input The ray-cast input parameters.\n         * @param xf The transform to be applied to the shape.\n         * @param childIndex The child shape index\n         */\n        ChainShape.prototype.rayCast = function (output, input, xf, childIndex) {\n            var edgeShape = new EdgeShape(this.getVertex(childIndex), this.getVertex(childIndex + 1));\n            return edgeShape.rayCast(output, input, xf, 0);\n        };\n        /**\n         * Given a transform, compute the associated axis aligned bounding box for a\n         * child shape.\n         *\n         * @param aabb Returns the axis aligned box.\n         * @param xf The world transform of the shape.\n         * @param childIndex The child shape\n         */\n        ChainShape.prototype.computeAABB = function (aabb, xf, childIndex) {\n            var v1 = Transform.mulVec2(xf, this.getVertex(childIndex));\n            var v2 = Transform.mulVec2(xf, this.getVertex(childIndex + 1));\n            aabb.combinePoints(v1, v2);\n        };\n        /**\n         * Compute the mass properties of this shape using its dimensions and density.\n         * The inertia tensor is computed about the local origin.\n         *\n         * Chains have zero mass.\n         *\n         * @param massData Returns the mass data for this shape.\n         * @param density The density in kilograms per meter squared.\n         */\n        ChainShape.prototype.computeMass = function (massData, density) {\n            massData.mass = 0.0;\n            massData.center = Vec2.zero();\n            massData.I = 0.0;\n        };\n        ChainShape.prototype.computeDistanceProxy = function (proxy, childIndex) {\n            proxy.m_buffer[0] = this.getVertex(childIndex);\n            proxy.m_buffer[1] = this.getVertex(childIndex + 1);\n            proxy.m_vertices = proxy.m_buffer;\n            proxy.m_count = 2;\n            proxy.m_radius = this.m_radius;\n        };\n        ChainShape.TYPE = 'chain';\n        return ChainShape;\n    }(Shape));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A convex polygon. It is assumed that the interior of the polygon is to the\n     * left of each edge. Polygons have a maximum number of vertices equal to\n     * Settings.maxPolygonVertices. In most cases you should not need many vertices\n     * for a convex polygon. extends Shape\n     */\n    var PolygonShape = /** @class */ (function (_super) {\n        __extends(PolygonShape, _super);\n        // @ts-ignore\n        function PolygonShape(vertices) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof PolygonShape)) {\n                return new PolygonShape(vertices);\n            }\n            _this = _super.call(this) || this;\n            _this.m_type = PolygonShape.TYPE;\n            _this.m_radius = Settings.polygonRadius;\n            _this.m_centroid = Vec2.zero();\n            _this.m_vertices = [];\n            _this.m_normals = [];\n            _this.m_count = 0;\n            if (vertices && vertices.length) {\n                _this._set(vertices);\n            }\n            return _this;\n        }\n        /** @internal */\n        PolygonShape.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                vertices: this.m_vertices,\n            };\n        };\n        /** @internal */\n        PolygonShape._deserialize = function (data, fixture, restore) {\n            var vertices = [];\n            if (data.vertices) {\n                for (var i = 0; i < data.vertices.length; i++) {\n                    vertices.push(restore(Vec2, data.vertices[i]));\n                }\n            }\n            var shape = new PolygonShape(vertices);\n            return shape;\n        };\n        PolygonShape.prototype.getVertex = function (index) {\n            return this.m_vertices[index];\n        };\n        /**\n         * @internal\n         * @deprecated Shapes should be treated as immutable.\n         *\n         * clone the concrete shape.\n         */\n        PolygonShape.prototype._clone = function () {\n            var clone = new PolygonShape();\n            clone.m_type = this.m_type;\n            clone.m_radius = this.m_radius;\n            clone.m_count = this.m_count;\n            clone.m_centroid.setVec2(this.m_centroid);\n            for (var i = 0; i < this.m_count; i++) {\n                clone.m_vertices.push(this.m_vertices[i].clone());\n            }\n            for (var i = 0; i < this.m_normals.length; i++) {\n                clone.m_normals.push(this.m_normals[i].clone());\n            }\n            return clone;\n        };\n        /**\n         * Get the number of child primitives.\n         */\n        PolygonShape.prototype.getChildCount = function () {\n            return 1;\n        };\n        /** @internal */\n        PolygonShape.prototype._reset = function () {\n            this._set(this.m_vertices);\n        };\n        /**\n         * @internal\n         *\n         * Create a convex hull from the given array of local points. The count must be\n         * in the range [3, Settings.maxPolygonVertices].\n         *\n         * Warning: the points may be re-ordered, even if they form a convex polygon\n         * Warning: collinear points are handled but not removed. Collinear points may\n         * lead to poor stacking behavior.\n         */\n        PolygonShape.prototype._set = function (vertices) {\n            if (vertices.length < 3) {\n                this._setAsBox(1.0, 1.0);\n                return;\n            }\n            var n = math$1.min(vertices.length, Settings.maxPolygonVertices);\n            // Perform welding and copy vertices into local buffer.\n            var ps = []; // [Settings.maxPolygonVertices];\n            for (var i = 0; i < n; ++i) {\n                var v = vertices[i];\n                var unique = true;\n                for (var j = 0; j < ps.length; ++j) {\n                    if (Vec2.distanceSquared(v, ps[j]) < 0.25 * Settings.linearSlopSquared) {\n                        unique = false;\n                        break;\n                    }\n                }\n                if (unique) {\n                    ps.push(v);\n                }\n            }\n            n = ps.length;\n            if (n < 3) {\n                this._setAsBox(1.0, 1.0);\n                return;\n            }\n            // Create the convex hull using the Gift wrapping algorithm\n            // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm\n            // Find the right most point on the hull (in case of multiple points bottom most is used)\n            var i0 = 0;\n            var x0 = ps[0].x;\n            for (var i = 1; i < n; ++i) {\n                var x = ps[i].x;\n                if (x > x0 || (x === x0 && ps[i].y < ps[i0].y)) {\n                    i0 = i;\n                    x0 = x;\n                }\n            }\n            var hull = []; // [Settings.maxPolygonVertices];\n            var m = 0;\n            var ih = i0;\n            while (true) {\n                hull[m] = ih;\n                var ie = 0;\n                for (var j = 1; j < n; ++j) {\n                    if (ie === ih) {\n                        ie = j;\n                        continue;\n                    }\n                    var r = Vec2.sub(ps[ie], ps[hull[m]]);\n                    var v = Vec2.sub(ps[j], ps[hull[m]]);\n                    var c = Vec2.crossVec2Vec2(r, v);\n                    // c < 0 means counter-clockwise wrapping, c > 0 means clockwise wrapping\n                    if (c < 0.0) {\n                        ie = j;\n                    }\n                    // Collinearity check\n                    if (c === 0.0 && v.lengthSquared() > r.lengthSquared()) {\n                        ie = j;\n                    }\n                }\n                ++m;\n                ih = ie;\n                if (ie === i0) {\n                    break;\n                }\n            }\n            if (m < 3) {\n                this._setAsBox(1.0, 1.0);\n                return;\n            }\n            this.m_count = m;\n            // Copy vertices.\n            this.m_vertices = [];\n            for (var i = 0; i < m; ++i) {\n                this.m_vertices[i] = ps[hull[i]];\n            }\n            // Compute normals. Ensure the edges have non-zero length.\n            for (var i = 0; i < m; ++i) {\n                var i1 = i;\n                var i2 = i + 1 < m ? i + 1 : 0;\n                var edge = Vec2.sub(this.m_vertices[i2], this.m_vertices[i1]);\n                this.m_normals[i] = Vec2.crossVec2Num(edge, 1.0);\n                this.m_normals[i].normalize();\n            }\n            // Compute the polygon centroid.\n            this.m_centroid = ComputeCentroid(this.m_vertices, m);\n        };\n        /** @internal */\n        PolygonShape.prototype._setAsBox = function (hx, hy, center, angle) {\n            // start with right-bottom, counter-clockwise, as in Gift wrapping algorithm in PolygonShape._set()\n            this.m_vertices[0] = Vec2.neo(hx, -hy);\n            this.m_vertices[1] = Vec2.neo(hx, hy);\n            this.m_vertices[2] = Vec2.neo(-hx, hy);\n            this.m_vertices[3] = Vec2.neo(-hx, -hy);\n            this.m_normals[0] = Vec2.neo(1.0, 0.0);\n            this.m_normals[1] = Vec2.neo(0.0, 1.0);\n            this.m_normals[2] = Vec2.neo(-1.0, 0.0);\n            this.m_normals[3] = Vec2.neo(0.0, -1.0);\n            this.m_count = 4;\n            if (Vec2.isValid(center)) {\n                angle = angle || 0;\n                this.m_centroid.setVec2(center);\n                var xf = Transform.identity();\n                xf.p.setVec2(center);\n                xf.q.setAngle(angle);\n                // Transform vertices and normals.\n                for (var i = 0; i < this.m_count; ++i) {\n                    this.m_vertices[i] = Transform.mulVec2(xf, this.m_vertices[i]);\n                    this.m_normals[i] = Rot.mulVec2(xf.q, this.m_normals[i]);\n                }\n            }\n        };\n        /**\n         * Test a point for containment in this shape. This only works for convex\n         * shapes.\n         *\n         * @param xf The shape world transform.\n         * @param p A point in world coordinates.\n         */\n        PolygonShape.prototype.testPoint = function (xf, p) {\n            var pLocal = Rot.mulTVec2(xf.q, Vec2.sub(p, xf.p));\n            for (var i = 0; i < this.m_count; ++i) {\n                var dot = Vec2.dot(this.m_normals[i], Vec2.sub(pLocal, this.m_vertices[i]));\n                if (dot > 0.0) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        /**\n         * Cast a ray against a child shape.\n         *\n         * @param output The ray-cast results.\n         * @param input The ray-cast input parameters.\n         * @param xf The transform to be applied to the shape.\n         * @param childIndex The child shape index\n         */\n        PolygonShape.prototype.rayCast = function (output, input, xf, childIndex) {\n            // Put the ray into the polygon's frame of reference.\n            var p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n            var p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n            var d = Vec2.sub(p2, p1);\n            var lower = 0.0;\n            var upper = input.maxFraction;\n            var index = -1;\n            for (var i = 0; i < this.m_count; ++i) {\n                // p = p1 + a * d\n                // dot(normal, p - v) = 0\n                // dot(normal, p1 - v) + a * dot(normal, d) = 0\n                var numerator = Vec2.dot(this.m_normals[i], Vec2.sub(this.m_vertices[i], p1));\n                var denominator = Vec2.dot(this.m_normals[i], d);\n                if (denominator == 0.0) {\n                    if (numerator < 0.0) {\n                        return false;\n                    }\n                }\n                else {\n                    // Note: we want this predicate without division:\n                    // lower < numerator / denominator, where denominator < 0\n                    // Since denominator < 0, we have to flip the inequality:\n                    // lower < numerator / denominator <==> denominator * lower > numerator.\n                    if (denominator < 0.0 && numerator < lower * denominator) {\n                        // Increase lower.\n                        // The segment enters this half-space.\n                        lower = numerator / denominator;\n                        index = i;\n                    }\n                    else if (denominator > 0.0 && numerator < upper * denominator) {\n                        // Decrease upper.\n                        // The segment exits this half-space.\n                        upper = numerator / denominator;\n                    }\n                }\n                // The use of epsilon here causes the assert on lower to trip\n                // in some cases. Apparently the use of epsilon was to make edge\n                // shapes work, but now those are handled separately.\n                // if (upper < lower - Math.EPSILON)\n                if (upper < lower) {\n                    return false;\n                }\n            }\n            if (index >= 0) {\n                output.fraction = lower;\n                output.normal = Rot.mulVec2(xf.q, this.m_normals[index]);\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Given a transform, compute the associated axis aligned bounding box for a\n         * child shape.\n         *\n         * @param aabb Returns the axis aligned box.\n         * @param xf The world transform of the shape.\n         * @param childIndex The child shape\n         */\n        PolygonShape.prototype.computeAABB = function (aabb, xf, childIndex) {\n            var minX = Infinity;\n            var minY = Infinity;\n            var maxX = -Infinity;\n            var maxY = -Infinity;\n            for (var i = 0; i < this.m_count; ++i) {\n                var v = Transform.mulVec2(xf, this.m_vertices[i]);\n                minX = math$1.min(minX, v.x);\n                maxX = math$1.max(maxX, v.x);\n                minY = math$1.min(minY, v.y);\n                maxY = math$1.max(maxY, v.y);\n            }\n            aabb.lowerBound.setNum(minX, minY);\n            aabb.upperBound.setNum(maxX, maxY);\n            aabb.extend(this.m_radius);\n        };\n        /**\n         * Compute the mass properties of this shape using its dimensions and density.\n         * The inertia tensor is computed about the local origin.\n         *\n         * @param massData Returns the mass data for this shape.\n         * @param density The density in kilograms per meter squared.\n         */\n        PolygonShape.prototype.computeMass = function (massData, density) {\n            var center = Vec2.zero();\n            var area = 0.0;\n            var I = 0.0;\n            // s is the reference point for forming triangles.\n            // It's location doesn't change the result (except for rounding error).\n            var s = Vec2.zero();\n            // This code would put the reference point inside the polygon.\n            for (var i = 0; i < this.m_count; ++i) {\n                s.add(this.m_vertices[i]);\n            }\n            s.mul(1.0 / this.m_count);\n            var k_inv3 = 1.0 / 3.0;\n            for (var i = 0; i < this.m_count; ++i) {\n                // Triangle vertices.\n                var e1 = Vec2.sub(this.m_vertices[i], s);\n                var e2 = i + 1 < this.m_count ? Vec2.sub(this.m_vertices[i + 1], s) : Vec2.sub(this.m_vertices[0], s);\n                var D = Vec2.crossVec2Vec2(e1, e2);\n                var triangleArea = 0.5 * D;\n                area += triangleArea;\n                // Area weighted centroid\n                center.addCombine(triangleArea * k_inv3, e1, triangleArea * k_inv3, e2);\n                var ex1 = e1.x;\n                var ey1 = e1.y;\n                var ex2 = e2.x;\n                var ey2 = e2.y;\n                var intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;\n                var inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;\n                I += (0.25 * k_inv3 * D) * (intx2 + inty2);\n            }\n            // Total mass\n            massData.mass = density * area;\n            center.mul(1.0 / area);\n            massData.center.setCombine(1, center, 1, s);\n            // Inertia tensor relative to the local origin (point s).\n            massData.I = density * I;\n            // Shift to center of mass then to original body origin.\n            massData.I += massData.mass * (Vec2.dot(massData.center, massData.center) - Vec2.dot(center, center));\n        };\n        /**\n         * Validate convexity. This is a very time consuming operation.\n         * @returns true if valid\n         */\n        PolygonShape.prototype.validate = function () {\n            for (var i = 0; i < this.m_count; ++i) {\n                var i1 = i;\n                var i2 = i < this.m_count - 1 ? i1 + 1 : 0;\n                var p = this.m_vertices[i1];\n                var e = Vec2.sub(this.m_vertices[i2], p);\n                for (var j = 0; j < this.m_count; ++j) {\n                    if (j == i1 || j == i2) {\n                        continue;\n                    }\n                    var v = Vec2.sub(this.m_vertices[j], p);\n                    var c = Vec2.crossVec2Vec2(e, v);\n                    if (c < 0.0) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        PolygonShape.prototype.computeDistanceProxy = function (proxy) {\n            proxy.m_vertices = this.m_vertices;\n            proxy.m_count = this.m_count;\n            proxy.m_radius = this.m_radius;\n        };\n        PolygonShape.TYPE = 'polygon';\n        return PolygonShape;\n    }(Shape));\n    function ComputeCentroid(vs, count) {\n        var c = Vec2.zero();\n        var area = 0.0;\n        // pRef is the reference point for forming triangles.\n        // It's location doesn't change the result (except for rounding error).\n        var pRef = Vec2.zero();\n        var i; \n        var inv3 = 1.0 / 3.0;\n        for (var i = 0; i < count; ++i) {\n            // Triangle vertices.\n            var p1 = pRef;\n            var p2 = vs[i];\n            var p3 = i + 1 < count ? vs[i + 1] : vs[0];\n            var e1 = Vec2.sub(p2, p1);\n            var e2 = Vec2.sub(p3, p1);\n            var D = Vec2.crossVec2Vec2(e1, e2);\n            var triangleArea = 0.5 * D;\n            area += triangleArea;\n            // Area weighted centroid\n            c.addMul(triangleArea * inv3, p1);\n            c.addMul(triangleArea * inv3, p2);\n            c.addMul(triangleArea * inv3, p3);\n        }\n        c.mul(1.0 / area);\n        return c;\n    }\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A rectangle polygon which extend PolygonShape.\n     */\n    var BoxShape = /** @class */ (function (_super) {\n        __extends(BoxShape, _super);\n        function BoxShape(hx, hy, center, angle) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof BoxShape)) {\n                return new BoxShape(hx, hy, center, angle);\n            }\n            _this = _super.call(this) || this;\n            _this._setAsBox(hx, hy, center, angle);\n            return _this;\n        }\n        BoxShape.TYPE = 'polygon';\n        return BoxShape;\n    }(PolygonShape));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var CircleShape = /** @class */ (function (_super) {\n        __extends(CircleShape, _super);\n        // tslint:disable-next-line:typedef\n        function CircleShape(a, b) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof CircleShape)) {\n                return new CircleShape(a, b);\n            }\n            _this = _super.call(this) || this;\n            _this.m_type = CircleShape.TYPE;\n            _this.m_p = Vec2.zero();\n            _this.m_radius = 1;\n            if (typeof a === 'object' && Vec2.isValid(a)) {\n                _this.m_p.setVec2(a);\n                if (typeof b === 'number') {\n                    _this.m_radius = b;\n                }\n            }\n            else if (typeof a === 'number') {\n                _this.m_radius = a;\n            }\n            return _this;\n        }\n        /** @internal */\n        CircleShape.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                p: this.m_p,\n                radius: this.m_radius,\n            };\n        };\n        /** @internal */\n        CircleShape._deserialize = function (data) {\n            return new CircleShape(data.p, data.radius);\n        };\n        // TODO: already defined in Shape\n        CircleShape.prototype.getRadius = function () {\n            return this.m_radius;\n        };\n        CircleShape.prototype.getCenter = function () {\n            return this.m_p;\n        };\n        CircleShape.prototype.getVertex = function (index) {\n            return this.m_p;\n        };\n        /**\n         * @internal\n         * @deprecated Shapes should be treated as immutable.\n         *\n         * clone the concrete shape.\n         */\n        CircleShape.prototype._clone = function () {\n            var clone = new CircleShape();\n            clone.m_type = this.m_type;\n            clone.m_radius = this.m_radius;\n            clone.m_p = this.m_p.clone();\n            return clone;\n        };\n        /**\n         * Get the number of child primitives.\n         */\n        CircleShape.prototype.getChildCount = function () {\n            return 1;\n        };\n        /**\n         * Test a point for containment in this shape. This only works for convex\n         * shapes.\n         *\n         * @param xf The shape world transform.\n         * @param p A point in world coordinates.\n         */\n        CircleShape.prototype.testPoint = function (xf, p) {\n            var center = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n            var d = Vec2.sub(p, center);\n            return Vec2.dot(d, d) <= this.m_radius * this.m_radius;\n        };\n        /**\n         * Cast a ray against a child shape.\n         *\n         * @param output The ray-cast results.\n         * @param input The ray-cast input parameters.\n         * @param xf The transform to be applied to the shape.\n         * @param childIndex The child shape index\n         */\n        CircleShape.prototype.rayCast = function (output, input, xf, childIndex) {\n            // Collision Detection in Interactive 3D Environments by Gino van den Bergen\n            // From Section 3.1.2\n            // x = s + a * r\n            // norm(x) = radius\n            var position = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n            var s = Vec2.sub(input.p1, position);\n            var b = Vec2.dot(s, s) - this.m_radius * this.m_radius;\n            // Solve quadratic equation.\n            var r = Vec2.sub(input.p2, input.p1);\n            var c = Vec2.dot(s, r);\n            var rr = Vec2.dot(r, r);\n            var sigma = c * c - rr * b;\n            // Check for negative discriminant and short segment.\n            if (sigma < 0.0 || rr < math$1.EPSILON) {\n                return false;\n            }\n            // Find the point of intersection of the line with the circle.\n            var a = -(c + math$1.sqrt(sigma));\n            // Is the intersection point on the segment?\n            if (0.0 <= a && a <= input.maxFraction * rr) {\n                a /= rr;\n                output.fraction = a;\n                output.normal = Vec2.add(s, Vec2.mulNumVec2(a, r));\n                output.normal.normalize();\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Given a transform, compute the associated axis aligned bounding box for a\n         * child shape.\n         *\n         * @param aabb Returns the axis aligned box.\n         * @param xf The world transform of the shape.\n         * @param childIndex The child shape\n         */\n        CircleShape.prototype.computeAABB = function (aabb, xf, childIndex) {\n            var p = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n            aabb.lowerBound.setNum(p.x - this.m_radius, p.y - this.m_radius);\n            aabb.upperBound.setNum(p.x + this.m_radius, p.y + this.m_radius);\n        };\n        /**\n         * Compute the mass properties of this shape using its dimensions and density.\n         * The inertia tensor is computed about the local origin.\n         *\n         * @param massData Returns the mass data for this shape.\n         * @param density The density in kilograms per meter squared.\n         */\n        CircleShape.prototype.computeMass = function (massData, density) {\n            massData.mass = density * math$1.PI * this.m_radius * this.m_radius;\n            massData.center = this.m_p;\n            // inertia about the local origin\n            massData.I = massData.mass\n                * (0.5 * this.m_radius * this.m_radius + Vec2.dot(this.m_p, this.m_p));\n        };\n        CircleShape.prototype.computeDistanceProxy = function (proxy) {\n            proxy.m_vertices.push(this.m_p);\n            proxy.m_count = 1;\n            proxy.m_radius = this.m_radius;\n        };\n        CircleShape.TYPE = 'circle';\n        return CircleShape;\n    }(Shape));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS$a = {\n        frequencyHz: 0.0,\n        dampingRatio: 0.0\n    };\n    /**\n     * A distance joint constrains two points on two bodies to remain at a fixed\n     * distance from each other. You can view this as a massless, rigid rod.\n     *\n     * @param anchorA Anchor A in global coordination.\n     * @param anchorB Anchor B in global coordination.\n     */\n    var DistanceJoint = /** @class */ (function (_super) {\n        __extends(DistanceJoint, _super);\n        function DistanceJoint(def, bodyA, bodyB, anchorA, anchorB) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof DistanceJoint)) {\n                return new DistanceJoint(def, bodyA, bodyB, anchorA, anchorB);\n            }\n            // order of constructor arguments is changed in v0.2\n            if (bodyB && anchorA && ('m_type' in anchorA) && ('x' in bodyB) && ('y' in bodyB)) {\n                var temp = bodyB;\n                bodyB = anchorA;\n                anchorA = temp;\n            }\n            def = options(def, DEFAULTS$a);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = DistanceJoint.TYPE;\n            // Solver shared\n            _this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.zero());\n            _this.m_length = math$1.isFinite(def.length) ? def.length :\n                Vec2.distance(bodyA.getWorldPoint(_this.m_localAnchorA), bodyB.getWorldPoint(_this.m_localAnchorB));\n            _this.m_frequencyHz = def.frequencyHz;\n            _this.m_dampingRatio = def.dampingRatio;\n            _this.m_impulse = 0.0;\n            _this.m_gamma = 0.0;\n            _this.m_bias = 0.0;\n            return _this;\n            // 1-D constrained system\n            // m (v2 - v1) = lambda\n            // v2 + (beta/h) * x1 + gamma * lambda = 0, gamma has units of inverse mass.\n            // x2 = x1 + h * v2\n            // 1-D mass-damper-spring system\n            // m (v2 - v1) + h * d * v2 + h * k *\n            // C = norm(p2 - p1) - L\n            // u = (p2 - p1) / norm(p2 - p1)\n            // Cdot = dot(u, v2 + cross(w2, r2) - v1 - cross(w1, r1))\n            // J = [-u -cross(r1, u) u cross(r2, u)]\n            // K = J * invM * JT\n            // = invMass1 + invI1 * cross(r1, u)^2 + invMass2 + invI2 * cross(r2, u)^2\n        }\n        /** @internal */\n        DistanceJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                frequencyHz: this.m_frequencyHz,\n                dampingRatio: this.m_dampingRatio,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                length: this.m_length,\n                impulse: this.m_impulse,\n                gamma: this.m_gamma,\n                bias: this.m_bias,\n            };\n        };\n        /** @internal */\n        DistanceJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new DistanceJoint(data);\n            return joint;\n        };\n        /** @internal */\n        DistanceJoint.prototype._setAnchors = function (def) {\n            if (def.anchorA) {\n                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            }\n            else if (def.localAnchorA) {\n                this.m_localAnchorA.setVec2(def.localAnchorA);\n            }\n            if (def.anchorB) {\n                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            }\n            else if (def.localAnchorB) {\n                this.m_localAnchorB.setVec2(def.localAnchorB);\n            }\n            if (def.length > 0) {\n                this.m_length = +def.length;\n            }\n            else if (def.length < 0) ;\n            else if (def.anchorA || def.anchorA || def.anchorA || def.anchorA) {\n                this.m_length = Vec2.distance(this.m_bodyA.getWorldPoint(this.m_localAnchorA), this.m_bodyB.getWorldPoint(this.m_localAnchorB));\n            }\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */\n        DistanceJoint.prototype.getLocalAnchorA = function () {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */\n        DistanceJoint.prototype.getLocalAnchorB = function () {\n            return this.m_localAnchorB;\n        };\n        /**\n         * Set the natural length. Manipulating the length can lead to non-physical\n         * behavior when the frequency is zero.\n         */\n        DistanceJoint.prototype.setLength = function (length) {\n            this.m_length = length;\n        };\n        /**\n         * Get the natural length.\n         */\n        DistanceJoint.prototype.getLength = function () {\n            return this.m_length;\n        };\n        DistanceJoint.prototype.setFrequency = function (hz) {\n            this.m_frequencyHz = hz;\n        };\n        DistanceJoint.prototype.getFrequency = function () {\n            return this.m_frequencyHz;\n        };\n        DistanceJoint.prototype.setDampingRatio = function (ratio) {\n            this.m_dampingRatio = ratio;\n        };\n        DistanceJoint.prototype.getDampingRatio = function () {\n            return this.m_dampingRatio;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        DistanceJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        DistanceJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        DistanceJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        DistanceJoint.prototype.getReactionTorque = function (inv_dt) {\n            return 0.0;\n        };\n        DistanceJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            this.m_u = Vec2.sub(Vec2.add(cB, this.m_rB), Vec2.add(cA, this.m_rA));\n            // Handle singularity.\n            var length = this.m_u.length();\n            if (length > Settings.linearSlop) {\n                this.m_u.mul(1.0 / length);\n            }\n            else {\n                this.m_u.setNum(0.0, 0.0);\n            }\n            var crAu = Vec2.crossVec2Vec2(this.m_rA, this.m_u);\n            var crBu = Vec2.crossVec2Vec2(this.m_rB, this.m_u);\n            var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB\n                + this.m_invIB * crBu * crBu;\n            // Compute the effective mass matrix.\n            this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n            if (this.m_frequencyHz > 0.0) {\n                var C = length - this.m_length;\n                // Frequency\n                var omega = 2.0 * math$1.PI * this.m_frequencyHz;\n                // Damping coefficient\n                var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;\n                // Spring stiffness\n                var k = this.m_mass * omega * omega;\n                // magic formulas\n                var h = step.dt;\n                this.m_gamma = h * (d + h * k);\n                this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n                this.m_bias = C * h * k * this.m_gamma;\n                invMass += this.m_gamma;\n                this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n            }\n            else {\n                this.m_gamma = 0.0;\n                this.m_bias = 0.0;\n            }\n            if (step.warmStarting) {\n                // Scale the impulse to support a variable time step.\n                this.m_impulse *= step.dtRatio;\n                var P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n                vA.subMul(this.m_invMassA, P);\n                wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n                vB.addMul(this.m_invMassB, P);\n                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n            }\n            else {\n                this.m_impulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        DistanceJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            // Cdot = dot(u, v + cross(w, r))\n            var vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n            var vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n            var Cdot = Vec2.dot(this.m_u, vpB) - Vec2.dot(this.m_u, vpA);\n            var impulse = -this.m_mass\n                * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);\n            this.m_impulse += impulse;\n            var P = Vec2.mulNumVec2(impulse, this.m_u);\n            vA.subMul(this.m_invMassA, P);\n            wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n            vB.addMul(this.m_invMassB, P);\n            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        DistanceJoint.prototype.solvePositionConstraints = function (step) {\n            if (this.m_frequencyHz > 0.0) {\n                // There is no position correction for soft distance constraints.\n                return true;\n            }\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n            var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n            var u = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));\n            var length = u.normalize();\n            var C = length - this.m_length;\n            C = math$1\n                .clamp(C, -Settings.maxLinearCorrection, Settings.maxLinearCorrection);\n            var impulse = -this.m_mass * C;\n            var P = Vec2.mulNumVec2(impulse, u);\n            cA.subMul(this.m_invMassA, P);\n            aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n            cB.addMul(this.m_invMassB, P);\n            aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n            this.m_bodyA.c_position.c.setVec2(cA);\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c.setVec2(cB);\n            this.m_bodyB.c_position.a = aB;\n            return math$1.abs(C) < Settings.linearSlop;\n        };\n        DistanceJoint.TYPE = 'distance-joint';\n        return DistanceJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS$9 = {\n        maxForce: 0.0,\n        maxTorque: 0.0,\n    };\n    /**\n     * Friction joint. This is used for top-down friction. It provides 2D\n     * translational friction and angular friction.\n     *\n     * @param anchor Anchor in global coordination.\n     */\n    var FrictionJoint = /** @class */ (function (_super) {\n        __extends(FrictionJoint, _super);\n        function FrictionJoint(def, bodyA, bodyB, anchor) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof FrictionJoint)) {\n                return new FrictionJoint(def, bodyA, bodyB, anchor);\n            }\n            def = options(def, DEFAULTS$9);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = FrictionJoint.TYPE;\n            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n            // Solver shared\n            _this.m_linearImpulse = Vec2.zero();\n            _this.m_angularImpulse = 0.0;\n            _this.m_maxForce = def.maxForce;\n            _this.m_maxTorque = def.maxTorque;\n            return _this;\n            // Point-to-point constraint\n            // Cdot = v2 - v1\n            // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n            // J = [-I -r1_skew I r2_skew ]\n            // Identity used:\n            // w k % (rx i + ry j) = w * (-ry i + rx j)\n            // Angle constraint\n            // Cdot = w2 - w1\n            // J = [0 0 -1 0 0 1]\n            // K = invI1 + invI2\n        }\n        /** @internal */\n        FrictionJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                maxForce: this.m_maxForce,\n                maxTorque: this.m_maxTorque,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n            };\n        };\n        /** @internal */\n        FrictionJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new FrictionJoint(data);\n            return joint;\n        };\n        /** @internal */\n        FrictionJoint.prototype._setAnchors = function (def) {\n            if (def.anchorA) {\n                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            }\n            else if (def.localAnchorA) {\n                this.m_localAnchorA.setVec2(def.localAnchorA);\n            }\n            if (def.anchorB) {\n                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            }\n            else if (def.localAnchorB) {\n                this.m_localAnchorB.setVec2(def.localAnchorB);\n            }\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */\n        FrictionJoint.prototype.getLocalAnchorA = function () {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */\n        FrictionJoint.prototype.getLocalAnchorB = function () {\n            return this.m_localAnchorB;\n        };\n        /**\n         * Set the maximum friction force in N.\n         */\n        FrictionJoint.prototype.setMaxForce = function (force) {\n            this.m_maxForce = force;\n        };\n        /**\n         * Get the maximum friction force in N.\n         */\n        FrictionJoint.prototype.getMaxForce = function () {\n            return this.m_maxForce;\n        };\n        /**\n         * Set the maximum friction torque in N*m.\n         */\n        FrictionJoint.prototype.setMaxTorque = function (torque) {\n            this.m_maxTorque = torque;\n        };\n        /**\n         * Get the maximum friction torque in N*m.\n         */\n        FrictionJoint.prototype.getMaxTorque = function () {\n            return this.m_maxTorque;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        FrictionJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        FrictionJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        FrictionJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        FrictionJoint.prototype.getReactionTorque = function (inv_dt) {\n            return inv_dt * this.m_angularImpulse;\n        };\n        FrictionJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            // Compute the effective mass matrix.\n            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // J = [-I -r1_skew I r2_skew]\n            // [ 0 -1 0 1]\n            // r_skew = [-ry; rx]\n            // Matlab\n            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var K = new Mat22();\n            K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y\n                * this.m_rB.y;\n            K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n            K.ey.x = K.ex.y;\n            K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x\n                * this.m_rB.x;\n            this.m_linearMass = K.getInverse();\n            this.m_angularMass = iA + iB;\n            if (this.m_angularMass > 0.0) {\n                this.m_angularMass = 1.0 / this.m_angularMass;\n            }\n            if (step.warmStarting) {\n                // Scale impulses to support a variable time step.\n                this.m_linearImpulse.mul(step.dtRatio);\n                this.m_angularImpulse *= step.dtRatio;\n                var P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n            }\n            else {\n                this.m_linearImpulse.setZero();\n                this.m_angularImpulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        FrictionJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var h = step.dt; // float\n            // Solve angular friction\n            {\n                var Cdot = wB - wA; // float\n                var impulse = -this.m_angularMass * Cdot; // float\n                var oldImpulse = this.m_angularImpulse; // float\n                var maxImpulse = h * this.m_maxTorque; // float\n                this.m_angularImpulse = math$1.clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);\n                impulse = this.m_angularImpulse - oldImpulse;\n                wA -= iA * impulse;\n                wB += iB * impulse;\n            }\n            // Solve linear friction\n            {\n                var Cdot = Vec2.sub(Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB)), Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA))); // Vec2\n                var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot)); // Vec2\n                var oldImpulse = this.m_linearImpulse; // Vec2\n                this.m_linearImpulse.add(impulse);\n                var maxImpulse = h * this.m_maxForce; // float\n                if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {\n                    this.m_linearImpulse.normalize();\n                    this.m_linearImpulse.mul(maxImpulse);\n                }\n                impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n                vA.subMul(mA, impulse);\n                wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n                vB.addMul(mB, impulse);\n                wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        FrictionJoint.prototype.solvePositionConstraints = function (step) {\n            return true;\n        };\n        FrictionJoint.TYPE = 'friction-joint';\n        return FrictionJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A 3-by-3 matrix. Stored in column-major order.\n     */\n    var Mat33 = /** @class */ (function () {\n        function Mat33(a, b, c) {\n            if (typeof a === 'object' && a !== null) {\n                this.ex = Vec3.clone(a);\n                this.ey = Vec3.clone(b);\n                this.ez = Vec3.clone(c);\n            }\n            else {\n                this.ex = Vec3.zero();\n                this.ey = Vec3.zero();\n                this.ez = Vec3.zero();\n            }\n        }\n        /** @internal */\n        Mat33.prototype.toString = function () {\n            return JSON.stringify(this);\n        };\n        Mat33.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return Vec3.isValid(obj.ex) && Vec3.isValid(obj.ey) && Vec3.isValid(obj.ez);\n        };\n        Mat33.assert = function (o) {\n            return;\n        };\n        /**\n         * Set this matrix to all zeros.\n         */\n        Mat33.prototype.setZero = function () {\n            this.ex.setZero();\n            this.ey.setZero();\n            this.ez.setZero();\n            return this;\n        };\n        /**\n         * Solve A * x = b, where b is a column vector. This is more efficient than\n         * computing the inverse in one-shot cases.\n         */\n        Mat33.prototype.solve33 = function (v) {\n            var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));\n            if (det !== 0.0) {\n                det = 1.0 / det;\n            }\n            var r = new Vec3();\n            r.x = det * Vec3.dot(v, Vec3.cross(this.ey, this.ez));\n            r.y = det * Vec3.dot(this.ex, Vec3.cross(v, this.ez));\n            r.z = det * Vec3.dot(this.ex, Vec3.cross(this.ey, v));\n            return r;\n        };\n        /**\n         * Solve A * x = b, where b is a column vector. This is more efficient than\n         * computing the inverse in one-shot cases. Solve only the upper 2-by-2 matrix\n         * equation.\n         */\n        Mat33.prototype.solve22 = function (v) {\n            var a11 = this.ex.x;\n            var a12 = this.ey.x;\n            var a21 = this.ex.y;\n            var a22 = this.ey.y;\n            var det = a11 * a22 - a12 * a21;\n            if (det !== 0.0) {\n                det = 1.0 / det;\n            }\n            var r = Vec2.zero();\n            r.x = det * (a22 * v.x - a12 * v.y);\n            r.y = det * (a11 * v.y - a21 * v.x);\n            return r;\n        };\n        /**\n         * Get the inverse of this matrix as a 2-by-2. Returns the zero matrix if\n         * singular.\n         */\n        Mat33.prototype.getInverse22 = function (M) {\n            var a = this.ex.x;\n            var b = this.ey.x;\n            var c = this.ex.y;\n            var d = this.ey.y;\n            var det = a * d - b * c;\n            if (det !== 0.0) {\n                det = 1.0 / det;\n            }\n            M.ex.x = det * d;\n            M.ey.x = -det * b;\n            M.ex.z = 0.0;\n            M.ex.y = -det * c;\n            M.ey.y = det * a;\n            M.ey.z = 0.0;\n            M.ez.x = 0.0;\n            M.ez.y = 0.0;\n            M.ez.z = 0.0;\n        };\n        /**\n         * Get the symmetric inverse of this matrix as a 3-by-3. Returns the zero matrix\n         * if singular.\n         */\n        Mat33.prototype.getSymInverse33 = function (M) {\n            var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));\n            if (det !== 0.0) {\n                det = 1.0 / det;\n            }\n            var a11 = this.ex.x;\n            var a12 = this.ey.x;\n            var a13 = this.ez.x;\n            var a22 = this.ey.y;\n            var a23 = this.ez.y;\n            var a33 = this.ez.z;\n            M.ex.x = det * (a22 * a33 - a23 * a23);\n            M.ex.y = det * (a13 * a23 - a12 * a33);\n            M.ex.z = det * (a12 * a23 - a13 * a22);\n            M.ey.x = M.ex.y;\n            M.ey.y = det * (a11 * a33 - a13 * a13);\n            M.ey.z = det * (a13 * a12 - a11 * a23);\n            M.ez.x = M.ex.z;\n            M.ez.y = M.ey.z;\n            M.ez.z = det * (a11 * a22 - a12 * a12);\n        };\n        // tslint:disable-next-line:typedef\n        Mat33.mul = function (a, b) {\n            if (b && 'z' in b && 'y' in b && 'x' in b) {\n                var x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n                var y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n                var z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n                return new Vec3(x, y, z);\n            }\n            else if (b && 'y' in b && 'x' in b) {\n                var x = a.ex.x * b.x + a.ey.x * b.y;\n                var y = a.ex.y * b.x + a.ey.y * b.y;\n                return Vec2.neo(x, y);\n            }\n        };\n        Mat33.mulVec3 = function (a, b) {\n            var x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n            var y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n            var z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n            return new Vec3(x, y, z);\n        };\n        Mat33.mulVec2 = function (a, b) {\n            var x = a.ex.x * b.x + a.ey.x * b.y;\n            var y = a.ex.y * b.x + a.ey.y * b.y;\n            return Vec2.neo(x, y);\n        };\n        Mat33.add = function (a, b) {\n            return new Mat33(Vec3.add(a.ex, b.ex), Vec3.add(a.ey, b.ey), Vec3.add(a.ez, b.ez));\n        };\n        return Mat33;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var inactiveLimit$2 = 0;\n    var atLowerLimit$1 = 1;\n    var atUpperLimit$2 = 2;\n    var equalLimits$1 = 3;\n    var DEFAULTS$8 = {\n        lowerAngle: 0.0,\n        upperAngle: 0.0,\n        maxMotorTorque: 0.0,\n        motorSpeed: 0.0,\n        enableLimit: false,\n        enableMotor: false\n    };\n    /**\n     * A revolute joint constrains two bodies to share a common point while they are\n     * free to rotate about the point. The relative rotation about the shared point\n     * is the joint angle. You can limit the relative rotation with a joint limit\n     * that specifies a lower and upper angle. You can use a motor to drive the\n     * relative rotation about the shared point. A maximum motor torque is provided\n     * so that infinite forces are not generated.\n     */\n    var RevoluteJoint = /** @class */ (function (_super) {\n        __extends(RevoluteJoint, _super);\n        // @ts-ignore\n        function RevoluteJoint(def, bodyA, bodyB, anchor) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof RevoluteJoint)) {\n                return new RevoluteJoint(def, bodyA, bodyB, anchor);\n            }\n            def = options(def, DEFAULTS$8);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            // effective mass for point-to-point constraint.\n            /** @internal */ _this.m_mass = new Mat33();\n            /** @internal */ _this.m_limitState = inactiveLimit$2; // TODO enum\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = RevoluteJoint.TYPE;\n            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n            _this.m_referenceAngle = math$1.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n            _this.m_impulse = new Vec3();\n            _this.m_motorImpulse = 0.0;\n            _this.m_lowerAngle = def.lowerAngle;\n            _this.m_upperAngle = def.upperAngle;\n            _this.m_maxMotorTorque = def.maxMotorTorque;\n            _this.m_motorSpeed = def.motorSpeed;\n            _this.m_enableLimit = def.enableLimit;\n            _this.m_enableMotor = def.enableMotor;\n            return _this;\n            // Point-to-point constraint\n            // C = p2 - p1\n            // Cdot = v2 - v1\n            // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n            // J = [-I -r1_skew I r2_skew ]\n            // Identity used:\n            // w k % (rx i + ry j) = w * (-ry i + rx j)\n            // Motor constraint\n            // Cdot = w2 - w1\n            // J = [0 0 -1 0 0 1]\n            // K = invI1 + invI2\n        }\n        /** @internal */\n        RevoluteJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                lowerAngle: this.m_lowerAngle,\n                upperAngle: this.m_upperAngle,\n                maxMotorTorque: this.m_maxMotorTorque,\n                motorSpeed: this.m_motorSpeed,\n                enableLimit: this.m_enableLimit,\n                enableMotor: this.m_enableMotor,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                referenceAngle: this.m_referenceAngle,\n            };\n        };\n        /** @internal */\n        RevoluteJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new RevoluteJoint(data);\n            return joint;\n        };\n        /** @internal */\n        RevoluteJoint.prototype._setAnchors = function (def) {\n            if (def.anchorA) {\n                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            }\n            else if (def.localAnchorA) {\n                this.m_localAnchorA.setVec2(def.localAnchorA);\n            }\n            if (def.anchorB) {\n                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            }\n            else if (def.localAnchorB) {\n                this.m_localAnchorB.setVec2(def.localAnchorB);\n            }\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */\n        RevoluteJoint.prototype.getLocalAnchorA = function () {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */\n        RevoluteJoint.prototype.getLocalAnchorB = function () {\n            return this.m_localAnchorB;\n        };\n        /**\n         * Get the reference angle.\n         */\n        RevoluteJoint.prototype.getReferenceAngle = function () {\n            return this.m_referenceAngle;\n        };\n        /**\n         * Get the current joint angle in radians.\n         */\n        RevoluteJoint.prototype.getJointAngle = function () {\n            var bA = this.m_bodyA;\n            var bB = this.m_bodyB;\n            return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;\n        };\n        /**\n         * Get the current joint angle speed in radians per second.\n         */\n        RevoluteJoint.prototype.getJointSpeed = function () {\n            var bA = this.m_bodyA;\n            var bB = this.m_bodyB;\n            return bB.m_angularVelocity - bA.m_angularVelocity;\n        };\n        /**\n         * Is the joint motor enabled?\n         */\n        RevoluteJoint.prototype.isMotorEnabled = function () {\n            return this.m_enableMotor;\n        };\n        /**\n         * Enable/disable the joint motor.\n         */\n        RevoluteJoint.prototype.enableMotor = function (flag) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_enableMotor = flag;\n        };\n        /**\n         * Get the current motor torque given the inverse time step. Unit is N*m.\n         */\n        RevoluteJoint.prototype.getMotorTorque = function (inv_dt) {\n            return inv_dt * this.m_motorImpulse;\n        };\n        /**\n         * Set the motor speed in radians per second.\n         */\n        RevoluteJoint.prototype.setMotorSpeed = function (speed) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_motorSpeed = speed;\n        };\n        /**\n         * Get the motor speed in radians per second.\n         */\n        RevoluteJoint.prototype.getMotorSpeed = function () {\n            return this.m_motorSpeed;\n        };\n        /**\n         * Set the maximum motor torque, usually in N-m.\n         */\n        RevoluteJoint.prototype.setMaxMotorTorque = function (torque) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_maxMotorTorque = torque;\n        };\n        RevoluteJoint.prototype.getMaxMotorTorque = function () {\n            return this.m_maxMotorTorque;\n        };\n        /**\n         * Is the joint limit enabled?\n         */\n        RevoluteJoint.prototype.isLimitEnabled = function () {\n            return this.m_enableLimit;\n        };\n        /**\n         * Enable/disable the joint limit.\n         */\n        RevoluteJoint.prototype.enableLimit = function (flag) {\n            if (flag != this.m_enableLimit) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_enableLimit = flag;\n                this.m_impulse.z = 0.0;\n            }\n        };\n        /**\n         * Get the lower joint limit in radians.\n         */\n        RevoluteJoint.prototype.getLowerLimit = function () {\n            return this.m_lowerAngle;\n        };\n        /**\n         * Get the upper joint limit in radians.\n         */\n        RevoluteJoint.prototype.getUpperLimit = function () {\n            return this.m_upperAngle;\n        };\n        /**\n         * Set the joint limits in radians.\n         */\n        RevoluteJoint.prototype.setLimits = function (lower, upper) {\n            if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_impulse.z = 0.0;\n                this.m_lowerAngle = lower;\n                this.m_upperAngle = upper;\n            }\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        RevoluteJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        RevoluteJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force given the inverse time step. Unit is N.\n         */\n        RevoluteJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque due to the joint limit given the inverse time step.\n         * Unit is N*m.\n         */\n        RevoluteJoint.prototype.getReactionTorque = function (inv_dt) {\n            return inv_dt * this.m_impulse.z;\n        };\n        RevoluteJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // J = [-I -r1_skew I r2_skew]\n            // [ 0 -1 0 1]\n            // r_skew = [-ry; rx]\n            // Matlab\n            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            var fixedRotation = (iA + iB === 0.0); // bool\n            this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y\n                * this.m_rB.y * iB;\n            this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y\n                * this.m_rB.x * iB;\n            this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n            this.m_mass.ex.y = this.m_mass.ey.x;\n            this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x\n                * this.m_rB.x * iB;\n            this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n            this.m_mass.ex.z = this.m_mass.ez.x;\n            this.m_mass.ey.z = this.m_mass.ez.y;\n            this.m_mass.ez.z = iA + iB;\n            this.m_motorMass = iA + iB;\n            if (this.m_motorMass > 0.0) {\n                this.m_motorMass = 1.0 / this.m_motorMass;\n            }\n            if (this.m_enableMotor == false || fixedRotation) {\n                this.m_motorImpulse = 0.0;\n            }\n            if (this.m_enableLimit && fixedRotation == false) {\n                var jointAngle = aB - aA - this.m_referenceAngle; // float\n                if (math$1.abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * Settings.angularSlop) {\n                    this.m_limitState = equalLimits$1;\n                }\n                else if (jointAngle <= this.m_lowerAngle) {\n                    if (this.m_limitState != atLowerLimit$1) {\n                        this.m_impulse.z = 0.0;\n                    }\n                    this.m_limitState = atLowerLimit$1;\n                }\n                else if (jointAngle >= this.m_upperAngle) {\n                    if (this.m_limitState != atUpperLimit$2) {\n                        this.m_impulse.z = 0.0;\n                    }\n                    this.m_limitState = atUpperLimit$2;\n                }\n                else {\n                    this.m_limitState = inactiveLimit$2;\n                    this.m_impulse.z = 0.0;\n                }\n            }\n            else {\n                this.m_limitState = inactiveLimit$2;\n            }\n            if (step.warmStarting) {\n                // Scale impulses to support a variable time step.\n                this.m_impulse.mul(step.dtRatio);\n                this.m_motorImpulse *= step.dtRatio;\n                var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);\n            }\n            else {\n                this.m_impulse.setZero();\n                this.m_motorImpulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        RevoluteJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            var fixedRotation = (iA + iB === 0.0); // bool\n            // Solve motor constraint.\n            if (this.m_enableMotor && this.m_limitState != equalLimits$1\n                && fixedRotation == false) {\n                var Cdot = wB - wA - this.m_motorSpeed; // float\n                var impulse = -this.m_motorMass * Cdot; // float\n                var oldImpulse = this.m_motorImpulse; // float\n                var maxImpulse = step.dt * this.m_maxMotorTorque; // float\n                this.m_motorImpulse = math$1.clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n                impulse = this.m_motorImpulse - oldImpulse;\n                wA -= iA * impulse;\n                wB += iB * impulse;\n            }\n            // Solve limit constraint.\n            if (this.m_enableLimit && this.m_limitState != inactiveLimit$2\n                && fixedRotation == false) {\n                var Cdot1 = Vec2.zero();\n                Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n                Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n                var Cdot2 = wB - wA; // float\n                var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n                var impulse = Vec3.neg(this.m_mass.solve33(Cdot)); // Vec3\n                if (this.m_limitState == equalLimits$1) {\n                    this.m_impulse.add(impulse);\n                }\n                else if (this.m_limitState == atLowerLimit$1) {\n                    var newImpulse = this.m_impulse.z + impulse.z; // float\n                    if (newImpulse < 0.0) {\n                        var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2\n                        var reduced = this.m_mass.solve22(rhs); // Vec2\n                        impulse.x = reduced.x;\n                        impulse.y = reduced.y;\n                        impulse.z = -this.m_impulse.z;\n                        this.m_impulse.x += reduced.x;\n                        this.m_impulse.y += reduced.y;\n                        this.m_impulse.z = 0.0;\n                    }\n                    else {\n                        this.m_impulse.add(impulse);\n                    }\n                }\n                else if (this.m_limitState == atUpperLimit$2) {\n                    var newImpulse = this.m_impulse.z + impulse.z; // float\n                    if (newImpulse > 0.0) {\n                        var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2\n                        var reduced = this.m_mass.solve22(rhs); // Vec2\n                        impulse.x = reduced.x;\n                        impulse.y = reduced.y;\n                        impulse.z = -this.m_impulse.z;\n                        this.m_impulse.x += reduced.x;\n                        this.m_impulse.y += reduced.y;\n                        this.m_impulse.z = 0.0;\n                    }\n                    else {\n                        this.m_impulse.add(impulse);\n                    }\n                }\n                var P = Vec2.neo(impulse.x, impulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n            }\n            else {\n                // Solve point-to-point constraint\n                var Cdot = Vec2.zero();\n                Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n                Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n                var impulse = this.m_mass.solve22(Vec2.neg(Cdot)); // Vec2\n                this.m_impulse.x += impulse.x;\n                this.m_impulse.y += impulse.y;\n                vA.subMul(mA, impulse);\n                wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n                vB.addMul(mB, impulse);\n                wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        RevoluteJoint.prototype.solvePositionConstraints = function (step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var angularError = 0.0; // float\n            var positionError = 0.0; // float\n            var fixedRotation = (this.m_invIA + this.m_invIB == 0.0); // bool\n            // Solve angular limit constraint.\n            if (this.m_enableLimit && this.m_limitState != inactiveLimit$2\n                && fixedRotation == false) {\n                var angle = aB - aA - this.m_referenceAngle; // float\n                var limitImpulse = 0.0; // float\n                if (this.m_limitState == equalLimits$1) {\n                    // Prevent large angular corrections\n                    var C = math$1.clamp(angle - this.m_lowerAngle, -Settings.maxAngularCorrection, Settings.maxAngularCorrection); // float\n                    limitImpulse = -this.m_motorMass * C;\n                    angularError = math$1.abs(C);\n                }\n                else if (this.m_limitState == atLowerLimit$1) {\n                    var C = angle - this.m_lowerAngle; // float\n                    angularError = -C;\n                    // Prevent large angular corrections and allow some slop.\n                    C = math$1.clamp(C + Settings.angularSlop, -Settings.maxAngularCorrection, 0.0);\n                    limitImpulse = -this.m_motorMass * C;\n                }\n                else if (this.m_limitState == atUpperLimit$2) {\n                    var C = angle - this.m_upperAngle; // float\n                    angularError = C;\n                    // Prevent large angular corrections and allow some slop.\n                    C = math$1.clamp(C - Settings.angularSlop, 0.0, Settings.maxAngularCorrection);\n                    limitImpulse = -this.m_motorMass * C;\n                }\n                aA -= this.m_invIA * limitImpulse;\n                aB += this.m_invIB * limitImpulse;\n            }\n            // Solve point-to-point constraint.\n            {\n                qA.setAngle(aA);\n                qB.setAngle(aB);\n                var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2\n                var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2\n                var C = Vec2.zero();\n                C.addCombine(1, cB, 1, rB);\n                C.subCombine(1, cA, 1, rA);\n                positionError = C.length();\n                var mA = this.m_invMassA;\n                var mB = this.m_invMassB; // float\n                var iA = this.m_invIA;\n                var iB = this.m_invIB; // float\n                var K = new Mat22();\n                K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;\n                K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;\n                K.ey.x = K.ex.y;\n                K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;\n                var impulse = Vec2.neg(K.solve(C)); // Vec2\n                cA.subMul(mA, impulse);\n                aA -= iA * Vec2.crossVec2Vec2(rA, impulse);\n                cB.addMul(mB, impulse);\n                aB += iB * Vec2.crossVec2Vec2(rB, impulse);\n            }\n            this.m_bodyA.c_position.c.setVec2(cA);\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c.setVec2(cB);\n            this.m_bodyB.c_position.a = aB;\n            return positionError <= Settings.linearSlop\n                && angularError <= Settings.angularSlop;\n        };\n        RevoluteJoint.TYPE = 'revolute-joint';\n        return RevoluteJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var inactiveLimit$1 = 0;\n    var atLowerLimit = 1;\n    var atUpperLimit$1 = 2;\n    var equalLimits = 3;\n    var DEFAULTS$7 = {\n        enableLimit: false,\n        lowerTranslation: 0.0,\n        upperTranslation: 0.0,\n        enableMotor: false,\n        maxMotorForce: 0.0,\n        motorSpeed: 0.0\n    };\n    /**\n     * A prismatic joint. This joint provides one degree of freedom: translation\n     * along an axis fixed in bodyA. Relative rotation is prevented. You can use a\n     * joint limit to restrict the range of motion and a joint motor to drive the\n     * motion or to model joint friction.\n     */\n    var PrismaticJoint = /** @class */ (function (_super) {\n        __extends(PrismaticJoint, _super);\n        function PrismaticJoint(def, bodyA, bodyB, anchor, axis) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof PrismaticJoint)) {\n                return new PrismaticJoint(def, bodyA, bodyB, anchor, axis);\n            }\n            def = options(def, DEFAULTS$7);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = PrismaticJoint.TYPE;\n            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n            _this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2.neo(1.0, 0.0));\n            _this.m_localXAxisA.normalize();\n            _this.m_localYAxisA = Vec2.crossNumVec2(1.0, _this.m_localXAxisA);\n            _this.m_referenceAngle = math$1.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n            _this.m_impulse = new Vec3();\n            _this.m_motorMass = 0.0;\n            _this.m_motorImpulse = 0.0;\n            _this.m_lowerTranslation = def.lowerTranslation;\n            _this.m_upperTranslation = def.upperTranslation;\n            _this.m_maxMotorForce = def.maxMotorForce;\n            _this.m_motorSpeed = def.motorSpeed;\n            _this.m_enableLimit = def.enableLimit;\n            _this.m_enableMotor = def.enableMotor;\n            _this.m_limitState = inactiveLimit$1;\n            _this.m_axis = Vec2.zero();\n            _this.m_perp = Vec2.zero();\n            _this.m_K = new Mat33();\n            return _this;\n            // Linear constraint (point-to-line)\n            // d = p2 - p1 = x2 + r2 - x1 - r1\n            // C = dot(perp, d)\n            // Cdot = dot(d, cross(w1, perp)) + dot(perp, v2 + cross(w2, r2) - v1 -\n            // cross(w1, r1))\n            // = -dot(perp, v1) - dot(cross(d + r1, perp), w1) + dot(perp, v2) +\n            // dot(cross(r2, perp), v2)\n            // J = [-perp, -cross(d + r1, perp), perp, cross(r2,perp)]\n            //\n            // Angular constraint\n            // C = a2 - a1 + a_initial\n            // Cdot = w2 - w1\n            // J = [0 0 -1 0 0 1]\n            //\n            // K = J * invM * JT\n            //\n            // J = [-a -s1 a s2]\n            // [0 -1 0 1]\n            // a = perp\n            // s1 = cross(d + r1, a) = cross(p2 - x1, a)\n            // s2 = cross(r2, a) = cross(p2 - x2, a)\n            // Motor/Limit linear constraint\n            // C = dot(ax1, d)\n            // Cdot = = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) +\n            // dot(cross(r2, ax1), v2)\n            // J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]\n            // Block Solver\n            // We develop a block solver that includes the joint limit. This makes the\n            // limit stiff (inelastic) even\n            // when the mass has poor distribution (leading to large torques about the\n            // joint anchor points).\n            //\n            // The Jacobian has 3 rows:\n            // J = [-uT -s1 uT s2] // linear\n            // [0 -1 0 1] // angular\n            // [-vT -a1 vT a2] // limit\n            //\n            // u = perp\n            // v = axis\n            // s1 = cross(d + r1, u), s2 = cross(r2, u)\n            // a1 = cross(d + r1, v), a2 = cross(r2, v)\n            // M * (v2 - v1) = JT * df\n            // J * v2 = bias\n            //\n            // v2 = v1 + invM * JT * df\n            // J * (v1 + invM * JT * df) = bias\n            // K * df = bias - J * v1 = -Cdot\n            // K = J * invM * JT\n            // Cdot = J * v1 - bias\n            //\n            // Now solve for f2.\n            // df = f2 - f1\n            // K * (f2 - f1) = -Cdot\n            // f2 = invK * (-Cdot) + f1\n            //\n            // Clamp accumulated limit impulse.\n            // lower: f2(3) = max(f2(3), 0)\n            // upper: f2(3) = min(f2(3), 0)\n            //\n            // Solve for correct f2(1:2)\n            // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:3) * f1\n            // = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:2) * f1(1:2) + K(1:2,3) * f1(3)\n            // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3)) +\n            // K(1:2,1:2) * f1(1:2)\n            // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n            // f1(1:2)\n            //\n            // Now compute impulse to be applied:\n            // df = f2 - f1\n        }\n        /** @internal */\n        PrismaticJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                lowerTranslation: this.m_lowerTranslation,\n                upperTranslation: this.m_upperTranslation,\n                maxMotorForce: this.m_maxMotorForce,\n                motorSpeed: this.m_motorSpeed,\n                enableLimit: this.m_enableLimit,\n                enableMotor: this.m_enableMotor,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                localAxisA: this.m_localXAxisA,\n                referenceAngle: this.m_referenceAngle,\n            };\n        };\n        /** @internal */\n        PrismaticJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            data.localAxisA = Vec2.clone(data.localAxisA);\n            var joint = new PrismaticJoint(data);\n            return joint;\n        };\n        /** @internal */\n        PrismaticJoint.prototype._setAnchors = function (def) {\n            if (def.anchorA) {\n                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            }\n            else if (def.localAnchorA) {\n                this.m_localAnchorA.setVec2(def.localAnchorA);\n            }\n            if (def.anchorB) {\n                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            }\n            else if (def.localAnchorB) {\n                this.m_localAnchorB.setVec2(def.localAnchorB);\n            }\n            if (def.localAxisA) {\n                this.m_localXAxisA.setVec2(def.localAxisA);\n                this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n            }\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */\n        PrismaticJoint.prototype.getLocalAnchorA = function () {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */\n        PrismaticJoint.prototype.getLocalAnchorB = function () {\n            return this.m_localAnchorB;\n        };\n        /**\n         * The local joint axis relative to bodyA.\n         */\n        PrismaticJoint.prototype.getLocalAxisA = function () {\n            return this.m_localXAxisA;\n        };\n        /**\n         * Get the reference angle.\n         */\n        PrismaticJoint.prototype.getReferenceAngle = function () {\n            return this.m_referenceAngle;\n        };\n        /**\n         * Get the current joint translation, usually in meters.\n         */\n        PrismaticJoint.prototype.getJointTranslation = function () {\n            var pA = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n            var pB = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n            var d = Vec2.sub(pB, pA);\n            var axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);\n            var translation = Vec2.dot(d, axis);\n            return translation;\n        };\n        /**\n         * Get the current joint translation speed, usually in meters per second.\n         */\n        PrismaticJoint.prototype.getJointSpeed = function () {\n            var bA = this.m_bodyA;\n            var bB = this.m_bodyB;\n            var rA = Rot.mulVec2(bA.m_xf.q, Vec2.sub(this.m_localAnchorA, bA.m_sweep.localCenter)); // Vec2\n            var rB = Rot.mulVec2(bB.m_xf.q, Vec2.sub(this.m_localAnchorB, bB.m_sweep.localCenter)); // Vec2\n            var p1 = Vec2.add(bA.m_sweep.c, rA); // Vec2\n            var p2 = Vec2.add(bB.m_sweep.c, rB); // Vec2\n            var d = Vec2.sub(p2, p1); // Vec2\n            var axis = Rot.mulVec2(bA.m_xf.q, this.m_localXAxisA); // Vec2\n            var vA = bA.m_linearVelocity; // Vec2\n            var vB = bB.m_linearVelocity; // Vec2\n            var wA = bA.m_angularVelocity; // float\n            var wB = bB.m_angularVelocity; // float\n            var speed = Vec2.dot(d, Vec2.crossNumVec2(wA, axis))\n                + Vec2.dot(axis, Vec2.sub(Vec2.addCrossNumVec2(vB, wB, rB), Vec2.addCrossNumVec2(vA, wA, rA))); // float\n            return speed;\n        };\n        /**\n         * Is the joint limit enabled?\n         */\n        PrismaticJoint.prototype.isLimitEnabled = function () {\n            return this.m_enableLimit;\n        };\n        /**\n         * Enable/disable the joint limit.\n         */\n        PrismaticJoint.prototype.enableLimit = function (flag) {\n            if (flag != this.m_enableLimit) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_enableLimit = flag;\n                this.m_impulse.z = 0.0;\n            }\n        };\n        /**\n         * Get the lower joint limit, usually in meters.\n         */\n        PrismaticJoint.prototype.getLowerLimit = function () {\n            return this.m_lowerTranslation;\n        };\n        /**\n         * Get the upper joint limit, usually in meters.\n         */\n        PrismaticJoint.prototype.getUpperLimit = function () {\n            return this.m_upperTranslation;\n        };\n        /**\n         * Set the joint limits, usually in meters.\n         */\n        PrismaticJoint.prototype.setLimits = function (lower, upper) {\n            if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_lowerTranslation = lower;\n                this.m_upperTranslation = upper;\n                this.m_impulse.z = 0.0;\n            }\n        };\n        /**\n         * Is the joint motor enabled?\n         */\n        PrismaticJoint.prototype.isMotorEnabled = function () {\n            return this.m_enableMotor;\n        };\n        /**\n         * Enable/disable the joint motor.\n         */\n        PrismaticJoint.prototype.enableMotor = function (flag) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_enableMotor = flag;\n        };\n        /**\n         * Set the motor speed, usually in meters per second.\n         */\n        PrismaticJoint.prototype.setMotorSpeed = function (speed) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_motorSpeed = speed;\n        };\n        /**\n         * Set the maximum motor force, usually in N.\n         */\n        PrismaticJoint.prototype.setMaxMotorForce = function (force) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_maxMotorForce = force;\n        };\n        PrismaticJoint.prototype.getMaxMotorForce = function () {\n            return this.m_maxMotorForce;\n        };\n        /**\n         * Get the motor speed, usually in meters per second.\n         */\n        PrismaticJoint.prototype.getMotorSpeed = function () {\n            return this.m_motorSpeed;\n        };\n        /**\n         * Get the current motor force given the inverse time step, usually in N.\n         */\n        PrismaticJoint.prototype.getMotorForce = function (inv_dt) {\n            return inv_dt * this.m_motorImpulse;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        PrismaticJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        PrismaticJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        PrismaticJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        PrismaticJoint.prototype.getReactionTorque = function (inv_dt) {\n            return inv_dt * this.m_impulse.y;\n        };\n        PrismaticJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            // Compute the effective masses.\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            var d = Vec2.zero();\n            d.addCombine(1, cB, 1, rB);\n            d.subCombine(1, cA, 1, rA);\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            // Compute motor Jacobian and effective mass.\n            {\n                this.m_axis = Rot.mulVec2(qA, this.m_localXAxisA);\n                this.m_a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_axis);\n                this.m_a2 = Vec2.crossVec2Vec2(rB, this.m_axis);\n                this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2\n                    * this.m_a2;\n                if (this.m_motorMass > 0.0) {\n                    this.m_motorMass = 1.0 / this.m_motorMass;\n                }\n            }\n            // Prismatic constraint.\n            {\n                this.m_perp = Rot.mulVec2(qA, this.m_localYAxisA);\n                this.m_s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_perp);\n                this.m_s2 = Vec2.crossVec2Vec2(rB, this.m_perp);\n                Vec2.crossVec2Vec2(rA, this.m_perp);\n                var k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;\n                var k12 = iA * this.m_s1 + iB * this.m_s2;\n                var k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;\n                var k22 = iA + iB;\n                if (k22 == 0.0) {\n                    // For bodies with fixed rotation.\n                    k22 = 1.0;\n                }\n                var k23 = iA * this.m_a1 + iB * this.m_a2;\n                var k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\n                this.m_K.ex.set(k11, k12, k13);\n                this.m_K.ey.set(k12, k22, k23);\n                this.m_K.ez.set(k13, k23, k33);\n            }\n            // Compute motor and limit terms.\n            if (this.m_enableLimit) {\n                var jointTranslation = Vec2.dot(this.m_axis, d); // float\n                if (math$1.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * Settings.linearSlop) {\n                    this.m_limitState = equalLimits;\n                }\n                else if (jointTranslation <= this.m_lowerTranslation) {\n                    if (this.m_limitState != atLowerLimit) {\n                        this.m_limitState = atLowerLimit;\n                        this.m_impulse.z = 0.0;\n                    }\n                }\n                else if (jointTranslation >= this.m_upperTranslation) {\n                    if (this.m_limitState != atUpperLimit$1) {\n                        this.m_limitState = atUpperLimit$1;\n                        this.m_impulse.z = 0.0;\n                    }\n                }\n                else {\n                    this.m_limitState = inactiveLimit$1;\n                    this.m_impulse.z = 0.0;\n                }\n            }\n            else {\n                this.m_limitState = inactiveLimit$1;\n                this.m_impulse.z = 0.0;\n            }\n            if (this.m_enableMotor == false) {\n                this.m_motorImpulse = 0.0;\n            }\n            if (step.warmStarting) {\n                // Account for variable time step.\n                this.m_impulse.mul(step.dtRatio);\n                this.m_motorImpulse *= step.dtRatio;\n                var P = Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse\n                    + this.m_impulse.z, this.m_axis);\n                var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y\n                    + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;\n                var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y\n                    + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            }\n            else {\n                this.m_impulse.setZero();\n                this.m_motorImpulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        PrismaticJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            // Solve linear motor constraint.\n            if (this.m_enableMotor && this.m_limitState != equalLimits) {\n                var Cdot = Vec2.dot(this.m_axis, Vec2.sub(vB, vA)) + this.m_a2 * wB\n                    - this.m_a1 * wA;\n                var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);\n                var oldImpulse = this.m_motorImpulse;\n                var maxImpulse = step.dt * this.m_maxMotorForce;\n                this.m_motorImpulse = math$1.clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n                impulse = this.m_motorImpulse - oldImpulse;\n                var P = Vec2.mulNumVec2(impulse, this.m_axis);\n                var LA = impulse * this.m_a1;\n                var LB = impulse * this.m_a2;\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            }\n            var Cdot1 = Vec2.zero();\n            Cdot1.x += Vec2.dot(this.m_perp, vB) + this.m_s2 * wB;\n            Cdot1.x -= Vec2.dot(this.m_perp, vA) + this.m_s1 * wA;\n            Cdot1.y = wB - wA;\n            if (this.m_enableLimit && this.m_limitState != inactiveLimit$1) {\n                // Solve prismatic and limit constraint in block form.\n                var Cdot2 = 0;\n                Cdot2 += Vec2.dot(this.m_axis, vB) + this.m_a2 * wB;\n                Cdot2 -= Vec2.dot(this.m_axis, vA) + this.m_a1 * wA;\n                var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n                var f1 = Vec3.clone(this.m_impulse);\n                var df = this.m_K.solve33(Vec3.neg(Cdot)); // Vec3\n                this.m_impulse.add(df);\n                if (this.m_limitState == atLowerLimit) {\n                    this.m_impulse.z = math$1.max(this.m_impulse.z, 0.0);\n                }\n                else if (this.m_limitState == atUpperLimit$1) {\n                    this.m_impulse.z = math$1.min(this.m_impulse.z, 0.0);\n                }\n                // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n                // f1(1:2)\n                var b = Vec2.combine(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2.neo(this.m_K.ez.x, this.m_K.ez.y)); // Vec2\n                var f2r = Vec2.add(this.m_K.solve22(b), Vec2.neo(f1.x, f1.y)); // Vec2\n                this.m_impulse.x = f2r.x;\n                this.m_impulse.y = f2r.y;\n                df = Vec3.sub(this.m_impulse, f1);\n                var P = Vec2.combine(df.x, this.m_perp, df.z, this.m_axis); // Vec2\n                var LA = df.x * this.m_s1 + df.y + df.z * this.m_a1; // float\n                var LB = df.x * this.m_s2 + df.y + df.z * this.m_a2; // float\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            }\n            else {\n                // Limit is inactive, just solve the prismatic constraint in block form.\n                var df = this.m_K.solve22(Vec2.neg(Cdot1)); // Vec2\n                this.m_impulse.x += df.x;\n                this.m_impulse.y += df.y;\n                var P = Vec2.mulNumVec2(df.x, this.m_perp); // Vec2\n                var LA = df.x * this.m_s1 + df.y; // float\n                var LB = df.x * this.m_s2 + df.y; // float\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        PrismaticJoint.prototype.solvePositionConstraints = function (step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            // Compute fresh Jacobians\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2\n            var d = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA)); // Vec2\n            var axis = Rot.mulVec2(qA, this.m_localXAxisA); // Vec2\n            var a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), axis); // float\n            var a2 = Vec2.crossVec2Vec2(rB, axis); // float\n            var perp = Rot.mulVec2(qA, this.m_localYAxisA); // Vec2\n            var s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), perp); // float\n            var s2 = Vec2.crossVec2Vec2(rB, perp); // float\n            var impulse = new Vec3();\n            var C1 = Vec2.zero(); // Vec2\n            C1.x = Vec2.dot(perp, d);\n            C1.y = aB - aA - this.m_referenceAngle;\n            var linearError = math$1.abs(C1.x); // float\n            var angularError = math$1.abs(C1.y); // float\n            var linearSlop = Settings.linearSlop;\n            var maxLinearCorrection = Settings.maxLinearCorrection;\n            var active = false; // bool\n            var C2 = 0.0; // float\n            if (this.m_enableLimit) {\n                var translation = Vec2.dot(axis, d); // float\n                if (math$1.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * linearSlop) {\n                    // Prevent large angular corrections\n                    C2 = math$1.clamp(translation, -maxLinearCorrection, maxLinearCorrection);\n                    linearError = math$1.max(linearError, math$1.abs(translation));\n                    active = true;\n                }\n                else if (translation <= this.m_lowerTranslation) {\n                    // Prevent large linear corrections and allow some slop.\n                    C2 = math$1.clamp(translation - this.m_lowerTranslation + linearSlop, -maxLinearCorrection, 0.0);\n                    linearError = math$1\n                        .max(linearError, this.m_lowerTranslation - translation);\n                    active = true;\n                }\n                else if (translation >= this.m_upperTranslation) {\n                    // Prevent large linear corrections and allow some slop.\n                    C2 = math$1.clamp(translation - this.m_upperTranslation - linearSlop, 0.0, maxLinearCorrection);\n                    linearError = math$1\n                        .max(linearError, translation - this.m_upperTranslation);\n                    active = true;\n                }\n            }\n            if (active) {\n                var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float\n                var k12 = iA * s1 + iB * s2; // float\n                var k13 = iA * s1 * a1 + iB * s2 * a2; // float\n                var k22 = iA + iB; // float\n                if (k22 == 0.0) {\n                    // For fixed rotation\n                    k22 = 1.0;\n                }\n                var k23 = iA * a1 + iB * a2; // float\n                var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2; // float\n                var K = new Mat33();\n                K.ex.set(k11, k12, k13);\n                K.ey.set(k12, k22, k23);\n                K.ez.set(k13, k23, k33);\n                var C = new Vec3();\n                C.x = C1.x;\n                C.y = C1.y;\n                C.z = C2;\n                impulse = K.solve33(Vec3.neg(C));\n            }\n            else {\n                var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float\n                var k12 = iA * s1 + iB * s2; // float\n                var k22 = iA + iB; // float\n                if (k22 == 0.0) {\n                    k22 = 1.0;\n                }\n                var K = new Mat22();\n                K.ex.setNum(k11, k12);\n                K.ey.setNum(k12, k22);\n                var impulse1 = K.solve(Vec2.neg(C1)); // Vec2\n                impulse.x = impulse1.x;\n                impulse.y = impulse1.y;\n                impulse.z = 0.0;\n            }\n            var P = Vec2.combine(impulse.x, perp, impulse.z, axis); // Vec2\n            var LA = impulse.x * s1 + impulse.y + impulse.z * a1; // float\n            var LB = impulse.x * s2 + impulse.y + impulse.z * a2; // float\n            cA.subMul(mA, P);\n            aA -= iA * LA;\n            cB.addMul(mB, P);\n            aB += iB * LB;\n            this.m_bodyA.c_position.c = cA;\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c = cB;\n            this.m_bodyB.c_position.a = aB;\n            return linearError <= Settings.linearSlop\n                && angularError <= Settings.angularSlop;\n        };\n        PrismaticJoint.TYPE = 'prismatic-joint';\n        return PrismaticJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS$6 = {\n        ratio: 1.0\n    };\n    /**\n     * A gear joint is used to connect two joints together. Either joint can be a\n     * revolute or prismatic joint. You specify a gear ratio to bind the motions\n     * together: coordinate1 + ratio * coordinate2 = constant\n     *\n     * The ratio can be negative or positive. If one joint is a revolute joint and\n     * the other joint is a prismatic joint, then the ratio will have units of\n     * length or units of 1/length. Warning: You have to manually destroy the gear\n     * joint if joint1 or joint2 is destroyed.\n     *\n     * This definition requires two existing revolute or prismatic joints (any\n     * combination will work).\n     */\n    var GearJoint = /** @class */ (function (_super) {\n        __extends(GearJoint, _super);\n        function GearJoint(def, bodyA, bodyB, joint1, joint2, ratio) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof GearJoint)) {\n                return new GearJoint(def, bodyA, bodyB, joint1, joint2, ratio);\n            }\n            def = options(def, DEFAULTS$6);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = GearJoint.TYPE;\n            _this.m_joint1 = joint1 ? joint1 : def.joint1;\n            _this.m_joint2 = joint2 ? joint2 : def.joint2;\n            _this.m_ratio = math$1.isFinite(ratio) ? ratio : def.ratio;\n            _this.m_type1 = _this.m_joint1.getType();\n            _this.m_type2 = _this.m_joint2.getType();\n            // joint1 connects body A to body C\n            // joint2 connects body B to body D\n            var coordinateA;\n            var coordinateB;\n            // TODO_ERIN there might be some problem with the joint edges in Joint.\n            _this.m_bodyC = _this.m_joint1.getBodyA();\n            _this.m_bodyA = _this.m_joint1.getBodyB();\n            // Get geometry of joint1\n            var xfA = _this.m_bodyA.m_xf;\n            var aA = _this.m_bodyA.m_sweep.a;\n            var xfC = _this.m_bodyC.m_xf;\n            var aC = _this.m_bodyC.m_sweep.a;\n            if (_this.m_type1 === RevoluteJoint.TYPE) {\n                var revolute = _this.m_joint1;\n                _this.m_localAnchorC = revolute.m_localAnchorA;\n                _this.m_localAnchorA = revolute.m_localAnchorB;\n                _this.m_referenceAngleA = revolute.m_referenceAngle;\n                _this.m_localAxisC = Vec2.zero();\n                coordinateA = aA - aC - _this.m_referenceAngleA;\n            }\n            else {\n                var prismatic = _this.m_joint1;\n                _this.m_localAnchorC = prismatic.m_localAnchorA;\n                _this.m_localAnchorA = prismatic.m_localAnchorB;\n                _this.m_referenceAngleA = prismatic.m_referenceAngle;\n                _this.m_localAxisC = prismatic.m_localXAxisA;\n                var pC = _this.m_localAnchorC;\n                var pA = Rot.mulTVec2(xfC.q, Vec2.add(Rot.mulVec2(xfA.q, _this.m_localAnchorA), Vec2.sub(xfA.p, xfC.p)));\n                coordinateA = Vec2.dot(pA, _this.m_localAxisC) - Vec2.dot(pC, _this.m_localAxisC);\n            }\n            _this.m_bodyD = _this.m_joint2.getBodyA();\n            _this.m_bodyB = _this.m_joint2.getBodyB();\n            // Get geometry of joint2\n            var xfB = _this.m_bodyB.m_xf;\n            var aB = _this.m_bodyB.m_sweep.a;\n            var xfD = _this.m_bodyD.m_xf;\n            var aD = _this.m_bodyD.m_sweep.a;\n            if (_this.m_type2 === RevoluteJoint.TYPE) {\n                var revolute = _this.m_joint2;\n                _this.m_localAnchorD = revolute.m_localAnchorA;\n                _this.m_localAnchorB = revolute.m_localAnchorB;\n                _this.m_referenceAngleB = revolute.m_referenceAngle;\n                _this.m_localAxisD = Vec2.zero();\n                coordinateB = aB - aD - _this.m_referenceAngleB;\n            }\n            else {\n                var prismatic = _this.m_joint2;\n                _this.m_localAnchorD = prismatic.m_localAnchorA;\n                _this.m_localAnchorB = prismatic.m_localAnchorB;\n                _this.m_referenceAngleB = prismatic.m_referenceAngle;\n                _this.m_localAxisD = prismatic.m_localXAxisA;\n                var pD = _this.m_localAnchorD;\n                var pB = Rot.mulTVec2(xfD.q, Vec2.add(Rot.mulVec2(xfB.q, _this.m_localAnchorB), Vec2.sub(xfB.p, xfD.p)));\n                coordinateB = Vec2.dot(pB, _this.m_localAxisD) - Vec2.dot(pD, _this.m_localAxisD);\n            }\n            _this.m_constant = coordinateA + _this.m_ratio * coordinateB;\n            _this.m_impulse = 0.0;\n            return _this;\n            // Gear Joint:\n            // C0 = (coordinate1 + ratio * coordinate2)_initial\n            // C = (coordinate1 + ratio * coordinate2) - C0 = 0\n            // J = [J1 ratio * J2]\n            // K = J * invM * JT\n            // = J1 * invM1 * J1T + ratio * ratio * J2 * invM2 * J2T\n            //\n            // Revolute:\n            // coordinate = rotation\n            // Cdot = angularVelocity\n            // J = [0 0 1]\n            // K = J * invM * JT = invI\n            //\n            // Prismatic:\n            // coordinate = dot(p - pg, ug)\n            // Cdot = dot(v + cross(w, r), ug)\n            // J = [ug cross(r, ug)]\n            // K = J * invM * JT = invMass + invI * cross(r, ug)^2\n        }\n        /** @internal */\n        GearJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                joint1: this.m_joint1,\n                joint2: this.m_joint2,\n                ratio: this.m_ratio,\n                // _constant: this.m_constant,\n            };\n        };\n        /** @internal */\n        GearJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            data.joint1 = restore(Joint, data.joint1, world);\n            data.joint2 = restore(Joint, data.joint2, world);\n            var joint = new GearJoint(data);\n            // if (data._constant) joint.m_constant = data._constant;\n            return joint;\n        };\n        /**\n         * Get the first joint.\n         */\n        GearJoint.prototype.getJoint1 = function () {\n            return this.m_joint1;\n        };\n        /**\n         * Get the second joint.\n         */\n        GearJoint.prototype.getJoint2 = function () {\n            return this.m_joint2;\n        };\n        /**\n         * Set the gear ratio.\n         */\n        GearJoint.prototype.setRatio = function (ratio) {\n            this.m_ratio = ratio;\n        };\n        /**\n         * Get the gear ratio.\n         */\n        GearJoint.prototype.getRatio = function () {\n            return this.m_ratio;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        GearJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        GearJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        GearJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.mulNumVec2(this.m_impulse, this.m_JvAC).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        GearJoint.prototype.getReactionTorque = function (inv_dt) {\n            var L = this.m_impulse * this.m_JwA; // float\n            return inv_dt * L;\n        };\n        GearJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_lcA = this.m_bodyA.m_sweep.localCenter;\n            this.m_lcB = this.m_bodyB.m_sweep.localCenter;\n            this.m_lcC = this.m_bodyC.m_sweep.localCenter;\n            this.m_lcD = this.m_bodyD.m_sweep.localCenter;\n            this.m_mA = this.m_bodyA.m_invMass;\n            this.m_mB = this.m_bodyB.m_invMass;\n            this.m_mC = this.m_bodyC.m_invMass;\n            this.m_mD = this.m_bodyD.m_invMass;\n            this.m_iA = this.m_bodyA.m_invI;\n            this.m_iB = this.m_bodyB.m_invI;\n            this.m_iC = this.m_bodyC.m_invI;\n            this.m_iD = this.m_bodyD.m_invI;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var aC = this.m_bodyC.c_position.a;\n            var vC = this.m_bodyC.c_velocity.v;\n            var wC = this.m_bodyC.c_velocity.w;\n            var aD = this.m_bodyD.c_position.a;\n            var vD = this.m_bodyD.c_velocity.v;\n            var wD = this.m_bodyD.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var qC = Rot.neo(aC);\n            var qD = Rot.neo(aD);\n            this.m_mass = 0.0;\n            if (this.m_type1 == RevoluteJoint.TYPE) {\n                this.m_JvAC = Vec2.zero();\n                this.m_JwA = 1.0;\n                this.m_JwC = 1.0;\n                this.m_mass += this.m_iA + this.m_iC;\n            }\n            else {\n                var u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2\n                var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2\n                var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2\n                this.m_JvAC = u;\n                this.m_JwC = Vec2.crossVec2Vec2(rC, u);\n                this.m_JwA = Vec2.crossVec2Vec2(rA, u);\n                this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;\n            }\n            if (this.m_type2 == RevoluteJoint.TYPE) {\n                this.m_JvBD = Vec2.zero();\n                this.m_JwB = this.m_ratio;\n                this.m_JwD = this.m_ratio;\n                this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n            }\n            else {\n                var u = Rot.mulVec2(qD, this.m_localAxisD); // Vec2\n                var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD); // Vec2\n                var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB); // Vec2\n                this.m_JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n                this.m_JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n                this.m_JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n                this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;\n            }\n            // Compute effective mass.\n            this.m_mass = this.m_mass > 0.0 ? 1.0 / this.m_mass : 0.0;\n            if (step.warmStarting) {\n                vA.addMul(this.m_mA * this.m_impulse, this.m_JvAC);\n                wA += this.m_iA * this.m_impulse * this.m_JwA;\n                vB.addMul(this.m_mB * this.m_impulse, this.m_JvBD);\n                wB += this.m_iB * this.m_impulse * this.m_JwB;\n                vC.subMul(this.m_mC * this.m_impulse, this.m_JvAC);\n                wC -= this.m_iC * this.m_impulse * this.m_JwC;\n                vD.subMul(this.m_mD * this.m_impulse, this.m_JvBD);\n                wD -= this.m_iD * this.m_impulse * this.m_JwD;\n            }\n            else {\n                this.m_impulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n            this.m_bodyC.c_velocity.v.setVec2(vC);\n            this.m_bodyC.c_velocity.w = wC;\n            this.m_bodyD.c_velocity.v.setVec2(vD);\n            this.m_bodyD.c_velocity.w = wD;\n        };\n        GearJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var vC = this.m_bodyC.c_velocity.v;\n            var wC = this.m_bodyC.c_velocity.w;\n            var vD = this.m_bodyD.c_velocity.v;\n            var wD = this.m_bodyD.c_velocity.w;\n            var Cdot = Vec2.dot(this.m_JvAC, vA) - Vec2.dot(this.m_JvAC, vC)\n                + Vec2.dot(this.m_JvBD, vB) - Vec2.dot(this.m_JvBD, vD); // float\n            Cdot += (this.m_JwA * wA - this.m_JwC * wC)\n                + (this.m_JwB * wB - this.m_JwD * wD);\n            var impulse = -this.m_mass * Cdot; // float\n            this.m_impulse += impulse;\n            vA.addMul(this.m_mA * impulse, this.m_JvAC);\n            wA += this.m_iA * impulse * this.m_JwA;\n            vB.addMul(this.m_mB * impulse, this.m_JvBD);\n            wB += this.m_iB * impulse * this.m_JwB;\n            vC.subMul(this.m_mC * impulse, this.m_JvAC);\n            wC -= this.m_iC * impulse * this.m_JwC;\n            vD.subMul(this.m_mD * impulse, this.m_JvBD);\n            wD -= this.m_iD * impulse * this.m_JwD;\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n            this.m_bodyC.c_velocity.v.setVec2(vC);\n            this.m_bodyC.c_velocity.w = wC;\n            this.m_bodyD.c_velocity.v.setVec2(vD);\n            this.m_bodyD.c_velocity.w = wD;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        GearJoint.prototype.solvePositionConstraints = function (step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var cC = this.m_bodyC.c_position.c;\n            var aC = this.m_bodyC.c_position.a;\n            var cD = this.m_bodyD.c_position.c;\n            var aD = this.m_bodyD.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var qC = Rot.neo(aC);\n            var qD = Rot.neo(aD);\n            var linearError = 0.0;\n            var coordinateA;\n            var coordinateB;\n            var JvAC;\n            var JvBD;\n            var JwA;\n            var JwB;\n            var JwC;\n            var JwD;\n            var mass = 0.0;\n            if (this.m_type1 == RevoluteJoint.TYPE) {\n                JvAC = Vec2.zero();\n                JwA = 1.0;\n                JwC = 1.0;\n                mass += this.m_iA + this.m_iC;\n                coordinateA = aA - aC - this.m_referenceAngleA;\n            }\n            else {\n                var u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2\n                var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2\n                var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2\n                JvAC = u;\n                JwC = Vec2.crossVec2Vec2(rC, u);\n                JwA = Vec2.crossVec2Vec2(rA, u);\n                mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;\n                var pC = Vec2.sub(this.m_localAnchorC, this.m_lcC); // Vec2\n                var pA = Rot.mulTVec2(qC, Vec2.add(rA, Vec2.sub(cA, cC))); // Vec2\n                coordinateA = Vec2.dot(Vec2.sub(pA, pC), this.m_localAxisC);\n            }\n            if (this.m_type2 == RevoluteJoint.TYPE) {\n                JvBD = Vec2.zero();\n                JwB = this.m_ratio;\n                JwD = this.m_ratio;\n                mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n                coordinateB = aB - aD - this.m_referenceAngleB;\n            }\n            else {\n                var u = Rot.mulVec2(qD, this.m_localAxisD);\n                var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);\n                var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);\n                JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n                JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n                JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n                mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD\n                    * JwD * JwD + this.m_iB * JwB * JwB;\n                var pD = Vec2.sub(this.m_localAnchorD, this.m_lcD); // Vec2\n                var pB = Rot.mulTVec2(qD, Vec2.add(rB, Vec2.sub(cB, cD))); // Vec2\n                coordinateB = Vec2.dot(pB, this.m_localAxisD)\n                    - Vec2.dot(pD, this.m_localAxisD);\n            }\n            var C = (coordinateA + this.m_ratio * coordinateB) - this.m_constant; // float\n            var impulse = 0.0; // float\n            if (mass > 0.0) {\n                impulse = -C / mass;\n            }\n            cA.addMul(this.m_mA * impulse, JvAC);\n            aA += this.m_iA * impulse * JwA;\n            cB.addMul(this.m_mB * impulse, JvBD);\n            aB += this.m_iB * impulse * JwB;\n            cC.subMul(this.m_mC * impulse, JvAC);\n            aC -= this.m_iC * impulse * JwC;\n            cD.subMul(this.m_mD * impulse, JvBD);\n            aD -= this.m_iD * impulse * JwD;\n            this.m_bodyA.c_position.c.setVec2(cA);\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c.setVec2(cB);\n            this.m_bodyB.c_position.a = aB;\n            this.m_bodyC.c_position.c.setVec2(cC);\n            this.m_bodyC.c_position.a = aC;\n            this.m_bodyD.c_position.c.setVec2(cD);\n            this.m_bodyD.c_position.a = aD;\n            // TODO_ERIN not implemented\n            return linearError < Settings.linearSlop;\n        };\n        GearJoint.TYPE = 'gear-joint';\n        return GearJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS$5 = {\n        maxForce: 1.0,\n        maxTorque: 1.0,\n        correctionFactor: 0.3\n    };\n    /**\n     * A motor joint is used to control the relative motion between two bodies. A\n     * typical usage is to control the movement of a dynamic body with respect to\n     * the ground.\n     */\n    var MotorJoint = /** @class */ (function (_super) {\n        __extends(MotorJoint, _super);\n        function MotorJoint(def, bodyA, bodyB) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof MotorJoint)) {\n                return new MotorJoint(def, bodyA, bodyB);\n            }\n            def = options(def, DEFAULTS$5);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = MotorJoint.TYPE;\n            _this.m_linearOffset = math$1.isFinite(def.linearOffset) ? def.linearOffset : bodyA.getLocalPoint(bodyB.getPosition());\n            _this.m_angularOffset = math$1.isFinite(def.angularOffset) ? def.angularOffset : bodyB.getAngle() - bodyA.getAngle();\n            _this.m_linearImpulse = Vec2.zero();\n            _this.m_angularImpulse = 0.0;\n            _this.m_maxForce = def.maxForce;\n            _this.m_maxTorque = def.maxTorque;\n            _this.m_correctionFactor = def.correctionFactor;\n            return _this;\n            // Point-to-point constraint\n            // Cdot = v2 - v1\n            // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n            // J = [-I -r1_skew I r2_skew ]\n            // Identity used:\n            // w k % (rx i + ry j) = w * (-ry i + rx j)\n            // Angle constraint\n            // Cdot = w2 - w1\n            // J = [0 0 -1 0 0 1]\n            // K = invI1 + invI2\n        }\n        /** @internal */\n        MotorJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                maxForce: this.m_maxForce,\n                maxTorque: this.m_maxTorque,\n                correctionFactor: this.m_correctionFactor,\n                linearOffset: this.m_linearOffset,\n                angularOffset: this.m_angularOffset,\n            };\n        };\n        /** @internal */\n        MotorJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new MotorJoint(data);\n            return joint;\n        };\n        /** @internal */\n        MotorJoint.prototype._setAnchors = function (def) {\n        };\n        /**\n         * Set the maximum friction force in N.\n         */\n        MotorJoint.prototype.setMaxForce = function (force) {\n            this.m_maxForce = force;\n        };\n        /**\n         * Get the maximum friction force in N.\n         */\n        MotorJoint.prototype.getMaxForce = function () {\n            return this.m_maxForce;\n        };\n        /**\n         * Set the maximum friction torque in N*m.\n         */\n        MotorJoint.prototype.setMaxTorque = function (torque) {\n            this.m_maxTorque = torque;\n        };\n        /**\n         * Get the maximum friction torque in N*m.\n         */\n        MotorJoint.prototype.getMaxTorque = function () {\n            return this.m_maxTorque;\n        };\n        /**\n         * Set the position correction factor in the range [0,1].\n         */\n        MotorJoint.prototype.setCorrectionFactor = function (factor) {\n            this.m_correctionFactor = factor;\n        };\n        /**\n         * Get the position correction factor in the range [0,1].\n         */\n        MotorJoint.prototype.getCorrectionFactor = function () {\n            return this.m_correctionFactor;\n        };\n        /**\n         * Set/get the target linear offset, in frame A, in meters.\n         */\n        MotorJoint.prototype.setLinearOffset = function (linearOffset) {\n            if (linearOffset.x != this.m_linearOffset.x\n                || linearOffset.y != this.m_linearOffset.y) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_linearOffset = linearOffset;\n            }\n        };\n        MotorJoint.prototype.getLinearOffset = function () {\n            return this.m_linearOffset;\n        };\n        /**\n         * Set/get the target angular offset, in radians.\n         */\n        MotorJoint.prototype.setAngularOffset = function (angularOffset) {\n            if (angularOffset != this.m_angularOffset) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_angularOffset = angularOffset;\n            }\n        };\n        MotorJoint.prototype.getAngularOffset = function () {\n            return this.m_angularOffset;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        MotorJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getPosition();\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        MotorJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getPosition();\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        MotorJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        MotorJoint.prototype.getReactionTorque = function (inv_dt) {\n            return inv_dt * this.m_angularImpulse;\n        };\n        MotorJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            // Compute the effective mass matrix.\n            this.m_rA = Rot.mulVec2(qA, Vec2.neg(this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.neg(this.m_localCenterB));\n            // J = [-I -r1_skew I r2_skew]\n            // [ 0 -1 0 1]\n            // r_skew = [-ry; rx]\n            // Matlab\n            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var K = new Mat22();\n            K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;\n            K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n            K.ey.x = K.ex.y;\n            K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;\n            this.m_linearMass = K.getInverse();\n            this.m_angularMass = iA + iB;\n            if (this.m_angularMass > 0.0) {\n                this.m_angularMass = 1.0 / this.m_angularMass;\n            }\n            this.m_linearError = Vec2.zero();\n            this.m_linearError.addCombine(1, cB, 1, this.m_rB);\n            this.m_linearError.subCombine(1, cA, 1, this.m_rA);\n            this.m_linearError.sub(Rot.mulVec2(qA, this.m_linearOffset));\n            this.m_angularError = aB - aA - this.m_angularOffset;\n            if (step.warmStarting) {\n                // Scale impulses to support a variable time step.\n                this.m_linearImpulse.mul(step.dtRatio);\n                this.m_angularImpulse *= step.dtRatio;\n                var P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n            }\n            else {\n                this.m_linearImpulse.setZero();\n                this.m_angularImpulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        MotorJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var h = step.dt;\n            var inv_h = step.inv_dt;\n            // Solve angular friction\n            {\n                var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;\n                var impulse = -this.m_angularMass * Cdot;\n                var oldImpulse = this.m_angularImpulse;\n                var maxImpulse = h * this.m_maxTorque;\n                this.m_angularImpulse = math$1.clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);\n                impulse = this.m_angularImpulse - oldImpulse;\n                wA -= iA * impulse;\n                wB += iB * impulse;\n            }\n            // Solve linear friction\n            {\n                var Cdot = Vec2.zero();\n                Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n                Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n                Cdot.addMul(inv_h * this.m_correctionFactor, this.m_linearError);\n                var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));\n                var oldImpulse = Vec2.clone(this.m_linearImpulse);\n                this.m_linearImpulse.add(impulse);\n                var maxImpulse = h * this.m_maxForce;\n                this.m_linearImpulse.clamp(maxImpulse);\n                impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n                vA.subMul(mA, impulse);\n                wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n                vB.addMul(mB, impulse);\n                wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        MotorJoint.prototype.solvePositionConstraints = function (step) {\n            return true;\n        };\n        MotorJoint.TYPE = 'motor-joint';\n        return MotorJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS$4 = {\n        maxForce: 0.0,\n        frequencyHz: 5.0,\n        dampingRatio: 0.7\n    };\n    /**\n     * A mouse joint is used to make a point on a body track a specified world\n     * point. This a soft constraint with a maximum force. This allows the\n     * constraint to stretch and without applying huge forces.\n     *\n     * NOTE: this joint is not documented in the manual because it was developed to\n     * be used in the testbed. If you want to learn how to use the mouse joint, look\n     * at the testbed.\n     */\n    var MouseJoint = /** @class */ (function (_super) {\n        __extends(MouseJoint, _super);\n        function MouseJoint(def, bodyA, bodyB, target) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof MouseJoint)) {\n                return new MouseJoint(def, bodyA, bodyB, target);\n            }\n            def = options(def, DEFAULTS$4);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = MouseJoint.TYPE;\n            _this.m_targetA = target ? Vec2.clone(target) : def.target || Vec2.zero();\n            _this.m_localAnchorB = Transform.mulTVec2(bodyB.getTransform(), _this.m_targetA);\n            _this.m_maxForce = def.maxForce;\n            _this.m_impulse = Vec2.zero();\n            _this.m_frequencyHz = def.frequencyHz;\n            _this.m_dampingRatio = def.dampingRatio;\n            _this.m_beta = 0.0;\n            _this.m_gamma = 0.0;\n            // Solver temp\n            _this.m_rB = Vec2.zero();\n            _this.m_localCenterB = Vec2.zero();\n            _this.m_invMassB = 0.0;\n            _this.m_invIB = 0.0;\n            _this.m_mass = new Mat22();\n            _this.m_C = Vec2.zero();\n            return _this;\n            // p = attached point, m = mouse point\n            // C = p - m\n            // Cdot = v\n            // = v + cross(w, r)\n            // J = [I r_skew]\n            // Identity used:\n            // w k % (rx i + ry j) = w * (-ry i + rx j)\n        }\n        /** @internal */\n        MouseJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                target: this.m_targetA,\n                maxForce: this.m_maxForce,\n                frequencyHz: this.m_frequencyHz,\n                dampingRatio: this.m_dampingRatio,\n                _localAnchorB: this.m_localAnchorB,\n            };\n        };\n        /** @internal */\n        MouseJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            data.target = Vec2.clone(data.target);\n            var joint = new MouseJoint(data);\n            if (data._localAnchorB) {\n                joint.m_localAnchorB = data._localAnchorB;\n            }\n            return joint;\n        };\n        /**\n         * Use this to update the target point.\n         */\n        MouseJoint.prototype.setTarget = function (target) {\n            if (this.m_bodyB.isAwake() == false) {\n                this.m_bodyB.setAwake(true);\n            }\n            this.m_targetA = Vec2.clone(target);\n        };\n        MouseJoint.prototype.getTarget = function () {\n            return this.m_targetA;\n        };\n        /**\n         * Set the maximum force in Newtons.\n         */\n        MouseJoint.prototype.setMaxForce = function (force) {\n            this.m_maxForce = force;\n        };\n        /**\n         * Get the maximum force in Newtons.\n         */\n        MouseJoint.prototype.getMaxForce = function () {\n            return this.m_maxForce;\n        };\n        /**\n         * Set the frequency in Hertz.\n         */\n        MouseJoint.prototype.setFrequency = function (hz) {\n            this.m_frequencyHz = hz;\n        };\n        /**\n         * Get the frequency in Hertz.\n         */\n        MouseJoint.prototype.getFrequency = function () {\n            return this.m_frequencyHz;\n        };\n        /**\n         * Set the damping ratio (dimensionless).\n         */\n        MouseJoint.prototype.setDampingRatio = function (ratio) {\n            this.m_dampingRatio = ratio;\n        };\n        /**\n         * Get the damping ratio (dimensionless).\n         */\n        MouseJoint.prototype.getDampingRatio = function () {\n            return this.m_dampingRatio;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        MouseJoint.prototype.getAnchorA = function () {\n            return Vec2.clone(this.m_targetA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        MouseJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        MouseJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.mulNumVec2(inv_dt, this.m_impulse);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        MouseJoint.prototype.getReactionTorque = function (inv_dt) {\n            return inv_dt * 0.0;\n        };\n        /**\n         * Shift the origin for any points stored in world coordinates.\n         */\n        MouseJoint.prototype.shiftOrigin = function (newOrigin) {\n            this.m_targetA.sub(newOrigin);\n        };\n        MouseJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var position = this.m_bodyB.c_position;\n            var velocity = this.m_bodyB.c_velocity;\n            var cB = position.c;\n            var aB = position.a;\n            var vB = velocity.v;\n            var wB = velocity.w;\n            var qB = Rot.neo(aB);\n            var mass = this.m_bodyB.getMass();\n            // Frequency\n            var omega = 2.0 * math$1.PI * this.m_frequencyHz;\n            // Damping coefficient\n            var d = 2.0 * mass * this.m_dampingRatio * omega;\n            // Spring stiffness\n            var k = mass * (omega * omega);\n            // magic formulas\n            // gamma has units of inverse mass.\n            // beta has units of inverse time.\n            var h = step.dt;\n            this.m_gamma = h * (d + h * k);\n            if (this.m_gamma != 0.0) {\n                this.m_gamma = 1.0 / this.m_gamma;\n            }\n            this.m_beta = h * k * this.m_gamma;\n            // Compute the effective mass matrix.\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // K = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) *\n            // invI2 * skew(r2)]\n            // = [1/m1+1/m2 0 ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y\n            // -r1.x*r1.y]\n            // [ 0 1/m1+1/m2] [-r1.x*r1.y r1.x*r1.x] [-r1.x*r1.y r1.x*r1.x]\n            var K = new Mat22();\n            K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y\n                + this.m_gamma;\n            K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;\n            K.ey.x = K.ex.y;\n            K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x\n                + this.m_gamma;\n            this.m_mass = K.getInverse();\n            this.m_C.setVec2(cB);\n            this.m_C.addCombine(1, this.m_rB, -1, this.m_targetA);\n            this.m_C.mul(this.m_beta);\n            // Cheat with some damping\n            wB *= 0.98;\n            if (step.warmStarting) {\n                this.m_impulse.mul(step.dtRatio);\n                vB.addMul(this.m_invMassB, this.m_impulse);\n                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, this.m_impulse);\n            }\n            else {\n                this.m_impulse.setZero();\n            }\n            velocity.v.setVec2(vB);\n            velocity.w = wB;\n        };\n        MouseJoint.prototype.solveVelocityConstraints = function (step) {\n            var velocity = this.m_bodyB.c_velocity;\n            var vB = Vec2.clone(velocity.v);\n            var wB = velocity.w;\n            // Cdot = v + cross(w, r)\n            var Cdot = Vec2.crossNumVec2(wB, this.m_rB);\n            Cdot.add(vB);\n            Cdot.addCombine(1, this.m_C, this.m_gamma, this.m_impulse);\n            Cdot.neg();\n            var impulse = Mat22.mulVec2(this.m_mass, Cdot);\n            var oldImpulse = Vec2.clone(this.m_impulse);\n            this.m_impulse.add(impulse);\n            var maxImpulse = step.dt * this.m_maxForce;\n            this.m_impulse.clamp(maxImpulse);\n            impulse = Vec2.sub(this.m_impulse, oldImpulse);\n            vB.addMul(this.m_invMassB, impulse);\n            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n            velocity.v.setVec2(vB);\n            velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        MouseJoint.prototype.solvePositionConstraints = function (step) {\n            return true;\n        };\n        MouseJoint.TYPE = 'mouse-joint';\n        return MouseJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS$3 = {\n        collideConnected: true\n    };\n    /**\n     * The pulley joint is connected to two bodies and two fixed ground points. The\n     * pulley supports a ratio such that: length1 + ratio * length2 <= constant\n     *\n     * Yes, the force transmitted is scaled by the ratio.\n     *\n     * Warning: the pulley joint can get a bit squirrelly by itself. They often work\n     * better when combined with prismatic joints. You should also cover the the\n     * anchor points with static shapes to prevent one side from going to zero\n     * length.\n     */\n    var PulleyJoint = /** @class */ (function (_super) {\n        __extends(PulleyJoint, _super);\n        function PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof PulleyJoint)) {\n                return new PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);\n            }\n            def = options(def, DEFAULTS$3);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = PulleyJoint.TYPE;\n            _this.m_groundAnchorA = groundA ? groundA : def.groundAnchorA || Vec2.neo(-1.0, 1.0);\n            _this.m_groundAnchorB = groundB ? groundB : def.groundAnchorB || Vec2.neo(1.0, 1.0);\n            _this.m_localAnchorA = anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.neo(-1.0, 0.0);\n            _this.m_localAnchorB = anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.neo(1.0, 0.0);\n            _this.m_lengthA = math$1.isFinite(def.lengthA) ? def.lengthA : Vec2.distance(anchorA, groundA);\n            _this.m_lengthB = math$1.isFinite(def.lengthB) ? def.lengthB : Vec2.distance(anchorB, groundB);\n            _this.m_ratio = math$1.isFinite(ratio) ? ratio : def.ratio;\n            _this.m_constant = _this.m_lengthA + _this.m_ratio * _this.m_lengthB;\n            _this.m_impulse = 0.0;\n            return _this;\n            // Pulley:\n            // length1 = norm(p1 - s1)\n            // length2 = norm(p2 - s2)\n            // C0 = (length1 + ratio * length2)_initial\n            // C = C0 - (length1 + ratio * length2)\n            // u1 = (p1 - s1) / norm(p1 - s1)\n            // u2 = (p2 - s2) / norm(p2 - s2)\n            // Cdot = -dot(u1, v1 + cross(w1, r1)) - ratio * dot(u2, v2 + cross(w2, r2))\n            // J = -[u1 cross(r1, u1) ratio * u2 ratio * cross(r2, u2)]\n            // K = J * invM * JT\n            // = invMass1 + invI1 * cross(r1, u1)^2 + ratio^2 * (invMass2 + invI2 *\n            // cross(r2, u2)^2)\n        }\n        PulleyJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                groundAnchorA: this.m_groundAnchorA,\n                groundAnchorB: this.m_groundAnchorB,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                lengthA: this.m_lengthA,\n                lengthB: this.m_lengthB,\n                ratio: this.m_ratio,\n            };\n        };\n        /** @internal */\n        PulleyJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new PulleyJoint(data);\n            return joint;\n        };\n        /**\n         * Get the first ground anchor.\n         */\n        PulleyJoint.prototype.getGroundAnchorA = function () {\n            return this.m_groundAnchorA;\n        };\n        /**\n         * Get the second ground anchor.\n         */\n        PulleyJoint.prototype.getGroundAnchorB = function () {\n            return this.m_groundAnchorB;\n        };\n        /**\n         * Get the current length of the segment attached to bodyA.\n         */\n        PulleyJoint.prototype.getLengthA = function () {\n            return this.m_lengthA;\n        };\n        /**\n         * Get the current length of the segment attached to bodyB.\n         */\n        PulleyJoint.prototype.getLengthB = function () {\n            return this.m_lengthB;\n        };\n        /**\n         * Get the pulley ratio.\n         */\n        PulleyJoint.prototype.getRatio = function () {\n            return this.m_ratio;\n        };\n        /**\n         * Get the current length of the segment attached to bodyA.\n         */\n        PulleyJoint.prototype.getCurrentLengthA = function () {\n            var p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n            var s = this.m_groundAnchorA;\n            return Vec2.distance(p, s);\n        };\n        /**\n         * Get the current length of the segment attached to bodyB.\n         */\n        PulleyJoint.prototype.getCurrentLengthB = function () {\n            var p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n            var s = this.m_groundAnchorB;\n            return Vec2.distance(p, s);\n        };\n        /**\n         * Shift the origin for any points stored in world coordinates.\n         *\n         * @param newOrigin\n         */\n        PulleyJoint.prototype.shiftOrigin = function (newOrigin) {\n            this.m_groundAnchorA.sub(newOrigin);\n            this.m_groundAnchorB.sub(newOrigin);\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        PulleyJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        PulleyJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        PulleyJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.mulNumVec2(this.m_impulse, this.m_uB).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        PulleyJoint.prototype.getReactionTorque = function (inv_dt) {\n            return 0.0;\n        };\n        PulleyJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // Get the pulley axes.\n            this.m_uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n            this.m_uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n            var lengthA = this.m_uA.length();\n            var lengthB = this.m_uB.length();\n            if (lengthA > 10.0 * Settings.linearSlop) {\n                this.m_uA.mul(1.0 / lengthA);\n            }\n            else {\n                this.m_uA.setZero();\n            }\n            if (lengthB > 10.0 * Settings.linearSlop) {\n                this.m_uB.mul(1.0 / lengthB);\n            }\n            else {\n                this.m_uB.setZero();\n            }\n            // Compute effective mass.\n            var ruA = Vec2.crossVec2Vec2(this.m_rA, this.m_uA); // float\n            var ruB = Vec2.crossVec2Vec2(this.m_rB, this.m_uB); // float\n            var mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float\n            var mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float\n            this.m_mass = mA + this.m_ratio * this.m_ratio * mB;\n            if (this.m_mass > 0.0) {\n                this.m_mass = 1.0 / this.m_mass;\n            }\n            if (step.warmStarting) {\n                // Scale impulses to support variable time steps.\n                this.m_impulse *= step.dtRatio;\n                // Warm starting.\n                var PA = Vec2.mulNumVec2(-this.m_impulse, this.m_uA);\n                var PB = Vec2.mulNumVec2(-this.m_ratio * this.m_impulse, this.m_uB);\n                vA.addMul(this.m_invMassA, PA);\n                wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n                vB.addMul(this.m_invMassB, PB);\n                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n            }\n            else {\n                this.m_impulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        PulleyJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n            var vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n            var Cdot = -Vec2.dot(this.m_uA, vpA) - this.m_ratio\n                * Vec2.dot(this.m_uB, vpB); // float\n            var impulse = -this.m_mass * Cdot; // float\n            this.m_impulse += impulse;\n            var PA = Vec2.mulNumVec2(-impulse, this.m_uA); // Vec2\n            var PB = Vec2.mulNumVec2(-this.m_ratio * impulse, this.m_uB); // Vec2\n            vA.addMul(this.m_invMassA, PA);\n            wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n            vB.addMul(this.m_invMassB, PB);\n            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        PulleyJoint.prototype.solvePositionConstraints = function (step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // Get the pulley axes.\n            var uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n            var uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n            var lengthA = uA.length();\n            var lengthB = uB.length();\n            if (lengthA > 10.0 * Settings.linearSlop) {\n                uA.mul(1.0 / lengthA);\n            }\n            else {\n                uA.setZero();\n            }\n            if (lengthB > 10.0 * Settings.linearSlop) {\n                uB.mul(1.0 / lengthB);\n            }\n            else {\n                uB.setZero();\n            }\n            // Compute effective mass.\n            var ruA = Vec2.crossVec2Vec2(rA, uA);\n            var ruB = Vec2.crossVec2Vec2(rB, uB);\n            var mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float\n            var mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float\n            var mass = mA + this.m_ratio * this.m_ratio * mB; // float\n            if (mass > 0.0) {\n                mass = 1.0 / mass;\n            }\n            var C = this.m_constant - lengthA - this.m_ratio * lengthB; // float\n            var linearError = math$1.abs(C); // float\n            var impulse = -mass * C; // float\n            var PA = Vec2.mulNumVec2(-impulse, uA); // Vec2\n            var PB = Vec2.mulNumVec2(-this.m_ratio * impulse, uB); // Vec2\n            cA.addMul(this.m_invMassA, PA);\n            aA += this.m_invIA * Vec2.crossVec2Vec2(rA, PA);\n            cB.addMul(this.m_invMassB, PB);\n            aB += this.m_invIB * Vec2.crossVec2Vec2(rB, PB);\n            this.m_bodyA.c_position.c = cA;\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c = cB;\n            this.m_bodyB.c_position.a = aB;\n            return linearError < Settings.linearSlop;\n        };\n        PulleyJoint.TYPE = 'pulley-joint';\n        return PulleyJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var inactiveLimit = 0;\n    var atUpperLimit = 2;\n    var DEFAULTS$2 = {\n        maxLength: 0.0,\n    };\n    /**\n     * A rope joint enforces a maximum distance between two points on two bodies. It\n     * has no other effect.\n     *\n     * Warning: if you attempt to change the maximum length during the simulation\n     * you will get some non-physical behavior.\n     *\n     * A model that would allow you to dynamically modify the length would have some\n     * sponginess, so I chose not to implement it that way. See {@link DistanceJoint} if you\n     * want to dynamically control length.\n     */\n    var RopeJoint = /** @class */ (function (_super) {\n        __extends(RopeJoint, _super);\n        function RopeJoint(def, bodyA, bodyB, anchor) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof RopeJoint)) {\n                return new RopeJoint(def, bodyA, bodyB, anchor);\n            }\n            def = options(def, DEFAULTS$2);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = RopeJoint.TYPE;\n            _this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.neo(-1.0, 0.0);\n            _this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.neo(1.0, 0.0);\n            _this.m_maxLength = def.maxLength;\n            _this.m_mass = 0.0;\n            _this.m_impulse = 0.0;\n            _this.m_length = 0.0;\n            _this.m_state = inactiveLimit;\n            return _this;\n            // Limit:\n            // C = norm(pB - pA) - L\n            // u = (pB - pA) / norm(pB - pA)\n            // Cdot = dot(u, vB + cross(wB, rB) - vA - cross(wA, rA))\n            // J = [-u -cross(rA, u) u cross(rB, u)]\n            // K = J * invM * JT\n            // = invMassA + invIA * cross(rA, u)^2 + invMassB + invIB * cross(rB, u)^2\n        }\n        /** @internal */\n        RopeJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                maxLength: this.m_maxLength,\n            };\n        };\n        /** @internal */\n        RopeJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new RopeJoint(data);\n            return joint;\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */\n        RopeJoint.prototype.getLocalAnchorA = function () {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */\n        RopeJoint.prototype.getLocalAnchorB = function () {\n            return this.m_localAnchorB;\n        };\n        /**\n         * Set the maximum length of the rope.\n         */\n        RopeJoint.prototype.setMaxLength = function (length) {\n            this.m_maxLength = length;\n        };\n        /**\n         * Get the maximum length of the rope.\n         */\n        RopeJoint.prototype.getMaxLength = function () {\n            return this.m_maxLength;\n        };\n        RopeJoint.prototype.getLimitState = function () {\n            // TODO LimitState\n            return this.m_state;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        RopeJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        RopeJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        RopeJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        RopeJoint.prototype.getReactionTorque = function (inv_dt) {\n            return 0.0;\n        };\n        RopeJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            this.m_rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n            this.m_rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n            this.m_u = Vec2.zero();\n            this.m_u.addCombine(1, cB, 1, this.m_rB);\n            this.m_u.subCombine(1, cA, 1, this.m_rA); // Vec2\n            this.m_length = this.m_u.length();\n            var C = this.m_length - this.m_maxLength; // float\n            if (C > 0.0) {\n                this.m_state = atUpperLimit;\n            }\n            else {\n                this.m_state = inactiveLimit;\n            }\n            if (this.m_length > Settings.linearSlop) {\n                this.m_u.mul(1.0 / this.m_length);\n            }\n            else {\n                this.m_u.setZero();\n                this.m_mass = 0.0;\n                this.m_impulse = 0.0;\n                return;\n            }\n            // Compute effective mass.\n            var crA = Vec2.crossVec2Vec2(this.m_rA, this.m_u); // float\n            var crB = Vec2.crossVec2Vec2(this.m_rB, this.m_u); // float\n            var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB\n                + this.m_invIB * crB * crB; // float\n            this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n            if (step.warmStarting) {\n                // Scale the impulse to support a variable time step.\n                this.m_impulse *= step.dtRatio;\n                var P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n                vA.subMul(this.m_invMassA, P);\n                wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n                vB.addMul(this.m_invMassB, P);\n                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n            }\n            else {\n                this.m_impulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        RopeJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            // Cdot = dot(u, v + cross(w, r))\n            var vpA = Vec2.addCrossNumVec2(vA, wA, this.m_rA); // Vec2\n            var vpB = Vec2.addCrossNumVec2(vB, wB, this.m_rB); // Vec2\n            var C = this.m_length - this.m_maxLength; // float\n            var Cdot = Vec2.dot(this.m_u, Vec2.sub(vpB, vpA)); // float\n            // Predictive constraint.\n            if (C < 0.0) {\n                Cdot += step.inv_dt * C;\n            }\n            var impulse = -this.m_mass * Cdot; // float\n            var oldImpulse = this.m_impulse; // float\n            this.m_impulse = math$1.min(0.0, this.m_impulse + impulse);\n            impulse = this.m_impulse - oldImpulse;\n            var P = Vec2.mulNumVec2(impulse, this.m_u); // Vec2\n            vA.subMul(this.m_invMassA, P);\n            wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n            vB.addMul(this.m_invMassB, P);\n            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        RopeJoint.prototype.solvePositionConstraints = function (step) {\n            var cA = this.m_bodyA.c_position.c; // Vec2\n            var aA = this.m_bodyA.c_position.a; // float\n            var cB = this.m_bodyB.c_position.c; // Vec2\n            var aB = this.m_bodyB.c_position.a; // float\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n            var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n            var u = Vec2.zero();\n            u.addCombine(1, cB, 1, rB);\n            u.subCombine(1, cA, 1, rA); // Vec2\n            var length = u.normalize(); // float\n            var C = length - this.m_maxLength; // float\n            C = math$1.clamp(C, 0.0, Settings.maxLinearCorrection);\n            var impulse = -this.m_mass * C; // float\n            var P = Vec2.mulNumVec2(impulse, u); // Vec2\n            cA.subMul(this.m_invMassA, P);\n            aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n            cB.addMul(this.m_invMassB, P);\n            aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n            this.m_bodyA.c_position.c.setVec2(cA);\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c.setVec2(cB);\n            this.m_bodyB.c_position.a = aB;\n            return length - this.m_maxLength < Settings.linearSlop;\n        };\n        RopeJoint.TYPE = 'rope-joint';\n        return RopeJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS$1 = {\n        frequencyHz: 0.0,\n        dampingRatio: 0.0,\n    };\n    /**\n     * A weld joint essentially glues two bodies together. A weld joint may distort\n     * somewhat because the island constraint solver is approximate.\n     */\n    var WeldJoint = /** @class */ (function (_super) {\n        __extends(WeldJoint, _super);\n        function WeldJoint(def, bodyA, bodyB, anchor) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof WeldJoint)) {\n                return new WeldJoint(def, bodyA, bodyB, anchor);\n            }\n            def = options(def, DEFAULTS$1);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = WeldJoint.TYPE;\n            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n            _this.m_referenceAngle = math$1.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n            _this.m_frequencyHz = def.frequencyHz;\n            _this.m_dampingRatio = def.dampingRatio;\n            _this.m_impulse = new Vec3();\n            _this.m_bias = 0.0;\n            _this.m_gamma = 0.0;\n            // Solver temp\n            _this.m_rA; // Vec2\n            _this.m_rB; // Vec2\n            _this.m_localCenterA; // Vec2\n            _this.m_localCenterB; // Vec2\n            _this.m_invMassA; // float\n            _this.m_invMassB; // float\n            _this.m_invIA; // float\n            _this.m_invIB; // float\n            _this.m_mass = new Mat33();\n            return _this;\n            // Point-to-point constraint\n            // C = p2 - p1\n            // Cdot = v2 - v1\n            // / = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n            // J = [-I -r1_skew I r2_skew ]\n            // Identity used:\n            // w k % (rx i + ry j) = w * (-ry i + rx j)\n            // Angle constraint\n            // C = angle2 - angle1 - referenceAngle\n            // Cdot = w2 - w1\n            // J = [0 0 -1 0 0 1]\n            // K = invI1 + invI2\n        }\n        /** @internal */\n        WeldJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                frequencyHz: this.m_frequencyHz,\n                dampingRatio: this.m_dampingRatio,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                referenceAngle: this.m_referenceAngle,\n            };\n        };\n        /** @internal */\n        WeldJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new WeldJoint(data);\n            return joint;\n        };\n        /** @internal */\n        WeldJoint.prototype._setAnchors = function (def) {\n            if (def.anchorA) {\n                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            }\n            else if (def.localAnchorA) {\n                this.m_localAnchorA.setVec2(def.localAnchorA);\n            }\n            if (def.anchorB) {\n                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            }\n            else if (def.localAnchorB) {\n                this.m_localAnchorB.setVec2(def.localAnchorB);\n            }\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */\n        WeldJoint.prototype.getLocalAnchorA = function () {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */\n        WeldJoint.prototype.getLocalAnchorB = function () {\n            return this.m_localAnchorB;\n        };\n        /**\n         * Get the reference angle.\n         */\n        WeldJoint.prototype.getReferenceAngle = function () {\n            return this.m_referenceAngle;\n        };\n        /**\n         * Set frequency in Hz.\n         */\n        WeldJoint.prototype.setFrequency = function (hz) {\n            this.m_frequencyHz = hz;\n        };\n        /**\n         * Get frequency in Hz.\n         */\n        WeldJoint.prototype.getFrequency = function () {\n            return this.m_frequencyHz;\n        };\n        /**\n         * Set damping ratio.\n         */\n        WeldJoint.prototype.setDampingRatio = function (ratio) {\n            this.m_dampingRatio = ratio;\n        };\n        /**\n         * Get damping ratio.\n         */\n        WeldJoint.prototype.getDampingRatio = function () {\n            return this.m_dampingRatio;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        WeldJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        WeldJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        WeldJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        WeldJoint.prototype.getReactionTorque = function (inv_dt) {\n            return inv_dt * this.m_impulse.z;\n        };\n        WeldJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // J = [-I -r1_skew I r2_skew]\n            // [ 0 -1 0 1]\n            // r_skew = [-ry; rx]\n            // Matlab\n            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var K = new Mat33();\n            K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y\n                * iB;\n            K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\n            K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n            K.ex.y = K.ey.x;\n            K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x\n                * iB;\n            K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n            K.ex.z = K.ez.x;\n            K.ey.z = K.ez.y;\n            K.ez.z = iA + iB;\n            if (this.m_frequencyHz > 0.0) {\n                K.getInverse22(this.m_mass);\n                var invM = iA + iB; // float\n                var m = invM > 0.0 ? 1.0 / invM : 0.0; // float\n                var C = aB - aA - this.m_referenceAngle; // float\n                // Frequency\n                var omega = 2.0 * math$1.PI * this.m_frequencyHz; // float\n                // Damping coefficient\n                var d = 2.0 * m * this.m_dampingRatio * omega; // float\n                // Spring stiffness\n                var k = m * omega * omega; // float\n                // magic formulas\n                var h = step.dt; // float\n                this.m_gamma = h * (d + h * k);\n                this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n                this.m_bias = C * h * k * this.m_gamma;\n                invM += this.m_gamma;\n                this.m_mass.ez.z = invM != 0.0 ? 1.0 / invM : 0.0;\n            }\n            else if (K.ez.z == 0.0) {\n                K.getInverse22(this.m_mass);\n                this.m_gamma = 0.0;\n                this.m_bias = 0.0;\n            }\n            else {\n                K.getSymInverse33(this.m_mass);\n                this.m_gamma = 0.0;\n                this.m_bias = 0.0;\n            }\n            if (step.warmStarting) {\n                // Scale impulses to support a variable time step.\n                this.m_impulse.mul(step.dtRatio);\n                var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_impulse.z);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_impulse.z);\n            }\n            else {\n                this.m_impulse.setZero();\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        WeldJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            if (this.m_frequencyHz > 0.0) {\n                var Cdot2 = wB - wA; // float\n                var impulse2 = -this.m_mass.ez.z\n                    * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z); // float\n                this.m_impulse.z += impulse2;\n                wA -= iA * impulse2;\n                wB += iB * impulse2;\n                var Cdot1 = Vec2.zero();\n                Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n                Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA)); // Vec2\n                var impulse1 = Vec2.neg(Mat33.mulVec2(this.m_mass, Cdot1)); // Vec2\n                this.m_impulse.x += impulse1.x;\n                this.m_impulse.y += impulse1.y;\n                var P = Vec2.clone(impulse1); // Vec2\n                vA.subMul(mA, P);\n                wA -= iA * Vec2.crossVec2Vec2(this.m_rA, P);\n                vB.addMul(mB, P);\n                wB += iB * Vec2.crossVec2Vec2(this.m_rB, P);\n            }\n            else {\n                var Cdot1 = Vec2.zero();\n                Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n                Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA)); // Vec2\n                var Cdot2 = wB - wA; // float\n                var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2); // Vec3\n                var impulse = Vec3.neg(Mat33.mulVec3(this.m_mass, Cdot)); // Vec3\n                this.m_impulse.add(impulse);\n                var P = Vec2.neo(impulse.x, impulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        WeldJoint.prototype.solvePositionConstraints = function (step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            var positionError;\n            var angularError;\n            var K = new Mat33();\n            K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;\n            K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;\n            K.ez.x = -rA.y * iA - rB.y * iB;\n            K.ex.y = K.ey.x;\n            K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;\n            K.ez.y = rA.x * iA + rB.x * iB;\n            K.ex.z = K.ez.x;\n            K.ey.z = K.ez.y;\n            K.ez.z = iA + iB;\n            if (this.m_frequencyHz > 0.0) {\n                var C1 = Vec2.zero();\n                C1.addCombine(1, cB, 1, rB);\n                C1.subCombine(1, cA, 1, rA); // Vec2\n                positionError = C1.length();\n                angularError = 0.0;\n                var P = Vec2.neg(K.solve22(C1)); // Vec2\n                cA.subMul(mA, P);\n                aA -= iA * Vec2.crossVec2Vec2(rA, P);\n                cB.addMul(mB, P);\n                aB += iB * Vec2.crossVec2Vec2(rB, P);\n            }\n            else {\n                var C1 = Vec2.zero();\n                C1.addCombine(1, cB, 1, rB);\n                C1.subCombine(1, cA, 1, rA);\n                var C2 = aB - aA - this.m_referenceAngle; // float\n                positionError = C1.length();\n                angularError = math$1.abs(C2);\n                var C = new Vec3(C1.x, C1.y, C2);\n                var impulse = new Vec3();\n                if (K.ez.z > 0.0) {\n                    impulse = Vec3.neg(K.solve33(C));\n                }\n                else {\n                    var impulse2 = Vec2.neg(K.solve22(C1));\n                    impulse.set(impulse2.x, impulse2.y, 0.0);\n                }\n                var P = Vec2.neo(impulse.x, impulse.y);\n                cA.subMul(mA, P);\n                aA -= iA * (Vec2.crossVec2Vec2(rA, P) + impulse.z);\n                cB.addMul(mB, P);\n                aB += iB * (Vec2.crossVec2Vec2(rB, P) + impulse.z);\n            }\n            this.m_bodyA.c_position.c = cA;\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c = cB;\n            this.m_bodyB.c_position.a = aB;\n            return positionError <= Settings.linearSlop && angularError <= Settings.angularSlop;\n        };\n        WeldJoint.TYPE = 'weld-joint';\n        return WeldJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS = {\n        enableMotor: false,\n        maxMotorTorque: 0.0,\n        motorSpeed: 0.0,\n        frequencyHz: 2.0,\n        dampingRatio: 0.7,\n    };\n    /**\n     * A wheel joint. This joint provides two degrees of freedom: translation along\n     * an axis fixed in bodyA and rotation in the plane. In other words, it is a\n     * point to line constraint with a rotational motor and a linear spring/damper.\n     * This joint is designed for vehicle suspensions.\n     */\n    var WheelJoint = /** @class */ (function (_super) {\n        __extends(WheelJoint, _super);\n        // @ts-ignore\n        function WheelJoint(def, bodyA, bodyB, anchor, axis) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof WheelJoint)) {\n                return new WheelJoint(def, bodyA, bodyB, anchor, axis);\n            }\n            def = options(def, DEFAULTS);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            /** @internal */ _this.m_ax = Vec2.zero();\n            /** @internal */ _this.m_ay = Vec2.zero();\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = WheelJoint.TYPE;\n            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n            // @ts-ignore localAxis\n            _this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || def.localAxis || Vec2.neo(1.0, 0.0));\n            _this.m_localYAxisA = Vec2.crossNumVec2(1.0, _this.m_localXAxisA);\n            _this.m_mass = 0.0;\n            _this.m_impulse = 0.0;\n            _this.m_motorMass = 0.0;\n            _this.m_motorImpulse = 0.0;\n            _this.m_springMass = 0.0;\n            _this.m_springImpulse = 0.0;\n            _this.m_maxMotorTorque = def.maxMotorTorque;\n            _this.m_motorSpeed = def.motorSpeed;\n            _this.m_enableMotor = def.enableMotor;\n            _this.m_frequencyHz = def.frequencyHz;\n            _this.m_dampingRatio = def.dampingRatio;\n            _this.m_bias = 0.0;\n            _this.m_gamma = 0.0;\n            return _this;\n            // Linear constraint (point-to-line)\n            // d = pB - pA = xB + rB - xA - rA\n            // C = dot(ay, d)\n            // Cdot = dot(d, cross(wA, ay)) + dot(ay, vB + cross(wB, rB) - vA - cross(wA,\n            // rA))\n            // = -dot(ay, vA) - dot(cross(d + rA, ay), wA) + dot(ay, vB) + dot(cross(rB,\n            // ay), vB)\n            // J = [-ay, -cross(d + rA, ay), ay, cross(rB, ay)]\n            // Spring linear constraint\n            // C = dot(ax, d)\n            // Cdot = = -dot(ax, vA) - dot(cross(d + rA, ax), wA) + dot(ax, vB) +\n            // dot(cross(rB, ax), vB)\n            // J = [-ax -cross(d+rA, ax) ax cross(rB, ax)]\n            // Motor rotational constraint\n            // Cdot = wB - wA\n            // J = [0 0 -1 0 0 1]\n        }\n        /** @internal */\n        WheelJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                enableMotor: this.m_enableMotor,\n                maxMotorTorque: this.m_maxMotorTorque,\n                motorSpeed: this.m_motorSpeed,\n                frequencyHz: this.m_frequencyHz,\n                dampingRatio: this.m_dampingRatio,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                localAxisA: this.m_localXAxisA,\n            };\n        };\n        /** @internal */\n        WheelJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new WheelJoint(data);\n            return joint;\n        };\n        /** @internal */\n        WheelJoint.prototype._setAnchors = function (def) {\n            if (def.anchorA) {\n                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            }\n            else if (def.localAnchorA) {\n                this.m_localAnchorA.setVec2(def.localAnchorA);\n            }\n            if (def.anchorB) {\n                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            }\n            else if (def.localAnchorB) {\n                this.m_localAnchorB.setVec2(def.localAnchorB);\n            }\n            if (def.localAxisA) {\n                this.m_localXAxisA.setVec2(def.localAxisA);\n                this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n            }\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */\n        WheelJoint.prototype.getLocalAnchorA = function () {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */\n        WheelJoint.prototype.getLocalAnchorB = function () {\n            return this.m_localAnchorB;\n        };\n        /**\n         * The local joint axis relative to bodyA.\n         */\n        WheelJoint.prototype.getLocalAxisA = function () {\n            return this.m_localXAxisA;\n        };\n        /**\n         * Get the current joint translation, usually in meters.\n         */\n        WheelJoint.prototype.getJointTranslation = function () {\n            var bA = this.m_bodyA;\n            var bB = this.m_bodyB;\n            var pA = bA.getWorldPoint(this.m_localAnchorA); // Vec2\n            var pB = bB.getWorldPoint(this.m_localAnchorB); // Vec2\n            var d = Vec2.sub(pB, pA); // Vec2\n            var axis = bA.getWorldVector(this.m_localXAxisA); // Vec2\n            var translation = Vec2.dot(d, axis); // float\n            return translation;\n        };\n        /**\n         * Get the current joint translation speed, usually in meters per second.\n         */\n        WheelJoint.prototype.getJointSpeed = function () {\n            var wA = this.m_bodyA.m_angularVelocity;\n            var wB = this.m_bodyB.m_angularVelocity;\n            return wB - wA;\n        };\n        /**\n         * Is the joint motor enabled?\n         */\n        WheelJoint.prototype.isMotorEnabled = function () {\n            return this.m_enableMotor;\n        };\n        /**\n         * Enable/disable the joint motor.\n         */\n        WheelJoint.prototype.enableMotor = function (flag) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_enableMotor = flag;\n        };\n        /**\n         * Set the motor speed, usually in radians per second.\n         */\n        WheelJoint.prototype.setMotorSpeed = function (speed) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_motorSpeed = speed;\n        };\n        /**\n         * Get the motor speed, usually in radians per second.\n         */\n        WheelJoint.prototype.getMotorSpeed = function () {\n            return this.m_motorSpeed;\n        };\n        /**\n         * Set/Get the maximum motor force, usually in N-m.\n         */\n        WheelJoint.prototype.setMaxMotorTorque = function (torque) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_maxMotorTorque = torque;\n        };\n        WheelJoint.prototype.getMaxMotorTorque = function () {\n            return this.m_maxMotorTorque;\n        };\n        /**\n         * Get the current motor torque given the inverse time step, usually in N-m.\n         */\n        WheelJoint.prototype.getMotorTorque = function (inv_dt) {\n            return inv_dt * this.m_motorImpulse;\n        };\n        /**\n         * Set/Get the spring frequency in hertz. Setting the frequency to zero disables\n         * the spring.\n         */\n        WheelJoint.prototype.setSpringFrequencyHz = function (hz) {\n            this.m_frequencyHz = hz;\n        };\n        WheelJoint.prototype.getSpringFrequencyHz = function () {\n            return this.m_frequencyHz;\n        };\n        /**\n         * Set/Get the spring damping ratio\n         */\n        WheelJoint.prototype.setSpringDampingRatio = function (ratio) {\n            this.m_dampingRatio = ratio;\n        };\n        WheelJoint.prototype.getSpringDampingRatio = function () {\n            return this.m_dampingRatio;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        WheelJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        WheelJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        WheelJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        WheelJoint.prototype.getReactionTorque = function (inv_dt) {\n            return inv_dt * this.m_motorImpulse;\n        };\n        WheelJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            // Compute the effective masses.\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            var d = Vec2.zero();\n            d.addCombine(1, cB, 1, rB);\n            d.subCombine(1, cA, 1, rA); // Vec2\n            // Point to line constraint\n            {\n                this.m_ay = Rot.mulVec2(qA, this.m_localYAxisA);\n                this.m_sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ay);\n                this.m_sBy = Vec2.crossVec2Vec2(rB, this.m_ay);\n                this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy\n                    * this.m_sBy;\n                if (this.m_mass > 0.0) {\n                    this.m_mass = 1.0 / this.m_mass;\n                }\n            }\n            // Spring constraint\n            this.m_springMass = 0.0;\n            this.m_bias = 0.0;\n            this.m_gamma = 0.0;\n            if (this.m_frequencyHz > 0.0) {\n                this.m_ax = Rot.mulVec2(qA, this.m_localXAxisA);\n                this.m_sAx = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ax);\n                this.m_sBx = Vec2.crossVec2Vec2(rB, this.m_ax);\n                var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx\n                    * this.m_sBx; // float\n                if (invMass > 0.0) {\n                    this.m_springMass = 1.0 / invMass;\n                    var C = Vec2.dot(d, this.m_ax); // float\n                    // Frequency\n                    var omega = 2.0 * math$1.PI * this.m_frequencyHz; // float\n                    // Damping coefficient\n                    var damp = 2.0 * this.m_springMass * this.m_dampingRatio * omega; // float\n                    // Spring stiffness\n                    var k = this.m_springMass * omega * omega; // float\n                    // magic formulas\n                    var h = step.dt; // float\n                    this.m_gamma = h * (damp + h * k);\n                    if (this.m_gamma > 0.0) {\n                        this.m_gamma = 1.0 / this.m_gamma;\n                    }\n                    this.m_bias = C * h * k * this.m_gamma;\n                    this.m_springMass = invMass + this.m_gamma;\n                    if (this.m_springMass > 0.0) {\n                        this.m_springMass = 1.0 / this.m_springMass;\n                    }\n                }\n            }\n            else {\n                this.m_springImpulse = 0.0;\n            }\n            // Rotational motor\n            if (this.m_enableMotor) {\n                this.m_motorMass = iA + iB;\n                if (this.m_motorMass > 0.0) {\n                    this.m_motorMass = 1.0 / this.m_motorMass;\n                }\n            }\n            else {\n                this.m_motorMass = 0.0;\n                this.m_motorImpulse = 0.0;\n            }\n            if (step.warmStarting) {\n                // Account for variable time step.\n                this.m_impulse *= step.dtRatio;\n                this.m_springImpulse *= step.dtRatio;\n                this.m_motorImpulse *= step.dtRatio;\n                var P = Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);\n                var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;\n                var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;\n                vA.subMul(this.m_invMassA, P);\n                wA -= this.m_invIA * LA;\n                vB.addMul(this.m_invMassB, P);\n                wB += this.m_invIB * LB;\n            }\n            else {\n                this.m_impulse = 0.0;\n                this.m_springImpulse = 0.0;\n                this.m_motorImpulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        WheelJoint.prototype.solveVelocityConstraints = function (step) {\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            // Solve spring constraint\n            {\n                var Cdot = Vec2.dot(this.m_ax, vB) - Vec2.dot(this.m_ax, vA) + this.m_sBx\n                    * wB - this.m_sAx * wA; // float\n                var impulse = -this.m_springMass\n                    * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse); // float\n                this.m_springImpulse += impulse;\n                var P = Vec2.mulNumVec2(impulse, this.m_ax); // Vec2\n                var LA = impulse * this.m_sAx; // float\n                var LB = impulse * this.m_sBx; // float\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            }\n            // Solve rotational motor constraint\n            {\n                var Cdot = wB - wA - this.m_motorSpeed; // float\n                var impulse = -this.m_motorMass * Cdot; // float\n                var oldImpulse = this.m_motorImpulse; // float\n                var maxImpulse = step.dt * this.m_maxMotorTorque; // float\n                this.m_motorImpulse = math$1.clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n                impulse = this.m_motorImpulse - oldImpulse;\n                wA -= iA * impulse;\n                wB += iB * impulse;\n            }\n            // Solve point to line constraint\n            {\n                var Cdot = Vec2.dot(this.m_ay, vB) - Vec2.dot(this.m_ay, vA) + this.m_sBy\n                    * wB - this.m_sAy * wA; // float\n                var impulse = -this.m_mass * Cdot; // float\n                this.m_impulse += impulse;\n                var P = Vec2.mulNumVec2(impulse, this.m_ay); // Vec2\n                var LA = impulse * this.m_sAy; // float\n                var LB = impulse * this.m_sBy; // float\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            }\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        WheelJoint.prototype.solvePositionConstraints = function (step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            var d = Vec2.zero();\n            d.addCombine(1, cB, 1, rB);\n            d.subCombine(1, cA, 1, rA);\n            var ay = Rot.mulVec2(qA, this.m_localYAxisA);\n            var sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), ay); // float\n            var sBy = Vec2.crossVec2Vec2(rB, ay); // float\n            var C = Vec2.dot(d, ay); // float\n            var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy\n                * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy; // float\n            var impulse; // float\n            if (k != 0.0) {\n                impulse = -C / k;\n            }\n            else {\n                impulse = 0.0;\n            }\n            var P = Vec2.mulNumVec2(impulse, ay); // Vec2\n            var LA = impulse * sAy; // float\n            var LB = impulse * sBy; // float\n            cA.subMul(this.m_invMassA, P);\n            aA -= this.m_invIA * LA;\n            cB.addMul(this.m_invMassB, P);\n            aB += this.m_invIB * LB;\n            this.m_bodyA.c_position.c.setVec2(cA);\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c.setVec2(cB);\n            this.m_bodyB.c_position.a = aB;\n            return math$1.abs(C) <= Settings.linearSlop;\n        };\n        WheelJoint.TYPE = 'wheel-joint';\n        return WheelJoint;\n    }(Joint));\n\n    var SID = 0;\n    function Serializer(opts) {\n        var _a;\n        opts = opts || {};\n        var rootClass = opts.rootClass || World;\n        var preSerialize = opts.preSerialize || function (obj) { return obj; };\n        var postSerialize = opts.postSerialize || function (data, obj) { return data; };\n        var preDeserialize = opts.preDeserialize || function (data) { return data; };\n        var postDeserialize = opts.postDeserialize || function (obj, data) { return obj; };\n        // This is used to create ref objects during serialize\n        var refTypes = {\n            World: World,\n            Body: Body,\n            Joint: Joint,\n            Fixture: Fixture,\n            Shape: Shape,\n        };\n        // This is used by restore to deserialize objects and refs\n        var restoreTypes = __assign({ Vec2: Vec2,\n            Vec3: Vec3 }, refTypes);\n        var CLASS_BY_TYPE_PROP = (_a = {},\n            _a[Body.STATIC] = Body,\n            _a[Body.DYNAMIC] = Body,\n            _a[Body.KINEMATIC] = Body,\n            _a[ChainShape.TYPE] = ChainShape,\n            _a[BoxShape.TYPE] = BoxShape,\n            _a[EdgeShape.TYPE] = EdgeShape,\n            _a[PolygonShape.TYPE] = PolygonShape,\n            _a[CircleShape.TYPE] = CircleShape,\n            _a[DistanceJoint.TYPE] = DistanceJoint,\n            _a[FrictionJoint.TYPE] = FrictionJoint,\n            _a[GearJoint.TYPE] = GearJoint,\n            _a[MotorJoint.TYPE] = MotorJoint,\n            _a[MouseJoint.TYPE] = MouseJoint,\n            _a[PrismaticJoint.TYPE] = PrismaticJoint,\n            _a[PulleyJoint.TYPE] = PulleyJoint,\n            _a[RevoluteJoint.TYPE] = RevoluteJoint,\n            _a[RopeJoint.TYPE] = RopeJoint,\n            _a[WeldJoint.TYPE] = WeldJoint,\n            _a[WheelJoint.TYPE] = WheelJoint,\n            _a);\n        this.toJson = function (root) {\n            var json = [];\n            var queue = [root];\n            var refMap = {};\n            function storeRef(value, typeName) {\n                value.__sid = value.__sid || ++SID;\n                if (!refMap[value.__sid]) {\n                    queue.push(value);\n                    var index = json.length + queue.length;\n                    var ref = {\n                        refIndex: index,\n                        refType: typeName\n                    };\n                    refMap[value.__sid] = ref;\n                }\n                return refMap[value.__sid];\n            }\n            function serialize(obj) {\n                obj = preSerialize(obj);\n                var data = obj._serialize();\n                data = postSerialize(data, obj);\n                return data;\n            }\n            function toJson(value, top) {\n                if (typeof value !== 'object' || value === null) {\n                    return value;\n                }\n                if (typeof value._serialize === 'function') {\n                    if (value !== top) {\n                        // tslint:disable-next-line:no-for-in\n                        for (var typeName in refTypes) {\n                            if (value instanceof refTypes[typeName]) {\n                                return storeRef(value, typeName);\n                            }\n                        }\n                    }\n                    value = serialize(value);\n                }\n                if (Array.isArray(value)) {\n                    var newValue = [];\n                    for (var key = 0; key < value.length; key++) {\n                        newValue[key] = toJson(value[key]);\n                    }\n                    value = newValue;\n                }\n                else {\n                    var newValue = {};\n                    // tslint:disable-next-line:no-for-in\n                    for (var key in value) {\n                        if (value.hasOwnProperty(key)) {\n                            newValue[key] = toJson(value[key]);\n                        }\n                    }\n                    value = newValue;\n                }\n                return value;\n            }\n            while (queue.length) {\n                var obj = queue.shift();\n                var str = toJson(obj, obj);\n                json.push(str);\n            }\n            return json;\n        };\n        this.fromJson = function (json) {\n            var refMap = {};\n            function findDeserilizer(data, cls) {\n                if (!cls || !cls._deserialize) {\n                    cls = CLASS_BY_TYPE_PROP[data.type];\n                }\n                return cls && cls._deserialize;\n            }\n            /**\n             * Deserialize a data object.\n             */\n            function deserialize(cls, data, ctx) {\n                var deserializer = findDeserilizer(data, cls);\n                if (!deserializer) {\n                    return;\n                }\n                data = preDeserialize(data);\n                var obj = deserializer(data, ctx, restoreRef);\n                obj = postDeserialize(obj, data);\n                return obj;\n            }\n            /**\n             * Restore a ref object or deserialize a data object.\n             *\n             * This is passed as callback to class deserializers.\n             */\n            function restoreRef(cls, ref, ctx) {\n                if (!ref.refIndex) {\n                    return cls && cls._deserialize && deserialize(cls, ref, ctx);\n                }\n                cls = restoreTypes[ref.refType] || cls;\n                var index = ref.refIndex;\n                if (!refMap[index]) {\n                    var data = json[index];\n                    var obj = deserialize(cls, data, ctx);\n                    refMap[index] = obj;\n                }\n                return refMap[index];\n            }\n            var root = rootClass._deserialize(json[0], null, restoreRef);\n            return root;\n        };\n    }\n    var serializer = new Serializer();\n    Serializer.toJson = serializer.toJson;\n    Serializer.fromJson = serializer.fromJson;\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    Contact.addType(CircleShape.TYPE, CircleShape.TYPE, CircleCircleContact);\n    function CircleCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {\n        CollideCircles(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);\n    }\n    function CollideCircles(manifold, circleA, xfA, circleB, xfB) {\n        manifold.pointCount = 0;\n        var pA = Transform.mulVec2(xfA, circleA.m_p);\n        var pB = Transform.mulVec2(xfB, circleB.m_p);\n        var distSqr = Vec2.distanceSquared(pB, pA);\n        var rA = circleA.m_radius;\n        var rB = circleB.m_radius;\n        var radius = rA + rB;\n        if (distSqr > radius * radius) {\n            return;\n        }\n        manifold.type = ManifoldType.e_circles;\n        manifold.localPoint.setVec2(circleA.m_p);\n        manifold.localNormal.setZero();\n        manifold.pointCount = 1;\n        manifold.points[0].localPoint.setVec2(circleB.m_p);\n        // manifold.points[0].id.key = 0;\n        manifold.points[0].id.cf.indexA = 0;\n        manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n        manifold.points[0].id.cf.indexB = 0;\n        manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n    }\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    Contact.addType(EdgeShape.TYPE, CircleShape.TYPE, EdgeCircleContact);\n    Contact.addType(ChainShape.TYPE, CircleShape.TYPE, ChainCircleContact);\n    function EdgeCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {\n        var shapeA = fixtureA.getShape();\n        var shapeB = fixtureB.getShape();\n        CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n    }\n    function ChainCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {\n        var chain = fixtureA.getShape();\n        var edge = new EdgeShape();\n        chain.getChildEdge(edge, indexA);\n        var shapeA = edge;\n        var shapeB = fixtureB.getShape();\n        CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n    }\n    // Compute contact points for edge versus circle.\n    // This accounts for edge connectivity.\n    function CollideEdgeCircle(manifold, edgeA, xfA, circleB, xfB) {\n        manifold.pointCount = 0;\n        // Compute circle in frame of edge\n        var Q = Transform.mulTVec2(xfA, Transform.mulVec2(xfB, circleB.m_p));\n        var A = edgeA.m_vertex1;\n        var B = edgeA.m_vertex2;\n        var e = Vec2.sub(B, A);\n        // Barycentric coordinates\n        var u = Vec2.dot(e, Vec2.sub(B, Q));\n        var v = Vec2.dot(e, Vec2.sub(Q, A));\n        var radius = edgeA.m_radius + circleB.m_radius;\n        // Region A\n        if (v <= 0.0) {\n            var P_1 = Vec2.clone(A);\n            var d_1 = Vec2.sub(Q, P_1);\n            var dd_1 = Vec2.dot(d_1, d_1);\n            if (dd_1 > radius * radius) {\n                return;\n            }\n            // Is there an edge connected to A?\n            if (edgeA.m_hasVertex0) {\n                var A1 = edgeA.m_vertex0;\n                var B1 = A;\n                var e1 = Vec2.sub(B1, A1);\n                var u1 = Vec2.dot(e1, Vec2.sub(B1, Q));\n                // Is the circle in Region AB of the previous edge?\n                if (u1 > 0.0) {\n                    return;\n                }\n            }\n            manifold.type = ManifoldType.e_circles;\n            manifold.localNormal.setZero();\n            manifold.localPoint.setVec2(P_1);\n            manifold.pointCount = 1;\n            manifold.points[0].localPoint.setVec2(circleB.m_p);\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 0;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n            return;\n        }\n        // Region B\n        if (u <= 0.0) {\n            var P_2 = Vec2.clone(B);\n            var d_2 = Vec2.sub(Q, P_2);\n            var dd_2 = Vec2.dot(d_2, d_2);\n            if (dd_2 > radius * radius) {\n                return;\n            }\n            // Is there an edge connected to B?\n            if (edgeA.m_hasVertex3) {\n                var B2 = edgeA.m_vertex3;\n                var A2 = B;\n                var e2 = Vec2.sub(B2, A2);\n                var v2 = Vec2.dot(e2, Vec2.sub(Q, A2));\n                // Is the circle in Region AB of the next edge?\n                if (v2 > 0.0) {\n                    return;\n                }\n            }\n            manifold.type = ManifoldType.e_circles;\n            manifold.localNormal.setZero();\n            manifold.localPoint.setVec2(P_2);\n            manifold.pointCount = 1;\n            manifold.points[0].localPoint.setVec2(circleB.m_p);\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 1;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n            return;\n        }\n        // Region AB\n        var den = Vec2.dot(e, e);\n        var P = Vec2.combine(u / den, A, v / den, B);\n        var d = Vec2.sub(Q, P);\n        var dd = Vec2.dot(d, d);\n        if (dd > radius * radius) {\n            return;\n        }\n        var n = Vec2.neo(-e.y, e.x);\n        if (Vec2.dot(n, Vec2.sub(Q, A)) < 0.0) {\n            n.setNum(-n.x, -n.y);\n        }\n        n.normalize();\n        manifold.type = ManifoldType.e_faceA;\n        manifold.localNormal = n;\n        manifold.localPoint.setVec2(A);\n        manifold.pointCount = 1;\n        manifold.points[0].localPoint.setVec2(circleB.m_p);\n        // manifold.points[0].id.key = 0;\n        manifold.points[0].id.cf.indexA = 0;\n        manifold.points[0].id.cf.typeA = ContactFeatureType.e_face;\n        manifold.points[0].id.cf.indexB = 0;\n        manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n    }\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    Contact.addType(PolygonShape.TYPE, PolygonShape.TYPE, PolygonContact);\n    function PolygonContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {\n        CollidePolygons(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);\n    }\n    /**\n     * Find the max separation between poly1 and poly2 using edge normals from\n     * poly1.\n     */\n    function findMaxSeparation(poly1, xf1, poly2, xf2, output) {\n        var count1 = poly1.m_count;\n        var count2 = poly2.m_count;\n        var n1s = poly1.m_normals;\n        var v1s = poly1.m_vertices;\n        var v2s = poly2.m_vertices;\n        var xf = Transform.mulTXf(xf2, xf1);\n        var bestIndex = 0;\n        var maxSeparation = -Infinity;\n        for (var i = 0; i < count1; ++i) {\n            // Get poly1 normal in frame2.\n            var n = Rot.mulVec2(xf.q, n1s[i]);\n            var v1 = Transform.mulVec2(xf, v1s[i]);\n            // Find deepest point for normal i.\n            var si = Infinity;\n            for (var j = 0; j < count2; ++j) {\n                var sij = Vec2.dot(n, v2s[j]) - Vec2.dot(n, v1);\n                if (sij < si) {\n                    si = sij;\n                }\n            }\n            if (si > maxSeparation) {\n                maxSeparation = si;\n                bestIndex = i;\n            }\n        }\n        // used to keep last FindMaxSeparation call values\n        output.maxSeparation = maxSeparation;\n        output.bestIndex = bestIndex;\n    }\n    function findIncidentEdge(c, poly1, xf1, edge1, poly2, xf2) {\n        var normals1 = poly1.m_normals;\n        var count2 = poly2.m_count;\n        var vertices2 = poly2.m_vertices;\n        var normals2 = poly2.m_normals;\n        // Get the normal of the reference edge in poly2's frame.\n        var normal1 = Rot.mulTVec2(xf2.q, Rot.mulVec2(xf1.q, normals1[edge1]));\n        // Find the incident edge on poly2.\n        var index = 0;\n        var minDot = Infinity;\n        for (var i = 0; i < count2; ++i) {\n            var dot = Vec2.dot(normal1, normals2[i]);\n            if (dot < minDot) {\n                minDot = dot;\n                index = i;\n            }\n        }\n        // Build the clip vertices for the incident edge.\n        var i1 = index;\n        var i2 = i1 + 1 < count2 ? i1 + 1 : 0;\n        c[0].v = Transform.mulVec2(xf2, vertices2[i1]);\n        c[0].id.cf.indexA = edge1;\n        c[0].id.cf.indexB = i1;\n        c[0].id.cf.typeA = ContactFeatureType.e_face;\n        c[0].id.cf.typeB = ContactFeatureType.e_vertex;\n        c[1].v = Transform.mulVec2(xf2, vertices2[i2]);\n        c[1].id.cf.indexA = edge1;\n        c[1].id.cf.indexB = i2;\n        c[1].id.cf.typeA = ContactFeatureType.e_face;\n        c[1].id.cf.typeB = ContactFeatureType.e_vertex;\n    }\n    var maxSeparation = {\n        maxSeparation: 0,\n        bestIndex: 0,\n    };\n    /**\n     *\n     * Find edge normal of max separation on A - return if separating axis is found<br>\n     * Find edge normal of max separation on B - return if separation axis is found<br>\n     * Choose reference edge as min(minA, minB)<br>\n     * Find incident edge<br>\n     * Clip\n     *\n     * The normal points from 1 to 2\n     */\n    function CollidePolygons(manifold, polyA, xfA, polyB, xfB) {\n        manifold.pointCount = 0;\n        var totalRadius = polyA.m_radius + polyB.m_radius;\n        findMaxSeparation(polyA, xfA, polyB, xfB, maxSeparation);\n        var edgeA = maxSeparation.bestIndex;\n        var separationA = maxSeparation.maxSeparation;\n        if (separationA > totalRadius)\n            return;\n        findMaxSeparation(polyB, xfB, polyA, xfA, maxSeparation);\n        var edgeB = maxSeparation.bestIndex;\n        var separationB = maxSeparation.maxSeparation;\n        if (separationB > totalRadius)\n            return;\n        var poly1; // reference polygon\n        var poly2; // incident polygon\n        var xf1;\n        var xf2;\n        var edge1; // reference edge\n        var flip;\n        var k_tol = 0.1 * Settings.linearSlop;\n        if (separationB > separationA + k_tol) {\n            poly1 = polyB;\n            poly2 = polyA;\n            xf1 = xfB;\n            xf2 = xfA;\n            edge1 = edgeB;\n            manifold.type = ManifoldType.e_faceB;\n            flip = 1;\n        }\n        else {\n            poly1 = polyA;\n            poly2 = polyB;\n            xf1 = xfA;\n            xf2 = xfB;\n            edge1 = edgeA;\n            manifold.type = ManifoldType.e_faceA;\n            flip = 0;\n        }\n        var incidentEdge = [new ClipVertex(), new ClipVertex()];\n        findIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);\n        var count1 = poly1.m_count;\n        var vertices1 = poly1.m_vertices;\n        var iv1 = edge1;\n        var iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;\n        var v11 = vertices1[iv1];\n        var v12 = vertices1[iv2];\n        var localTangent = Vec2.sub(v12, v11);\n        localTangent.normalize();\n        var localNormal = Vec2.crossVec2Num(localTangent, 1.0);\n        var planePoint = Vec2.combine(0.5, v11, 0.5, v12);\n        var tangent = Rot.mulVec2(xf1.q, localTangent);\n        var normal = Vec2.crossVec2Num(tangent, 1.0);\n        v11 = Transform.mulVec2(xf1, v11);\n        v12 = Transform.mulVec2(xf1, v12);\n        // Face offset.\n        var frontOffset = Vec2.dot(normal, v11);\n        // Side offsets, extended by polytope skin thickness.\n        var sideOffset1 = -Vec2.dot(tangent, v11) + totalRadius;\n        var sideOffset2 = Vec2.dot(tangent, v12) + totalRadius;\n        // Clip incident edge against extruded edge1 side edges.\n        var clipPoints1 = [new ClipVertex(), new ClipVertex()];\n        var clipPoints2 = [new ClipVertex(), new ClipVertex()];\n        var np;\n        // Clip to box side 1\n        np = clipSegmentToLine(clipPoints1, incidentEdge, Vec2.neg(tangent), sideOffset1, iv1);\n        if (np < 2) {\n            return;\n        }\n        // Clip to negative box side 1\n        np = clipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2, iv2);\n        if (np < 2) {\n            return;\n        }\n        // Now clipPoints2 contains the clipped points.\n        manifold.localNormal = localNormal;\n        manifold.localPoint = planePoint;\n        var pointCount = 0;\n        for (var i = 0; i < clipPoints2.length /* maxManifoldPoints */; ++i) {\n            var separation = Vec2.dot(normal, clipPoints2[i].v) - frontOffset;\n            if (separation <= totalRadius) {\n                var cp = manifold.points[pointCount];\n                cp.localPoint.setVec2(Transform.mulTVec2(xf2, clipPoints2[i].v));\n                cp.id = clipPoints2[i].id;\n                if (flip) {\n                    // Swap features\n                    var cf = cp.id.cf;\n                    var indexA = cf.indexA;\n                    var indexB = cf.indexB;\n                    var typeA = cf.typeA;\n                    var typeB = cf.typeB;\n                    cf.indexA = indexB;\n                    cf.indexB = indexA;\n                    cf.typeA = typeB;\n                    cf.typeB = typeA;\n                }\n                ++pointCount;\n            }\n        }\n        manifold.pointCount = pointCount;\n    }\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    Contact.addType(PolygonShape.TYPE, CircleShape.TYPE, PolygonCircleContact);\n    function PolygonCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {\n        CollidePolygonCircle(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);\n    }\n    function CollidePolygonCircle(manifold, polygonA, xfA, circleB, xfB) {\n        manifold.pointCount = 0;\n        // Compute circle position in the frame of the polygon.\n        var c = Transform.mulVec2(xfB, circleB.m_p);\n        var cLocal = Transform.mulTVec2(xfA, c);\n        // Find the min separating edge.\n        var normalIndex = 0;\n        var separation = -Infinity;\n        var radius = polygonA.m_radius + circleB.m_radius;\n        var vertexCount = polygonA.m_count;\n        var vertices = polygonA.m_vertices;\n        var normals = polygonA.m_normals;\n        for (var i = 0; i < vertexCount; ++i) {\n            var s = Vec2.dot(normals[i], Vec2.sub(cLocal, vertices[i]));\n            if (s > radius) {\n                // Early out.\n                return;\n            }\n            if (s > separation) {\n                separation = s;\n                normalIndex = i;\n            }\n        }\n        // Vertices that subtend the incident face.\n        var vertIndex1 = normalIndex;\n        var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;\n        var v1 = vertices[vertIndex1];\n        var v2 = vertices[vertIndex2];\n        // If the center is inside the polygon ...\n        if (separation < math$1.EPSILON) {\n            manifold.pointCount = 1;\n            manifold.type = ManifoldType.e_faceA;\n            manifold.localNormal.setVec2(normals[normalIndex]);\n            manifold.localPoint.setCombine(0.5, v1, 0.5, v2);\n            manifold.points[0].localPoint = circleB.m_p;\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 0;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n            return;\n        }\n        // Compute barycentric coordinates\n        var u1 = Vec2.dot(Vec2.sub(cLocal, v1), Vec2.sub(v2, v1));\n        var u2 = Vec2.dot(Vec2.sub(cLocal, v2), Vec2.sub(v1, v2));\n        if (u1 <= 0.0) {\n            if (Vec2.distanceSquared(cLocal, v1) > radius * radius) {\n                return;\n            }\n            manifold.pointCount = 1;\n            manifold.type = ManifoldType.e_faceA;\n            manifold.localNormal.setCombine(1, cLocal, -1, v1);\n            manifold.localNormal.normalize();\n            manifold.localPoint = v1;\n            manifold.points[0].localPoint.setVec2(circleB.m_p);\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 0;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n        }\n        else if (u2 <= 0.0) {\n            if (Vec2.distanceSquared(cLocal, v2) > radius * radius) {\n                return;\n            }\n            manifold.pointCount = 1;\n            manifold.type = ManifoldType.e_faceA;\n            manifold.localNormal.setCombine(1, cLocal, -1, v2);\n            manifold.localNormal.normalize();\n            manifold.localPoint.setVec2(v2);\n            manifold.points[0].localPoint.setVec2(circleB.m_p);\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 0;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n        }\n        else {\n            var faceCenter = Vec2.mid(v1, v2);\n            var separation_1 = Vec2.dot(cLocal, normals[vertIndex1]) - Vec2.dot(faceCenter, normals[vertIndex1]);\n            if (separation_1 > radius) {\n                return;\n            }\n            manifold.pointCount = 1;\n            manifold.type = ManifoldType.e_faceA;\n            manifold.localNormal.setVec2(normals[vertIndex1]);\n            manifold.localPoint.setVec2(faceCenter);\n            manifold.points[0].localPoint.setVec2(circleB.m_p);\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 0;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n        }\n    }\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    Contact.addType(EdgeShape.TYPE, PolygonShape.TYPE, EdgePolygonContact);\n    Contact.addType(ChainShape.TYPE, PolygonShape.TYPE, ChainPolygonContact);\n    function EdgePolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {\n        CollideEdgePolygon(manifold, fA.getShape(), xfA, fB.getShape(), xfB);\n    }\n    function ChainPolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {\n        var chain = fA.getShape();\n        var edge = new EdgeShape();\n        chain.getChildEdge(edge, indexA);\n        CollideEdgePolygon(manifold, edge, xfA, fB.getShape(), xfB);\n    }\n    var EPAxisType;\n    (function (EPAxisType) {\n        EPAxisType[EPAxisType[\"e_unknown\"] = -1] = \"e_unknown\";\n        EPAxisType[EPAxisType[\"e_edgeA\"] = 1] = \"e_edgeA\";\n        EPAxisType[EPAxisType[\"e_edgeB\"] = 2] = \"e_edgeB\";\n    })(EPAxisType || (EPAxisType = {}));\n    // unused?\n    var VertexType;\n    (function (VertexType) {\n        VertexType[VertexType[\"e_isolated\"] = 0] = \"e_isolated\";\n        VertexType[VertexType[\"e_concave\"] = 1] = \"e_concave\";\n        VertexType[VertexType[\"e_convex\"] = 2] = \"e_convex\";\n    })(VertexType || (VertexType = {}));\n    /**\n     * This structure is used to keep track of the best separating axis.\n     */\n    var EPAxis = /** @class */ (function () {\n        function EPAxis() {\n        }\n        return EPAxis;\n    }());\n    /**\n     * This holds polygon B expressed in frame A.\n     */\n    var TempPolygon = /** @class */ (function () {\n        function TempPolygon() {\n            this.vertices = []; // [Settings.maxPolygonVertices]\n            this.normals = []; // [Settings.maxPolygonVertices];\n            this.count = 0;\n        }\n        return TempPolygon;\n    }());\n    /**\n     * Reference face used for clipping\n     */\n    var ReferenceFace = /** @class */ (function () {\n        function ReferenceFace() {\n            this.normal = Vec2.zero();\n            this.sideNormal1 = Vec2.zero();\n            this.sideNormal2 = Vec2.zero();\n        }\n        return ReferenceFace;\n    }());\n    // reused\n    var edgeAxis = new EPAxis();\n    var polygonAxis = new EPAxis();\n    var polygonBA = new TempPolygon();\n    var rf = new ReferenceFace();\n    /**\n     * This function collides and edge and a polygon, taking into account edge\n     * adjacency.\n     */\n    function CollideEdgePolygon(manifold, edgeA, xfA, polygonB, xfB) {\n        // Algorithm:\n        // 1. Classify v1 and v2\n        // 2. Classify polygon centroid as front or back\n        // 3. Flip normal if necessary\n        // 4. Initialize normal range to [-pi, pi] about face normal\n        // 5. Adjust normal range according to adjacent edges\n        // 6. Visit each separating axes, only accept axes within the range\n        // 7. Return if _any_ axis indicates separation\n        // 8. Clip\n        // let m_type1: VertexType;\n        // let m_type2: VertexType;\n        var xf = Transform.mulTXf(xfA, xfB);\n        var centroidB = Transform.mulVec2(xf, polygonB.m_centroid);\n        var v0 = edgeA.m_vertex0;\n        var v1 = edgeA.m_vertex1;\n        var v2 = edgeA.m_vertex2;\n        var v3 = edgeA.m_vertex3;\n        var hasVertex0 = edgeA.m_hasVertex0;\n        var hasVertex3 = edgeA.m_hasVertex3;\n        var edge1 = Vec2.sub(v2, v1);\n        edge1.normalize();\n        var normal1 = Vec2.neo(edge1.y, -edge1.x);\n        var offset1 = Vec2.dot(normal1, Vec2.sub(centroidB, v1));\n        var offset0 = 0.0;\n        var offset2 = 0.0;\n        var convex1 = false;\n        var convex2 = false;\n        var normal0;\n        var normal2;\n        // Is there a preceding edge?\n        if (hasVertex0) {\n            var edge0 = Vec2.sub(v1, v0);\n            edge0.normalize();\n            normal0 = Vec2.neo(edge0.y, -edge0.x);\n            convex1 = Vec2.crossVec2Vec2(edge0, edge1) >= 0.0;\n            offset0 = Vec2.dot(normal0, centroidB) - Vec2.dot(normal0, v0);\n        }\n        // Is there a following edge?\n        if (hasVertex3) {\n            var edge2 = Vec2.sub(v3, v2);\n            edge2.normalize();\n            normal2 = Vec2.neo(edge2.y, -edge2.x);\n            convex2 = Vec2.crossVec2Vec2(edge1, edge2) > 0.0;\n            offset2 = Vec2.dot(normal2, centroidB) - Vec2.dot(normal2, v2);\n        }\n        var front;\n        var normal = Vec2.zero();\n        var lowerLimit = Vec2.zero();\n        var upperLimit = Vec2.zero();\n        // Determine front or back collision. Determine collision normal limits.\n        if (hasVertex0 && hasVertex3) {\n            if (convex1 && convex2) {\n                front = offset0 >= 0.0 || offset1 >= 0.0 || offset2 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal0);\n                    upperLimit.setVec2(normal2);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal1);\n                    upperLimit.setMul(-1, normal1);\n                }\n            }\n            else if (convex1) {\n                front = offset0 >= 0.0 || (offset1 >= 0.0 && offset2 >= 0.0);\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal0);\n                    upperLimit.setVec2(normal1);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal2);\n                    upperLimit.setMul(-1, normal1);\n                }\n            }\n            else if (convex2) {\n                front = offset2 >= 0.0 || (offset0 >= 0.0 && offset1 >= 0.0);\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal1);\n                    upperLimit.setVec2(normal2);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal1);\n                    upperLimit.setMul(-1, normal0);\n                }\n            }\n            else {\n                front = offset0 >= 0.0 && offset1 >= 0.0 && offset2 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal1);\n                    upperLimit.setVec2(normal1);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal2);\n                    upperLimit.setMul(-1, normal0);\n                }\n            }\n        }\n        else if (hasVertex0) {\n            if (convex1) {\n                front = offset0 >= 0.0 || offset1 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal0);\n                    upperLimit.setMul(-1, normal1);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setVec2(normal1);\n                    upperLimit.setMul(-1, normal1);\n                }\n            }\n            else {\n                front = offset0 >= 0.0 && offset1 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal1);\n                    upperLimit.setMul(-1, normal1);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setVec2(normal1);\n                    upperLimit.setMul(-1, normal0);\n                }\n            }\n        }\n        else if (hasVertex3) {\n            if (convex2) {\n                front = offset1 >= 0.0 || offset2 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setMul(-1, normal1);\n                    upperLimit.setVec2(normal2);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal1);\n                    upperLimit.setVec2(normal1);\n                }\n            }\n            else {\n                front = offset1 >= 0.0 && offset2 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setMul(-1, normal1);\n                    upperLimit.setVec2(normal1);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal2);\n                    upperLimit.setVec2(normal1);\n                }\n            }\n        }\n        else {\n            front = offset1 >= 0.0;\n            if (front) {\n                normal.setVec2(normal1);\n                lowerLimit.setMul(-1, normal1);\n                upperLimit.setMul(-1, normal1);\n            }\n            else {\n                normal.setMul(-1, normal1);\n                lowerLimit.setVec2(normal1);\n                upperLimit.setVec2(normal1);\n            }\n        }\n        // Get polygonB in frameA\n        polygonBA.count = polygonB.m_count;\n        for (var i = 0; i < polygonB.m_count; ++i) {\n            polygonBA.vertices[i] = Transform.mulVec2(xf, polygonB.m_vertices[i]);\n            polygonBA.normals[i] = Rot.mulVec2(xf.q, polygonB.m_normals[i]);\n        }\n        var radius = 2.0 * Settings.polygonRadius;\n        manifold.pointCount = 0;\n        { // ComputeEdgeSeparation\n            edgeAxis.type = EPAxisType.e_edgeA;\n            edgeAxis.index = front ? 0 : 1;\n            edgeAxis.separation = Infinity;\n            for (var i = 0; i < polygonBA.count; ++i) {\n                var s = Vec2.dot(normal, Vec2.sub(polygonBA.vertices[i], v1));\n                if (s < edgeAxis.separation) {\n                    edgeAxis.separation = s;\n                }\n            }\n        }\n        // If no valid normal can be found than this edge should not collide.\n        // @ts-ignore\n        if (edgeAxis.type == EPAxisType.e_unknown) {\n            return;\n        }\n        if (edgeAxis.separation > radius) {\n            return;\n        }\n        { // ComputePolygonSeparation\n            polygonAxis.type = EPAxisType.e_unknown;\n            polygonAxis.index = -1;\n            polygonAxis.separation = -Infinity;\n            var perp = Vec2.neo(-normal.y, normal.x);\n            for (var i = 0; i < polygonBA.count; ++i) {\n                var n = Vec2.neg(polygonBA.normals[i]);\n                var s1 = Vec2.dot(n, Vec2.sub(polygonBA.vertices[i], v1));\n                var s2 = Vec2.dot(n, Vec2.sub(polygonBA.vertices[i], v2));\n                var s = math$1.min(s1, s2);\n                if (s > radius) {\n                    // No collision\n                    polygonAxis.type = EPAxisType.e_edgeB;\n                    polygonAxis.index = i;\n                    polygonAxis.separation = s;\n                    break;\n                }\n                // Adjacency\n                if (Vec2.dot(n, perp) >= 0.0) {\n                    if (Vec2.dot(Vec2.sub(n, upperLimit), normal) < -Settings.angularSlop) {\n                        continue;\n                    }\n                }\n                else {\n                    if (Vec2.dot(Vec2.sub(n, lowerLimit), normal) < -Settings.angularSlop) {\n                        continue;\n                    }\n                }\n                if (s > polygonAxis.separation) {\n                    polygonAxis.type = EPAxisType.e_edgeB;\n                    polygonAxis.index = i;\n                    polygonAxis.separation = s;\n                }\n            }\n        }\n        if (polygonAxis.type != EPAxisType.e_unknown && polygonAxis.separation > radius) {\n            return;\n        }\n        // Use hysteresis for jitter reduction.\n        var k_relativeTol = 0.98;\n        var k_absoluteTol = 0.001;\n        var primaryAxis;\n        if (polygonAxis.type == EPAxisType.e_unknown) {\n            primaryAxis = edgeAxis;\n        }\n        else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {\n            primaryAxis = polygonAxis;\n        }\n        else {\n            primaryAxis = edgeAxis;\n        }\n        var ie = [new ClipVertex(), new ClipVertex()];\n        if (primaryAxis.type == EPAxisType.e_edgeA) {\n            manifold.type = ManifoldType.e_faceA;\n            // Search for the polygon normal that is most anti-parallel to the edge\n            // normal.\n            var bestIndex = 0;\n            var bestValue = Vec2.dot(normal, polygonBA.normals[0]);\n            for (var i = 1; i < polygonBA.count; ++i) {\n                var value = Vec2.dot(normal, polygonBA.normals[i]);\n                if (value < bestValue) {\n                    bestValue = value;\n                    bestIndex = i;\n                }\n            }\n            var i1 = bestIndex;\n            var i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;\n            ie[0].v = polygonBA.vertices[i1];\n            ie[0].id.cf.indexA = 0;\n            ie[0].id.cf.indexB = i1;\n            ie[0].id.cf.typeA = ContactFeatureType.e_face;\n            ie[0].id.cf.typeB = ContactFeatureType.e_vertex;\n            ie[1].v = polygonBA.vertices[i2];\n            ie[1].id.cf.indexA = 0;\n            ie[1].id.cf.indexB = i2;\n            ie[1].id.cf.typeA = ContactFeatureType.e_face;\n            ie[1].id.cf.typeB = ContactFeatureType.e_vertex;\n            if (front) {\n                rf.i1 = 0;\n                rf.i2 = 1;\n                rf.v1 = v1;\n                rf.v2 = v2;\n                rf.normal.setVec2(normal1);\n            }\n            else {\n                rf.i1 = 1;\n                rf.i2 = 0;\n                rf.v1 = v2;\n                rf.v2 = v1;\n                rf.normal.setMul(-1, normal1);\n            }\n        }\n        else {\n            manifold.type = ManifoldType.e_faceB;\n            ie[0].v = v1;\n            ie[0].id.cf.indexA = 0;\n            ie[0].id.cf.indexB = primaryAxis.index;\n            ie[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            ie[0].id.cf.typeB = ContactFeatureType.e_face;\n            ie[1].v = v2;\n            ie[1].id.cf.indexA = 0;\n            ie[1].id.cf.indexB = primaryAxis.index;\n            ie[1].id.cf.typeA = ContactFeatureType.e_vertex;\n            ie[1].id.cf.typeB = ContactFeatureType.e_face;\n            rf.i1 = primaryAxis.index;\n            rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;\n            rf.v1 = polygonBA.vertices[rf.i1];\n            rf.v2 = polygonBA.vertices[rf.i2];\n            rf.normal.setVec2(polygonBA.normals[rf.i1]);\n        }\n        rf.sideNormal1.setNum(rf.normal.y, -rf.normal.x);\n        rf.sideNormal2.setMul(-1, rf.sideNormal1);\n        rf.sideOffset1 = Vec2.dot(rf.sideNormal1, rf.v1);\n        rf.sideOffset2 = Vec2.dot(rf.sideNormal2, rf.v2);\n        // Clip incident edge against extruded edge1 side edges.\n        var clipPoints1 = [new ClipVertex(), new ClipVertex()];\n        var clipPoints2 = [new ClipVertex(), new ClipVertex()];\n        var np;\n        // Clip to box side 1\n        np = clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);\n        if (np < Settings.maxManifoldPoints) {\n            return;\n        }\n        // Clip to negative box side 1\n        np = clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);\n        if (np < Settings.maxManifoldPoints) {\n            return;\n        }\n        // Now clipPoints2 contains the clipped points.\n        if (primaryAxis.type == EPAxisType.e_edgeA) {\n            manifold.localNormal = Vec2.clone(rf.normal);\n            manifold.localPoint = Vec2.clone(rf.v1);\n        }\n        else {\n            manifold.localNormal = Vec2.clone(polygonB.m_normals[rf.i1]);\n            manifold.localPoint = Vec2.clone(polygonB.m_vertices[rf.i1]);\n        }\n        var pointCount = 0;\n        for (var i = 0; i < Settings.maxManifoldPoints; ++i) {\n            var separation = Vec2.dot(rf.normal, Vec2.sub(clipPoints2[i].v, rf.v1));\n            if (separation <= radius) {\n                var cp = manifold.points[pointCount]; // ManifoldPoint\n                if (primaryAxis.type == EPAxisType.e_edgeA) {\n                    cp.localPoint = Transform.mulTVec2(xf, clipPoints2[i].v);\n                    cp.id = clipPoints2[i].id;\n                }\n                else {\n                    cp.localPoint = clipPoints2[i].v;\n                    cp.id.cf.typeA = clipPoints2[i].id.cf.typeB;\n                    cp.id.cf.typeB = clipPoints2[i].id.cf.typeA;\n                    cp.id.cf.indexA = clipPoints2[i].id.cf.indexB;\n                    cp.id.cf.indexB = clipPoints2[i].id.cf.indexA;\n                }\n                ++pointCount;\n            }\n        }\n        manifold.pointCount = pointCount;\n    }\n\n    // @ts-ignore\n    Solver.TimeStep = TimeStep;\n    // @ts-ignore\n    Distance.testOverlap = testOverlap;\n    // @ts-ignore\n    Distance.Input = DistanceInput;\n    // @ts-ignore\n    Distance.Output = DistanceOutput;\n    // @ts-ignore\n    Distance.Proxy = DistanceProxy;\n    // @ts-ignore\n    Distance.Cache = SimplexCache;\n    // @ts-ignore\n    TimeOfImpact.Input = TOIInput;\n    // @ts-ignore\n    TimeOfImpact.Output = TOIOutput;\n\n    function createCommonjsModule(fn) {\n      var module = { exports: {} };\n    \treturn fn(module, module.exports), module.exports;\n    }\n\n    var stats = {};\n\n    var extend = function(base) {\n      for (var i = 1; i < arguments.length; i++) {\n        var obj = arguments[i];\n        for ( var key in obj) {\n          if (obj.hasOwnProperty(key)) {\n            base[key] = obj[key];\n          }\n        }\n      }\n      return base;\n    };\n\n    /**\n     * ! is the definitive JavaScript type testing library\n     * \n     * @copyright 2013-2014 Enrico Marino / Jordan Harband\n     * @license MIT\n     */\n\n    var is_1 = createCommonjsModule(function (module) {\n    var objProto = Object.prototype;\n    var owns = objProto.hasOwnProperty;\n    var toStr = objProto.toString;\n\n    var hexRegex = /^[A-Fa-f0-9]+$/;\n\n    var is = module.exports = {};\n\n    is.a = is.an = is.type = function(value, type) {\n      return typeof value === type;\n    };\n\n    is.defined = function(value) {\n      return typeof value !== 'undefined';\n    };\n\n    is.empty = function(value) {\n      var type = toStr.call(value);\n      var key;\n\n      if ('[object Array]' === type || '[object Arguments]' === type\n          || '[object String]' === type) {\n        return value.length === 0;\n      }\n\n      if ('[object Object]' === type) {\n        for (key in value) {\n          if (owns.call(value, key)) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      return !value;\n    };\n\n    is.equal = function(value, other) {\n      if (value === other) {\n        return true;\n      }\n\n      var type = toStr.call(value);\n      var key;\n\n      if (type !== toStr.call(other)) {\n        return false;\n      }\n\n      if ('[object Object]' === type) {\n        for (key in value) {\n          if (!is.equal(value[key], other[key]) || !(key in other)) {\n            return false;\n          }\n        }\n        for (key in other) {\n          if (!is.equal(value[key], other[key]) || !(key in value)) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      if ('[object Array]' === type) {\n        key = value.length;\n        if (key !== other.length) {\n          return false;\n        }\n        while (--key) {\n          if (!is.equal(value[key], other[key])) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      if ('[object Function]' === type) {\n        return value.prototype === other.prototype;\n      }\n\n      if ('[object Date]' === type) {\n        return value.getTime() === other.getTime();\n      }\n\n      return false;\n    };\n\n    is.instance = function(value, constructor) {\n      return value instanceof constructor;\n    };\n\n    is.nil = function(value) {\n      return value === null;\n    };\n\n    is.undef = function(value) {\n      return typeof value === 'undefined';\n    };\n\n    is.array = function(value) {\n      return '[object Array]' === toStr.call(value);\n    };\n\n    is.emptyarray = function(value) {\n      return is.array(value) && value.length === 0;\n    };\n\n    is.arraylike = function(value) {\n      return !!value && !is.boolean(value) && owns.call(value, 'length')\n          && isFinite(value.length) && is.number(value.length) && value.length >= 0;\n    };\n\n    is.boolean = function(value) {\n      return '[object Boolean]' === toStr.call(value);\n    };\n\n    is.element = function(value) {\n      return value !== undefined && typeof HTMLElement !== 'undefined'\n          && value instanceof HTMLElement && value.nodeType === 1;\n    };\n\n    is.fn = function(value) {\n      return '[object Function]' === toStr.call(value);\n    };\n\n    is.number = function(value) {\n      return '[object Number]' === toStr.call(value);\n    };\n\n    is.nan = function(value) {\n      return !is.number(value) || value !== value;\n    };\n\n    is.object = function(value) {\n      return '[object Object]' === toStr.call(value);\n    };\n\n    is.hash = function(value) {\n      return is.object(value) && value.constructor === Object && !value.nodeType\n          && !value.setInterval;\n    };\n\n    is.regexp = function(value) {\n      return '[object RegExp]' === toStr.call(value);\n    };\n\n    is.string = function(value) {\n      return '[object String]' === toStr.call(value);\n    };\n\n    is.hex = function(value) {\n      return is.string(value) && (!value.length || hexRegex.test(value));\n    };\n    });\n\n    var _await = function() {\n      var count = 0;\n      function fork(fn, n) {\n        count += n = (typeof n === 'number' && n >= 1 ? n : 1);\n        return function() {\n          fn && fn.apply(this, arguments);\n          if (n > 0) {\n            n--, count--, call();\n          }\n        };\n      }\n      var then = [];\n      function call() {\n        if (count === 0) {\n          while (then.length) {\n            setTimeout(then.shift(), 0);\n          }\n        }\n      }\n      fork.then = function(fn) {\n        if (count === 0) {\n          setTimeout(fn, 0);\n        } else {\n          then.push(fn);\n        }\n      };\n      return fork;\n    };\n\n    stats.create = 0;\n\n    function Class(arg) {\n      if (!(this instanceof Class)) {\n        if (is_1.fn(arg)) {\n          return Class.app.apply(Class, arguments);\n        } else if (is_1.object(arg)) {\n          return Class.atlas.apply(Class, arguments);\n        } else {\n          return arg;\n        }\n      }\n\n      stats.create++;\n\n      for (var i = 0; i < _init.length; i++) {\n        _init[i].call(this);\n      }\n    }\n\n    var _init = [];\n\n    Class._init = function(fn) {\n      _init.push(fn);\n    };\n\n    var _load = [];\n\n    Class._load = function(fn) {\n      _load.push(fn);\n    };\n\n    var _config = {};\n\n    Class.config = function() {\n      if (arguments.length === 1 && is_1.string(arguments[0])) {\n        return _config[arguments[0]];\n      }\n      if (arguments.length === 1 && is_1.object(arguments[0])) {\n        extend(_config, arguments[0]);\n      }\n      if (arguments.length === 2 && is_1.string(arguments[0])) ;\n    };\n\n    var _app_queue = [];\n    var _stages = [];\n    var _loaded = false;\n    var _paused = false;\n\n    Class.app = function(app, opts) {\n      if (!_loaded) {\n        _app_queue.push(arguments);\n        return;\n      }\n      var loader = Class.config('app-loader');\n      loader(function(stage, canvas) {\n        for (var i = 0; i < _load.length; i++) {\n          _load[i].call(this, stage, canvas);\n        }\n        app(stage, canvas);\n        _stages.push(stage);\n        stage.start();\n      }, opts);\n    };\n\n    var loading = _await();\n\n    Class.preload = function(load) {\n      if (typeof load === 'string') {\n        var url = Class.resolve(load);\n        if (/\\.js($|\\?|\\#)/.test(url)) {\n          load = function(callback) {\n            loadScript(url, callback);\n          };\n        }\n      }\n      if (typeof load !== 'function') {\n        return;\n      }\n      // if (!_started) {\n      // _preload_queue.push(load);\n      // return;\n      // }\n      load(loading());\n    };\n\n    Class.start = function(config) {\n\n      Class.config(config);\n\n      // false && console.log('Preloading...');\n      // _started = true;\n      // while (_preload_queue.length) {\n      // var load = _preload_queue.shift();\n      // load(loading());\n      // }\n\n      loading.then(function() {\n        _loaded = true;\n        while (_app_queue.length) {\n          var args = _app_queue.shift();\n          Class.app.apply(Class, args);\n        }\n      });\n    };\n\n    Class.pause = function() {\n      if (!_paused) {\n        _paused = true;\n        for (var i = _stages.length - 1; i >= 0; i--) {\n          _stages[i].pause();\n        }\n      }\n    };\n\n    Class.resume = function() {\n      if (_paused) {\n        _paused = false;\n        for (var i = _stages.length - 1; i >= 0; i--) {\n          _stages[i].resume();\n        }\n      }\n    };\n\n    Class.create = function() {\n      return new Class();\n    };\n\n    Class.resolve = (function() {\n\n      if (typeof window === 'undefined' || typeof document === 'undefined') {\n        return function(url) {\n          return url;\n        };\n      }\n\n      var scripts = document.getElementsByTagName('script');\n\n      function getScriptSrc() {\n        // HTML5\n        if (document.currentScript) {\n          return document.currentScript.src;\n        }\n\n        // IE>=10\n        var stack;\n        try {\n          var err = new Error();\n          if (err.stack) {\n            stack = err.stack;\n          } else {\n            throw err;\n          }\n        } catch (err) {\n          stack = err.stack;\n        }\n        if (typeof stack === 'string') {\n          stack = stack.split('\\n');\n          // Uses the last line, where the call started\n          for (var i = stack.length; i--;) {\n            var url = stack[i].match(/(\\w+\\:\\/\\/[^/]*?\\/.+?)(:\\d+)(:\\d+)?/);\n            if (url) {\n              return url[1];\n            }\n          }\n        }\n\n        // IE<11\n        if (scripts.length && 'readyState' in scripts[0]) {\n          for (var i = scripts.length; i--;) {\n            if (scripts[i].readyState === 'interactive') {\n              return scripts[i].src;\n            }\n          }\n        }\n\n        return location.href;\n      }\n\n      return function(url) {\n        if (/^\\.\\//.test(url)) {\n          var src = getScriptSrc();\n          var base = src.substring(0, src.lastIndexOf('/') + 1);\n          url = base + url.substring(2);\n          // } else if (/^\\.\\.\\//.test(url)) {\n          // url = base + url;\n        }\n        return url;\n      };\n    })();\n\n    var core = Class;\n\n    function loadScript(src, callback) {\n      var el = document.createElement('script');\n      el.addEventListener('load', function() {\n        callback();\n      });\n      el.addEventListener('error', function(err) {\n        callback(err || 'Error loading script: ' + src);\n      });\n      el.src = src;\n      el.id = 'preload-' + Date.now();\n      document.body.appendChild(el);\n    }\n\n    function Matrix$1(a, b, c, d, e, f) {\n      this.reset(a, b, c, d, e, f);\n    }\n    Matrix$1.prototype.toString = function() {\n      return '[' + this.a + ', ' + this.b + ', ' + this.c + ', ' + this.d + ', '\n          + this.e + ', ' + this.f + ']';\n    };\n\n    Matrix$1.prototype.clone = function() {\n      return new Matrix$1(this.a, this.b, this.c, this.d, this.e, this.f);\n    };\n\n    Matrix$1.prototype.reset = function(a, b, c, d, e, f) {\n      this._dirty = true;\n      if (typeof a === 'object') {\n        this.a = a.a, this.d = a.d;\n        this.b = a.b, this.c = a.c;\n        this.e = a.e, this.f = a.f;\n      } else {\n        this.a = a || 1, this.d = d || 1;\n        this.b = b || 0, this.c = c || 0;\n        this.e = e || 0, this.f = f || 0;\n      }\n      return this;\n    };\n\n    Matrix$1.prototype.identity = function() {\n      this._dirty = true;\n      this.a = 1;\n      this.b = 0;\n      this.c = 0;\n      this.d = 1;\n      this.e = 0;\n      this.f = 0;\n      return this;\n    };\n\n    Matrix$1.prototype.rotate = function(angle) {\n      if (!angle) {\n        return this;\n      }\n\n      this._dirty = true;\n\n      var u = angle ? Math.cos(angle) : 1;\n      // android bug may give bad 0 values\n      var v = angle ? Math.sin(angle) : 0;\n\n      var a = u * this.a - v * this.b;\n      var b = u * this.b + v * this.a;\n      var c = u * this.c - v * this.d;\n      var d = u * this.d + v * this.c;\n      var e = u * this.e - v * this.f;\n      var f = u * this.f + v * this.e;\n\n      this.a = a;\n      this.b = b;\n      this.c = c;\n      this.d = d;\n      this.e = e;\n      this.f = f;\n\n      return this;\n    };\n\n    Matrix$1.prototype.translate = function(x, y) {\n      if (!x && !y) {\n        return this;\n      }\n      this._dirty = true;\n      this.e += x;\n      this.f += y;\n      return this;\n    };\n\n    Matrix$1.prototype.scale = function(x, y) {\n      if (!(x - 1) && !(y - 1)) {\n        return this;\n      }\n      this._dirty = true;\n      this.a *= x;\n      this.b *= y;\n      this.c *= x;\n      this.d *= y;\n      this.e *= x;\n      this.f *= y;\n      return this;\n    };\n\n    Matrix$1.prototype.skew = function(x, y) {\n      if (!x && !y) {\n        return this;\n      }\n      this._dirty = true;\n\n      var a = this.a + this.b * x;\n      var b = this.b + this.a * y;\n      var c = this.c + this.d * x;\n      var d = this.d + this.c * y;\n      var e = this.e + this.f * x;\n      var f = this.f + this.e * y;\n\n      this.a = a;\n      this.b = b;\n      this.c = c;\n      this.d = d;\n      this.e = e;\n      this.f = f;\n      return this;\n    };\n\n    Matrix$1.prototype.concat = function(m) {\n      this._dirty = true;\n\n      var n = this;\n\n      var a = n.a * m.a + n.b * m.c;\n      var b = n.b * m.d + n.a * m.b;\n      var c = n.c * m.a + n.d * m.c;\n      var d = n.d * m.d + n.c * m.b;\n      var e = n.e * m.a + m.e + n.f * m.c;\n      var f = n.f * m.d + m.f + n.e * m.b;\n\n      this.a = a;\n      this.b = b;\n      this.c = c;\n      this.d = d;\n      this.e = e;\n      this.f = f;\n\n      return this;\n    };\n\n    Matrix$1.prototype.inverse = Matrix$1.prototype.reverse = function() {\n      if (this._dirty) {\n        this._dirty = false;\n        this.inversed = this.inversed || new Matrix$1();\n        var z = this.a * this.d - this.b * this.c;\n        this.inversed.a = this.d / z;\n        this.inversed.b = -this.b / z;\n        this.inversed.c = -this.c / z;\n        this.inversed.d = this.a / z;\n        this.inversed.e = (this.c * this.f - this.e * this.d) / z;\n        this.inversed.f = (this.e * this.b - this.a * this.f) / z;\n      }\n      return this.inversed;\n    };\n\n    Matrix$1.prototype.map = function(p, q) {\n      q = q || {};\n      q.x = this.a * p.x + this.c * p.y + this.e;\n      q.y = this.b * p.x + this.d * p.y + this.f;\n      return q;\n    };\n\n    Matrix$1.prototype.mapX = function(x, y) {\n      if (typeof x === 'object')\n        y = x.y, x = x.x;\n      return this.a * x + this.c * y + this.e;\n    };\n\n    Matrix$1.prototype.mapY = function(x, y) {\n      if (typeof x === 'object')\n        y = x.y, x = x.x;\n      return this.b * x + this.d * y + this.f;\n    };\n\n    var matrix = Matrix$1;\n\n    var create = createCommonjsModule(function (module) {\n    if (typeof Object.create == 'function') {\n      module.exports = function(proto, props) {\n        return Object.create.call(Object, proto, props);\n      };\n    } else {\n      module.exports = function(proto, props) {\n        if (props)\n          throw Error('Second argument is not supported!');\n        if (typeof proto !== 'object' || proto === null)\n          throw Error('Invalid prototype!');\n        noop.prototype = proto;\n        return new noop;\n      };\n      function noop() {\n      }\n    }\n    });\n\n    var native = Math;\n\n    var math = create(Math);\n\n    var random = function(min, max) {\n      if (typeof min === 'undefined') {\n        max = 1, min = 0;\n      } else if (typeof max === 'undefined') {\n        max = min, min = 0;\n      }\n      return min == max ? min : native.random() * (max - min) + min;\n    };\n\n    var rotate = function(num, min, max) {\n      if (typeof min === 'undefined') {\n        max = 1, min = 0;\n      } else if (typeof max === 'undefined') {\n        max = min, min = 0;\n      }\n      if (max > min) {\n        num = (num - min) % (max - min);\n        return num + (num < 0 ? max : min);\n      } else {\n        num = (num - max) % (min - max);\n        return num + (num <= 0 ? min : max);\n      }\n    };\n\n    var limit = function(num, min, max) {\n      if (num < min) {\n        return min;\n      } else if (num > max) {\n        return max;\n      } else {\n        return num;\n      }\n    };\n\n    var length = function(x, y) {\n      return native.sqrt(x * x + y * y);\n    };\n    math.random = random;\n    math.rotate = rotate;\n    math.limit = limit;\n    math.length = length;\n\n    function Texture$1(image, ratio) {\n      if (typeof image === 'object') {\n        this.src(image, ratio);\n      }\n    }\n\n    Texture$1.prototype.pipe = function() {\n      return new Texture$1(this);\n    };\n\n    /**\n     * Signatures: (image), (x, y, w, h), (w, h)\n     */\n    Texture$1.prototype.src = function(x, y, w, h) {\n      if (typeof x === 'object') {\n        var image = x, ratio = y || 1;\n\n        this._image = image;\n        this._sx = this._dx = 0;\n        this._sy = this._dy = 0;\n        this._sw = this._dw = image.width / ratio;\n        this._sh = this._dh = image.height / ratio;\n\n        this.width = image.width / ratio;\n        this.height = image.height / ratio;\n\n        this.ratio = ratio;\n\n      } else {\n        if (typeof w === 'undefined') {\n          w = x, h = y;\n        } else {\n          this._sx = x, this._sy = y;\n        }\n        this._sw = this._dw = w;\n        this._sh = this._dh = h;\n\n        this.width = w;\n        this.height = h;\n      }\n      return this;\n    };\n\n    /**\n     * Signatures: (x, y, w, h), (x, y)\n     */\n    Texture$1.prototype.dest = function(x, y, w, h) {\n      this._dx = x, this._dy = y;\n      this._dx = x, this._dy = y;\n      if (typeof w !== 'undefined') {\n        this._dw = w, this._dh = h;\n        this.width = w, this.height = h;\n      }\n      return this;\n    };\n\n    Texture$1.prototype.draw = function(context, x1, y1, x2, y2, x3, y3, x4, y4) {\n      var image = this._image;\n      if (image === null || typeof image !== 'object') {\n        return;\n      }\n\n      var sx = this._sx, sy = this._sy;\n      var sw = this._sw, sh = this._sh;\n      var dx = this._dx, dy = this._dy;\n      var dw = this._dw, dh = this._dh;\n\n      if (typeof x3 !== 'undefined') {\n        x1 = math.limit(x1, 0, this._sw), x2 = math.limit(x2, 0, this._sw - x1);\n        y1 = math.limit(y1, 0, this._sh), y2 = math.limit(y2, 0, this._sh - y1);\n        sx += x1, sy += y1, sw = x2, sh = y2;\n        dx = x3, dy = y3, dw = x4, dh = y4;\n\n      } else if (typeof x2 !== 'undefined') {\n        dx = x1, dy = y1, dw = x2, dh = y2;\n\n      } else if (typeof x1 !== 'undefined') {\n        dw = x1, dh = y1;\n      }\n\n      var ratio = this.ratio || 1;\n      sx *= ratio, sy *= ratio, sw *= ratio, sh *= ratio;\n\n      try {\n        if (typeof image.draw === 'function') {\n          image.draw(context, sx, sy, sw, sh, dx, dy, dw, dh);\n        } else {\n          stats.draw++;\n          context.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);\n        }\n      } catch (ex) {\n        if (!image._draw_failed) {\n          console.log('Unable to draw: ', image);\n          console.log(ex);\n          image._draw_failed = true;\n        }\n      }\n    };\n\n    var texture = Texture$1;\n\n    var startsWith = function(str, sub) {\n      return typeof str === 'string' && typeof sub === 'string'\n          && str.substring(0, sub.length) == sub;\n    };\n\n    var string = {\n    \tstartsWith: startsWith\n    };\n\n    // name : atlas\n    var _atlases_map = {};\n    // [atlas]\n    var _atlases_arr = [];\n\n    // TODO: print subquery not found error\n    // TODO: index textures\n\n    core.atlas = function(def) {\n      var atlas = is_1.fn(def.draw) ? def : new Atlas(def);\n      if (def.name) {\n        _atlases_map[def.name] = atlas;\n      }\n      _atlases_arr.push(atlas);\n\n      deprecated(def, 'imagePath');\n      deprecated(def, 'imageRatio');\n\n      var url = def.imagePath;\n      var ratio = def.imageRatio || 1;\n      if (is_1.string(def.image)) {\n        url = def.image;\n      } else if (is_1.hash(def.image)) {\n        url = def.image.src || def.image.url;\n        ratio = def.image.ratio || ratio;\n      }\n      url && core.preload(function(done) {\n        url = core.resolve(url);\n        var imageloader = core.config('image-loader');\n\n        imageloader(url, function(image) {\n          atlas.src(image, ratio);\n          done();\n\n        }, function(err) {\n          done();\n        });\n      });\n\n      return atlas;\n    };\n\n    Atlas._super = texture;\n    Atlas.prototype = create(Atlas._super.prototype);\n\n    function Atlas(def) {\n      Atlas._super.call(this);\n\n      var atlas = this;\n\n      deprecated(def, 'filter');\n      deprecated(def, 'cutouts');\n      deprecated(def, 'sprites');\n      deprecated(def, 'factory');\n\n      var map = def.map || def.filter;\n      var ppu = def.ppu || def.ratio || 1;\n      var trim = def.trim || 0;\n      var textures = def.textures;\n      var factory = def.factory;\n      var cutouts = def.cutouts || def.sprites;\n\n      function make(def) {\n        if (!def || is_1.fn(def.draw)) {\n          return def;\n        }\n\n        def = extend({}, def);\n\n        if (is_1.fn(map)) {\n          def = map(def);\n        }\n\n        if (ppu != 1) {\n          def.x *= ppu, def.y *= ppu;\n          def.width *= ppu, def.height *= ppu;\n          def.top *= ppu, def.bottom *= ppu;\n          def.left *= ppu, def.right *= ppu;\n        }\n\n        if (trim != 0) {\n          def.x += trim, def.y += trim;\n          def.width -= 2 * trim, def.height -= 2 * trim;\n          def.top -= trim, def.bottom -= trim;\n          def.left -= trim, def.right -= trim;\n        }\n\n        var texture = atlas.pipe();\n        texture.top = def.top, texture.bottom = def.bottom;\n        texture.left = def.left, texture.right = def.right;\n        texture.src(def.x, def.y, def.width, def.height);\n        return texture;\n      }\n\n      function find(query) {\n        if (textures) {\n          if (is_1.fn(textures)) {\n            return textures(query);\n          } else if (is_1.hash(textures)) {\n            return textures[query];\n          }\n        }\n        if (cutouts) { // deprecated\n          var result = null, n = 0;\n          for (var i = 0; i < cutouts.length; i++) {\n            if (string.startsWith(cutouts[i].name, query)) {\n              if (n === 0) {\n                result = cutouts[i];\n              } else if (n === 1) {\n                result = [ result, cutouts[i] ];\n              } else {\n                result.push(cutouts[i]);\n              }\n              n++;\n            }\n          }\n          if (n === 0 && is_1.fn(factory)) {\n            result = function(subquery) {\n              return factory(query + (subquery ? subquery : ''));\n            };\n          }\n          return result;\n        }\n      }\n\n      this.select = function(query) {\n        if (!query) {\n          // TODO: if `textures` is texture def, map or fn?\n          return new Selection(this.pipe());\n        }\n        var found = find(query);\n        if (found) {\n          return new Selection(found, find, make);\n        }\n      };\n\n    }\n    var nfTexture = new texture();\n    nfTexture.x = nfTexture.y = nfTexture.width = nfTexture.height = 0;\n    nfTexture.pipe = nfTexture.src = nfTexture.dest = function() {\n      return this;\n    };\n    nfTexture.draw = function() {\n    };\n\n    var nfSelection = new Selection(nfTexture);\n\n    function Selection(result, find, make) {\n      function link(result, subquery) {\n        if (!result) {\n          return nfTexture;\n\n        } else if (is_1.fn(result.draw)) {\n          return result;\n\n        } else if (is_1.hash(result) && is_1.number(result.width)\n            && is_1.number(result.height) && is_1.fn(make)) {\n          return make(result);\n\n        } else if (is_1.hash(result) && is_1.defined(subquery)) {\n          return link(result[subquery]);\n\n        } else if (is_1.fn(result)) {\n          return link(result(subquery));\n\n        } else if (is_1.array(result)) {\n          return link(result[0]);\n\n        } else if (is_1.string(result) && is_1.fn(find)) {\n          return link(find(result));\n        }\n      }\n\n      this.one = function(subquery) {\n        return link(result, subquery);\n      };\n\n      this.array = function(arr) {\n        var array = is_1.array(arr) ? arr : [];\n        if (is_1.array(result)) {\n          for (var i = 0; i < result.length; i++) {\n            array[i] = link(result[i]);\n          }\n        } else {\n          array[0] = link(result);\n        }\n        return array;\n      };\n    }\n\n    core.texture = function(query) {\n      if (!is_1.string(query)) {\n        return new Selection(query);\n      }\n\n      var result = null, atlas, i;\n\n      if ((i = query.indexOf(':')) > 0 && query.length > i + 1) {\n        atlas = _atlases_map[query.slice(0, i)];\n        result = atlas && atlas.select(query.slice(i + 1));\n      }\n\n      if (!result && (atlas = _atlases_map[query])) {\n        result = atlas.select();\n      }\n\n      for (i = 0; !result && i < _atlases_arr.length; i++) {\n        result = _atlases_arr[i].select(query);\n      }\n\n      if (!result) {\n        console.error('Texture not found: ' + query);\n        result = nfSelection;\n      }\n\n      return result;\n    };\n\n    function deprecated(hash, name, msg) {\n      if (name in hash)\n        console.log(msg ? msg.replace('%name', name) : '\\'' + name\n            + '\\' field of texture atlas is deprecated.');\n    }\n\n    var iid$1 = 0;\n\n    // TODO: do not clear next/prev/parent on remove\n\n    core.prototype._label = '';\n\n    core.prototype._visible = true;\n\n    core.prototype._parent = null;\n    core.prototype._next = null;\n    core.prototype._prev = null;\n\n    core.prototype._first = null;\n    core.prototype._last = null;\n\n    core.prototype._attrs = null;\n    core.prototype._flags = null;\n\n    core.prototype.toString = function() {\n      return '[' + this._label + ']';\n    };\n\n    /**\n     * @deprecated Use label()\n     */\n    core.prototype.id = function(id) {\n      return this.label(id);\n    };\n\n    core.prototype.label = function(label) {\n      if (typeof label === 'undefined') {\n        return this._label;\n      }\n      this._label = label;\n      return this;\n    };\n\n    core.prototype.attr = function(name, value) {\n      if (typeof value === 'undefined') {\n        return this._attrs !== null ? this._attrs[name] : undefined;\n      }\n      (this._attrs !== null ? this._attrs : this._attrs = {})[name] = value;\n      return this;\n    };\n\n    core.prototype.visible = function(visible) {\n      if (typeof visible === 'undefined') {\n        return this._visible;\n      }\n      this._visible = visible;\n      this._parent && (this._parent._ts_children = ++iid$1);\n      this._ts_pin = ++iid$1;\n      this.touch();\n      return this;\n    };\n\n    core.prototype.hide = function() {\n      return this.visible(false);\n    };\n\n    core.prototype.show = function() {\n      return this.visible(true);\n    };\n\n    core.prototype.parent = function() {\n      return this._parent;\n    };\n\n    core.prototype.next = function(visible) {\n      var next = this._next;\n      while (next && visible && !next._visible) {\n        next = next._next;\n      }\n      return next;\n    };\n\n    core.prototype.prev = function(visible) {\n      var prev = this._prev;\n      while (prev && visible && !prev._visible) {\n        prev = prev._prev;\n      }\n      return prev;\n    };\n\n    core.prototype.first = function(visible) {\n      var next = this._first;\n      while (next && visible && !next._visible) {\n        next = next._next;\n      }\n      return next;\n    };\n\n    core.prototype.last = function(visible) {\n      var prev = this._last;\n      while (prev && visible && !prev._visible) {\n        prev = prev._prev;\n      }\n      return prev;\n    };\n\n    core.prototype.visit = function(visitor, data) {\n      var reverse = visitor.reverse;\n      var visible = visitor.visible;\n      if (visitor.start && visitor.start(this, data)) {\n        return;\n      }\n      var child, next = reverse ? this.last(visible) : this.first(visible);\n      while (child = next) {\n        next = reverse ? child.prev(visible) : child.next(visible);\n        if (child.visit(visitor, data)) {\n          return true;\n        }\n      }\n      return visitor.end && visitor.end(this, data);\n    };\n\n    core.prototype.append = function(child, more) {\n      if (is_1.array(child))\n        for (var i = 0; i < child.length; i++)\n          append(this, child[i]);\n\n      else if (typeof more !== 'undefined') // deprecated\n        for (var i = 0; i < arguments.length; i++)\n          append(this, arguments[i]);\n\n      else if (typeof child !== 'undefined')\n        append(this, child);\n\n      return this;\n    };\n\n    core.prototype.prepend = function(child, more) {\n      if (is_1.array(child))\n        for (var i = child.length - 1; i >= 0; i--)\n          prepend(this, child[i]);\n\n      else if (typeof more !== 'undefined') // deprecated\n        for (var i = arguments.length - 1; i >= 0; i--)\n          prepend(this, arguments[i]);\n\n      else if (typeof child !== 'undefined')\n        prepend(this, child);\n\n      return this;\n    };\n\n    core.prototype.appendTo = function(parent) {\n      append(parent, this);\n      return this;\n    };\n\n    core.prototype.prependTo = function(parent) {\n      prepend(parent, this);\n      return this;\n    };\n\n    core.prototype.insertNext = function(sibling, more) {\n      if (is_1.array(sibling))\n        for (var i = 0; i < sibling.length; i++)\n          insertAfter(sibling[i], this);\n\n      else if (typeof more !== 'undefined') // deprecated\n        for (var i = 0; i < arguments.length; i++)\n          insertAfter(arguments[i], this);\n\n      else if (typeof sibling !== 'undefined')\n        insertAfter(sibling, this);\n\n      return this;\n    };\n\n    core.prototype.insertPrev = function(sibling, more) {\n      if (is_1.array(sibling))\n        for (var i = sibling.length - 1; i >= 0; i--)\n          insertBefore(sibling[i], this);\n\n      else if (typeof more !== 'undefined') // deprecated\n        for (var i = arguments.length - 1; i >= 0; i--)\n          insertBefore(arguments[i], this);\n\n      else if (typeof sibling !== 'undefined')\n        insertBefore(sibling, this);\n\n      return this;\n    };\n\n    core.prototype.insertAfter = function(prev) {\n      insertAfter(this, prev);\n      return this;\n    };\n\n    core.prototype.insertBefore = function(next) {\n      insertBefore(this, next);\n      return this;\n    };\n\n    function append(parent, child) {\n      _ensure(child);\n      _ensure(parent);\n\n      child.remove();\n\n      if (parent._last) {\n        parent._last._next = child;\n        child._prev = parent._last;\n      }\n\n      child._parent = parent;\n      parent._last = child;\n\n      if (!parent._first) {\n        parent._first = child;\n      }\n\n      child._parent._flag(child, true);\n\n      child._ts_parent = ++iid$1;\n      parent._ts_children = ++iid$1;\n      parent.touch();\n    }\n\n    function prepend(parent, child) {\n      _ensure(child);\n      _ensure(parent);\n\n      child.remove();\n\n      if (parent._first) {\n        parent._first._prev = child;\n        child._next = parent._first;\n      }\n\n      child._parent = parent;\n      parent._first = child;\n\n      if (!parent._last) {\n        parent._last = child;\n      }\n\n      child._parent._flag(child, true);\n\n      child._ts_parent = ++iid$1;\n      parent._ts_children = ++iid$1;\n      parent.touch();\n    }\n    function insertBefore(self, next) {\n      _ensure(self);\n      _ensure(next);\n\n      self.remove();\n\n      var parent = next._parent;\n      var prev = next._prev;\n\n      next._prev = self;\n      prev && (prev._next = self) || parent && (parent._first = self);\n\n      self._parent = parent;\n      self._prev = prev;\n      self._next = next;\n\n      self._parent._flag(self, true);\n\n      self._ts_parent = ++iid$1;\n      self.touch();\n    }\n    function insertAfter(self, prev) {\n      _ensure(self);\n      _ensure(prev);\n\n      self.remove();\n\n      var parent = prev._parent;\n      var next = prev._next;\n\n      prev._next = self;\n      next && (next._prev = self) || parent && (parent._last = self);\n\n      self._parent = parent;\n      self._prev = prev;\n      self._next = next;\n\n      self._parent._flag(self, true);\n\n      self._ts_parent = ++iid$1;\n      self.touch();\n    }\n    core.prototype.remove = function(child, more) {\n      if (typeof child !== 'undefined') {\n        if (is_1.array(child)) {\n          for (var i = 0; i < child.length; i++)\n            _ensure(child[i]).remove();\n\n        } else if (typeof more !== 'undefined') {\n          for (var i = 0; i < arguments.length; i++)\n            _ensure(arguments[i]).remove();\n\n        } else {\n          _ensure(child).remove();\n        }\n        return this;\n      }\n\n      if (this._prev) {\n        this._prev._next = this._next;\n      }\n      if (this._next) {\n        this._next._prev = this._prev;\n      }\n\n      if (this._parent) {\n        if (this._parent._first === this) {\n          this._parent._first = this._next;\n        }\n        if (this._parent._last === this) {\n          this._parent._last = this._prev;\n        }\n\n        this._parent._flag(this, false);\n\n        this._parent._ts_children = ++iid$1;\n        this._parent.touch();\n      }\n\n      this._prev = this._next = this._parent = null;\n      this._ts_parent = ++iid$1;\n      // this._parent.touch();\n\n      return this;\n    };\n\n    core.prototype.empty = function() {\n      var child, next = this._first;\n      while (child = next) {\n        next = child._next;\n        child._prev = child._next = child._parent = null;\n\n        this._flag(child, false);\n      }\n\n      this._first = this._last = null;\n\n      this._ts_children = ++iid$1;\n      this.touch();\n      return this;\n    };\n\n    core.prototype.touch = function() {\n      this._ts_touch = ++iid$1;\n      this._parent && this._parent.touch();\n      return this;\n    };\n\n    /**\n     * Deep flags used for optimizing event distribution.\n     */\n    core.prototype._flag = function(obj, name) {\n      if (typeof name === 'undefined') {\n        return this._flags !== null && this._flags[obj] || 0;\n      }\n      if (typeof obj === 'string') {\n        if (name) {\n          this._flags = this._flags || {};\n          if (!this._flags[obj] && this._parent) {\n            this._parent._flag(obj, true);\n          }\n          this._flags[obj] = (this._flags[obj] || 0) + 1;\n\n        } else if (this._flags && this._flags[obj] > 0) {\n          if (this._flags[obj] == 1 && this._parent) {\n            this._parent._flag(obj, false);\n          }\n          this._flags[obj] = this._flags[obj] - 1;\n        }\n      }\n      if (typeof obj === 'object') {\n        if (obj._flags) {\n          for ( var type in obj._flags) {\n            if (obj._flags[type] > 0) {\n              this._flag(type, name);\n            }\n          }\n        }\n      }\n      return this;\n    };\n\n    /**\n     * @private\n     */\n    core.prototype.hitTest = function(hit) {\n      var width = this._pin._width;\n      var height = this._pin._height;\n      return hit.x >= 0 && hit.x <= width && hit.y >= 0 && hit.y <= height;\n    };\n\n    function _ensure(obj) {\n      if (obj && obj instanceof core) {\n        return obj;\n      }\n      throw 'Invalid node: ' + obj;\n    }\n\n    var event = function(prototype, callback) {\n\n      prototype._listeners = null;\n\n      prototype.on = prototype.listen = function(types, listener) {\n        if (!types || !types.length || typeof listener !== 'function') {\n          return this;\n        }\n        if (this._listeners === null) {\n          this._listeners = {};\n        }\n        var isarray = typeof types !== 'string' && typeof types.join === 'function';\n        if (types = (isarray ? types.join(' ') : types).match(/\\S+/g)) {\n          for (var i = 0; i < types.length; i++) {\n            var type = types[i];\n            this._listeners[type] = this._listeners[type] || [];\n            this._listeners[type].push(listener);\n            if (typeof callback === 'function') {\n              callback(this, type, true);\n            }\n          }\n        }\n        return this;\n      };\n\n      prototype.off = function(types, listener) {\n        if (!types || !types.length || typeof listener !== 'function') {\n          return this;\n        }\n        if (this._listeners === null) {\n          return this;\n        }\n        var isarray = typeof types !== 'string' && typeof types.join === 'function';\n        if (types = (isarray ? types.join(' ') : types).match(/\\S+/g)) {\n          for (var i = 0; i < types.length; i++) {\n            var type = types[i], all = this._listeners[type], index;\n            if (all && (index = all.indexOf(listener)) >= 0) {\n              all.splice(index, 1);\n              if (!all.length) {\n                delete this._listeners[type];\n              }\n              if (typeof callback === 'function') {\n                callback(this, type, false);\n              }\n            }\n          }\n        }\n        return this;\n      };\n\n      prototype.listeners = function(type) {\n        return this._listeners && this._listeners[type];\n      };\n\n      prototype.publish = function(name, args) {\n        var listeners = this.listeners(name);\n        if (!listeners || !listeners.length) {\n          return 0;\n        }\n        for (var l = 0; l < listeners.length; l++) {\n          listeners[l].apply(this, args);\n        }\n        return listeners.length;\n      };\n\n      prototype.trigger = function(name, args) {\n        this.publish(name, args);\n        return this;\n      };\n\n    };\n\n    event(core.prototype, function(obj, name, on) {\n      obj._flag(name, on);\n    });\n\n    var iid = 0;\n\n    core._init(function() {\n      this._pin = new Pin(this);\n    });\n\n    core.prototype.matrix = function(relative) {\n      if (relative === true) {\n        return this._pin.relativeMatrix();\n      }\n      return this._pin.absoluteMatrix();\n    };\n\n    core.prototype.pin = function(a, b) {\n      if (typeof a === 'object') {\n        this._pin.set(a);\n        return this;\n\n      } else if (typeof a === 'string') {\n        if (typeof b === 'undefined') {\n          return this._pin.get(a);\n        } else {\n          this._pin.set(a, b);\n          return this;\n        }\n      } else if (typeof a === 'undefined') {\n        return this._pin;\n      }\n    };\n\n    function Pin(owner) {\n\n      this._owner = owner;\n      this._parent = null;\n\n      // relative to parent\n      this._relativeMatrix = new matrix();\n\n      // relative to stage\n      this._absoluteMatrix = new matrix();\n\n      this.reset();\n    }\n    Pin.prototype.reset = function() {\n\n      this._textureAlpha = 1;\n      this._alpha = 1;\n\n      this._width = 0;\n      this._height = 0;\n\n      this._scaleX = 1;\n      this._scaleY = 1;\n      this._skewX = 0;\n      this._skewY = 0;\n      this._rotation = 0;\n\n      // scale/skew/rotate center\n      this._pivoted = false;\n      this._pivotX = null;\n      this._pivotY = null;\n\n      // self pin point\n      this._handled = false;\n      this._handleX = 0;\n      this._handleY = 0;\n\n      // parent pin point\n      this._aligned = false;\n      this._alignX = 0;\n      this._alignY = 0;\n\n      // as seen by parent px\n      this._offsetX = 0;\n      this._offsetY = 0;\n\n      this._boxX = 0;\n      this._boxY = 0;\n      this._boxWidth = this._width;\n      this._boxHeight = this._height;\n\n      // TODO: also set for owner\n      this._ts_translate = ++iid;\n      this._ts_transform = ++iid;\n      this._ts_matrix = ++iid;\n    };\n\n    Pin.prototype._update = function() {\n      this._parent = this._owner._parent && this._owner._parent._pin;\n\n      // if handled and transformed then be translated\n      if (this._handled && this._mo_handle != this._ts_transform) {\n        this._mo_handle = this._ts_transform;\n        this._ts_translate = ++iid;\n      }\n\n      if (this._aligned && this._parent\n          && this._mo_align != this._parent._ts_transform) {\n        this._mo_align = this._parent._ts_transform;\n        this._ts_translate = ++iid;\n      }\n\n      return this;\n    };\n\n    Pin.prototype.toString = function() {\n      return this._owner + ' (' + (this._parent ? this._parent._owner : null) + ')';\n    };\n\n    // TODO: ts fields require refactoring\n\n    Pin.prototype.absoluteMatrix = function() {\n      this._update();\n      var ts = Math.max(\n        this._ts_transform,\n        this._ts_translate,\n        this._parent ? this._parent._ts_matrix : 0\n      );\n      if (this._mo_abs == ts) {\n        return this._absoluteMatrix;\n      }\n      this._mo_abs = ts;\n\n      var abs = this._absoluteMatrix;\n      abs.reset(this.relativeMatrix());\n\n      this._parent && abs.concat(this._parent._absoluteMatrix);\n\n      this._ts_matrix = ++iid;\n\n      return abs;\n    };\n\n    Pin.prototype.relativeMatrix = function() {\n      this._update();\n      var ts = Math.max(this._ts_transform, this._ts_translate,\n          this._parent ? this._parent._ts_transform : 0);\n      if (this._mo_rel == ts) {\n        return this._relativeMatrix;\n      }\n      this._mo_rel = ts;\n\n      var rel = this._relativeMatrix;\n\n      rel.identity();\n      if (this._pivoted) {\n        rel.translate(-this._pivotX * this._width, -this._pivotY * this._height);\n      }\n      rel.scale(this._scaleX, this._scaleY);\n      rel.skew(this._skewX, this._skewY);\n      rel.rotate(this._rotation);\n      if (this._pivoted) {\n        rel.translate(this._pivotX * this._width, this._pivotY * this._height);\n      }\n\n      // calculate effective box\n      if (this._pivoted) {\n        // origin\n        this._boxX = 0;\n        this._boxY = 0;\n        this._boxWidth = this._width;\n        this._boxHeight = this._height;\n\n      } else {\n        // aabb\n        var p, q;\n        if (rel.a > 0 && rel.c > 0 || rel.a < 0 && rel.c < 0) {\n          p = 0, q = rel.a * this._width + rel.c * this._height;\n        } else {\n          p = rel.a * this._width, q = rel.c * this._height;\n        }\n        if (p > q) {\n          this._boxX = q;\n          this._boxWidth = p - q;\n        } else {\n          this._boxX = p;\n          this._boxWidth = q - p;\n        }\n        if (rel.b > 0 && rel.d > 0 || rel.b < 0 && rel.d < 0) {\n          p = 0, q = rel.b * this._width + rel.d * this._height;\n        } else {\n          p = rel.b * this._width, q = rel.d * this._height;\n        }\n        if (p > q) {\n          this._boxY = q;\n          this._boxHeight = p - q;\n        } else {\n          this._boxY = p;\n          this._boxHeight = q - p;\n        }\n      }\n\n      this._x = this._offsetX;\n      this._y = this._offsetY;\n\n      this._x -= this._boxX + this._handleX * this._boxWidth;\n      this._y -= this._boxY + this._handleY * this._boxHeight;\n\n      if (this._aligned && this._parent) {\n        this._parent.relativeMatrix();\n        this._x += this._alignX * this._parent._width;\n        this._y += this._alignY * this._parent._height;\n      }\n\n      rel.translate(this._x, this._y);\n\n      return this._relativeMatrix;\n    };\n\n    Pin.prototype.get = function(key) {\n      if (typeof getters[key] === 'function') {\n        return getters[key](this);\n      }\n    };\n\n    // TODO: Use defineProperty instead? What about multi-field pinning?\n    Pin.prototype.set = function(a, b) {\n      if (typeof a === 'string') {\n        if (typeof setters[a] === 'function' && typeof b !== 'undefined') {\n          setters[a](this, b);\n        }\n      } else if (typeof a === 'object') {\n        for (b in a) {\n          if (typeof setters[b] === 'function' && typeof a[b] !== 'undefined') {\n            setters[b](this, a[b], a);\n          }\n        }\n      }\n      if (this._owner) {\n        this._owner._ts_pin = ++iid;\n        this._owner.touch();\n      }\n      return this;\n    };\n\n    var getters = {\n      alpha : function(pin) {\n        return pin._alpha;\n      },\n\n      textureAlpha : function(pin) {\n        return pin._textureAlpha;\n      },\n\n      width : function(pin) {\n        return pin._width;\n      },\n\n      height : function(pin) {\n        return pin._height;\n      },\n\n      boxWidth : function(pin) {\n        return pin._boxWidth;\n      },\n\n      boxHeight : function(pin) {\n        return pin._boxHeight;\n      },\n\n      // scale : function(pin) {\n      // },\n\n      scaleX : function(pin) {\n        return pin._scaleX;\n      },\n\n      scaleY : function(pin) {\n        return pin._scaleY;\n      },\n\n      // skew : function(pin) {\n      // },\n\n      skewX : function(pin) {\n        return pin._skewX;\n      },\n\n      skewY : function(pin) {\n        return pin._skewY;\n      },\n\n      rotation : function(pin) {\n        return pin._rotation;\n      },\n\n      // pivot : function(pin) {\n      // },\n\n      pivotX : function(pin) {\n        return pin._pivotX;\n      },\n\n      pivotY : function(pin) {\n        return pin._pivotY;\n      },\n\n      // offset : function(pin) {\n      // },\n\n      offsetX : function(pin) {\n        return pin._offsetX;\n      },\n\n      offsetY : function(pin) {\n        return pin._offsetY;\n      },\n\n      // align : function(pin) {\n      // },\n\n      alignX : function(pin) {\n        return pin._alignX;\n      },\n\n      alignY : function(pin) {\n        return pin._alignY;\n      },\n\n      // handle : function(pin) {\n      // },\n\n      handleX : function(pin) {\n        return pin._handleX;\n      },\n\n      handleY : function(pin) {\n        return pin._handleY;\n      }\n    };\n\n    var setters = {\n      alpha : function(pin, value) {\n        pin._alpha = value;\n      },\n\n      textureAlpha : function(pin, value) {\n        pin._textureAlpha = value;\n      },\n\n      width : function(pin, value) {\n        pin._width_ = value;\n        pin._width = value;\n        pin._ts_transform = ++iid;\n      },\n\n      height : function(pin, value) {\n        pin._height_ = value;\n        pin._height = value;\n        pin._ts_transform = ++iid;\n      },\n\n      scale : function(pin, value) {\n        pin._scaleX = value;\n        pin._scaleY = value;\n        pin._ts_transform = ++iid;\n      },\n\n      scaleX : function(pin, value) {\n        pin._scaleX = value;\n        pin._ts_transform = ++iid;\n      },\n\n      scaleY : function(pin, value) {\n        pin._scaleY = value;\n        pin._ts_transform = ++iid;\n      },\n\n      skew : function(pin, value) {\n        pin._skewX = value;\n        pin._skewY = value;\n        pin._ts_transform = ++iid;\n      },\n\n      skewX : function(pin, value) {\n        pin._skewX = value;\n        pin._ts_transform = ++iid;\n      },\n\n      skewY : function(pin, value) {\n        pin._skewY = value;\n        pin._ts_transform = ++iid;\n      },\n\n      rotation : function(pin, value) {\n        pin._rotation = value;\n        pin._ts_transform = ++iid;\n      },\n\n      pivot : function(pin, value) {\n        pin._pivotX = value;\n        pin._pivotY = value;\n        pin._pivoted = true;\n        pin._ts_transform = ++iid;\n      },\n\n      pivotX : function(pin, value) {\n        pin._pivotX = value;\n        pin._pivoted = true;\n        pin._ts_transform = ++iid;\n      },\n\n      pivotY : function(pin, value) {\n        pin._pivotY = value;\n        pin._pivoted = true;\n        pin._ts_transform = ++iid;\n      },\n\n      offset : function(pin, value) {\n        pin._offsetX = value;\n        pin._offsetY = value;\n        pin._ts_translate = ++iid;\n      },\n\n      offsetX : function(pin, value) {\n        pin._offsetX = value;\n        pin._ts_translate = ++iid;\n      },\n\n      offsetY : function(pin, value) {\n        pin._offsetY = value;\n        pin._ts_translate = ++iid;\n      },\n\n      align : function(pin, value) {\n        this.alignX(pin, value);\n        this.alignY(pin, value);\n      },\n\n      alignX : function(pin, value) {\n        pin._alignX = value;\n        pin._aligned = true;\n        pin._ts_translate = ++iid;\n\n        this.handleX(pin, value);\n      },\n\n      alignY : function(pin, value) {\n        pin._alignY = value;\n        pin._aligned = true;\n        pin._ts_translate = ++iid;\n\n        this.handleY(pin, value);\n      },\n\n      handle : function(pin, value) {\n        this.handleX(pin, value);\n        this.handleY(pin, value);\n      },\n\n      handleX : function(pin, value) {\n        pin._handleX = value;\n        pin._handled = true;\n        pin._ts_translate = ++iid;\n      },\n\n      handleY : function(pin, value) {\n        pin._handleY = value;\n        pin._handled = true;\n        pin._ts_translate = ++iid;\n      },\n\n      resizeMode : function(pin, value, all) {\n        if (all) {\n          if (value == 'in') {\n            value = 'in-pad';\n          } else if (value == 'out') {\n            value = 'out-crop';\n          }\n          scaleTo(pin, all.resizeWidth, all.resizeHeight, value);\n        }\n      },\n\n      resizeWidth : function(pin, value, all) {\n        if (!all || !all.resizeMode) {\n          scaleTo(pin, value, null);\n        }\n      },\n\n      resizeHeight : function(pin, value, all) {\n        if (!all || !all.resizeMode) {\n          scaleTo(pin, null, value);\n        }\n      },\n\n      scaleMode : function(pin, value, all) {\n        if (all) {\n          scaleTo(pin, all.scaleWidth, all.scaleHeight, value);\n        }\n      },\n\n      scaleWidth : function(pin, value, all) {\n        if (!all || !all.scaleMode) {\n          scaleTo(pin, value, null);\n        }\n      },\n\n      scaleHeight : function(pin, value, all) {\n        if (!all || !all.scaleMode) {\n          scaleTo(pin, null, value);\n        }\n      },\n\n      matrix : function(pin, value) {\n        this.scaleX(pin, value.a);\n        this.skewX(pin, value.c / value.d);\n        this.skewY(pin, value.b / value.a);\n        this.scaleY(pin, value.d);\n        this.offsetX(pin, value.e);\n        this.offsetY(pin, value.f);\n        this.rotation(pin, 0);\n      }\n    };\n\n    function scaleTo(pin, width, height, mode) {\n      var w = typeof width === 'number';\n      var h = typeof height === 'number';\n      var m = typeof mode === 'string';\n      pin._ts_transform = ++iid;\n      if (w) {\n        pin._scaleX = width / pin._width_;\n        pin._width = pin._width_;\n      }\n      if (h) {\n        pin._scaleY = height / pin._height_;\n        pin._height = pin._height_;\n      }\n      if (w && h && m) {\n        if (mode == 'out' || mode == 'out-crop') {\n          pin._scaleX = pin._scaleY = Math.max(pin._scaleX, pin._scaleY);\n        } else if (mode == 'in' || mode == 'in-pad') {\n          pin._scaleX = pin._scaleY = Math.min(pin._scaleX, pin._scaleY);\n        }\n        if (mode == 'out-crop' || mode == 'in-pad') {\n          pin._width = width / pin._scaleX;\n          pin._height = height / pin._scaleY;\n        }\n      }\n    }\n    core.prototype.scaleTo = function(a, b, c) {\n      if (typeof a === 'object')\n        c = b, b = a.y, a = a.x;\n      scaleTo(this._pin, a, b, c);\n      return this;\n    };\n\n    // Used by Tween class\n    Pin._add_shortcuts = function(Class) {\n      Class.prototype.size = function(w, h) {\n        this.pin('width', w);\n        this.pin('height', h);\n        return this;\n      };\n\n      Class.prototype.width = function(w) {\n        if (typeof w === 'undefined') {\n          return this.pin('width');\n        }\n        this.pin('width', w);\n        return this;\n      };\n\n      Class.prototype.height = function(h) {\n        if (typeof h === 'undefined') {\n          return this.pin('height');\n        }\n        this.pin('height', h);\n        return this;\n      };\n\n      Class.prototype.offset = function(a, b) {\n        if (typeof a === 'object')\n          b = a.y, a = a.x;\n        this.pin('offsetX', a);\n        this.pin('offsetY', b);\n        return this;\n      };\n\n      Class.prototype.rotate = function(a) {\n        this.pin('rotation', a);\n        return this;\n      };\n\n      Class.prototype.skew = function(a, b) {\n        if (typeof a === 'object')\n          b = a.y, a = a.x;\n        else if (typeof b === 'undefined')\n          b = a;\n        this.pin('skewX', a);\n        this.pin('skewY', b);\n        return this;\n      };\n\n      Class.prototype.scale = function(a, b) {\n        if (typeof a === 'object')\n          b = a.y, a = a.x;\n        else if (typeof b === 'undefined')\n          b = a;\n        this.pin('scaleX', a);\n        this.pin('scaleY', b);\n        return this;\n      };\n\n      Class.prototype.alpha = function(a, ta) {\n        this.pin('alpha', a);\n        if (typeof ta !== 'undefined') {\n          this.pin('textureAlpha', ta);\n        }\n        return this;\n      };\n    };\n\n    Pin._add_shortcuts(core);\n\n    var pin = Pin;\n\n    core.prototype._textures = null;\n    core.prototype._alpha = 1;\n\n    core.prototype.render = function(context) {\n      if (!this._visible) {\n        return;\n      }\n      stats.node++;\n\n      var m = this.matrix();\n      context.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);\n\n      // move this elsewhere!\n      this._alpha = this._pin._alpha * (this._parent ? this._parent._alpha : 1);\n      var alpha = this._pin._textureAlpha * this._alpha;\n\n      if (context.globalAlpha != alpha) {\n        context.globalAlpha = alpha;\n      }\n\n      if (this._textures !== null) {\n        for (var i = 0, n = this._textures.length; i < n; i++) {\n          this._textures[i].draw(context);\n        }\n      }\n\n      if (context.globalAlpha != this._alpha) {\n        context.globalAlpha = this._alpha;\n      }\n\n      var child, next = this._first;\n      while (child = next) {\n        next = child._next;\n        child.render(context);\n      }\n    };\n\n    core.prototype._tickBefore = null;\n    core.prototype._tickAfter = null;\n    core.prototype.MAX_ELAPSE = Infinity;\n\n    core.prototype._tick = function(elapsed, now, last) {\n      if (!this._visible) {\n        return;\n      }\n\n      if (elapsed > this.MAX_ELAPSE) {\n        elapsed = this.MAX_ELAPSE;\n      }\n\n      var ticked = false;\n\n      if (this._tickBefore !== null) {\n        for (var i = 0; i < this._tickBefore.length; i++) {\n          stats.tick++;\n          var tickFn = this._tickBefore[i];\n          ticked = tickFn.call(this, elapsed, now, last) === true || ticked;\n        }\n      }\n\n      var child, next = this._first;\n      while (child = next) {\n        next = child._next;\n        if (child._flag('_tick')) {\n          ticked = child._tick(elapsed, now, last) === true ? true : ticked;\n        }\n      }\n\n      if (this._tickAfter !== null) {\n        for (var i = 0; i < this._tickAfter.length; i++) {\n          stats.tick++;\n          var tickFn = this._tickAfter[i];\n          ticked = tickFn.call(this, elapsed, now, last) === true || ticked;\n        }\n      }\n\n      return ticked;\n    };\n\n    core.prototype.tick = function(ticker, before) {\n      if (typeof ticker !== 'function') {\n        return;\n      }\n      if (before) {\n        if (this._tickBefore === null) {\n          this._tickBefore = [];\n        }\n        this._tickBefore.push(ticker);\n      } else {\n        if (this._tickAfter === null) {\n          this._tickAfter = [];\n        }\n        this._tickAfter.push(ticker);\n      }\n      this._flag('_tick', this._tickAfter !== null && this._tickAfter.length > 0\n          || this._tickBefore !== null && this._tickBefore.length > 0);\n    };\n\n    core.prototype.untick = function(ticker) {\n      if (typeof ticker !== 'function') {\n        return;\n      }\n      var i;\n      if (this._tickBefore !== null && (i = this._tickBefore.indexOf(ticker)) >= 0) {\n        this._tickBefore.splice(i, 1);\n      }\n      if (this._tickAfter !== null && (i = this._tickAfter.indexOf(ticker)) >= 0) {\n        this._tickAfter.splice(i, 1);\n      }\n    };\n\n    core.prototype.timeout = function(fn, time) {\n      this.setTimeout(fn, time);\n    };\n\n    core.prototype.setTimeout = function(fn, time) {\n      function timer(t) {\n        if ((time -= t) < 0) {\n          this.untick(timer);\n          fn.call(this);\n        } else {\n          return true;\n        }\n      }\n      this.tick(timer);\n      return timer;\n    };\n\n    core.prototype.clearTimeout = function(timer) {\n      this.untick(timer);\n    };\n\n    Root._super = core;\n    Root.prototype = create(Root._super.prototype);\n\n    core.root = function(request, render) {\n      return new Root(request, render);\n    };\n\n    function Root(request, render) {\n      Root._super.call(this);\n      this.label('Root');\n\n      var paused = true;\n      var stopped = true;\n\n      var self = this;\n      var lastTime = 0;\n      var loop = function(now) {\n        if (paused === true || stopped === true) {\n          return;\n        }\n\n        stats.tick = stats.node = stats.draw = 0;\n\n        var last = lastTime || now;\n        var elapsed = now - last;\n        lastTime = now;\n\n        var ticked = self._tick(elapsed, now, last);\n        if (self._mo_touch != self._ts_touch) {\n          self._mo_touch = self._ts_touch;\n          render(self);\n          request(loop);\n        } else if (ticked) {\n          request(loop);\n        } else {\n          paused = true;\n        }\n\n        stats.fps = elapsed ? 1000 / elapsed : 0;\n      };\n\n      this.start = function() {\n        stopped = false;\n        return this.resume();\n      };\n\n      this.resume = function() {\n        if (paused) {\n          this.publish('resume');\n          paused = false;\n          request(loop);\n        }\n        return this;\n      };\n\n      this.pause = function() {\n        if (!paused) {\n          this.publish('pause');\n        }\n        paused = true;\n        return this;\n      };\n\n      this.touch_root = this.touch;\n      this.touch = function() {\n        this.resume();\n        return this.touch_root();\n      };\n      this.stop = function() {\n        stopped = true;\n        return this;\n      };\n    }\n    Root.prototype.background = function(color) {\n      // to be implemented by loaders\n      return this;\n    };\n\n    Root.prototype.viewport = function(width, height, ratio) {\n      if (typeof width === 'undefined') {\n        return extend({}, this._viewport);\n      }\n      this._viewport = {\n        width : width,\n        height : height,\n        ratio : ratio || 1\n      };\n      this.viewbox();\n      var data = extend({}, this._viewport);\n      this.visit({\n        start : function(node) {\n          if (!node._flag('viewport')) {\n            return true;\n          }\n          node.publish('viewport', [ data ]);\n        }\n      });\n      return this;\n    };\n\n    // TODO: static/fixed viewbox\n    Root.prototype.viewbox = function(width, height, mode) {\n      if (typeof width === 'number' && typeof height === 'number') {\n        this._viewbox = {\n          width : width,\n          height : height,\n          mode : /^(in|out|in-pad|out-crop)$/.test(mode) ? mode : 'in-pad'\n        };\n      }\n\n      var box = this._viewbox;\n      var size = this._viewport;\n      if (size && box) {\n        this.pin({\n          width : box.width,\n          height : box.height\n        });\n        this.scaleTo(size.width, size.height, box.mode);\n      } else if (size) {\n        this.pin({\n          width : size.width,\n          height : size.height\n        });\n      }\n\n      return this;\n    };\n\n    var lib = core;\n    var Matrix = matrix;\n    var Texture = texture;\n    lib.Matrix = Matrix;\n    lib.Texture = Texture;\n\n    core.canvas = function(type, attributes, drawFn) {\n      if (typeof type === 'string') {\n        if (typeof attributes === 'object') ; else {\n          if (typeof attributes === 'function') {\n            drawFn = attributes;\n          }\n          attributes = {};\n        }\n      } else {\n        if (typeof type === 'function') {\n          drawFn = type;\n        }\n        attributes = {};\n        type = '2d';\n      }\n\n      var canvas = document.createElement('canvas');\n      var context = canvas.getContext(type, attributes);\n      var texture$1 = new texture(canvas);\n\n      texture$1.context = function() {\n        return context;\n      };\n\n      texture$1.size = function(width, height, ratio) {\n        ratio = ratio || 1;\n        canvas.width = width * ratio;\n        canvas.height = height * ratio;\n        this.src(canvas, ratio);\n        return this;\n      };\n\n      texture$1.canvas = function(fn) {\n        if (typeof fn === 'function') {\n          fn.call(this, context);\n        } else if (typeof fn === 'undefined' && typeof drawFn === 'function') {\n          drawFn.call(this, context);\n        }\n        return this;\n      };\n\n      if (typeof drawFn === 'function') {\n        drawFn.call(texture$1, context);\n      }\n\n      return texture$1;\n    };\n\n    var repeat = function(img, owidth, oheight, stretch, inner, insert) {\n\n      var width = img.width;\n      var height = img.height;\n      var left = img.left;\n      var right = img.right;\n      var top = img.top;\n      var bottom = img.bottom;\n\n      left = typeof left === 'number' && left === left ? left : 0;\n      right = typeof right === 'number' && right === right ? right : 0;\n      top = typeof top === 'number' && top === top ? top : 0;\n      bottom = typeof bottom === 'number' && bottom === bottom ? bottom : 0;\n\n      width = width - left - right;\n      height = height - top - bottom;\n\n      if (!inner) {\n        owidth = Math.max(owidth - left - right, 0);\n        oheight = Math.max(oheight - top - bottom, 0);\n      }\n\n      var i = 0;\n\n      if (top > 0 && left > 0)\n        insert(i++, 0, 0, left, top, 0, 0, left, top);\n      if (bottom > 0 && left > 0)\n        insert(i++, 0, height + top, left, bottom, 0, oheight + top, left, bottom);\n      if (top > 0 && right > 0)\n        insert(i++, width + left, 0, right, top, owidth + left, 0, right, top);\n      if (bottom > 0 && right > 0)\n        insert(i++, width + left, height + top, right, bottom, owidth + left,\n            oheight + top, right, bottom);\n\n      if (stretch) {\n        if (top > 0)\n          insert(i++, left, 0, width, top, left, 0, owidth, top);\n        if (bottom > 0)\n          insert(i++, left, height + top, width, bottom, left, oheight + top,\n              owidth, bottom);\n        if (left > 0)\n          insert(i++, 0, top, left, height, 0, top, left, oheight);\n        if (right > 0)\n          insert(i++, width + left, top, right, height, owidth + left, top, right,\n              oheight);\n        // center\n        insert(i++, left, top, width, height, left, top, owidth, oheight);\n\n      } else { // tile\n        var l = left, r = owidth, w;\n        while (r > 0) {\n          w = Math.min(width, r), r -= width;\n          var t = top, b = oheight, h;\n          while (b > 0) {\n            h = Math.min(height, b), b -= height;\n            insert(i++, left, top, w, h, l, t, w, h);\n            if (r <= 0) {\n              if (left)\n                insert(i++, 0, top, left, h, 0, t, left, h);\n              if (right)\n                insert(i++, width + left, top, right, h, l + w, t, right, h);\n            }\n            t += h;\n          }\n          if (top)\n            insert(i++, left, 0, w, top, l, 0, w, top);\n          if (bottom)\n            insert(i++, left, height + top, w, bottom, l, t, w, bottom);\n          l += w;\n        }\n      }\n\n      return i;\n    };\n\n    var image = Image$1;\n\n    core.image = function(image) {\n      var img = new Image$1();\n      image && img.image(image);\n      return img;\n    };\n\n    Image$1._super = core;\n    Image$1.prototype = create(Image$1._super.prototype);\n\n    function Image$1() {\n      Image$1._super.call(this);\n      this.label('Image');\n      this._textures = [];\n      this._image = null;\n    }\n    /**\n     * @deprecated Use image\n     */\n    Image$1.prototype.setImage = function(a, b, c) {\n      return this.image(a, b, c);\n    };\n\n    Image$1.prototype.image = function(image) {\n      this._image = core.texture(image).one();\n      this.pin('width', this._image ? this._image.width : 0);\n      this.pin('height', this._image ? this._image.height : 0);\n      this._textures[0] = this._image.pipe();\n      this._textures.length = 1;\n      return this;\n    };\n\n    Image$1.prototype.tile = function(inner) {\n      this._repeat(false, inner);\n      return this;\n    };\n\n    Image$1.prototype.stretch = function(inner) {\n      this._repeat(true, inner);\n      return this;\n    };\n\n    Image$1.prototype._repeat = function(stretch, inner) {\n      var self = this;\n      this.untick(this._repeatTicker);\n      this.tick(this._repeatTicker = function() {\n        if (this._mo_stretch == this._pin._ts_transform) {\n          return;\n        }\n        this._mo_stretch = this._pin._ts_transform;\n        var width = this.pin('width');\n        var height = this.pin('height');\n        this._textures.length = repeat(this._image, width, height, stretch, inner,\n            insert);\n      });\n\n      function insert(i, sx, sy, sw, sh, dx, dy, dw, dh) {\n        var repeat = self._textures.length > i ? self._textures[i]\n            : self._textures[i] = self._image.pipe();\n        repeat.src(sx, sy, sw, sh);\n        repeat.dest(dx, dy, dw, dh);\n      }\n    };\n\n    core.anim = function(frames, fps) {\n      var anim = new Anim();\n      anim.frames(frames).gotoFrame(0);\n      fps && anim.fps(fps);\n      return anim;\n    };\n\n    Anim._super = core;\n    Anim.prototype = create(Anim._super.prototype);\n\n    // TODO: replace with atlas fps or texture time\n    core.Anim = {\n      FPS : 15\n    };\n\n    function Anim() {\n      Anim._super.call(this);\n      this.label('Anim');\n\n      this._textures = [];\n\n      this._fps = core.Anim.FPS;\n      this._ft = 1000 / this._fps;\n\n      this._time = -1;\n      this._repeat = 0;\n\n      this._index = 0;\n      this._frames = [];\n\n      var lastTime = 0;\n      this.tick(function(t, now, last) {\n        if (this._time < 0 || this._frames.length <= 1) {\n          return;\n        }\n\n        // ignore old elapsed\n        var ignore = lastTime != last;\n        lastTime = now;\n        if (ignore) {\n          return true;\n        }\n\n        this._time += t;\n        if (this._time < this._ft) {\n          return true;\n        }\n        var n = this._time / this._ft | 0;\n        this._time -= n * this._ft;\n        this.moveFrame(n);\n        if (this._repeat > 0 && (this._repeat -= n) <= 0) {\n          this.stop();\n          this._callback && this._callback();\n          return false;\n        }\n        return true;\n      }, false);\n    }\n    Anim.prototype.fps = function(fps) {\n      if (typeof fps === 'undefined') {\n        return this._fps;\n      }\n      this._fps = fps > 0 ? fps : core.Anim.FPS;\n      this._ft = 1000 / this._fps;\n      return this;\n    };\n\n    /**\n     * @deprecated Use frames\n     */\n    Anim.prototype.setFrames = function(a, b, c) {\n      return this.frames(a, b, c);\n    };\n\n    Anim.prototype.frames = function(frames) {\n      this._index = 0;\n      this._frames = core.texture(frames).array();\n      this.touch();\n      return this;\n    };\n\n    Anim.prototype.length = function() {\n      return this._frames ? this._frames.length : 0;\n    };\n\n    Anim.prototype.gotoFrame = function(frame, resize) {\n      this._index = math.rotate(frame, this._frames.length) | 0;\n      resize = resize || !this._textures[0];\n      this._textures[0] = this._frames[this._index];\n      if (resize) {\n        this.pin('width', this._textures[0].width);\n        this.pin('height', this._textures[0].height);\n      }\n      this.touch();\n      return this;\n    };\n\n    Anim.prototype.moveFrame = function(move) {\n      return this.gotoFrame(this._index + move);\n    };\n\n    Anim.prototype.repeat = function(repeat, callback) {\n      this._repeat = repeat * this._frames.length - 1;\n      this._callback = callback;\n      this.play();\n      return this;\n    };\n\n    Anim.prototype.play = function(frame) {\n      if (typeof frame !== 'undefined') {\n        this.gotoFrame(frame);\n        this._time = 0;\n      } else if (this._time < 0) {\n        this._time = 0;\n      }\n\n      this.touch();\n      return this;\n    };\n\n    Anim.prototype.stop = function(frame) {\n      this._time = -1;\n      if (typeof frame !== 'undefined') {\n        this.gotoFrame(frame);\n      }\n      return this;\n    };\n\n    core.string = function(frames) {\n      return new Str().frames(frames);\n    };\n\n    Str._super = core;\n    Str.prototype = create(Str._super.prototype);\n\n    function Str() {\n      Str._super.call(this);\n      this.label('String');\n      this._textures = [];\n    }\n    /**\n     * @deprecated Use frames\n     */\n    Str.prototype.setFont = function(a, b, c) {\n      return this.frames(a, b, c);\n    };\n\n    Str.prototype.frames = function(frames) {\n      this._textures = [];\n      if (typeof frames == 'string') {\n        frames = core.texture(frames);\n        this._item = function(value) {\n          return frames.one(value);\n        };\n      } else if (typeof frames === 'object') {\n        this._item = function(value) {\n          return frames[value];\n        };\n      } else if (typeof frames === 'function') {\n        this._item = frames;\n      }\n      return this;\n    };\n\n    /**\n     * @deprecated Use value\n     */\n    Str.prototype.setValue = function(a, b, c) {\n      return this.value(a, b, c);\n    };\n\n    Str.prototype.value = function(value) {\n      if (typeof value === 'undefined') {\n        return this._value;\n      }\n      if (this._value === value) {\n        return this;\n      }\n      this._value = value;\n\n      if (value === null) {\n        value = '';\n      } else if (typeof value !== 'string' && !is_1.array(value)) {\n        value = value.toString();\n      }\n\n      this._spacing = this._spacing || 0;\n\n      var width = 0, height = 0;\n      for (var i = 0; i < value.length; i++) {\n        var image = this._textures[i] = this._item(value[i]);\n        width += i > 0 ? this._spacing : 0;\n        image.dest(width, 0);\n        width = width + image.width;\n        height = Math.max(height, image.height);\n      }\n      this.pin('width', width);\n      this.pin('height', height);\n      this._textures.length = value.length;\n      return this;\n    };\n\n    core.row = function(align) {\n      return core.create().row(align).label('Row');\n    };\n\n    core.prototype.row = function(align) {\n      this.sequence('row', align);\n      return this;\n    };\n\n    core.column = function(align) {\n      return core.create().column(align).label('Row');\n    };\n\n    core.prototype.column = function(align) {\n      this.sequence('column', align);\n      return this;\n    };\n\n    core.sequence = function(type, align) {\n      return core.create().sequence(type, align).label('Sequence');\n    };\n\n    core.prototype.sequence = function(type, align) {\n\n      this._padding = this._padding || 0;\n      this._spacing = this._spacing || 0;\n\n      this.untick(this._layoutTiker);\n      this.tick(this._layoutTiker = function() {\n        if (this._mo_seq == this._ts_touch) {\n          return;\n        }\n        this._mo_seq = this._ts_touch;\n\n        var alignChildren = (this._mo_seqAlign != this._ts_children);\n        this._mo_seqAlign = this._ts_children;\n\n        var width = 0, height = 0;\n\n        var child, next = this.first(true);\n        var first = true;\n        while (child = next) {\n          next = child.next(true);\n\n          child.matrix(true);\n          var w = child.pin('boxWidth');\n          var h = child.pin('boxHeight');\n\n          if (type == 'column') {\n            !first && (height += this._spacing);\n            child.pin('offsetY') != height && child.pin('offsetY', height);\n            width = Math.max(width, w);\n            height = height + h;\n            alignChildren && child.pin('alignX', align);\n\n          } else if (type == 'row') {\n            !first && (width += this._spacing);\n            child.pin('offsetX') != width && child.pin('offsetX', width);\n            width = width + w;\n            height = Math.max(height, h);\n            alignChildren && child.pin('alignY', align);\n          }\n          first = false;\n        }\n        width += 2 * this._padding;\n        height += 2 * this._padding;\n        this.pin('width') != width && this.pin('width', width);\n        this.pin('height') != height && this.pin('height', height);\n      });\n      return this;\n    };\n\n    core.box = function() {\n      return core.create().box().label('Box');\n    };\n\n    core.prototype.box = function() {\n      this._padding = this._padding || 0;\n\n      this.untick(this._layoutTiker);\n      this.tick(this._layoutTiker = function() {\n        if (this._mo_box == this._ts_touch) {\n          return;\n        }\n        this._mo_box = this._ts_touch;\n\n        var width = 0, height = 0;\n        var child, next = this.first(true);\n        while (child = next) {\n          next = child.next(true);\n          child.matrix(true);\n          var w = child.pin('boxWidth');\n          var h = child.pin('boxHeight');\n          width = Math.max(width, w);\n          height = Math.max(height, h);\n        }\n        width += 2 * this._padding;\n        height += 2 * this._padding;\n        this.pin('width') != width && this.pin('width', width);\n        this.pin('height') != height && this.pin('height', height);\n      });\n      return this;\n    };\n\n    core.layer = function() {\n      return core.create().layer().label('Layer');\n    };\n\n    core.prototype.layer = function() {\n\n      this.untick(this._layoutTiker);\n      this.tick(this._layoutTiker = function() {\n        var parent = this.parent();\n        if (parent) {\n          var width = parent.pin('width');\n          if (this.pin('width') != width) {\n            this.pin('width', width);\n          }\n          var height = parent.pin('height');\n          if (this.pin('height') != height) {\n            this.pin('height', height);\n          }\n        }\n      }, true);\n      return this;\n    };\n\n    // TODO: move padding to pin\n    core.prototype.padding = function(pad) {\n      this._padding = pad;\n      return this;\n    };\n\n    core.prototype.spacing = function(space) {\n      this._spacing = space;\n      return this;\n    };\n\n    function _identity(x) {\n      return x;\n    }var _cache = {};\n    var _modes = {};\n    var _easings = {};\n\n    function Easing(token) {\n      if (typeof token === 'function') {\n        return token;\n      }\n      if (typeof token !== 'string') {\n        return _identity;\n      }\n      var fn = _cache[token];\n      if (fn) {\n        return fn;\n      }\n      var match = /^(\\w+)(-(in|out|in-out|out-in))?(\\((.*)\\))?$/i.exec(token);\n      if (!match || !match.length) {\n        return _identity;\n      }\n      var easing = _easings[match[1]];\n      var mode = _modes[match[3]];\n      var params = match[5];\n      if (easing && easing.fn) {\n        fn = easing.fn;\n      } else if (easing && easing.fc) {\n        fn = easing.fc.apply(easing.fc, params\n            && params.replace(/\\s+/, '').split(','));\n      } else {\n        fn = _identity;\n      }\n      if (mode) {\n        fn = mode.fn(fn);\n      }\n      // TODO: It can be a memory leak with different `params`.\n      _cache[token] = fn;\n      return fn;\n    }\n    Easing.add = function(data) {\n      // TODO: create a map of all { name-mode : data }\n      var names = (data.name || data.mode).split(/\\s+/);\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        if (name) {\n          (data.name ? _easings : _modes)[name] = data;\n        }\n      }\n    };\n\n    Easing.add({\n      mode : 'in',\n      fn : function(f) {\n        return f;\n      }\n    });\n\n    Easing.add({\n      mode : 'out',\n      fn : function(f) {\n        return function(t) {\n          return 1 - f(1 - t);\n        };\n      }\n    });\n\n    Easing.add({\n      mode : 'in-out',\n      fn : function(f) {\n        return function(t) {\n          return (t < 0.5) ? (f(2 * t) / 2) : (1 - f(2 * (1 - t)) / 2);\n        };\n      }\n    });\n\n    Easing.add({\n      mode : 'out-in',\n      fn : function(f) {\n        return function(t) {\n          return (t < 0.5) ? (1 - f(2 * (1 - t)) / 2) : (f(2 * t) / 2);\n        };\n      }\n    });\n\n    Easing.add({\n      name : 'linear',\n      fn : function(t) {\n        return t;\n      }\n    });\n\n    Easing.add({\n      name : 'quad',\n      fn : function(t) {\n        return t * t;\n      }\n    });\n\n    Easing.add({\n      name : 'cubic',\n      fn : function(t) {\n        return t * t * t;\n      }\n    });\n\n    Easing.add({\n      name : 'quart',\n      fn : function(t) {\n        return t * t * t * t;\n      }\n    });\n\n    Easing.add({\n      name : 'quint',\n      fn : function(t) {\n        return t * t * t * t * t;\n      }\n    });\n\n    Easing.add({\n      name : 'sin sine',\n      fn : function(t) {\n        return 1 - Math.cos(t * Math.PI / 2);\n      }\n    });\n\n    Easing.add({\n      name : 'exp expo',\n      fn : function(t) {\n        return t == 0 ? 0 : Math.pow(2, 10 * (t - 1));\n      }\n    });\n\n    Easing.add({\n      name : 'circle circ',\n      fn : function(t) {\n        return 1 - Math.sqrt(1 - t * t);\n      }\n    });\n\n    Easing.add({\n      name : 'bounce',\n      fn : function(t) {\n        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625\n            * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625\n            * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t\n            + .984375;\n      }\n    });\n\n    Easing.add({\n      name : 'poly',\n      fc : function(e) {\n        return function(t) {\n          return Math.pow(t, e);\n        };\n      }\n    });\n\n    Easing.add({\n      name : 'elastic',\n      fc : function(a, p) {\n        p = p || 0.45;\n        a = a || 1;\n        var s = p / (2 * Math.PI) * Math.asin(1 / a);\n        return function(t) {\n          return 1 + a * Math.pow(2, -10 * t)\n              * Math.sin((t - s) * (2 * Math.PI) / p);\n        };\n      }\n    });\n\n    Easing.add({\n      name : 'back',\n      fc : function(s) {\n        s = typeof s !== 'undefined' ? s : 1.70158;\n        return function(t) {\n          return t * t * ((s + 1) * t - s);\n        };\n      }\n    });\n\n    var easing = Easing;\n\n    core.prototype.tween = function(duration, delay, append) {\n      if (typeof duration !== 'number') {\n        append = duration, delay = 0, duration = 0;\n      } else if (typeof delay !== 'number') {\n        append = delay, delay = 0;\n      }\n\n      if (!this._tweens) {\n        this._tweens = [];\n        var ticktime = 0;\n        this.tick(function(elapsed, now, last) {\n          if (!this._tweens.length) {\n            return;\n          }\n\n          // ignore old elapsed\n          var ignore = ticktime != last;\n          ticktime = now;\n          if (ignore) {\n            return true;\n          }\n\n          var head = this._tweens[0];\n\n          var next = head.tick(this, elapsed, now, last);\n\n          if (next && head === this._tweens[0]) {\n            this._tweens.shift();\n          }\n\n          if (Array.isArray(next)) {\n            for (var i = 0; i < next.length; i++) {\n              try {\n                next[i].call(this);\n              } catch (e) {\n                console.log(e);\n              }\n            }\n          } else if (typeof next === 'object') {\n            this._tweens.unshift(next);\n          }\n\n          return true;\n        }, true);\n      }\n\n      this.touch();\n      if (!append) {\n        this._tweens.length = 0;\n      }\n      var tween = new Tween(this, duration, delay);\n      this._tweens.push(tween);\n      return tween;\n    };\n\n    function Tween(owner, duration, delay) {\n      this._end = {};\n      this._duration = duration || 400;\n      this._delay = delay || 0;\n\n      this._owner = owner;\n      this._time = 0;\n    }\n    Tween.prototype.tick = function(node, elapsed, now, last) {\n      this._time += elapsed;\n\n      if (this._time < this._delay) {\n        return;\n      }\n\n      var time = this._time - this._delay;\n\n      if (!this._start) {\n        this._start = {};\n        for ( var key in this._end) {\n          this._start[key] = this._owner.pin(key);\n        }\n      }\n\n      var p, over;\n      if (time < this._duration) {\n        p = time / this._duration;\n        over = false;\n      } else {\n        p = 1;\n        over = true;\n      }\n\n      if (typeof this._easing == 'function') {\n        p = this._easing(p);\n      }\n\n      var q = 1 - p;\n\n      for ( var key in this._end) {\n        this._owner.pin(key, this._start[key] * q + this._end[key] * p);\n      }\n\n      if (over) {\n        var actions = [this._hide, this._remove, this._done];\n        actions = actions.filter(function( element ) {\n          return typeof element === 'function';\n        });\n        return this._next || actions;\n      }\n    };\n\n    Tween.prototype.tween = function(duration, delay) {\n      return this._next = new Tween(this._owner, duration, delay);\n    };\n\n    Tween.prototype.duration = function(duration) {\n      this._duration = duration;\n      return this;\n    };\n\n    Tween.prototype.delay = function(delay) {\n      this._delay = delay;\n      return this;\n    };\n\n    Tween.prototype.ease = function(easing$1) {\n      this._easing = easing(easing$1);\n      return this;\n    };\n\n    Tween.prototype.done = function(fn) {\n      this._done = fn;\n      return this;\n    };\n\n    Tween.prototype.hide = function() {\n      this._hide = function() {\n        this.hide();\n      };\n      return this;\n    };\n\n    Tween.prototype.remove = function() {\n      this._remove = function() {\n        this.remove();\n      };\n      return this;\n    };\n\n    Tween.prototype.pin = function(a, b) {\n      if (typeof a === 'object') {\n        for ( var attr in a) {\n          pinning(this._owner, this._end, attr, a[attr]);\n        }\n      } else if (typeof b !== 'undefined') {\n        pinning(this._owner, this._end, a, b);\n      }\n      return this;\n    };\n\n    function pinning(node, map, key, value) {\n      if (typeof node.pin(key) === 'number') {\n        map[key] = value;\n      } else if (typeof node.pin(key + 'X') === 'number'\n          && typeof node.pin(key + 'Y') === 'number') {\n        map[key + 'X'] = value;\n        map[key + 'Y'] = value;\n      }\n    }\n\n    pin._add_shortcuts(Tween);\n\n    /**\n     * @deprecated Use .done(fn) instead.\n     */\n    Tween.prototype.then = function(fn) {\n      this.done(fn);\n      return this;\n    };\n\n    /**\n     * @deprecated NOOP\n     */\n    Tween.prototype.clear = function(forward) {\n      return this;\n    };\n\n    core._load(function(stage, elem) {\n      Mouse.subscribe(stage, elem);\n    });\n\n    // TODO: capture mouse\n\n    Mouse.CLICK = 'click';\n    Mouse.START = 'touchstart mousedown';\n    Mouse.MOVE = 'touchmove mousemove';\n    Mouse.END = 'touchend mouseup';\n    Mouse.CANCEL = 'touchcancel mousecancel';\n\n    Mouse.subscribe = function(stage, elem) {\n      if (stage.mouse) {\n        return;\n      }\n\n      stage.mouse = new Mouse(stage, elem);\n\n      // `click` events are synthesized from start/end events on same nodes\n      // `mousecancel` events are synthesized on blur or mouseup outside element\n\n      elem.addEventListener('touchstart', handleStart);\n      elem.addEventListener('touchend', handleEnd);\n      elem.addEventListener('touchmove', handleMove);\n      elem.addEventListener('touchcancel', handleCancel);\n\n      elem.addEventListener('mousedown', handleStart);\n      elem.addEventListener('mouseup', handleEnd);\n      elem.addEventListener('mousemove', handleMove);\n\n      document.addEventListener('mouseup', handleCancel);\n      window.addEventListener(\"blur\", handleCancel);\n\n      var clicklist = [], cancellist = [];\n\n      function handleStart(event) {\n        event.preventDefault();\n        stage.mouse.locate(event);\n        // false && console.log('Mouse Start: ' + event.type + ' ' + mouse);\n        stage.mouse.publish(event.type, event);\n\n        stage.mouse.lookup('click', clicklist);\n        stage.mouse.lookup('mousecancel', cancellist);\n      }\n\n      function handleMove(event) {\n        event.preventDefault();\n        stage.mouse.locate(event);\n        stage.mouse.publish(event.type, event);\n      }\n\n      function handleEnd(event) {\n        event.preventDefault();\n        // up/end location is not available, last one is used instead\n        // false && console.log('Mouse End: ' + event.type + ' ' + mouse);\n        stage.mouse.publish(event.type, event);\n\n        if (clicklist.length) {\n          // false && console.log('Mouse Click: ' + clicklist.length);\n          stage.mouse.publish('click', event, clicklist);\n        }\n        cancellist.length = 0;\n      }\n\n      function handleCancel(event) {\n        if (cancellist.length) {\n          // false && console.log('Mouse Cancel: ' + event.type);\n          stage.mouse.publish('mousecancel', event, cancellist);\n        }\n        clicklist.length = 0;\n      }\n    };\n\n    function Mouse(stage, elem) {\n      if (!(this instanceof Mouse)) {\n        // old-style mouse subscription\n        return;\n      }\n\n      var ratio = stage.viewport().ratio || 1;\n\n      stage.on('viewport', function(size) {\n        ratio = size.ratio || ratio;\n      });\n\n      this.x = 0;\n      this.y = 0;\n      this.toString = function() {\n        return (this.x | 0) + 'x' + (this.y | 0);\n      };\n      this.locate = function(event) {\n        locateElevent(elem, event, this);\n        this.x *= ratio;\n        this.y *= ratio;\n      };\n      this.lookup = function(type, collect) {\n        this.type = type;\n        this.root = stage;\n        this.event = null;\n        collect.length = 0;\n        this.collect = collect;\n\n        this.root.visit(this.visitor, this);\n      };\n      this.publish = function(type, event, targets) {\n        this.type = type;\n        this.root = stage;\n        this.event = event;\n        this.collect = false;\n        this.timeStamp = Date.now();\n\n        if (targets) {\n          while (targets.length)\n            if (this.visitor.end(targets.shift(), this))\n              break;\n          targets.length = 0;\n        } else {\n          this.root.visit(this.visitor, this);\n        }\n      };\n      this.visitor = {\n        reverse : true,\n        visible : true,\n        start : function(node, mouse) {\n          return !node._flag(mouse.type);\n        },\n        end : function(node, mouse) {\n          // mouse: event/collect, type, root\n          rel.raw = mouse.event;\n          rel.type = mouse.type;\n          rel.timeStamp = mouse.timeStamp;\n          rel.abs.x = mouse.x;\n          rel.abs.y = mouse.y;\n\n          var listeners = node.listeners(mouse.type);\n          if (!listeners) {\n            return;\n          }\n          node.matrix().inverse().map(mouse, rel);\n          if (!(node === mouse.root || node.attr('spy') || node.hitTest(rel))) {\n            return;\n          }\n          if (mouse.collect) {\n            mouse.collect.push(node);\n          }\n          if (mouse.event) {\n            var cancel = false;\n            for (var l = 0; l < listeners.length; l++) {\n              cancel = listeners[l].call(node, rel) ? true : cancel;\n            }\n            return cancel;\n          }\n        }\n      };\n    }\n    // TODO: define per mouse object with get-only x and y\n    var rel = {}, abs = {};\n\n    defineValue(rel, 'clone', function(obj) {\n      obj = obj || {}, obj.x = this.x, obj.y = this.y;\n      return obj;\n    });\n    defineValue(rel, 'toString', function() {\n      return (this.x | 0) + 'x' + (this.y | 0) + ' (' + this.abs + ')';\n    });\n    defineValue(rel, 'abs', abs);\n    defineValue(abs, 'clone', function(obj) {\n      obj = obj || {}, obj.x = this.x, obj.y = this.y;\n      return obj;\n    });\n    defineValue(abs, 'toString', function() {\n      return (this.x | 0) + 'x' + (this.y | 0);\n    });\n\n    function defineValue(obj, name, value) {\n      Object.defineProperty(obj, name, {\n        value : value\n      });\n    }\n\n    function locateElevent(el, ev, loc) {\n      // pageX/Y if available?\n      if (ev.touches && ev.touches.length) {\n        loc.x = ev.touches[0].clientX;\n        loc.y = ev.touches[0].clientY;\n      } else {\n        loc.x = ev.clientX;\n        loc.y = ev.clientY;\n      }\n      var rect = el.getBoundingClientRect();\n      loc.x -= rect.left;\n      loc.y -= rect.top;\n      loc.x -= el.clientLeft | 0;\n      loc.y -= el.clientTop | 0;\n      return loc;\n    }\n    var mouse = Mouse;\n\n    /**\n     * Default loader for web.\n     */\n\n\n\n    core._supported = (function() {\n      var elem = document.createElement('canvas');\n      return (elem.getContext && elem.getContext('2d')) ? true : false;\n    })();\n\n    window.addEventListener('load', function() {\n      if (core._supported) {\n        core.start();\n      }\n      // TODO if not supported\n    }, false);\n\n    core.config({\n      'app-loader' : AppLoader,\n      'image-loader' : ImageLoader\n    });\n\n    function AppLoader(app, configs) {\n      configs = configs || {};\n      var canvas = configs.canvas, context = null, full = false;\n      var width = 0, height = 0, ratio = 1;\n\n      if (typeof canvas === 'string') {\n        canvas = document.getElementById(canvas);\n      }\n\n      if (!canvas) {\n        canvas = document.getElementById('cutjs')\n            || document.getElementById('stage');\n      }\n\n      if (!canvas) {\n        full = true;\n        canvas = document.createElement('canvas');\n        canvas.style.position = 'absolute';\n        canvas.style.top = '0';\n        canvas.style.left = '0';\n\n        var body = document.body;\n        body.insertBefore(canvas, body.firstChild);\n      }\n\n      context = canvas.getContext('2d');\n\n      var devicePixelRatio = window.devicePixelRatio || 1;\n      var backingStoreRatio = context.webkitBackingStorePixelRatio\n          || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio\n          || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n      ratio = devicePixelRatio / backingStoreRatio;\n\n      var requestAnimationFrame = window.requestAnimationFrame\n          || window.msRequestAnimationFrame || window.mozRequestAnimationFrame\n          || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame\n          || function(callback) {\n            return window.setTimeout(callback, 1000 / 60);\n          };\n      var root = core.root(requestAnimationFrame, render);\n\n      function render() {\n        if (width > 0 && height > 0) {\n          context.setTransform(1, 0, 0, 1, 0, 0);\n          context.clearRect(0, 0, width, height);\n          root.render(context);\n        }\n      }\n\n      root.background = function(color) {\n        canvas.style.backgroundColor = color;\n        return this;\n      };\n\n      app(root, canvas);\n\n      // resize();\n      // window.addEventListener('resize', resize, false);\n      // window.addEventListener('orientationchange', resize, false);\n\n      var lastWidth = -1;\n      var lastHeight = -1;\n      (function resizeLoop() {\n        var width, height;\n        if (full) {\n          // screen.availWidth/Height?\n          width = (window.innerWidth > 0 ? window.innerWidth : screen.width);\n          height = (window.innerHeight > 0 ? window.innerHeight : screen.height);\n        } else {\n          width = canvas.clientWidth;\n          height = canvas.clientHeight;\n        }\n        if (lastWidth !== width || lastHeight !== height) {\n          lastWidth = width;\n          lastHeight = height;\n          resize();\n        }\n        requestAnimationFrame(resizeLoop);\n      })();\n\n      function resize() {\n\n        if (full) {\n          // screen.availWidth/Height?\n          width = (window.innerWidth > 0 ? window.innerWidth : screen.width);\n          height = (window.innerHeight > 0 ? window.innerHeight : screen.height);\n\n          canvas.style.width = width + 'px';\n          canvas.style.height = height + 'px';\n\n        } else {\n          width = canvas.clientWidth;\n          height = canvas.clientHeight;\n        }\n\n        width *= ratio;\n        height *= ratio;\n\n        if (canvas.width === width && canvas.height === height) {\n          return;\n        }\n\n        canvas.width = width;\n        canvas.height = height;\n\n        root.viewport(width, height, ratio);\n\n        render();\n      }\n    }\n\n    function ImageLoader(src, success, error) {\n      var image = new Image();\n      image.onload = function() {\n        success(image);\n      };\n      image.onerror = error;\n      image.src = src;\n    }\n\n    var web = createCommonjsModule(function (module) {\n    module.exports = lib;\n\n    module.exports.internal = {};\n\n\n    module.exports.internal.Image = image;\n\n\n\n\n    module.exports.Mouse = mouse;\n    module.exports.Math = math;\n    module.exports._extend = extend;\n    module.exports._create = create;\n    });\n\n    function testbed(opts, callback) {\n        if (typeof opts === 'function') {\n            callback = opts;\n            opts = null;\n        }\n        web(function (stage, canvas) {\n            stage.on(web.Mouse.START, function () {\n                window.focus();\n                // @ts-ignore\n                document.activeElement && document.activeElement.blur();\n                canvas.focus();\n            });\n            stage.MAX_ELAPSE = 1000 / 30;\n            // @ts-ignore\n            var testbed = {};\n            testbed.canvas = canvas;\n            var paused = false;\n            stage.on('resume', function () {\n                paused = false;\n                testbed._resume && testbed._resume();\n            });\n            stage.on('pause', function () {\n                paused = true;\n                testbed._pause && testbed._pause();\n            });\n            testbed.isPaused = function () {\n                return paused;\n            };\n            testbed.togglePause = function () {\n                paused ? testbed.resume() : testbed.pause();\n            };\n            testbed.pause = function () {\n                stage.pause();\n            };\n            testbed.resume = function () {\n                stage.resume();\n                testbed.focus();\n            };\n            testbed.focus = function () {\n                // @ts-ignore\n                document.activeElement && document.activeElement.blur();\n                canvas.focus();\n            };\n            testbed.width = 80;\n            testbed.height = 60;\n            testbed.x = 0;\n            testbed.y = -10;\n            testbed.scaleY = -1;\n            testbed.ratio = 16;\n            testbed.hz = 60;\n            testbed.speed = 1;\n            testbed.activeKeys = {};\n            testbed.background = '#222222';\n            testbed.findOne = function () {\n                // todo: implement\n                return null;\n            };\n            testbed.findAll = function () {\n                // todo: implement\n                return [];\n            };\n            var statusText = '';\n            var statusMap = {};\n            function statusSet(name, value) {\n                if (typeof value !== 'function' && typeof value !== 'object') {\n                    statusMap[name] = value;\n                }\n            }\n            function statusMerge(obj) {\n                // tslint:disable-next-line:no-for-in\n                for (var key in obj) {\n                    statusSet(key, obj[key]);\n                }\n            }\n            testbed.status = function (a, b) {\n                if (typeof b !== 'undefined') {\n                    statusSet(a, b);\n                }\n                else if (a && typeof a === 'object') {\n                    statusMerge(a);\n                }\n                else if (typeof a === 'string') {\n                    statusText = a;\n                }\n                testbed._status && testbed._status(statusText, statusMap);\n            };\n            testbed.info = function (text) {\n                testbed._info && testbed._info(text);\n            };\n            var lastDrawHash = \"\";\n            var drawHash = \"\";\n            (function () {\n                var drawingTexture = new web.Texture();\n                stage.append(web.image(drawingTexture));\n                var buffer = [];\n                stage.tick(function () {\n                    buffer.length = 0;\n                }, true);\n                drawingTexture.draw = function (ctx) {\n                    ctx.save();\n                    ctx.transform(1, 0, 0, testbed.scaleY, -testbed.x, -testbed.y);\n                    ctx.lineWidth = 2 / testbed.ratio;\n                    ctx.lineCap = 'round';\n                    for (var drawing = buffer.shift(); drawing; drawing = buffer.shift()) {\n                        drawing(ctx, testbed.ratio);\n                    }\n                    ctx.restore();\n                };\n                testbed.drawPoint = function (p, r, color) {\n                    buffer.push(function (ctx, ratio) {\n                        ctx.beginPath();\n                        ctx.arc(p.x, p.y, 5 / ratio, 0, 2 * Math.PI);\n                        ctx.strokeStyle = color;\n                        ctx.stroke();\n                    });\n                    drawHash += \"point\" + p.x + ',' + p.y + ',' + r + ',' + color;\n                };\n                testbed.drawCircle = function (p, r, color) {\n                    buffer.push(function (ctx) {\n                        ctx.beginPath();\n                        ctx.arc(p.x, p.y, r, 0, 2 * Math.PI);\n                        ctx.strokeStyle = color;\n                        ctx.stroke();\n                    });\n                    drawHash += \"circle\" + p.x + ',' + p.y + ',' + r + ',' + color;\n                };\n                testbed.drawSegment = function (a, b, color) {\n                    buffer.push(function (ctx) {\n                        ctx.beginPath();\n                        ctx.moveTo(a.x, a.y);\n                        ctx.lineTo(b.x, b.y);\n                        ctx.strokeStyle = color;\n                        ctx.stroke();\n                    });\n                    drawHash += \"segment\" + a.x + ',' + a.y + ',' + b.x + ',' + b.y + ',' + color;\n                };\n                testbed.drawPolygon = function (points, color) {\n                    if (!points || !points.length) {\n                        return;\n                    }\n                    buffer.push(function (ctx) {\n                        ctx.beginPath();\n                        ctx.moveTo(points[0].x, points[0].y);\n                        for (var i = 1; i < points.length; i++) {\n                            ctx.lineTo(points[i].x, points[i].y);\n                        }\n                        ctx.strokeStyle = color;\n                        ctx.closePath();\n                        ctx.stroke();\n                    });\n                    drawHash += \"segment\";\n                    for (var i = 1; i < points.length; i++) {\n                        drawHash += points[i].x + ',' + points[i].y + ',';\n                    }\n                    drawHash += color;\n                };\n                testbed.drawAABB = function (aabb, color) {\n                    buffer.push(function (ctx) {\n                        ctx.beginPath();\n                        ctx.moveTo(aabb.lowerBound.x, aabb.lowerBound.y);\n                        ctx.lineTo(aabb.upperBound.x, aabb.lowerBound.y);\n                        ctx.lineTo(aabb.upperBound.x, aabb.upperBound.y);\n                        ctx.lineTo(aabb.lowerBound.x, aabb.upperBound.y);\n                        ctx.strokeStyle = color;\n                        ctx.closePath();\n                        ctx.stroke();\n                    });\n                    drawHash += \"aabb\";\n                    drawHash += aabb.lowerBound.x + ',' + aabb.lowerBound.y + ',';\n                    drawHash += aabb.upperBound.x + ',' + aabb.upperBound.y + ',';\n                    drawHash += color;\n                };\n                testbed.color = function (r, g, b) {\n                    r = r * 256 | 0;\n                    g = g * 256 | 0;\n                    b = b * 256 | 0;\n                    return 'rgb(' + r + ', ' + g + ', ' + b + ')';\n                };\n            })();\n            var world = callback(testbed);\n            var viewer = new Viewer(world, testbed);\n            var lastX = 0;\n            var lastY = 0;\n            stage.tick(function (dt, t) {\n                // update camera position\n                if (lastX !== testbed.x || lastY !== testbed.y) {\n                    viewer.offset(-testbed.x, -testbed.y);\n                    lastX = testbed.x;\n                    lastY = testbed.y;\n                }\n            });\n            viewer.tick(function (dt, t) {\n                // call testbed step, if provided\n                if (typeof testbed.step === 'function') {\n                    testbed.step(dt, t);\n                }\n                if (targetBody) {\n                    testbed.drawSegment(targetBody.getPosition(), mouseMove, 'rgba(255,255,255,0.2)');\n                }\n                if (lastDrawHash !== drawHash) {\n                    lastDrawHash = drawHash;\n                    stage.touch();\n                }\n                drawHash = \"\";\n                return true;\n            });\n            // stage.empty();\n            stage.background(testbed.background);\n            stage.viewbox(testbed.width, testbed.height);\n            stage.pin('alignX', -0.5);\n            stage.pin('alignY', -0.5);\n            stage.prepend(viewer);\n            function findBody(point) {\n                var body;\n                var aabb = new AABB(point, point);\n                world.queryAABB(aabb, function (fixture) {\n                    if (body) {\n                        return;\n                    }\n                    if (!fixture.getBody().isDynamic() || !fixture.testPoint(point)) {\n                        return;\n                    }\n                    body = fixture.getBody();\n                    return true;\n                });\n                return body;\n            }\n            var mouseGround = world.createBody();\n            var mouseJoint;\n            var targetBody;\n            var mouseMove = { x: 0, y: 0 };\n            viewer.attr('spy', true).on(web.Mouse.START, function (point) {\n                point = { x: point.x, y: testbed.scaleY * point.y };\n                if (targetBody) {\n                    return;\n                }\n                var body = findBody(point);\n                if (!body) {\n                    return;\n                }\n                if (testbed.mouseForce) {\n                    targetBody = body;\n                }\n                else {\n                    mouseJoint = new MouseJoint({ maxForce: 1000 }, mouseGround, body, Vec2.clone(point));\n                    world.createJoint(mouseJoint);\n                }\n            }).on(web.Mouse.MOVE, function (point) {\n                point = { x: point.x, y: testbed.scaleY * point.y };\n                if (mouseJoint) {\n                    mouseJoint.setTarget(point);\n                }\n                mouseMove.x = point.x;\n                mouseMove.y = point.y;\n            }).on(web.Mouse.END, function (point) {\n                point = { x: point.x, y: testbed.scaleY * point.y };\n                if (mouseJoint) {\n                    world.destroyJoint(mouseJoint);\n                    mouseJoint = null;\n                }\n                if (targetBody) {\n                    var force = Vec2.sub(point, targetBody.getPosition());\n                    targetBody.applyForceToCenter(force.mul(testbed.mouseForce), true);\n                    targetBody = null;\n                }\n            }).on(web.Mouse.CANCEL, function (point) {\n                point = { x: point.x, y: testbed.scaleY * point.y };\n                if (mouseJoint) {\n                    world.destroyJoint(mouseJoint);\n                    mouseJoint = null;\n                }\n                if (targetBody) {\n                    targetBody = null;\n                }\n            });\n            window.addEventListener(\"keydown\", function (e) {\n                switch (e.keyCode) {\n                    case 'P'.charCodeAt(0):\n                        testbed.togglePause();\n                        break;\n                }\n            }, false);\n            var downKeys = {};\n            window.addEventListener(\"keydown\", function (e) {\n                var keyCode = e.keyCode;\n                downKeys[keyCode] = true;\n                updateActiveKeys(keyCode, true);\n                testbed.keydown && testbed.keydown(keyCode, String.fromCharCode(keyCode));\n            });\n            window.addEventListener(\"keyup\", function (e) {\n                var keyCode = e.keyCode;\n                downKeys[keyCode] = false;\n                updateActiveKeys(keyCode, false);\n                testbed.keyup && testbed.keyup(keyCode, String.fromCharCode(keyCode));\n            });\n            var activeKeys = testbed.activeKeys;\n            function updateActiveKeys(keyCode, down) {\n                var char = String.fromCharCode(keyCode);\n                if (/\\w/.test(char)) {\n                    activeKeys[char] = down;\n                }\n                activeKeys.right = downKeys[39] || activeKeys['D'];\n                activeKeys.left = downKeys[37] || activeKeys['A'];\n                activeKeys.up = downKeys[38] || activeKeys['W'];\n                activeKeys.down = downKeys[40] || activeKeys['S'];\n                activeKeys.fire = downKeys[32] || downKeys[13];\n            }\n        });\n    }\n    Viewer._super = web;\n    Viewer.prototype = web._create(Viewer._super.prototype);\n    function Viewer(world, opts) {\n        var _this = this;\n        Viewer._super.call(this);\n        this.label('Planck');\n        opts = opts || {};\n        this._options = {};\n        this._options.speed = opts.speed || 1;\n        this._options.hz = opts.hz || 60;\n        if (Math.abs(this._options.hz) < 1) {\n            this._options.hz = 1 / this._options.hz;\n        }\n        this._options.scaleY = opts.scaleY || -1;\n        this._options.ratio = opts.ratio || 16;\n        this._options.lineWidth = 2 / this._options.ratio;\n        this._world = world;\n        var timeStep = 1 / this._options.hz;\n        var elapsedTime = 0;\n        this.tick(function (dt) {\n            dt = dt * 0.001 * _this._options.speed;\n            elapsedTime += dt;\n            while (elapsedTime > timeStep) {\n                world.step(timeStep);\n                elapsedTime -= timeStep;\n            }\n            _this.renderWorld();\n            return true;\n        }, true);\n        world.on('remove-fixture', function (obj) {\n            obj.ui && obj.ui.remove();\n        });\n        world.on('remove-joint', function (obj) {\n            obj.ui && obj.ui.remove();\n        });\n    }\n    Viewer.prototype.renderWorld = function () {\n        var world = this._world;\n        var options = this._options;\n        var viewer = this;\n        for (var b = world.getBodyList(); b; b = b.getNext()) {\n            for (var f = b.getFixtureList(); f; f = f.getNext()) {\n                if (!f.ui) {\n                    if (f.render && f.render.stroke) {\n                        options.strokeStyle = f.render.stroke;\n                    }\n                    else if (b.render && b.render.stroke) {\n                        options.strokeStyle = b.render.stroke;\n                    }\n                    else if (b.isDynamic()) {\n                        options.strokeStyle = 'rgba(255,255,255,0.9)';\n                    }\n                    else if (b.isKinematic()) {\n                        options.strokeStyle = 'rgba(255,255,255,0.7)';\n                    }\n                    else if (b.isStatic()) {\n                        options.strokeStyle = 'rgba(255,255,255,0.5)';\n                    }\n                    if (f.render && f.render.fill) {\n                        options.fillStyle = f.render.fill;\n                    }\n                    else if (b.render && b.render.fill) {\n                        options.fillStyle = b.render.fill;\n                    }\n                    else {\n                        options.fillStyle = '';\n                    }\n                    var type = f.getType();\n                    var shape = f.getShape();\n                    if (type == 'circle') {\n                        f.ui = viewer.drawCircle(shape, options);\n                    }\n                    if (type == 'edge') {\n                        f.ui = viewer.drawEdge(shape, options);\n                    }\n                    if (type == 'polygon') {\n                        f.ui = viewer.drawPolygon(shape, options);\n                    }\n                    if (type == 'chain') {\n                        f.ui = viewer.drawChain(shape, options);\n                    }\n                    if (f.ui) {\n                        f.ui.appendTo(viewer);\n                    }\n                }\n                if (f.ui) {\n                    var p = b.getPosition();\n                    var r = b.getAngle();\n                    if (f.ui.__lastX !== p.x || f.ui.__lastY !== p.y || f.ui.__lastR !== r) {\n                        f.ui.__lastX = p.x;\n                        f.ui.__lastY = p.y;\n                        f.ui.__lastR = r;\n                        f.ui.offset(p.x, options.scaleY * p.y);\n                        f.ui.rotate(options.scaleY * r);\n                    }\n                }\n            }\n        }\n        for (var j = world.getJointList(); j; j = j.getNext()) {\n            var type = j.getType();\n            var a = j.getAnchorA();\n            var b = j.getAnchorB();\n            if (!j.ui) {\n                options.strokeStyle = 'rgba(255,255,255,0.2)';\n                j.ui = viewer.drawJoint(j, options);\n                j.ui.pin('handle', 0.5);\n                if (j.ui) {\n                    j.ui.appendTo(viewer);\n                }\n            }\n            if (j.ui) {\n                var cx = (a.x + b.x) * 0.5;\n                var cy = options.scaleY * (a.y + b.y) * 0.5;\n                var dx = a.x - b.x;\n                var dy = options.scaleY * (a.y - b.y);\n                var d = Math.sqrt(dx * dx + dy * dy);\n                j.ui.width(d);\n                j.ui.rotate(Math.atan2(dy, dx));\n                j.ui.offset(cx, cy);\n            }\n        }\n    };\n    Viewer.prototype.drawJoint = function (joint, options) {\n        var lw = options.lineWidth;\n        var ratio = options.ratio;\n        var length = 10;\n        var texture = web.canvas(function (ctx) {\n            this.size(length + 2 * lw, 2 * lw, ratio);\n            ctx.scale(ratio, ratio);\n            ctx.beginPath();\n            ctx.moveTo(lw, lw);\n            ctx.lineTo(lw + length, lw);\n            ctx.lineCap = 'round';\n            ctx.lineWidth = options.lineWidth;\n            ctx.strokeStyle = options.strokeStyle;\n            ctx.stroke();\n        });\n        var image = web.image(texture).stretch();\n        return image;\n    };\n    Viewer.prototype.drawCircle = function (shape, options) {\n        var lw = options.lineWidth;\n        var ratio = options.ratio;\n        var r = shape.m_radius;\n        var cx = r + lw;\n        var cy = r + lw;\n        var w = r * 2 + lw * 2;\n        var h = r * 2 + lw * 2;\n        var texture = web.canvas(function (ctx) {\n            this.size(w, h, ratio);\n            ctx.scale(ratio, ratio);\n            ctx.arc(cx, cy, r, 0, 2 * Math.PI);\n            if (options.fillStyle) {\n                ctx.fillStyle = options.fillStyle;\n                ctx.fill();\n            }\n            ctx.lineTo(cx, cy);\n            ctx.lineWidth = options.lineWidth;\n            ctx.strokeStyle = options.strokeStyle;\n            ctx.stroke();\n        });\n        var image = web.image(texture)\n            .offset(shape.m_p.x - cx, options.scaleY * shape.m_p.y - cy);\n        var node = web.create().append(image);\n        return node;\n    };\n    Viewer.prototype.drawEdge = function (edge, options) {\n        var lw = options.lineWidth;\n        var ratio = options.ratio;\n        var v1 = edge.m_vertex1;\n        var v2 = edge.m_vertex2;\n        var dx = v2.x - v1.x;\n        var dy = v2.y - v1.y;\n        var length = Math.sqrt(dx * dx + dy * dy);\n        var texture = web.canvas(function (ctx) {\n            this.size(length + 2 * lw, 2 * lw, ratio);\n            ctx.scale(ratio, ratio);\n            ctx.beginPath();\n            ctx.moveTo(lw, lw);\n            ctx.lineTo(lw + length, lw);\n            ctx.lineCap = 'round';\n            ctx.lineWidth = options.lineWidth;\n            ctx.strokeStyle = options.strokeStyle;\n            ctx.stroke();\n        });\n        var minX = Math.min(v1.x, v2.x);\n        var minY = Math.min(options.scaleY * v1.y, options.scaleY * v2.y);\n        var image = web.image(texture);\n        image.rotate(options.scaleY * Math.atan2(dy, dx));\n        image.offset(minX - lw, minY - lw);\n        var node = web.create().append(image);\n        return node;\n    };\n    Viewer.prototype.drawPolygon = function (shape, options) {\n        var lw = options.lineWidth;\n        var ratio = options.ratio;\n        var vertices = shape.m_vertices;\n        if (!vertices.length) {\n            return;\n        }\n        var minX = Infinity;\n        var minY = Infinity;\n        var maxX = -Infinity;\n        var maxY = -Infinity;\n        for (var i = 0; i < vertices.length; ++i) {\n            var v = vertices[i];\n            minX = Math.min(minX, v.x);\n            maxX = Math.max(maxX, v.x);\n            minY = Math.min(minY, options.scaleY * v.y);\n            maxY = Math.max(maxY, options.scaleY * v.y);\n        }\n        var width = maxX - minX;\n        var height = maxY - minY;\n        var texture = web.canvas(function (ctx) {\n            this.size(width + 2 * lw, height + 2 * lw, ratio);\n            ctx.scale(ratio, ratio);\n            ctx.beginPath();\n            for (var i = 0; i < vertices.length; ++i) {\n                var v = vertices[i];\n                var x = v.x - minX + lw;\n                var y = options.scaleY * v.y - minY + lw;\n                if (i == 0)\n                    ctx.moveTo(x, y);\n                else\n                    ctx.lineTo(x, y);\n            }\n            if (vertices.length > 2) {\n                ctx.closePath();\n            }\n            if (options.fillStyle) {\n                ctx.fillStyle = options.fillStyle;\n                ctx.fill();\n                ctx.closePath();\n            }\n            ctx.lineCap = 'round';\n            ctx.lineWidth = options.lineWidth;\n            ctx.strokeStyle = options.strokeStyle;\n            ctx.stroke();\n        });\n        var image = web.image(texture);\n        image.offset(minX - lw, minY - lw);\n        var node = web.create().append(image);\n        return node;\n    };\n    Viewer.prototype.drawChain = function (shape, options) {\n        var lw = options.lineWidth;\n        var ratio = options.ratio;\n        var vertices = shape.m_vertices;\n        if (!vertices.length) {\n            return;\n        }\n        var minX = Infinity;\n        var minY = Infinity;\n        var maxX = -Infinity;\n        var maxY = -Infinity;\n        for (var i = 0; i < vertices.length; ++i) {\n            var v = vertices[i];\n            minX = Math.min(minX, v.x);\n            maxX = Math.max(maxX, v.x);\n            minY = Math.min(minY, options.scaleY * v.y);\n            maxY = Math.max(maxY, options.scaleY * v.y);\n        }\n        var width = maxX - minX;\n        var height = maxY - minY;\n        var texture = web.canvas(function (ctx) {\n            this.size(width + 2 * lw, height + 2 * lw, ratio);\n            ctx.scale(ratio, ratio);\n            ctx.beginPath();\n            for (var i = 0; i < vertices.length; ++i) {\n                var v = vertices[i];\n                var x = v.x - minX + lw;\n                var y = options.scaleY * v.y - minY + lw;\n                if (i == 0)\n                    ctx.moveTo(x, y);\n                else\n                    ctx.lineTo(x, y);\n            }\n            // TODO: if loop\n            if (vertices.length > 2) ;\n            if (options.fillStyle) {\n                ctx.fillStyle = options.fillStyle;\n                ctx.fill();\n                ctx.closePath();\n            }\n            ctx.lineCap = 'round';\n            ctx.lineWidth = options.lineWidth;\n            ctx.strokeStyle = options.strokeStyle;\n            ctx.stroke();\n        });\n        var image = web.image(texture);\n        image.offset(minX - lw, minY - lw);\n        var node = web.create().append(image);\n        return node;\n    };\n    /** @deprecated Merged with main namespace */\n    var internal = {};\n    // @ts-ignore\n    internal.CollidePolygons = CollidePolygons;\n    // @ts-ignore\n    internal.Settings = Settings;\n    // @ts-ignore\n    internal.Sweep = Sweep;\n    // @ts-ignore\n    internal.Manifold = Manifold;\n    // @ts-ignore\n    internal.Distance = Distance;\n    // @ts-ignore\n    internal.TimeOfImpact = TimeOfImpact;\n    // @ts-ignore\n    internal.DynamicTree = DynamicTree;\n    // @ts-ignore\n    internal.stats = stats$1;\n    // @ts-ignore\n    Solver.TimeStep = TimeStep;\n    // @ts-ignore\n    Distance.testOverlap = testOverlap;\n    // @ts-ignore\n    Distance.Input = DistanceInput;\n    // @ts-ignore\n    Distance.Output = DistanceOutput;\n    // @ts-ignore\n    Distance.Proxy = DistanceProxy;\n    // @ts-ignore\n    Distance.Cache = SimplexCache;\n    // @ts-ignore\n    TimeOfImpact.Input = TOIInput;\n    // @ts-ignore\n    TimeOfImpact.Output = TOIOutput;\n\n    exports.AABB = AABB;\n    exports.Body = Body;\n    exports.Box = BoxShape;\n    exports.Chain = ChainShape;\n    exports.Circle = CircleShape;\n    exports.CollideCircles = CollideCircles;\n    exports.CollideEdgeCircle = CollideEdgeCircle;\n    exports.CollideEdgePolygon = CollideEdgePolygon;\n    exports.CollidePolygonCircle = CollidePolygonCircle;\n    exports.CollidePolygons = CollidePolygons;\n    exports.Contact = Contact;\n    exports.Distance = Distance;\n    exports.DistanceJoint = DistanceJoint;\n    exports.DynamicTree = DynamicTree;\n    exports.Edge = EdgeShape;\n    exports.Fixture = Fixture;\n    exports.FrictionJoint = FrictionJoint;\n    exports.GearJoint = GearJoint;\n    exports.Joint = Joint;\n    exports.Manifold = Manifold;\n    exports.Mat22 = Mat22;\n    exports.Mat33 = Mat33;\n    exports.Math = math$1;\n    exports.MotorJoint = MotorJoint;\n    exports.MouseJoint = MouseJoint;\n    exports.Polygon = PolygonShape;\n    exports.PrismaticJoint = PrismaticJoint;\n    exports.PulleyJoint = PulleyJoint;\n    exports.RevoluteJoint = RevoluteJoint;\n    exports.RopeJoint = RopeJoint;\n    exports.Rot = Rot;\n    exports.Serializer = Serializer;\n    exports.Settings = Settings;\n    exports.Shape = Shape;\n    exports.Sweep = Sweep;\n    exports.TimeOfImpact = TimeOfImpact;\n    exports.Transform = Transform;\n    exports.Vec2 = Vec2;\n    exports.Vec3 = Vec3;\n    exports.WeldJoint = WeldJoint;\n    exports.WheelJoint = WheelJoint;\n    exports.World = World;\n    exports.internal = internal;\n    exports.testbed = testbed;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=planck-with-testbed.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGxhbmNrL2Rpc3QvcGxhbmNrLXdpdGgtdGVzdGJlZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUE0RDtBQUNoRSxJQUFJLENBQ3VHO0FBQzNHLENBQUMsNkJBQTZCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1EQUFtRDtBQUNsRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1DQUFtQztBQUNsRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLDJEQUEyRDtBQUMxRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLHFEQUFxRDtBQUNwRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLG9EQUFvRDtBQUNuRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLHFEQUFxRDtBQUNwRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1QkFBdUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEdBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEdBQUc7QUFDaEQ7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEdBQUc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsR0FBRztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEdBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsR0FBRztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsR0FBRztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0NBQW9DO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnREFBZ0Q7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdDQUFnQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLGFBQWE7QUFDM0IsY0FBYyxhQUFhO0FBQzNCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQ0FBZ0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRCw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25ELDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRCw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RCxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHdDQUF3QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEM7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHdEQUF3RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZCQUE2QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZCQUE2QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7QUFDQSw4Q0FBOEMsR0FBRztBQUNqRDtBQUNBO0FBQ0EsNENBQTRDLEdBQUc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBCQUEwQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRCQUE0QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pELGdDQUFnQywwQkFBMEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRCQUE0QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQkFBMEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMEJBQTBCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEdBQUc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEdBQUc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxrREFBa0QsR0FBRztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQSwwREFBMEQsSUFBSTtBQUM5RCw4RUFBOEU7QUFDOUUsb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELElBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdDQUFnQztBQUM1RDtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdDQUFnQztBQUM1RCxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEdBQUc7QUFDaEQ7QUFDQTtBQUNBLDhDQUE4QyxHQUFHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEdBQUc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsR0FBRztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLE1BQU07QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsR0FBRztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBCQUEwQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLDBEQUEwRDtBQUMxRCx3REFBd0Q7QUFDeEQsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUlBQXFJO0FBQ3JJLGdGQUFnRjtBQUNoRix1REFBdUQ7QUFDdkQ7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsbUNBQW1DO0FBQ25DLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLG1DQUFtQztBQUNuQyxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELHdEQUF3RDtBQUN4RCxzREFBc0Q7QUFDdEQsa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQSwySEFBMkg7QUFDM0gsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLDJIQUEySDtBQUMzSCxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Qsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxvSUFBb0k7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5Riw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEcsb0dBQW9HO0FBQ3BHLGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQsc0NBQXNDO0FBQ3RDLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0M7QUFDQSxnSEFBZ0g7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFIO0FBQ3JILCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUUscUVBQXFFO0FBQ3JFLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0EsNERBQTREO0FBQzVELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUYsMEZBQTBGO0FBQzFGLGtFQUFrRTtBQUNsRSw0REFBNEQ7QUFDNUQsZ0VBQWdFO0FBQ2hFLG1EQUFtRDtBQUNuRCw0REFBNEQ7QUFDNUQsZ0VBQWdFO0FBQ2hFLG1EQUFtRDtBQUNuRDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDBCQUEwQjtBQUMxQjtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSw2Q0FBNkM7QUFDN0MsdURBQXVEO0FBQ3ZELG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSw2Q0FBNkM7QUFDN0MsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSxrRUFBa0U7QUFDbEUsa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsMEVBQTBFO0FBQzFFLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsMEVBQTBFO0FBQzFFLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCwwRUFBMEU7QUFDMUUsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRSxpRUFBaUU7QUFDakUsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLCtDQUErQztBQUMvQztBQUNBLDJEQUEyRDtBQUMzRCwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxpRUFBaUU7QUFDakUsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSw2Q0FBNkM7QUFDN0MscUNBQXFDO0FBQ3JDLG9EQUFvRDtBQUNwRCxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUscUJBQXFCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QsK0RBQStEO0FBQy9EO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCwrREFBK0Q7QUFDL0Qsc0RBQXNEO0FBQ3RELCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLCtDQUErQztBQUMvQztBQUNBLDRDQUE0QztBQUM1QyxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QixrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsdURBQXVEO0FBQ3ZELHlEQUF5RDtBQUN6RDtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLDJDQUEyQztBQUMzQztBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFLHFDQUFxQztBQUNyQyw4REFBOEQ7QUFDOUQsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsc0NBQXNDO0FBQ3RDLDhEQUE4RDtBQUM5RCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0EsNkRBQTZEO0FBQzdELCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsd0RBQXdEO0FBQ3hELHNEQUFzRDtBQUN0RCxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxtREFBbUQ7QUFDbkQ7QUFDQSw2REFBNkQ7QUFDN0QsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELGtEQUFrRDtBQUNsRCxxQ0FBcUM7QUFDckM7QUFDQSx1RUFBdUU7QUFDdkUseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSx5RUFBeUU7QUFDekUsc0VBQXNFO0FBQ3RFLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsd0JBQXdCO0FBQ3hCLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0JBQW9CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBZ0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdDQUFnQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdDQUFnQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLElBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVE7QUFDUjs7QUFFQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBLFVBQVU7QUFDVjs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixvQ0FBb0M7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDOztBQUVBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DOztBQUVBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDOztBQUVBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEOztBQUVBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDOztBQUVBLFVBQVU7QUFDViwwQkFBMEIsc0JBQXNCO0FBQ2hEOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsR0FBRztBQUM3Qyw2Q0FBNkMsR0FBRztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEdBQUc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELGFBQWE7O0FBRWhFLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3Rlc3QtcmVwby8uL25vZGVfbW9kdWxlcy9wbGFuY2svZGlzdC9wbGFuY2std2l0aC10ZXN0YmVkLmpzPzliY2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQbGFuY2suanMgdjEuMC4wLWFscGhhLjRcbiAqIEBsaWNlbnNlIFRoZSBNSVQgbGljZW5zZVxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwucGxhbmNrID0ge30pKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG4gICAgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbiAgICBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG4gICAgUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbiAgICBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbiAgICBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuICAgIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbiAgICBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcbiAgICBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuICAgIC8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvcHRpb25zIChpbnB1dCwgZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1vYmplY3QtbGl0ZXJhbC10eXBlLWFzc2VydGlvblxuICAgICAgICAgICAgaW5wdXQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gX19hc3NpZ24oe30sIGlucHV0KTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZvci1pblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHR5cGVvZiBpbnB1dFtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhkZWZhdWx0cyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdHMucHJvcGVydHlJc0VudW1lcmFibGUoc3ltYm9sKSAmJiB0eXBlb2YgaW5wdXRbc3ltYm9sXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W3N5bWJvbF0gPSBkZWZhdWx0c1tzeW1ib2xdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIHZhciBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3QgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHJlc3RbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICB2YXIgYXNzZXJ0ID0gZnVuY3Rpb24gKHN0YXRlbWVudCwgZXJyLCBsb2cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgdmFyIGNvbW1vbiA9IHtcbiAgICAgICAgYXNzZXJ0OiBhc3NlcnQsXG4gICAgICAgIGRlYnVnOiBkZWJ1ZyxcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIHZhciBtYXRoJDEgPSBPYmplY3QuY3JlYXRlKE1hdGgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICAvLyBub2luc3BlY3Rpb24gSlNDb25zdGFudFJlYXNzaWdubWVudFxuICAgIG1hdGgkMS5FUFNJTE9OID0gMWUtOTsgLy8gVE9ET1xuICAgIG1hdGgkMS5pc0Zpbml0ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHggPT09ICdudW1iZXInKSAmJiBpc0Zpbml0ZSh4KSAmJiAhaXNOYU4oeCk7XG4gICAgfTtcbiAgICBtYXRoJDEuYXNzZXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgbWF0aCQxLmludlNxcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAvLyBUT0RPOlxuICAgICAgICByZXR1cm4gMSAvIE1hdGguc3FydCh4KTtcbiAgICB9O1xuICAgIG1hdGgkMS5uZXh0UG93ZXJPZlR3byA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgeCB8PSAoeCA+PiAxKTtcbiAgICAgICAgeCB8PSAoeCA+PiAyKTtcbiAgICAgICAgeCB8PSAoeCA+PiA0KTtcbiAgICAgICAgeCB8PSAoeCA+PiA4KTtcbiAgICAgICAgeCB8PSAoeCA+PiAxNik7XG4gICAgICAgIHJldHVybiB4ICsgMTtcbiAgICB9O1xuICAgIG1hdGgkMS5pc1Bvd2VyT2ZUd28gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geCA+IDAgJiYgKHggJiAoeCAtIDEpKSA9PT0gMDtcbiAgICB9O1xuICAgIG1hdGgkMS5tb2QgPSBmdW5jdGlvbiAobnVtLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAodHlwZW9mIG1pbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG1heCA9IDE7XG4gICAgICAgICAgICBtaW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtYXggPSBtaW47XG4gICAgICAgICAgICBtaW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXggPiBtaW4pIHtcbiAgICAgICAgICAgIG51bSA9IChudW0gLSBtaW4pICUgKG1heCAtIG1pbik7XG4gICAgICAgICAgICByZXR1cm4gbnVtICsgKG51bSA8IDAgPyBtYXggOiBtaW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbnVtID0gKG51bSAtIG1heCkgJSAobWluIC0gbWF4KTtcbiAgICAgICAgICAgIHJldHVybiBudW0gKyAobnVtIDw9IDAgPyBtaW4gOiBtYXgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBtYXRoJDEuY2xhbXAgPSBmdW5jdGlvbiAobnVtLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAobnVtIDwgbWluKSB7XG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG51bSA+IG1heCkge1xuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIG1hdGgkMS5yYW5kb20gPSBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtaW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtYXggPSAxO1xuICAgICAgICAgICAgbWluID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWF4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbWF4ID0gbWluO1xuICAgICAgICAgICAgbWluID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluID09PSBtYXggPyBtaW4gOiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICB2YXIgVmVjMiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgZnVuY3Rpb24gVmVjMih4LCB5KSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVmVjMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0geC54O1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IHgueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgVmVjMi5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoVmVjMi5wcm90b3R5cGUpO1xuICAgICAgICAgICAgb2JqLnggPSBkYXRhLng7XG4gICAgICAgICAgICBvYmoueSA9IGRhdGEueTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIuemVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKFZlYzIucHJvdG90eXBlKTtcbiAgICAgICAgICAgIG9iai54ID0gMDtcbiAgICAgICAgICAgIG9iai55ID0gMDtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgVmVjMi5uZW8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoVmVjMi5wcm90b3R5cGUpO1xuICAgICAgICAgICAgb2JqLnggPSB4O1xuICAgICAgICAgICAgb2JqLnkgPSB5O1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi5jbG9uZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8odi54LCB2LnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRG9lcyB0aGlzIHZlY3RvciBjb250YWluIGZpbml0ZSBjb29yZGluYXRlcz9cbiAgICAgICAgICovXG4gICAgICAgIFZlYzIuaXNWYWxpZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0aCQxLmlzRmluaXRlKG9iai54KSAmJiBtYXRoJDEuaXNGaW5pdGUob2JqLnkpO1xuICAgICAgICB9O1xuICAgICAgICBWZWMyLmFzc2VydCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIuY2xvbmUodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyB2ZWN0b3IgdG8gYWxsIHplcm9zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBWZWMyLnByb3RvdHlwZS5zZXRaZXJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy54ID0gMC4wO1xuICAgICAgICAgICAgdGhpcy55ID0gMC4wO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyB2ZWN0b3IgdG8gc29tZSBzcGVjaWZpZWQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0eXBlZGVmXG4gICAgICAgIFZlYzIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0geC54O1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IHgueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgdmVjdG9yIHRvIHNvbWUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBWZWMyLnByb3RvdHlwZS5zZXROdW0gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIHZlY3RvciB0byBzb21lIHNwZWNpZmllZCBjb29yZGluYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgVmVjMi5wcm90b3R5cGUuc2V0VmVjMiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy54ID0gdmFsdWUueDtcbiAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlLnk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2V0Q29tYmluZSBvciBzZXRNdWxcbiAgICAgICAgICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLndTZXQgPSBmdW5jdGlvbiAoYSwgdiwgYiwgdykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDb21iaW5lKGEsIHYsIGIsIHcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TXVsKGEsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGxpbmVhciBjb21iaW5hdGlvbiBvZiB2IGFuZCB3OiBgYSAqIHYgKyBiICogd2BcbiAgICAgICAgICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLnNldENvbWJpbmUgPSBmdW5jdGlvbiAoYSwgdiwgYiwgdykge1xuICAgICAgICAgICAgdmFyIHggPSBhICogdi54ICsgYiAqIHcueDtcbiAgICAgICAgICAgIHZhciB5ID0gYSAqIHYueSArIGIgKiB3Lnk7XG4gICAgICAgICAgICAvLyBgdGhpc2AgbWF5IGJlIGB3YFxuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi5wcm90b3R5cGUuc2V0TXVsID0gZnVuY3Rpb24gKGEsIHYpIHtcbiAgICAgICAgICAgIHZhciB4ID0gYSAqIHYueDtcbiAgICAgICAgICAgIHZhciB5ID0gYSAqIHYueTtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSB2ZWN0b3IgdG8gdGhpcyB2ZWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICB0aGlzLnggKz0gdy54O1xuICAgICAgICAgICAgdGhpcy55ICs9IHcueTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBhZGRDb21iaW5lIG9yIGFkZE11bFxuICAgICAgICAgKi9cbiAgICAgICAgVmVjMi5wcm90b3R5cGUud0FkZCA9IGZ1bmN0aW9uIChhLCB2LCBiLCB3KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGIgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZENvbWJpbmUoYSwgdiwgYiwgdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRNdWwoYSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgbGluZWFyIGNvbWJpbmF0aW9uIG9mIHYgYW5kIHc6IGBhICogdiArIGIgKiB3YFxuICAgICAgICAgKi9cbiAgICAgICAgVmVjMi5wcm90b3R5cGUuYWRkQ29tYmluZSA9IGZ1bmN0aW9uIChhLCB2LCBiLCB3KSB7XG4gICAgICAgICAgICB2YXIgeCA9IGEgKiB2LnggKyBiICogdy54O1xuICAgICAgICAgICAgdmFyIHkgPSBhICogdi55ICsgYiAqIHcueTtcbiAgICAgICAgICAgIC8vIGB0aGlzYCBtYXkgYmUgYHdgXG4gICAgICAgICAgICB0aGlzLnggKz0geDtcbiAgICAgICAgICAgIHRoaXMueSArPSB5O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIucHJvdG90eXBlLmFkZE11bCA9IGZ1bmN0aW9uIChhLCB2KSB7XG4gICAgICAgICAgICB2YXIgeCA9IGEgKiB2Lng7XG4gICAgICAgICAgICB2YXIgeSA9IGEgKiB2Lnk7XG4gICAgICAgICAgICB0aGlzLnggKz0geDtcbiAgICAgICAgICAgIHRoaXMueSArPSB5O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2Ugc3ViQ29tYmluZSBvciBzdWJNdWxcbiAgICAgICAgICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLndTdWIgPSBmdW5jdGlvbiAoYSwgdiwgYiwgdykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJDb21iaW5lKGEsIHYsIGIsIHcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViTXVsKGEsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3VidHJhY3QgbGluZWFyIGNvbWJpbmF0aW9uIG9mIHYgYW5kIHc6IGBhICogdiArIGIgKiB3YFxuICAgICAgICAgKi9cbiAgICAgICAgVmVjMi5wcm90b3R5cGUuc3ViQ29tYmluZSA9IGZ1bmN0aW9uIChhLCB2LCBiLCB3KSB7XG4gICAgICAgICAgICB2YXIgeCA9IGEgKiB2LnggKyBiICogdy54O1xuICAgICAgICAgICAgdmFyIHkgPSBhICogdi55ICsgYiAqIHcueTtcbiAgICAgICAgICAgIC8vIGB0aGlzYCBtYXkgYmUgYHdgXG4gICAgICAgICAgICB0aGlzLnggLT0geDtcbiAgICAgICAgICAgIHRoaXMueSAtPSB5O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIucHJvdG90eXBlLnN1Yk11bCA9IGZ1bmN0aW9uIChhLCB2KSB7XG4gICAgICAgICAgICB2YXIgeCA9IGEgKiB2Lng7XG4gICAgICAgICAgICB2YXIgeSA9IGEgKiB2Lnk7XG4gICAgICAgICAgICB0aGlzLnggLT0geDtcbiAgICAgICAgICAgIHRoaXMueSAtPSB5O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJ0cmFjdCBhIHZlY3RvciBmcm9tIHRoaXMgdmVjdG9yXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICB0aGlzLnggLT0gdy54O1xuICAgICAgICAgICAgdGhpcy55IC09IHcueTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTXVsdGlwbHkgdGhpcyB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICB0aGlzLnggKj0gbTtcbiAgICAgICAgICAgIHRoaXMueSAqPSBtO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxlbmd0aCBvZiB0aGlzIHZlY3RvciAodGhlIG5vcm0pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgcGVyZm9ybWFuY2UsIHVzZSB0aGlzIGluc3RlYWQgb2YgbGVuZ3RoU3F1YXJlZCAoaWYgcG9zc2libGUpLlxuICAgICAgICAgKi9cbiAgICAgICAgVmVjMi5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubGVuZ3RoT2YodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxlbmd0aCBzcXVhcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgVmVjMi5wcm90b3R5cGUubGVuZ3RoU3F1YXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLmxlbmd0aFNxdWFyZWQodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHRoaXMgdmVjdG9yIGludG8gYSB1bml0IHZlY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgb2xkIGxlbmd0aFxuICAgICAgICAgKi9cbiAgICAgICAgVmVjMi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgICAgICBpZiAobGVuZ3RoIDwgbWF0aCQxLkVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGludkxlbmd0aCA9IDEuMCAvIGxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMueCAqPSBpbnZMZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnkgKj0gaW52TGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoaXMgdmVjdG9yICh0aGUgbm9ybSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBwZXJmb3JtYW5jZSwgdXNlIHRoaXMgaW5zdGVhZCBvZiBsZW5ndGhTcXVhcmVkIChpZiBwb3NzaWJsZSkuXG4gICAgICAgICAqL1xuICAgICAgICBWZWMyLmxlbmd0aE9mID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoJDEuc3FydCh2LnggKiB2LnggKyB2LnkgKiB2LnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBsZW5ndGggc3F1YXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIFZlYzIubGVuZ3RoU3F1YXJlZCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdi54ICogdi54ICsgdi55ICogdi55O1xuICAgICAgICB9O1xuICAgICAgICBWZWMyLmRpc3RhbmNlID0gZnVuY3Rpb24gKHYsIHcpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IHYueCAtIHcueDtcbiAgICAgICAgICAgIHZhciBkeSA9IHYueSAtIHcueTtcbiAgICAgICAgICAgIHJldHVybiBtYXRoJDEuc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIuZGlzdGFuY2VTcXVhcmVkID0gZnVuY3Rpb24gKHYsIHcpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IHYueCAtIHcueDtcbiAgICAgICAgICAgIHZhciBkeSA9IHYueSAtIHcueTtcbiAgICAgICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi5hcmVFcXVhbCA9IGZ1bmN0aW9uICh2LCB3KSB7XG4gICAgICAgICAgICByZXR1cm4gdiA9PT0gdyB8fCB0eXBlb2YgdyA9PT0gJ29iamVjdCcgJiYgdyAhPT0gbnVsbCAmJiB2LnggPT09IHcueCAmJiB2LnkgPT09IHcueTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgc2tldyB2ZWN0b3Igc3VjaCB0aGF0IGRvdChza2V3X3ZlYywgb3RoZXIpID09IGNyb3NzKHZlYywgb3RoZXIpXG4gICAgICAgICAqL1xuICAgICAgICBWZWMyLnNrZXcgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKC12LnksIHYueCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtIHRoZSBkb3QgcHJvZHVjdCBvbiB0d28gdmVjdG9ycy5cbiAgICAgICAgICovXG4gICAgICAgIFZlYzIuZG90ID0gZnVuY3Rpb24gKHYsIHcpIHtcbiAgICAgICAgICAgIHJldHVybiB2LnggKiB3LnggKyB2LnkgKiB3Lnk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtIHRoZSBjcm9zcyBwcm9kdWN0IG9uIHR3byB2ZWN0b3JzLiBJbiAyRCB0aGlzIHByb2R1Y2VzIGEgc2NhbGFyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQZXJmb3JtIHRoZSBjcm9zcyBwcm9kdWN0IG9uIGEgdmVjdG9yIGFuZCBhIHNjYWxhci4gSW4gMkQgdGhpcyBwcm9kdWNlcyBhXG4gICAgICAgICAqIHZlY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0eXBlZGVmXG4gICAgICAgIFZlYzIuY3Jvc3MgPSBmdW5jdGlvbiAodiwgdykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyh3ICogdi55LCAtdyAqIHYueCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oLXYgKiB3LnksIHYgKiB3LngpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYueCAqIHcueSAtIHYueSAqIHcueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm0gdGhlIGNyb3NzIHByb2R1Y3Qgb24gdHdvIHZlY3RvcnMuIEluIDJEIHRoaXMgcHJvZHVjZXMgYSBzY2FsYXIuXG4gICAgICAgICAqL1xuICAgICAgICBWZWMyLmNyb3NzVmVjMlZlYzIgPSBmdW5jdGlvbiAodiwgdykge1xuICAgICAgICAgICAgcmV0dXJuIHYueCAqIHcueSAtIHYueSAqIHcueDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm0gdGhlIGNyb3NzIHByb2R1Y3Qgb24gYSB2ZWN0b3IgYW5kIGEgc2NhbGFyLiBJbiAyRCB0aGlzIHByb2R1Y2VzIGFcbiAgICAgICAgICogdmVjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgVmVjMi5jcm9zc1ZlYzJOdW0gPSBmdW5jdGlvbiAodiwgdykge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHcgKiB2LnksIC13ICogdi54KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm0gdGhlIGNyb3NzIHByb2R1Y3Qgb24gYSB2ZWN0b3IgYW5kIGEgc2NhbGFyLiBJbiAyRCB0aGlzIHByb2R1Y2VzIGFcbiAgICAgICAgICogdmVjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgVmVjMi5jcm9zc051bVZlYzIgPSBmdW5jdGlvbiAodiwgdykge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKC12ICogdy55LCB2ICogdy54KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYGEgKyAodiB4IHcpYFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgVmVjMi5hZGRDcm9zcyA9IGZ1bmN0aW9uIChhLCB2LCB3KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHcgKiB2LnkgKyBhLngsIC13ICogdi54ICsgYS55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbygtdiAqIHcueSArIGEueCwgdiAqIHcueCArIGEueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGBhICsgKHYgeCB3KWBcbiAgICAgICAgICovXG4gICAgICAgIFZlYzIuYWRkQ3Jvc3NWZWMyTnVtID0gZnVuY3Rpb24gKGEsIHYsIHcpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyh3ICogdi55ICsgYS54LCAtdyAqIHYueCArIGEueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGBhICsgKHYgeCB3KWBcbiAgICAgICAgICovXG4gICAgICAgIFZlYzIuYWRkQ3Jvc3NOdW1WZWMyID0gZnVuY3Rpb24gKGEsIHYsIHcpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbygtdiAqIHcueSArIGEueCwgdiAqIHcueCArIGEueSk7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIuYWRkID0gZnVuY3Rpb24gKHYsIHcpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyh2LnggKyB3LngsIHYueSArIHcueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgVmVjMi53QWRkID0gZnVuY3Rpb24gKGEsIHYsIGIsIHcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlYzIuY29tYmluZShhLCB2LCBiLCB3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBWZWMyLm11bE51bVZlYzIoYSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIuY29tYmluZSA9IGZ1bmN0aW9uIChhLCB2LCBiLCB3KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi56ZXJvKCkuc2V0Q29tYmluZShhLCB2LCBiLCB3KTtcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi5zdWIgPSBmdW5jdGlvbiAodiwgdykge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHYueCAtIHcueCwgdi55IC0gdy55KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgVmVjMi5tdWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyhhLnggKiBiLCBhLnkgKiBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyhhICogYi54LCBhICogYi55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi5tdWxWZWMyTnVtID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyhhLnggKiBiLCBhLnkgKiBiKTtcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi5tdWxOdW1WZWMyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyhhICogYi54LCBhICogYi55KTtcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy54ID0gLXRoaXMueDtcbiAgICAgICAgICAgIHRoaXMueSA9IC10aGlzLnk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi5uZWcgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKC12LngsIC12LnkpO1xuICAgICAgICB9O1xuICAgICAgICBWZWMyLmFicyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8obWF0aCQxLmFicyh2LngpLCBtYXRoJDEuYWJzKHYueSkpO1xuICAgICAgICB9O1xuICAgICAgICBWZWMyLm1pZCA9IGZ1bmN0aW9uICh2LCB3KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oKHYueCArIHcueCkgKiAwLjUsICh2LnkgKyB3LnkpICogMC41KTtcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi51cHBlciA9IGZ1bmN0aW9uICh2LCB3KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8obWF0aCQxLm1heCh2LngsIHcueCksIG1hdGgkMS5tYXgodi55LCB3LnkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi5sb3dlciA9IGZ1bmN0aW9uICh2LCB3KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8obWF0aCQxLm1pbih2LngsIHcueCksIG1hdGgkMS5taW4odi55LCB3LnkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi5wcm90b3R5cGUuY2xhbXAgPSBmdW5jdGlvbiAobWF4KSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoU3FyID0gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xuICAgICAgICAgICAgaWYgKGxlbmd0aFNxciA+IG1heCAqIG1heCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnZMZW5ndGggPSBtYXRoJDEuaW52U3FydChsZW5ndGhTcXIpO1xuICAgICAgICAgICAgICAgIHRoaXMueCAqPSBpbnZMZW5ndGggKiBtYXg7XG4gICAgICAgICAgICAgICAgdGhpcy55ICo9IGludkxlbmd0aCAqIG1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBWZWMyLmNsYW1wID0gZnVuY3Rpb24gKHYsIG1heCkge1xuICAgICAgICAgICAgdiA9IFZlYzIubmVvKHYueCwgdi55KTtcbiAgICAgICAgICAgIHYuY2xhbXAobWF4KTtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9O1xuICAgICAgICAvKiogIEBpbnRlcm5hbCBAZGVwcmVjYXRlZCAqL1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHlwZWRlZlxuICAgICAgICBWZWMyLnNjYWxlRm4gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHYueCAqIHgsIHYueSAqIHkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqICBAaW50ZXJuYWwgQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgVmVjMi50cmFuc2xhdGVGbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8odi54ICsgeCwgdi55ICsgeSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVmVjMjtcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIHZhciBBQUJCID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBQUJCKGxvd2VyLCB1cHBlcikge1xuICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFBQkIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBQUJCKGxvd2VyLCB1cHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvd2VyQm91bmQgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb3dlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvd2VyQm91bmQuc2V0VmVjMihsb3dlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVwcGVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZC5zZXRWZWMyKHVwcGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwcGVyQm91bmQuc2V0VmVjMihsb3dlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmeSB0aGF0IHRoZSBib3VuZHMgYXJlIHNvcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIEFBQkIucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQUFCQi5pc1ZhbGlkKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBBQUJCLmlzVmFsaWQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFZlYzIuaXNWYWxpZChvYmoubG93ZXJCb3VuZCkgJiYgVmVjMi5pc1ZhbGlkKG9iai51cHBlckJvdW5kKSAmJiBWZWMyLnN1YihvYmoudXBwZXJCb3VuZCwgb2JqLmxvd2VyQm91bmQpLmxlbmd0aFNxdWFyZWQoKSA+PSAwO1xuICAgICAgICB9O1xuICAgICAgICBBQUJCLmFzc2VydCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgQUFCQi5cbiAgICAgICAgICovXG4gICAgICAgIEFBQkIucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbygodGhpcy5sb3dlckJvdW5kLnggKyB0aGlzLnVwcGVyQm91bmQueCkgKiAwLjUsICh0aGlzLmxvd2VyQm91bmQueSArIHRoaXMudXBwZXJCb3VuZC55KSAqIDAuNSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGV4dGVudHMgb2YgdGhlIEFBQkIgKGhhbGYtd2lkdGhzKS5cbiAgICAgICAgICovXG4gICAgICAgIEFBQkIucHJvdG90eXBlLmdldEV4dGVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oKHRoaXMudXBwZXJCb3VuZC54IC0gdGhpcy5sb3dlckJvdW5kLngpICogMC41LCAodGhpcy51cHBlckJvdW5kLnkgLSB0aGlzLmxvd2VyQm91bmQueSkgKiAwLjUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBwZXJpbWV0ZXIgbGVuZ3RoLlxuICAgICAgICAgKi9cbiAgICAgICAgQUFCQi5wcm90b3R5cGUuZ2V0UGVyaW1ldGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIDIuMCAqICh0aGlzLnVwcGVyQm91bmQueCAtIHRoaXMubG93ZXJCb3VuZC54ICsgdGhpcy51cHBlckJvdW5kLnkgLSB0aGlzLmxvd2VyQm91bmQueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21iaW5lIG9uZSBvciB0d28gQUFCQiBpbnRvIHRoaXMgb25lLlxuICAgICAgICAgKi9cbiAgICAgICAgQUFCQi5wcm90b3R5cGUuY29tYmluZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBiID0gYiB8fCB0aGlzO1xuICAgICAgICAgICAgdmFyIGxvd2VyQSA9IGEubG93ZXJCb3VuZDtcbiAgICAgICAgICAgIHZhciB1cHBlckEgPSBhLnVwcGVyQm91bmQ7XG4gICAgICAgICAgICB2YXIgbG93ZXJCID0gYi5sb3dlckJvdW5kO1xuICAgICAgICAgICAgdmFyIHVwcGVyQiA9IGIudXBwZXJCb3VuZDtcbiAgICAgICAgICAgIHZhciBsb3dlclggPSBtYXRoJDEubWluKGxvd2VyQS54LCBsb3dlckIueCk7XG4gICAgICAgICAgICB2YXIgbG93ZXJZID0gbWF0aCQxLm1pbihsb3dlckEueSwgbG93ZXJCLnkpO1xuICAgICAgICAgICAgdmFyIHVwcGVyWCA9IG1hdGgkMS5tYXgodXBwZXJCLngsIHVwcGVyQS54KTtcbiAgICAgICAgICAgIHZhciB1cHBlclkgPSBtYXRoJDEubWF4KHVwcGVyQi55LCB1cHBlckEueSk7XG4gICAgICAgICAgICB0aGlzLmxvd2VyQm91bmQuc2V0TnVtKGxvd2VyWCwgbG93ZXJZKTtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZC5zZXROdW0odXBwZXJYLCB1cHBlclkpO1xuICAgICAgICB9O1xuICAgICAgICBBQUJCLnByb3RvdHlwZS5jb21iaW5lUG9pbnRzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHRoaXMubG93ZXJCb3VuZC5zZXROdW0obWF0aCQxLm1pbihhLngsIGIueCksIG1hdGgkMS5taW4oYS55LCBiLnkpKTtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZC5zZXROdW0obWF0aCQxLm1heChhLngsIGIueCksIG1hdGgkMS5tYXgoYS55LCBiLnkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgQUFCQi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGFhYmIpIHtcbiAgICAgICAgICAgIHRoaXMubG93ZXJCb3VuZC5zZXROdW0oYWFiYi5sb3dlckJvdW5kLngsIGFhYmIubG93ZXJCb3VuZC55KTtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZC5zZXROdW0oYWFiYi51cHBlckJvdW5kLngsIGFhYmIudXBwZXJCb3VuZC55KTtcbiAgICAgICAgfTtcbiAgICAgICAgQUFCQi5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoYWFiYikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgdGhpcy5sb3dlckJvdW5kLnggPD0gYWFiYi5sb3dlckJvdW5kLng7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgdGhpcy5sb3dlckJvdW5kLnkgPD0gYWFiYi5sb3dlckJvdW5kLnk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgYWFiYi51cHBlckJvdW5kLnggPD0gdGhpcy51cHBlckJvdW5kLng7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgYWFiYi51cHBlckJvdW5kLnkgPD0gdGhpcy51cHBlckJvdW5kLnk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBBQUJCLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIEFBQkIuZXh0ZW5kKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBBQUJCLmV4dGVuZCA9IGZ1bmN0aW9uIChhYWJiLCB2YWx1ZSkge1xuICAgICAgICAgICAgYWFiYi5sb3dlckJvdW5kLnggLT0gdmFsdWU7XG4gICAgICAgICAgICBhYWJiLmxvd2VyQm91bmQueSAtPSB2YWx1ZTtcbiAgICAgICAgICAgIGFhYmIudXBwZXJCb3VuZC54ICs9IHZhbHVlO1xuICAgICAgICAgICAgYWFiYi51cHBlckJvdW5kLnkgKz0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIEFBQkIudGVzdE92ZXJsYXAgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgdmFyIGQxeCA9IGIubG93ZXJCb3VuZC54IC0gYS51cHBlckJvdW5kLng7XG4gICAgICAgICAgICB2YXIgZDJ4ID0gYS5sb3dlckJvdW5kLnggLSBiLnVwcGVyQm91bmQueDtcbiAgICAgICAgICAgIHZhciBkMXkgPSBiLmxvd2VyQm91bmQueSAtIGEudXBwZXJCb3VuZC55O1xuICAgICAgICAgICAgdmFyIGQyeSA9IGEubG93ZXJCb3VuZC55IC0gYi51cHBlckJvdW5kLnk7XG4gICAgICAgICAgICBpZiAoZDF4ID4gMCB8fCBkMXkgPiAwIHx8IGQyeCA+IDAgfHwgZDJ5ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBBQUJCLmFyZUVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLmFyZUVxdWFsKGEubG93ZXJCb3VuZCwgYi5sb3dlckJvdW5kKSAmJiBWZWMyLmFyZUVxdWFsKGEudXBwZXJCb3VuZCwgYi51cHBlckJvdW5kKTtcbiAgICAgICAgfTtcbiAgICAgICAgQUFCQi5kaWZmID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciB3RCA9IG1hdGgkMS5tYXgoMCwgbWF0aCQxLm1pbihhLnVwcGVyQm91bmQueCwgYi51cHBlckJvdW5kLngpIC0gbWF0aCQxLm1heChiLmxvd2VyQm91bmQueCwgYS5sb3dlckJvdW5kLngpKTtcbiAgICAgICAgICAgIHZhciBoRCA9IG1hdGgkMS5tYXgoMCwgbWF0aCQxLm1pbihhLnVwcGVyQm91bmQueSwgYi51cHBlckJvdW5kLnkpIC0gbWF0aCQxLm1heChiLmxvd2VyQm91bmQueSwgYS5sb3dlckJvdW5kLnkpKTtcbiAgICAgICAgICAgIHZhciB3QSA9IGEudXBwZXJCb3VuZC54IC0gYS5sb3dlckJvdW5kLng7XG4gICAgICAgICAgICB2YXIgaEEgPSBhLnVwcGVyQm91bmQueSAtIGEubG93ZXJCb3VuZC55O1xuICAgICAgICAgICAgdmFyIHdCID0gYi51cHBlckJvdW5kLnggLSBiLmxvd2VyQm91bmQueDtcbiAgICAgICAgICAgIHZhciBoQiA9IGIudXBwZXJCb3VuZC55IC0gYi5sb3dlckJvdW5kLnk7XG4gICAgICAgICAgICByZXR1cm4gd0EgKiBoQSArIHdCICogaEIgLSB3RCAqIGhEO1xuICAgICAgICB9O1xuICAgICAgICBBQUJCLnByb3RvdHlwZS5yYXlDYXN0ID0gZnVuY3Rpb24gKG91dHB1dCwgaW5wdXQpIHtcbiAgICAgICAgICAgIC8vIEZyb20gUmVhbC10aW1lIENvbGxpc2lvbiBEZXRlY3Rpb24sIHAxNzkuXG4gICAgICAgICAgICB2YXIgdG1pbiA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIHZhciB0bWF4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgcCA9IGlucHV0LnAxO1xuICAgICAgICAgICAgdmFyIGQgPSBWZWMyLnN1YihpbnB1dC5wMiwgaW5wdXQucDEpO1xuICAgICAgICAgICAgdmFyIGFic0QgPSBWZWMyLmFicyhkKTtcbiAgICAgICAgICAgIHZhciBub3JtYWwgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIGZvciAodmFyIGYgPSAneCc7IGYgIT09IG51bGw7IGYgPSAoZiA9PT0gJ3gnID8gJ3knIDogbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJzRC54IDwgbWF0aCQxLkVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyYWxsZWwuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwW2ZdIDwgdGhpcy5sb3dlckJvdW5kW2ZdIHx8IHRoaXMudXBwZXJCb3VuZFtmXSA8IHBbZl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludl9kID0gMS4wIC8gZFtmXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQxID0gKHRoaXMubG93ZXJCb3VuZFtmXSAtIHBbZl0pICogaW52X2Q7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0MiA9ICh0aGlzLnVwcGVyQm91bmRbZl0gLSBwW2ZdKSAqIGludl9kO1xuICAgICAgICAgICAgICAgICAgICAvLyBTaWduIG9mIHRoZSBub3JtYWwgdmVjdG9yLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IC0xLjA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0MSA+IHQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdDEgPSB0MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQyID0gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUHVzaCB0aGUgbWluIHVwXG4gICAgICAgICAgICAgICAgICAgIGlmICh0MSA+IHRtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbC5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxbZl0gPSBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1pbiA9IHQxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFB1bGwgdGhlIG1heCBkb3duXG4gICAgICAgICAgICAgICAgICAgIHRtYXggPSBtYXRoJDEubWluKHRtYXgsIHQyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtaW4gPiB0bWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb2VzIHRoZSByYXkgc3RhcnQgaW5zaWRlIHRoZSBib3g/XG4gICAgICAgICAgICAvLyBEb2VzIHRoZSByYXkgaW50ZXJzZWN0IGJleW9uZCB0aGUgbWF4IGZyYWN0aW9uP1xuICAgICAgICAgICAgaWYgKHRtaW4gPCAwLjAgfHwgaW5wdXQubWF4RnJhY3Rpb24gPCB0bWluKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW50ZXJzZWN0aW9uLlxuICAgICAgICAgICAgb3V0cHV0LmZyYWN0aW9uID0gdG1pbjtcbiAgICAgICAgICAgIG91dHB1dC5ub3JtYWwgPSBub3JtYWw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBQUJCLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFBQkI7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvLyBUT0RPIG1lcmdlIHdpdGggV29ybGQgb3B0aW9ucz9cbiAgICAvKipcbiAgICAgKiBUdW5pbmcgY29uc3RhbnRzIGJhc2VkIG9uIG1ldGVycy1raWxvZ3JhbXMtc2Vjb25kcyAoTUtTKSB1bml0cy5cbiAgICAgKi9cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW5uZWNlc3NhcnktY2xhc3NcbiAgICB2YXIgU2V0dGluZ3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNldHRpbmdzKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXR0aW5ncywgXCJsaW5lYXJTbG9wU3F1YXJlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNldHRpbmdzLmxpbmVhclNsb3AgKiBTZXR0aW5ncy5saW5lYXJTbG9wOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXR0aW5ncywgXCJwb2x5Z29uUmFkaXVzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHJhZGl1cyBvZiB0aGUgcG9seWdvbi9lZGdlIHNoYXBlIHNraW4uIFRoaXMgc2hvdWxkIG5vdCBiZSBtb2RpZmllZC5cbiAgICAgICAgICAgICAqIE1ha2luZyB0aGlzIHNtYWxsZXIgbWVhbnMgcG9seWdvbnMgd2lsbCBoYXZlIGFuIGluc3VmZmljaWVudCBidWZmZXIgZm9yXG4gICAgICAgICAgICAgKiBjb250aW51b3VzIGNvbGxpc2lvbi4gTWFraW5nIGl0IGxhcmdlciBtYXkgY3JlYXRlIGFydGlmYWN0cyBmb3IgdmVydGV4XG4gICAgICAgICAgICAgKiBjb2xsaXNpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gMi4wICogU2V0dGluZ3MubGluZWFyU2xvcDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0dGluZ3MsIFwibWF4VHJhbnNsYXRpb25TcXVhcmVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2V0dGluZ3MubWF4VHJhbnNsYXRpb24gKiBTZXR0aW5ncy5tYXhUcmFuc2xhdGlvbjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0dGluZ3MsIFwibWF4Um90YXRpb25TcXVhcmVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2V0dGluZ3MubWF4Um90YXRpb24gKiBTZXR0aW5ncy5tYXhSb3RhdGlvbjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0dGluZ3MsIFwibGluZWFyU2xlZXBUb2xlcmFuY2VTcXJcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBNYXRoLnBvdyhTZXR0aW5ncy5saW5lYXJTbGVlcFRvbGVyYW5jZSwgMik7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldHRpbmdzLCBcImFuZ3VsYXJTbGVlcFRvbGVyYW5jZVNxclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1hdGgucG93KFNldHRpbmdzLmFuZ3VsYXJTbGVlcFRvbGVyYW5jZSwgMik7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ29sbGlzaW9uXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29udGFjdCBwb2ludHMgYmV0d2VlbiB0d28gY29udmV4IHNoYXBlcy4gRG8gbm90IGNoYW5nZVxuICAgICAgICAgKiB0aGlzIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgU2V0dGluZ3MubWF4TWFuaWZvbGRQb2ludHMgPSAyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHZlcnRpY2VzIG9uIGEgY29udmV4IHBvbHlnb24uIFlvdSBjYW5ub3QgaW5jcmVhc2UgdGhpc1xuICAgICAgICAgKiB0b28gbXVjaCBiZWNhdXNlIEJsb2NrQWxsb2NhdG9yIGhhcyBhIG1heGltdW0gb2JqZWN0IHNpemUuXG4gICAgICAgICAqL1xuICAgICAgICBTZXR0aW5ncy5tYXhQb2x5Z29uVmVydGljZXMgPSAxMjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZCB0byBmYXR0ZW4gQUFCQnMgaW4gdGhlIGR5bmFtaWMgdHJlZS4gVGhpcyBhbGxvd3MgcHJveGllcyB0byBtb3ZlXG4gICAgICAgICAqIGJ5IGEgc21hbGwgYW1vdW50IHdpdGhvdXQgdHJpZ2dlcmluZyBhIHRyZWUgYWRqdXN0bWVudC4gVGhpcyBpcyBpbiBtZXRlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBTZXR0aW5ncy5hYWJiRXh0ZW5zaW9uID0gMC4xO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB1c2VkIHRvIGZhdHRlbiBBQUJCcyBpbiB0aGUgZHluYW1pYyB0cmVlLiBUaGlzIGlzIHVzZWQgdG8gcHJlZGljdCB0aGVcbiAgICAgICAgICogZnV0dXJlIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRpc3BsYWNlbWVudC4gVGhpcyBpcyBhIGRpbWVuc2lvbmxlc3NcbiAgICAgICAgICogbXVsdGlwbGllci5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLmFhYmJNdWx0aXBsaWVyID0gMi4wO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzbWFsbCBsZW5ndGggdXNlZCBhcyBhIGNvbGxpc2lvbiBhbmQgY29uc3RyYWludCB0b2xlcmFuY2UuIFVzdWFsbHkgaXQgaXNcbiAgICAgICAgICogY2hvc2VuIHRvIGJlIG51bWVyaWNhbGx5IHNpZ25pZmljYW50LCBidXQgdmlzdWFsbHkgaW5zaWduaWZpY2FudC5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLmxpbmVhclNsb3AgPSAwLjAwNTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc21hbGwgYW5nbGUgdXNlZCBhcyBhIGNvbGxpc2lvbiBhbmQgY29uc3RyYWludCB0b2xlcmFuY2UuIFVzdWFsbHkgaXQgaXNcbiAgICAgICAgICogY2hvc2VuIHRvIGJlIG51bWVyaWNhbGx5IHNpZ25pZmljYW50LCBidXQgdmlzdWFsbHkgaW5zaWduaWZpY2FudC5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLmFuZ3VsYXJTbG9wID0gKDIuMCAvIDE4MC4wICogTWF0aC5QSSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBzdWItc3RlcHMgcGVyIGNvbnRhY3QgaW4gY29udGludW91cyBwaHlzaWNzIHNpbXVsYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBTZXR0aW5ncy5tYXhTdWJTdGVwcyA9IDg7XG4gICAgICAgIC8vIER5bmFtaWNzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBjb250YWN0cyB0byBiZSBoYW5kbGVkIHRvIHNvbHZlIGEgVE9JIGltcGFjdC5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLm1heFRPSUNvbnRhY3RzID0gMzI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXhpbXVtIGl0ZXJhdGlvbnMgdG8gc29sdmUgYSBUT0kuXG4gICAgICAgICAqL1xuICAgICAgICBTZXR0aW5ncy5tYXhUT0lJdGVyYXRpb25zID0gMjA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXhpbXVtIGl0ZXJhdGlvbnMgdG8gZmluZCBEaXN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLm1heERpc3RuY2VJdGVyYXRpb25zID0gMjA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHZlbG9jaXR5IHRocmVzaG9sZCBmb3IgZWxhc3RpYyBjb2xsaXNpb25zLiBBbnkgY29sbGlzaW9uIHdpdGggYSByZWxhdGl2ZVxuICAgICAgICAgKiBsaW5lYXIgdmVsb2NpdHkgYmVsb3cgdGhpcyB0aHJlc2hvbGQgd2lsbCBiZSB0cmVhdGVkIGFzIGluZWxhc3RpYy5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLnZlbG9jaXR5VGhyZXNob2xkID0gMS4wO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gbGluZWFyIHBvc2l0aW9uIGNvcnJlY3Rpb24gdXNlZCB3aGVuIHNvbHZpbmcgY29uc3RyYWludHMuIFRoaXNcbiAgICAgICAgICogaGVscHMgdG8gcHJldmVudCBvdmVyc2hvb3QuXG4gICAgICAgICAqL1xuICAgICAgICBTZXR0aW5ncy5tYXhMaW5lYXJDb3JyZWN0aW9uID0gMC4yO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gYW5ndWxhciBwb3NpdGlvbiBjb3JyZWN0aW9uIHVzZWQgd2hlbiBzb2x2aW5nIGNvbnN0cmFpbnRzLiBUaGlzXG4gICAgICAgICAqIGhlbHBzIHRvIHByZXZlbnQgb3ZlcnNob290LlxuICAgICAgICAgKi9cbiAgICAgICAgU2V0dGluZ3MubWF4QW5ndWxhckNvcnJlY3Rpb24gPSAoOC4wIC8gMTgwLjAgKiBNYXRoLlBJKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIGxpbmVhciB2ZWxvY2l0eSBvZiBhIGJvZHkuIFRoaXMgbGltaXQgaXMgdmVyeSBsYXJnZSBhbmQgaXMgdXNlZFxuICAgICAgICAgKiB0byBwcmV2ZW50IG51bWVyaWNhbCBwcm9ibGVtcy4gWW91IHNob3VsZG4ndCBuZWVkIHRvIGFkanVzdCBTZXR0aW5ncy5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLm1heFRyYW5zbGF0aW9uID0gMi4wO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gYW5ndWxhciB2ZWxvY2l0eSBvZiBhIGJvZHkuIFRoaXMgbGltaXQgaXMgdmVyeSBsYXJnZSBhbmQgaXMgdXNlZFxuICAgICAgICAgKiB0byBwcmV2ZW50IG51bWVyaWNhbCBwcm9ibGVtcy4gWW91IHNob3VsZG4ndCBuZWVkIHRvIGFkanVzdCBTZXR0aW5ncy5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLm1heFJvdGF0aW9uID0gKDAuNSAqIE1hdGguUEkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBzY2FsZSBmYWN0b3IgY29udHJvbHMgaG93IGZhc3Qgb3ZlcmxhcCBpcyByZXNvbHZlZC4gSWRlYWxseSB0aGlzIHdvdWxkXG4gICAgICAgICAqIGJlIDEgc28gdGhhdCBvdmVybGFwIGlzIHJlbW92ZWQgaW4gb25lIHRpbWUgc3RlcC4gSG93ZXZlciB1c2luZyB2YWx1ZXMgY2xvc2VcbiAgICAgICAgICogdG8gMSBvZnRlbiBsZWFkIHRvIG92ZXJzaG9vdC5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLmJhdW1nYXJ0ZSA9IDAuMjtcbiAgICAgICAgU2V0dGluZ3MudG9pQmF1Z2FydGUgPSAwLjc1O1xuICAgICAgICAvLyBTbGVlcFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgdGhhdCBhIGJvZHkgbXVzdCBiZSBzdGlsbCBiZWZvcmUgaXQgd2lsbCBnbyB0byBzbGVlcC5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLnRpbWVUb1NsZWVwID0gMC41O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBib2R5IGNhbm5vdCBzbGVlcCBpZiBpdHMgbGluZWFyIHZlbG9jaXR5IGlzIGFib3ZlIHRoaXMgdG9sZXJhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgU2V0dGluZ3MubGluZWFyU2xlZXBUb2xlcmFuY2UgPSAwLjAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBib2R5IGNhbm5vdCBzbGVlcCBpZiBpdHMgYW5ndWxhciB2ZWxvY2l0eSBpcyBhYm92ZSB0aGlzIHRvbGVyYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLmFuZ3VsYXJTbGVlcFRvbGVyYW5jZSA9ICgyLjAgLyAxODAuMCAqIE1hdGguUEkpO1xuICAgICAgICByZXR1cm4gU2V0dGluZ3M7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggQWxpIFNoYWtpYmEgaHR0cDovL3NoYWtpYmEubWUvcGxhbmNrLmpzXG4gICAgICpcbiAgICAgKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuICAgICAqIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbiAgICAgKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuICAgICAqIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuICAgICAqIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbiAgICAgKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4gICAgICogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3RcbiAgICAgKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuICAgICAqIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuICAgICAqIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4gICAgICogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbiAgICAgKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4gICAgICogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cbiAgICAgKi9cbiAgICB2YXIgUG9vbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUG9vbChvcHRzKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ID0gW107XG4gICAgICAgICAgICB0aGlzLl9tYXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX291dENvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2luQ291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fZGlzY2FyZENvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2xpc3QgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21heCA9IG9wdHMubWF4IHx8IHRoaXMuX21heDtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUZuID0gb3B0cy5jcmVhdGU7XG4gICAgICAgICAgICB0aGlzLl9vdXRGbiA9IG9wdHMuYWxsb2NhdGU7XG4gICAgICAgICAgICB0aGlzLl9pbkZuID0gb3B0cy5yZWxlYXNlO1xuICAgICAgICAgICAgdGhpcy5fZGlzY2FyZEZuID0gb3B0cy5kaXNjYXJkO1xuICAgICAgICB9XG4gICAgICAgIFBvb2wucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4ID0gbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXg7XG4gICAgICAgIH07XG4gICAgICAgIFBvb2wucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlzdC5sZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIFBvb2wucHJvdG90eXBlLmFsbG9jYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgICAgICBpZiAodGhpcy5fbGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuX2xpc3Quc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jcmVhdGVGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5fY3JlYXRlRm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1vYmplY3QtbGl0ZXJhbC10eXBlLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICBpdGVtID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb3V0Q291bnQrKztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fb3V0Rm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRGbihpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9O1xuICAgICAgICBQb29sLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9saXN0Lmxlbmd0aCA8IHRoaXMuX21heCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luQ291bnQrKztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2luRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5GbihpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzY2FyZENvdW50Kys7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9kaXNjYXJkRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuX2Rpc2NhcmRGbihpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUG9vbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIgK1wiICsgdGhpcy5fY3JlYXRlQ291bnQgKyBcIiA+XCIgKyB0aGlzLl9vdXRDb3VudCArIFwiIDxcIiArIHRoaXMuX2luQ291bnQgKyBcIiAtXCJcbiAgICAgICAgICAgICAgICArIHRoaXMuX2Rpc2NhcmRDb3VudCArIFwiID1cIiArIHRoaXMuX2xpc3QubGVuZ3RoICsgXCIvXCIgKyB0aGlzLl9tYXg7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQb29sO1xuICAgIH0oKSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQSBub2RlIGluIHRoZSBkeW5hbWljIHRyZWUuIFRoZSBjbGllbnQgZG9lcyBub3QgaW50ZXJhY3Qgd2l0aCB0aGlzIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIHZhciBUcmVlTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVHJlZU5vZGUoaWQpIHtcbiAgICAgICAgICAgIC8qKiBFbmxhcmdlZCBBQUJCICovXG4gICAgICAgICAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xuICAgICAgICAgICAgdGhpcy51c2VyRGF0YSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNoaWxkMSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNoaWxkMiA9IG51bGw7XG4gICAgICAgICAgICAvKiogMDogbGVhZiwgLTE6IGZyZWUgbm9kZSAqL1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkICsgXCI6IFwiICsgdGhpcy51c2VyRGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLmlzTGVhZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkMSA9PSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVHJlZU5vZGU7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBBIGR5bmFtaWMgQUFCQiB0cmVlIGJyb2FkLXBoYXNlLCBpbnNwaXJlZCBieSBOYXRoYW5hZWwgUHJlc3NvbidzIGJ0RGJ2dC4gQVxuICAgICAqIGR5bmFtaWMgdHJlZSBhcnJhbmdlcyBkYXRhIGluIGEgYmluYXJ5IHRyZWUgdG8gYWNjZWxlcmF0ZSBxdWVyaWVzIHN1Y2ggYXNcbiAgICAgKiB2b2x1bWUgcXVlcmllcyBhbmQgcmF5IGNhc3RzLiBMZWFmcyBhcmUgcHJveGllcyB3aXRoIGFuIEFBQkIuIEluIHRoZSB0cmVlIHdlXG4gICAgICogZXhwYW5kIHRoZSBwcm94eSBBQUJCIGJ5IGBhYWJiRXh0ZW5zaW9uYCBzbyB0aGF0IHRoZSBwcm94eSBBQUJCIGlzIGJpZ2dlclxuICAgICAqIHRoYW4gdGhlIGNsaWVudCBvYmplY3QuIFRoaXMgYWxsb3dzIHRoZSBjbGllbnQgb2JqZWN0IHRvIG1vdmUgYnkgc21hbGxcbiAgICAgKiBhbW91bnRzIHdpdGhvdXQgdHJpZ2dlcmluZyBhIHRyZWUgdXBkYXRlLlxuICAgICAqXG4gICAgICogTm9kZXMgYXJlIHBvb2xlZCBhbmQgcmVsb2NhdGFibGUsIHNvIHdlIHVzZSBub2RlIGluZGljZXMgcmF0aGVyIHRoYW5cbiAgICAgKiBwb2ludGVycy5cbiAgICAgKi9cbiAgICB2YXIgRHluYW1pY1RyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIER5bmFtaWNUcmVlKCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFBvb2wgPSBuZXcgUG9vbCh7XG4gICAgICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1vYmplY3QtbGl0ZXJhbC10eXBlLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWxlYXNlOiBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tQb29sID0gbmV3IFBvb2woe1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWxlYXNlOiBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaXRlcmF0b3JQb29sID0gbmV3IFBvb2woe1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWxlYXNlOiBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubV9yb290ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubV9ub2RlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5tX2xhc3RQcm94eUlkID0gMDtcbiAgICAgICAgICAgIHRoaXMubV9wb29sID0gbmV3IFBvb2woe1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBwcm94eSB1c2VyIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdGhlIHByb3h5IHVzZXIgZGF0YSBvciAwIGlmIHRoZSBpZCBpcyBpbnZhbGlkLlxuICAgICAgICAgKi9cbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmdldFVzZXJEYXRhID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubV9ub2Rlc1tpZF07XG4gICAgICAgICAgICByZXR1cm4gbm9kZS51c2VyRGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZmF0IEFBQkIgZm9yIGEgbm9kZSBpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGUgcHJveHkgdXNlciBkYXRhIG9yIDAgaWYgdGhlIGlkIGlzIGludmFsaWQuXG4gICAgICAgICAqL1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuZ2V0RmF0QUFCQiA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm1fbm9kZXNbaWRdO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuYWFiYjtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmFsbG9jYXRlTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5tX3Bvb2wuYWxsb2NhdGUoKTtcbiAgICAgICAgICAgIG5vZGUuaWQgPSArK3RoaXMubV9sYXN0UHJveHlJZDtcbiAgICAgICAgICAgIG5vZGUudXNlckRhdGEgPSBudWxsO1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgbm9kZS5jaGlsZDEgPSBudWxsO1xuICAgICAgICAgICAgbm9kZS5jaGlsZDIgPSBudWxsO1xuICAgICAgICAgICAgbm9kZS5oZWlnaHQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMubV9ub2Rlc1tub2RlLmlkXSA9IG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmZyZWVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMubV9wb29sLnJlbGVhc2Uobm9kZSk7XG4gICAgICAgICAgICBub2RlLmhlaWdodCA9IC0xO1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWR5bmFtaWMtZGVsZXRlXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5tX25vZGVzW25vZGUuaWRdO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgcHJveHkgaW4gdGhlIHRyZWUgYXMgYSBsZWFmIG5vZGUuIFdlIHJldHVybiB0aGUgaW5kZXggb2YgdGhlIG5vZGVcbiAgICAgICAgICogaW5zdGVhZCBvZiBhIHBvaW50ZXIgc28gdGhhdCB3ZSBjYW4gZ3JvdyB0aGUgbm9kZSBwb29sLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDcmVhdGUgYSBwcm94eS4gUHJvdmlkZSBhIHRpZ2h0IGZpdHRpbmcgQUFCQiBhbmQgYSB1c2VyRGF0YSBwb2ludGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmNyZWF0ZVByb3h5ID0gZnVuY3Rpb24gKGFhYmIsIHVzZXJEYXRhKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYWxsb2NhdGVOb2RlKCk7XG4gICAgICAgICAgICBub2RlLmFhYmIuc2V0KGFhYmIpO1xuICAgICAgICAgICAgLy8gRmF0dGVuIHRoZSBhYWJiLlxuICAgICAgICAgICAgQUFCQi5leHRlbmQobm9kZS5hYWJiLCBTZXR0aW5ncy5hYWJiRXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIG5vZGUudXNlckRhdGEgPSB1c2VyRGF0YTtcbiAgICAgICAgICAgIG5vZGUuaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0TGVhZihub2RlKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmlkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveSBhIHByb3h5LiBUaGlzIGFzc2VydHMgaWYgdGhlIGlkIGlzIGludmFsaWQuXG4gICAgICAgICAqL1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuZGVzdHJveVByb3h5ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubV9ub2Rlc1tpZF07XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxlYWYobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmZyZWVOb2RlKG5vZGUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZSBhIHByb3h5IHdpdGggYSBzd2VwdGVkIEFBQkIuIElmIHRoZSBwcm94eSBoYXMgbW92ZWQgb3V0c2lkZSBvZiBpdHNcbiAgICAgICAgICogZmF0dGVuZWQgQUFCQiwgdGhlbiB0aGUgcHJveHkgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlIGFuZCByZS1pbnNlcnRlZC5cbiAgICAgICAgICogT3RoZXJ3aXNlIHRoZSBmdW5jdGlvbiByZXR1cm5zIGltbWVkaWF0ZWx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZCBEaXNwbGFjZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIHRoZSBwcm94eSB3YXMgcmUtaW5zZXJ0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUubW92ZVByb3h5ID0gZnVuY3Rpb24gKGlkLCBhYWJiLCBkKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubV9ub2Rlc1tpZF07XG4gICAgICAgICAgICBpZiAobm9kZS5hYWJiLmNvbnRhaW5zKGFhYmIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVMZWFmKG5vZGUpO1xuICAgICAgICAgICAgbm9kZS5hYWJiLnNldChhYWJiKTtcbiAgICAgICAgICAgIC8vIEV4dGVuZCBBQUJCLlxuICAgICAgICAgICAgYWFiYiA9IG5vZGUuYWFiYjtcbiAgICAgICAgICAgIEFBQkIuZXh0ZW5kKGFhYmIsIFNldHRpbmdzLmFhYmJFeHRlbnNpb24pO1xuICAgICAgICAgICAgLy8gUHJlZGljdCBBQUJCIGRpc3BsYWNlbWVudC5cbiAgICAgICAgICAgIC8vIGNvbnN0IGQgPSBWZWMyLm11bChTZXR0aW5ncy5hYWJiTXVsdGlwbGllciwgZGlzcGxhY2VtZW50KTtcbiAgICAgICAgICAgIGlmIChkLnggPCAwLjApIHtcbiAgICAgICAgICAgICAgICBhYWJiLmxvd2VyQm91bmQueCArPSBkLnggKiBTZXR0aW5ncy5hYWJiTXVsdGlwbGllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFhYmIudXBwZXJCb3VuZC54ICs9IGQueCAqIFNldHRpbmdzLmFhYmJNdWx0aXBsaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGQueSA8IDAuMCkge1xuICAgICAgICAgICAgICAgIGFhYmIubG93ZXJCb3VuZC55ICs9IGQueSAqIFNldHRpbmdzLmFhYmJNdWx0aXBsaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWFiYi51cHBlckJvdW5kLnkgKz0gZC55ICogU2V0dGluZ3MuYWFiYk11bHRpcGxpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluc2VydExlYWYobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmluc2VydExlYWYgPSBmdW5jdGlvbiAobGVhZikge1xuICAgICAgICAgICAgaWYgKHRoaXMubV9yb290ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fcm9vdCA9IGxlYWY7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3Jvb3QucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBiZXN0IHNpYmxpbmcgZm9yIHRoaXMgbm9kZVxuICAgICAgICAgICAgdmFyIGxlYWZBQUJCID0gbGVhZi5hYWJiO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5tX3Jvb3Q7XG4gICAgICAgICAgICB3aGlsZSAoIWluZGV4LmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkMSA9IGluZGV4LmNoaWxkMTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQyID0gaW5kZXguY2hpbGQyO1xuICAgICAgICAgICAgICAgIHZhciBhcmVhID0gaW5kZXguYWFiYi5nZXRQZXJpbWV0ZXIoKTtcbiAgICAgICAgICAgICAgICB2YXIgY29tYmluZWRBQUJCID0gbmV3IEFBQkIoKTtcbiAgICAgICAgICAgICAgICBjb21iaW5lZEFBQkIuY29tYmluZShpbmRleC5hYWJiLCBsZWFmQUFCQik7XG4gICAgICAgICAgICAgICAgdmFyIGNvbWJpbmVkQXJlYSA9IGNvbWJpbmVkQUFCQi5nZXRQZXJpbWV0ZXIoKTtcbiAgICAgICAgICAgICAgICAvLyBDb3N0IG9mIGNyZWF0aW5nIGEgbmV3IHBhcmVudCBmb3IgdGhpcyBub2RlIGFuZCB0aGUgbmV3IGxlYWZcbiAgICAgICAgICAgICAgICB2YXIgY29zdCA9IDIuMCAqIGNvbWJpbmVkQXJlYTtcbiAgICAgICAgICAgICAgICAvLyBNaW5pbXVtIGNvc3Qgb2YgcHVzaGluZyB0aGUgbGVhZiBmdXJ0aGVyIGRvd24gdGhlIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgaW5oZXJpdGFuY2VDb3N0ID0gMi4wICogKGNvbWJpbmVkQXJlYSAtIGFyZWEpO1xuICAgICAgICAgICAgICAgIC8vIENvc3Qgb2YgZGVzY2VuZGluZyBpbnRvIGNoaWxkMVxuICAgICAgICAgICAgICAgIHZhciBjb3N0MSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQxLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhYWJiID0gbmV3IEFBQkIoKTtcbiAgICAgICAgICAgICAgICAgICAgYWFiYi5jb21iaW5lKGxlYWZBQUJCLCBjaGlsZDEuYWFiYik7XG4gICAgICAgICAgICAgICAgICAgIGNvc3QxID0gYWFiYi5nZXRQZXJpbWV0ZXIoKSArIGluaGVyaXRhbmNlQ29zdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhYWJiID0gbmV3IEFBQkIoKTtcbiAgICAgICAgICAgICAgICAgICAgYWFiYi5jb21iaW5lKGxlYWZBQUJCLCBjaGlsZDEuYWFiYik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRBcmVhID0gY2hpbGQxLmFhYmIuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdBcmVhID0gYWFiYi5nZXRQZXJpbWV0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29zdDEgPSAobmV3QXJlYSAtIG9sZEFyZWEpICsgaW5oZXJpdGFuY2VDb3N0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb3N0IG9mIGRlc2NlbmRpbmcgaW50byBjaGlsZDJcbiAgICAgICAgICAgICAgICB2YXIgY29zdDIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkMi5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWFiYiA9IG5ldyBBQUJCKCk7XG4gICAgICAgICAgICAgICAgICAgIGFhYmIuY29tYmluZShsZWFmQUFCQiwgY2hpbGQyLmFhYmIpO1xuICAgICAgICAgICAgICAgICAgICBjb3N0MiA9IGFhYmIuZ2V0UGVyaW1ldGVyKCkgKyBpbmhlcml0YW5jZUNvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWFiYiA9IG5ldyBBQUJCKCk7XG4gICAgICAgICAgICAgICAgICAgIGFhYmIuY29tYmluZShsZWFmQUFCQiwgY2hpbGQyLmFhYmIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQXJlYSA9IGNoaWxkMi5hYWJiLmdldFBlcmltZXRlcigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3QXJlYSA9IGFhYmIuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvc3QyID0gbmV3QXJlYSAtIG9sZEFyZWEgKyBpbmhlcml0YW5jZUNvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERlc2NlbmQgYWNjb3JkaW5nIHRvIHRoZSBtaW5pbXVtIGNvc3QuXG4gICAgICAgICAgICAgICAgaWYgKGNvc3QgPCBjb3N0MSAmJiBjb3N0IDwgY29zdDIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERlc2NlbmRcbiAgICAgICAgICAgICAgICBpZiAoY29zdDEgPCBjb3N0Mikge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGNoaWxkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gY2hpbGQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzaWJsaW5nID0gaW5kZXg7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcGFyZW50LlxuICAgICAgICAgICAgdmFyIG9sZFBhcmVudCA9IHNpYmxpbmcucGFyZW50O1xuICAgICAgICAgICAgdmFyIG5ld1BhcmVudCA9IHRoaXMuYWxsb2NhdGVOb2RlKCk7XG4gICAgICAgICAgICBuZXdQYXJlbnQucGFyZW50ID0gb2xkUGFyZW50O1xuICAgICAgICAgICAgbmV3UGFyZW50LnVzZXJEYXRhID0gbnVsbDtcbiAgICAgICAgICAgIG5ld1BhcmVudC5hYWJiLmNvbWJpbmUobGVhZkFBQkIsIHNpYmxpbmcuYWFiYik7XG4gICAgICAgICAgICBuZXdQYXJlbnQuaGVpZ2h0ID0gc2libGluZy5oZWlnaHQgKyAxO1xuICAgICAgICAgICAgaWYgKG9sZFBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHNpYmxpbmcgd2FzIG5vdCB0aGUgcm9vdC5cbiAgICAgICAgICAgICAgICBpZiAob2xkUGFyZW50LmNoaWxkMSA9PT0gc2libGluZykge1xuICAgICAgICAgICAgICAgICAgICBvbGRQYXJlbnQuY2hpbGQxID0gbmV3UGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkUGFyZW50LmNoaWxkMiA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LmNoaWxkMSA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LmNoaWxkMiA9IGxlYWY7XG4gICAgICAgICAgICAgICAgc2libGluZy5wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2libGluZyB3YXMgdGhlIHJvb3QuXG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LmNoaWxkMSA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LmNoaWxkMiA9IGxlYWY7XG4gICAgICAgICAgICAgICAgc2libGluZy5wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3Jvb3QgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXYWxrIGJhY2sgdXAgdGhlIHRyZWUgZml4aW5nIGhlaWdodHMgYW5kIEFBQkJzXG4gICAgICAgICAgICBpbmRleCA9IGxlYWYucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuYmFsYW5jZShpbmRleCk7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkMSA9IGluZGV4LmNoaWxkMTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQyID0gaW5kZXguY2hpbGQyO1xuICAgICAgICAgICAgICAgIGluZGV4LmhlaWdodCA9IDEgKyBtYXRoJDEubWF4KGNoaWxkMS5oZWlnaHQsIGNoaWxkMi5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGluZGV4LmFhYmIuY29tYmluZShjaGlsZDEuYWFiYiwgY2hpbGQyLmFhYmIpO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXgucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmFsaWRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnJlbW92ZUxlYWYgPSBmdW5jdGlvbiAobGVhZikge1xuICAgICAgICAgICAgaWYgKGxlYWYgPT09IHRoaXMubV9yb290KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3Jvb3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBsZWFmLnBhcmVudDtcbiAgICAgICAgICAgIHZhciBncmFuZFBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICB2YXIgc2libGluZztcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2hpbGQxID09PSBsZWFmKSB7XG4gICAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5jaGlsZDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LmNoaWxkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFuZFBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVzdHJveSBwYXJlbnQgYW5kIGNvbm5lY3Qgc2libGluZyB0byBncmFuZFBhcmVudC5cbiAgICAgICAgICAgICAgICBpZiAoZ3JhbmRQYXJlbnQuY2hpbGQxID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhbmRQYXJlbnQuY2hpbGQxID0gc2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYW5kUGFyZW50LmNoaWxkMiA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gZ3JhbmRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmVlTm9kZShwYXJlbnQpO1xuICAgICAgICAgICAgICAgIC8vIEFkanVzdCBhbmNlc3RvciBib3VuZHMuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZ3JhbmRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJhbGFuY2UoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQxID0gaW5kZXguY2hpbGQxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQyID0gaW5kZXguY2hpbGQyO1xuICAgICAgICAgICAgICAgICAgICBpbmRleC5hYWJiLmNvbWJpbmUoY2hpbGQxLmFhYmIsIGNoaWxkMi5hYWJiKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXguaGVpZ2h0ID0gMSArIG1hdGgkMS5tYXgoY2hpbGQxLmhlaWdodCwgY2hpbGQyLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXgucGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubV9yb290ID0gc2libGluZztcbiAgICAgICAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmVlTm9kZShwYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmFsaWRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm0gYSBsZWZ0IG9yIHJpZ2h0IHJvdGF0aW9uIGlmIG5vZGUgQSBpcyBpbWJhbGFuY2VkLiBSZXR1cm5zIHRoZSBuZXdcbiAgICAgICAgICogcm9vdCBpbmRleC5cbiAgICAgICAgICovXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5iYWxhbmNlID0gZnVuY3Rpb24gKGlBKSB7XG4gICAgICAgICAgICB2YXIgQSA9IGlBO1xuICAgICAgICAgICAgaWYgKEEuaXNMZWFmKCkgfHwgQS5oZWlnaHQgPCAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlBO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIEIgPSBBLmNoaWxkMTtcbiAgICAgICAgICAgIHZhciBDID0gQS5jaGlsZDI7XG4gICAgICAgICAgICB2YXIgYmFsYW5jZSA9IEMuaGVpZ2h0IC0gQi5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBSb3RhdGUgQyB1cFxuICAgICAgICAgICAgaWYgKGJhbGFuY2UgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIEYgPSBDLmNoaWxkMTtcbiAgICAgICAgICAgICAgICB2YXIgRyA9IEMuY2hpbGQyO1xuICAgICAgICAgICAgICAgIC8vIFN3YXAgQSBhbmQgQ1xuICAgICAgICAgICAgICAgIEMuY2hpbGQxID0gQTtcbiAgICAgICAgICAgICAgICBDLnBhcmVudCA9IEEucGFyZW50O1xuICAgICAgICAgICAgICAgIEEucGFyZW50ID0gQztcbiAgICAgICAgICAgICAgICAvLyBBJ3Mgb2xkIHBhcmVudCBzaG91bGQgcG9pbnQgdG8gQ1xuICAgICAgICAgICAgICAgIGlmIChDLnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChDLnBhcmVudC5jaGlsZDEgPT09IGlBKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDLnBhcmVudC5jaGlsZDEgPSBDO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgQy5wYXJlbnQuY2hpbGQyID0gQztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3Jvb3QgPSBDO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSb3RhdGVcbiAgICAgICAgICAgICAgICBpZiAoRi5oZWlnaHQgPiBHLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBDLmNoaWxkMiA9IEY7XG4gICAgICAgICAgICAgICAgICAgIEEuY2hpbGQyID0gRztcbiAgICAgICAgICAgICAgICAgICAgRy5wYXJlbnQgPSBBO1xuICAgICAgICAgICAgICAgICAgICBBLmFhYmIuY29tYmluZShCLmFhYmIsIEcuYWFiYik7XG4gICAgICAgICAgICAgICAgICAgIEMuYWFiYi5jb21iaW5lKEEuYWFiYiwgRi5hYWJiKTtcbiAgICAgICAgICAgICAgICAgICAgQS5oZWlnaHQgPSAxICsgbWF0aCQxLm1heChCLmhlaWdodCwgRy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBDLmhlaWdodCA9IDEgKyBtYXRoJDEubWF4KEEuaGVpZ2h0LCBGLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBDLmNoaWxkMiA9IEc7XG4gICAgICAgICAgICAgICAgICAgIEEuY2hpbGQyID0gRjtcbiAgICAgICAgICAgICAgICAgICAgRi5wYXJlbnQgPSBBO1xuICAgICAgICAgICAgICAgICAgICBBLmFhYmIuY29tYmluZShCLmFhYmIsIEYuYWFiYik7XG4gICAgICAgICAgICAgICAgICAgIEMuYWFiYi5jb21iaW5lKEEuYWFiYiwgRy5hYWJiKTtcbiAgICAgICAgICAgICAgICAgICAgQS5oZWlnaHQgPSAxICsgbWF0aCQxLm1heChCLmhlaWdodCwgRi5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBDLmhlaWdodCA9IDEgKyBtYXRoJDEubWF4KEEuaGVpZ2h0LCBHLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUm90YXRlIEIgdXBcbiAgICAgICAgICAgIGlmIChiYWxhbmNlIDwgLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgRCA9IEIuY2hpbGQxO1xuICAgICAgICAgICAgICAgIHZhciBFID0gQi5jaGlsZDI7XG4gICAgICAgICAgICAgICAgLy8gU3dhcCBBIGFuZCBCXG4gICAgICAgICAgICAgICAgQi5jaGlsZDEgPSBBO1xuICAgICAgICAgICAgICAgIEIucGFyZW50ID0gQS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgQS5wYXJlbnQgPSBCO1xuICAgICAgICAgICAgICAgIC8vIEEncyBvbGQgcGFyZW50IHNob3VsZCBwb2ludCB0byBCXG4gICAgICAgICAgICAgICAgaWYgKEIucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEIucGFyZW50LmNoaWxkMSA9PT0gQSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQi5wYXJlbnQuY2hpbGQxID0gQjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEIucGFyZW50LmNoaWxkMiA9IEI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9yb290ID0gQjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUm90YXRlXG4gICAgICAgICAgICAgICAgaWYgKEQuaGVpZ2h0ID4gRS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgQi5jaGlsZDIgPSBEO1xuICAgICAgICAgICAgICAgICAgICBBLmNoaWxkMSA9IEU7XG4gICAgICAgICAgICAgICAgICAgIEUucGFyZW50ID0gQTtcbiAgICAgICAgICAgICAgICAgICAgQS5hYWJiLmNvbWJpbmUoQy5hYWJiLCBFLmFhYmIpO1xuICAgICAgICAgICAgICAgICAgICBCLmFhYmIuY29tYmluZShBLmFhYmIsIEQuYWFiYik7XG4gICAgICAgICAgICAgICAgICAgIEEuaGVpZ2h0ID0gMSArIG1hdGgkMS5tYXgoQy5oZWlnaHQsIEUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgQi5oZWlnaHQgPSAxICsgbWF0aCQxLm1heChBLmhlaWdodCwgRC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgQi5jaGlsZDIgPSBFO1xuICAgICAgICAgICAgICAgICAgICBBLmNoaWxkMSA9IEQ7XG4gICAgICAgICAgICAgICAgICAgIEQucGFyZW50ID0gQTtcbiAgICAgICAgICAgICAgICAgICAgQS5hYWJiLmNvbWJpbmUoQy5hYWJiLCBELmFhYmIpO1xuICAgICAgICAgICAgICAgICAgICBCLmFhYmIuY29tYmluZShBLmFhYmIsIEUuYWFiYik7XG4gICAgICAgICAgICAgICAgICAgIEEuaGVpZ2h0ID0gMSArIG1hdGgkMS5tYXgoQy5oZWlnaHQsIEQuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgQi5oZWlnaHQgPSAxICsgbWF0aCQxLm1heChBLmhlaWdodCwgRS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHV0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBiaW5hcnkgdHJlZSBpbiBPKE4pIHRpbWUuIFNob3VsZCBub3QgYmUgY2FsbGVkXG4gICAgICAgICAqIG9mdGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fcm9vdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3Jvb3QuaGVpZ2h0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByYXRpbyBvZiB0aGUgc3VtIG9mIHRoZSBub2RlIGFyZWFzIHRvIHRoZSByb290IGFyZWEuXG4gICAgICAgICAqL1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuZ2V0QXJlYVJhdGlvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubV9yb290ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLm1fcm9vdDtcbiAgICAgICAgICAgIHZhciByb290QXJlYSA9IHJvb3QuYWFiYi5nZXRQZXJpbWV0ZXIoKTtcbiAgICAgICAgICAgIHZhciB0b3RhbEFyZWEgPSAwLjA7XG4gICAgICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgICAgIHZhciBpdCA9IHRoaXMuaXRlcmF0b3JQb29sLmFsbG9jYXRlKCkucHJlb3JkZXIodGhpcy5tX3Jvb3QpO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgPSBpdC5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5oZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZyZWUgbm9kZSBpbiBwb29sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3RhbEFyZWEgKz0gbm9kZS5hYWJiLmdldFBlcmltZXRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pdGVyYXRvclBvb2wucmVsZWFzZShpdCk7XG4gICAgICAgICAgICByZXR1cm4gdG90YWxBcmVhIC8gcm9vdEFyZWE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wdXRlIHRoZSBoZWlnaHQgb2YgYSBzdWItdHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5jb21wdXRlSGVpZ2h0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMubV9ub2Rlc1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5tX3Jvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoMCA8PSBpZCAmJiBpZCA8IHRoaXMubV9ub2RlQ2FwYWNpdHkpO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoZWlnaHQxID0gdGhpcy5jb21wdXRlSGVpZ2h0KG5vZGUuY2hpbGQxLmlkKTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQyID0gdGhpcy5jb21wdXRlSGVpZ2h0KG5vZGUuY2hpbGQyLmlkKTtcbiAgICAgICAgICAgIHJldHVybiAxICsgbWF0aCQxLm1heChoZWlnaHQxLCBoZWlnaHQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnZhbGlkYXRlU3RydWN0dXJlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5tX3Jvb3QpIDtcbiAgICAgICAgICAgIHZhciBjaGlsZDEgPSBub2RlLmNoaWxkMTtcbiAgICAgICAgICAgIHZhciBjaGlsZDIgPSBub2RlLmNoaWxkMjtcbiAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVN0cnVjdHVyZShjaGlsZDEpO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVN0cnVjdHVyZShjaGlsZDIpO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUudmFsaWRhdGVNZXRyaWNzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hpbGQxID0gbm9kZS5jaGlsZDE7XG4gICAgICAgICAgICB2YXIgY2hpbGQyID0gbm9kZS5jaGlsZDI7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCgwIDw9IGNoaWxkMSAmJiBjaGlsZDEgPCB0aGlzLm1fbm9kZUNhcGFjaXR5KTtcbiAgICAgICAgICAgIC8vIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCgwIDw9IGNoaWxkMiAmJiBjaGlsZDIgPCB0aGlzLm1fbm9kZUNhcGFjaXR5KTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQxID0gY2hpbGQxLmhlaWdodDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQyID0gY2hpbGQyLmhlaWdodDtcbiAgICAgICAgICAgIDEgKyBtYXRoJDEubWF4KGhlaWdodDEsIGhlaWdodDIpO1xuICAgICAgICAgICAgdmFyIGFhYmIgPSBuZXcgQUFCQigpO1xuICAgICAgICAgICAgYWFiYi5jb21iaW5lKGNoaWxkMS5hYWJiLCBjaGlsZDIuYWFiYik7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlTWV0cmljcyhjaGlsZDEpO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZU1ldHJpY3MoY2hpbGQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkYXRlIHRoaXMgdHJlZS4gRm9yIHRlc3RpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlU3RydWN0dXJlKHRoaXMubV9yb290KTtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVNZXRyaWNzKHRoaXMubV9yb290KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbWF4aW11bSBiYWxhbmNlIG9mIGFuIG5vZGUgaW4gdGhlIHRyZWUuIFRoZSBiYWxhbmNlIGlzIHRoZSBkaWZmZXJlbmNlXG4gICAgICAgICAqIGluIGhlaWdodCBvZiB0aGUgdHdvIGNoaWxkcmVuIG9mIGEgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5nZXRNYXhCYWxhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1heEJhbGFuY2UgPSAwO1xuICAgICAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgICAgICB2YXIgaXQgPSB0aGlzLml0ZXJhdG9yUG9vbC5hbGxvY2F0ZSgpLnByZW9yZGVyKHRoaXMubV9yb290KTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlID0gaXQubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaGVpZ2h0IDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBiYWxhbmNlID0gbWF0aCQxLmFicyhub2RlLmNoaWxkMi5oZWlnaHQgLSBub2RlLmNoaWxkMS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIG1heEJhbGFuY2UgPSBtYXRoJDEubWF4KG1heEJhbGFuY2UsIGJhbGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pdGVyYXRvclBvb2wucmVsZWFzZShpdCk7XG4gICAgICAgICAgICByZXR1cm4gbWF4QmFsYW5jZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1aWxkIGFuIG9wdGltYWwgdHJlZS4gVmVyeSBleHBlbnNpdmUuIEZvciB0ZXN0aW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnJlYnVpbGRCb3R0b21VcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIC8vIEJ1aWxkIGFycmF5IG9mIGxlYXZlcy4gRnJlZSB0aGUgcmVzdC5cbiAgICAgICAgICAgIHZhciBub2RlO1xuICAgICAgICAgICAgdmFyIGl0ID0gdGhpcy5pdGVyYXRvclBvb2wuYWxsb2NhdGUoKS5wcmVvcmRlcih0aGlzLm1fcm9vdCk7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSA9IGl0Lm5leHQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZnJlZSBub2RlIGluIHBvb2xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbY291bnRdID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgKytjb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJlZU5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pdGVyYXRvclBvb2wucmVsZWFzZShpdCk7XG4gICAgICAgICAgICB3aGlsZSAoY291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbkNvc3QgPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICB2YXIgaU1pbiA9IC0xO1xuICAgICAgICAgICAgICAgIHZhciBqTWluID0gLTE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhYWJiaSA9IG5vZGVzW2ldLmFhYmI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IGNvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYWJiaiA9IG5vZGVzW2pdLmFhYmI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IG5ldyBBQUJCKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiLmNvbWJpbmUoYWFiYmksIGFhYmJqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3N0ID0gYi5nZXRQZXJpbWV0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3N0IDwgbWluQ29zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlNaW4gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpNaW4gPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkNvc3QgPSBjb3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaGlsZDEgPSBub2Rlc1tpTWluXTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQyID0gbm9kZXNbak1pbl07XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gdGhpcy5hbGxvY2F0ZU5vZGUoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRfMS5jaGlsZDEgPSBjaGlsZDE7XG4gICAgICAgICAgICAgICAgcGFyZW50XzEuY2hpbGQyID0gY2hpbGQyO1xuICAgICAgICAgICAgICAgIHBhcmVudF8xLmhlaWdodCA9IDEgKyBtYXRoJDEubWF4KGNoaWxkMS5oZWlnaHQsIGNoaWxkMi5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHBhcmVudF8xLmFhYmIuY29tYmluZShjaGlsZDEuYWFiYiwgY2hpbGQyLmFhYmIpO1xuICAgICAgICAgICAgICAgIHBhcmVudF8xLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2hpbGQxLnBhcmVudCA9IHBhcmVudF8xO1xuICAgICAgICAgICAgICAgIGNoaWxkMi5wYXJlbnQgPSBwYXJlbnRfMTtcbiAgICAgICAgICAgICAgICBub2Rlc1tqTWluXSA9IG5vZGVzW2NvdW50IC0gMV07XG4gICAgICAgICAgICAgICAgbm9kZXNbaU1pbl0gPSBwYXJlbnRfMTtcbiAgICAgICAgICAgICAgICAtLWNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX3Jvb3QgPSBub2Rlc1swXTtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNoaWZ0IHRoZSB3b3JsZCBvcmlnaW4uIFVzZWZ1bCBmb3IgbGFyZ2Ugd29ybGRzLiBUaGUgc2hpZnQgZm9ybXVsYSBpczpcbiAgICAgICAgICogcG9zaXRpb24gLT0gbmV3T3JpZ2luXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuZXdPcmlnaW4gVGhlIG5ldyBvcmlnaW4gd2l0aCByZXNwZWN0IHRvIHRoZSBvbGQgb3JpZ2luXG4gICAgICAgICAqL1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuc2hpZnRPcmlnaW4gPSBmdW5jdGlvbiAobmV3T3JpZ2luKSB7XG4gICAgICAgICAgICAvLyBCdWlsZCBhcnJheSBvZiBsZWF2ZXMuIEZyZWUgdGhlIHJlc3QuXG4gICAgICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgICAgIHZhciBpdCA9IHRoaXMuaXRlcmF0b3JQb29sLmFsbG9jYXRlKCkucHJlb3JkZXIodGhpcy5tX3Jvb3QpO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgPSBpdC5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWFiYiA9IG5vZGUuYWFiYjtcbiAgICAgICAgICAgICAgICBhYWJiLmxvd2VyQm91bmQueCAtPSBuZXdPcmlnaW4ueDtcbiAgICAgICAgICAgICAgICBhYWJiLmxvd2VyQm91bmQueSAtPSBuZXdPcmlnaW4ueTtcbiAgICAgICAgICAgICAgICBhYWJiLnVwcGVyQm91bmQueCAtPSBuZXdPcmlnaW4ueDtcbiAgICAgICAgICAgICAgICBhYWJiLnVwcGVyQm91bmQueSAtPSBuZXdPcmlnaW4ueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXRlcmF0b3JQb29sLnJlbGVhc2UoaXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUXVlcnkgYW4gQUFCQiBmb3Igb3ZlcmxhcHBpbmcgcHJveGllcy4gVGhlIGNhbGxiYWNrIGNsYXNzIGlzIGNhbGxlZCBmb3IgZWFjaFxuICAgICAgICAgKiBwcm94eSB0aGF0IG92ZXJsYXBzIHRoZSBzdXBwbGllZCBBQUJCLlxuICAgICAgICAgKi9cbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKGFhYmIsIHF1ZXJ5Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMuc3RhY2tQb29sLmFsbG9jYXRlKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMubV9yb290KTtcbiAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQUFCQi50ZXN0T3ZlcmxhcChub2RlLmFhYmIsIGFhYmIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvY2VlZCA9IHF1ZXJ5Q2FsbGJhY2sobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2VlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5vZGUuY2hpbGQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobm9kZS5jaGlsZDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFja1Bvb2wucmVsZWFzZShzdGFjayk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSYXktY2FzdCBhZ2FpbnN0IHRoZSBwcm94aWVzIGluIHRoZSB0cmVlLiBUaGlzIHJlbGllcyBvbiB0aGUgY2FsbGJhY2sgdG9cbiAgICAgICAgICogcGVyZm9ybSBhIGV4YWN0IHJheS1jYXN0IGluIHRoZSBjYXNlIHdlcmUgdGhlIHByb3h5IGNvbnRhaW5zIGEgc2hhcGUuIFRoZVxuICAgICAgICAgKiBjYWxsYmFjayBhbHNvIHBlcmZvcm1zIHRoZSBhbnkgY29sbGlzaW9uIGZpbHRlcmluZy4gVGhpcyBoYXMgcGVyZm9ybWFuY2VcbiAgICAgICAgICogcm91Z2hseSBlcXVhbCB0byBrICogbG9nKG4pLCB3aGVyZSBrIGlzIHRoZSBudW1iZXIgb2YgY29sbGlzaW9ucyBhbmQgbiBpcyB0aGVcbiAgICAgICAgICogbnVtYmVyIG9mIHByb3hpZXMgaW4gdGhlIHRyZWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgcmF5LWNhc3QgaW5wdXQgZGF0YS4gVGhlIHJheSBleHRlbmRzIGZyb20gYHAxYCB0byBgcDEgKyBtYXhGcmFjdGlvbiAqIChwMiAtIHAxKWAuXG4gICAgICAgICAqIEBwYXJhbSByYXlDYXN0Q2FsbGJhY2sgQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZWFjaCBwcm94eSB0aGF0IGlzIGhpdCBieSB0aGUgcmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbiAoaW5wdXQsIHJheUNhc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHAxID0gaW5wdXQucDE7XG4gICAgICAgICAgICB2YXIgcDIgPSBpbnB1dC5wMjtcbiAgICAgICAgICAgIHZhciByID0gVmVjMi5zdWIocDIsIHAxKTtcbiAgICAgICAgICAgIHIubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAvLyB2IGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIHNlZ21lbnQuXG4gICAgICAgICAgICB2YXIgdiA9IFZlYzIuY3Jvc3NOdW1WZWMyKDEuMCwgcik7XG4gICAgICAgICAgICB2YXIgYWJzX3YgPSBWZWMyLmFicyh2KTtcbiAgICAgICAgICAgIC8vIFNlcGFyYXRpbmcgYXhpcyBmb3Igc2VnbWVudCAoR2lubywgcDgwKS5cbiAgICAgICAgICAgIC8vIHxkb3QodiwgcDEgLSBjKXwgPiBkb3QofHZ8LCBoKVxuICAgICAgICAgICAgdmFyIG1heEZyYWN0aW9uID0gaW5wdXQubWF4RnJhY3Rpb247XG4gICAgICAgICAgICAvLyBCdWlsZCBhIGJvdW5kaW5nIGJveCBmb3IgdGhlIHNlZ21lbnQuXG4gICAgICAgICAgICB2YXIgc2VnbWVudEFBQkIgPSBuZXcgQUFCQigpO1xuICAgICAgICAgICAgdmFyIHQgPSBWZWMyLmNvbWJpbmUoKDEgLSBtYXhGcmFjdGlvbiksIHAxLCBtYXhGcmFjdGlvbiwgcDIpO1xuICAgICAgICAgICAgc2VnbWVudEFBQkIuY29tYmluZVBvaW50cyhwMSwgdCk7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrUG9vbC5hbGxvY2F0ZSgpO1xuICAgICAgICAgICAgdmFyIHN1YklucHV0ID0gdGhpcy5pbnB1dFBvb2wuYWxsb2NhdGUoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5tX3Jvb3QpO1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBQUJCLnRlc3RPdmVybGFwKG5vZGUuYWFiYiwgc2VnbWVudEFBQkIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VwYXJhdGluZyBheGlzIGZvciBzZWdtZW50IChHaW5vLCBwODApLlxuICAgICAgICAgICAgICAgIC8vIHxkb3QodiwgcDEgLSBjKXwgPiBkb3QofHZ8LCBoKVxuICAgICAgICAgICAgICAgIHZhciBjID0gbm9kZS5hYWJiLmdldENlbnRlcigpO1xuICAgICAgICAgICAgICAgIHZhciBoID0gbm9kZS5hYWJiLmdldEV4dGVudHMoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdGlvbiA9IG1hdGgkMS5hYnMoVmVjMi5kb3QodiwgVmVjMi5zdWIocDEsIGMpKSkgLSBWZWMyLmRvdChhYnNfdiwgaCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRpb24gPiAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YklucHV0LnAxID0gVmVjMi5jbG9uZShpbnB1dC5wMSk7XG4gICAgICAgICAgICAgICAgICAgIHN1YklucHV0LnAyID0gVmVjMi5jbG9uZShpbnB1dC5wMik7XG4gICAgICAgICAgICAgICAgICAgIHN1YklucHV0Lm1heEZyYWN0aW9uID0gbWF4RnJhY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJheUNhc3RDYWxsYmFjayhzdWJJbnB1dCwgbm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY2xpZW50IGhhcyB0ZXJtaW5hdGVkIHRoZSByYXkgY2FzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBzZWdtZW50IGJvdW5kaW5nIGJveC5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEZyYWN0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gVmVjMi5jb21iaW5lKCgxIC0gbWF4RnJhY3Rpb24pLCBwMSwgbWF4RnJhY3Rpb24sIHAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRBQUJCLmNvbWJpbmVQb2ludHMocDEsIHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5vZGUuY2hpbGQxKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChub2RlLmNoaWxkMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFja1Bvb2wucmVsZWFzZShzdGFjayk7XG4gICAgICAgICAgICB0aGlzLmlucHV0UG9vbC5yZWxlYXNlKHN1YklucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIER5bmFtaWNUcmVlO1xuICAgIH0oKSk7XG4gICAgdmFyIEl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJdGVyYXRvcigpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBJdGVyYXRvci5wcm90b3R5cGUucHJlb3JkZXIgPSBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnBhcmVudHMucHVzaChyb290KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKDApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMucGFyZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLnBhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucGFyZW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZXNbaV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZXNbaV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVzW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVzW2ldID0gMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGQxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudHMucHVzaChub2RlLmNoaWxkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGQxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlc1tpXSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlc1tpXSA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRzLnB1c2gobm9kZS5jaGlsZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudHMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEl0ZXJhdG9yLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50cy5sZW5ndGggPSAwO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSXRlcmF0b3I7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBUaGUgYnJvYWQtcGhhc2Ugd3JhcHMgYW5kIGV4dGVuZHMgYSBkeW5hbWljLXRyZWUgdG8ga2VlcCB0cmFjayBvZiBtb3ZlZFxuICAgICAqIG9iamVjdHMgYW5kIHF1ZXJ5IHRoZW0gb24gdXBkYXRlLlxuICAgICAqL1xuICAgIHZhciBCcm9hZFBoYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBCcm9hZFBoYXNlKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMubV90cmVlID0gbmV3IER5bmFtaWNUcmVlKCk7XG4gICAgICAgICAgICB0aGlzLm1fcHJveHlDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLm1fbW92ZUJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBRdWVyeSBhbiBBQUJCIGZvciBvdmVybGFwcGluZyBwcm94aWVzLiBUaGUgY2FsbGJhY2sgY2xhc3MgaXMgY2FsbGVkIGZvciBlYWNoXG4gICAgICAgICAgICAgKiBwcm94eSB0aGF0IG92ZXJsYXBzIHRoZSBzdXBwbGllZCBBQUJCLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gZnVuY3Rpb24gKGFhYmIsIHF1ZXJ5Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX3RyZWUucXVlcnkoYWFiYiwgcXVlcnlDYWxsYmFjayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5xdWVyeUNhbGxiYWNrID0gZnVuY3Rpb24gKHByb3h5SWQpIHtcbiAgICAgICAgICAgICAgICAvLyBBIHByb3h5IGNhbm5vdCBmb3JtIGEgcGFpciB3aXRoIGl0c2VsZi5cbiAgICAgICAgICAgICAgICBpZiAocHJveHlJZCA9PT0gX3RoaXMubV9xdWVyeVByb3h5SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwcm94eUlkQSA9IG1hdGgkMS5taW4ocHJveHlJZCwgX3RoaXMubV9xdWVyeVByb3h5SWQpO1xuICAgICAgICAgICAgICAgIHZhciBwcm94eUlkQiA9IG1hdGgkMS5tYXgocHJveHlJZCwgX3RoaXMubV9xdWVyeVByb3h5SWQpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFNraXAgYW55IGR1cGxpY2F0ZSBwYWlycy5cbiAgICAgICAgICAgICAgICB2YXIgdXNlckRhdGFBID0gX3RoaXMubV90cmVlLmdldFVzZXJEYXRhKHByb3h5SWRBKTtcbiAgICAgICAgICAgICAgICB2YXIgdXNlckRhdGFCID0gX3RoaXMubV90cmVlLmdldFVzZXJEYXRhKHByb3h5SWRCKTtcbiAgICAgICAgICAgICAgICAvLyBTZW5kIHRoZSBwYWlycyBiYWNrIHRvIHRoZSBjbGllbnQuXG4gICAgICAgICAgICAgICAgX3RoaXMubV9jYWxsYmFjayh1c2VyRGF0YUEsIHVzZXJEYXRhQik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdXNlciBkYXRhIGZyb20gYSBwcm94eS4gUmV0dXJucyBudWxsIGlmIHRoZSBpZCBpcyBpbnZhbGlkLlxuICAgICAgICAgKi9cbiAgICAgICAgQnJvYWRQaGFzZS5wcm90b3R5cGUuZ2V0VXNlckRhdGEgPSBmdW5jdGlvbiAocHJveHlJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV90cmVlLmdldFVzZXJEYXRhKHByb3h5SWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCBvdmVybGFwIG9mIGZhdCBBQUJCcy5cbiAgICAgICAgICovXG4gICAgICAgIEJyb2FkUGhhc2UucHJvdG90eXBlLnRlc3RPdmVybGFwID0gZnVuY3Rpb24gKHByb3h5SWRBLCBwcm94eUlkQikge1xuICAgICAgICAgICAgdmFyIGFhYmJBID0gdGhpcy5tX3RyZWUuZ2V0RmF0QUFCQihwcm94eUlkQSk7XG4gICAgICAgICAgICB2YXIgYWFiYkIgPSB0aGlzLm1fdHJlZS5nZXRGYXRBQUJCKHByb3h5SWRCKTtcbiAgICAgICAgICAgIHJldHVybiBBQUJCLnRlc3RPdmVybGFwKGFhYmJBLCBhYWJiQik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGZhdCBBQUJCIGZvciBhIHByb3h5LlxuICAgICAgICAgKi9cbiAgICAgICAgQnJvYWRQaGFzZS5wcm90b3R5cGUuZ2V0RmF0QUFCQiA9IGZ1bmN0aW9uIChwcm94eUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3RyZWUuZ2V0RmF0QUFCQihwcm94eUlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIHByb3hpZXMuXG4gICAgICAgICAqL1xuICAgICAgICBCcm9hZFBoYXNlLnByb3RvdHlwZS5nZXRQcm94eUNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9wcm94eUNvdW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBoZWlnaHQgb2YgdGhlIGVtYmVkZGVkIHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBCcm9hZFBoYXNlLnByb3RvdHlwZS5nZXRUcmVlSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV90cmVlLmdldEhlaWdodCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBiYWxhbmNlIChpbnRlZ2VyKSBvZiB0aGUgZW1iZWRkZWQgdHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIEJyb2FkUGhhc2UucHJvdG90eXBlLmdldFRyZWVCYWxhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV90cmVlLmdldE1heEJhbGFuY2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcXVhbGl0eSBtZXRyaWMgb2YgdGhlIGVtYmVkZGVkIHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBCcm9hZFBoYXNlLnByb3RvdHlwZS5nZXRUcmVlUXVhbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdHJlZS5nZXRBcmVhUmF0aW8oKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJheS1jYXN0IGFnYWluc3QgdGhlIHByb3hpZXMgaW4gdGhlIHRyZWUuIFRoaXMgcmVsaWVzIG9uIHRoZSBjYWxsYmFjayB0b1xuICAgICAgICAgKiBwZXJmb3JtIGEgZXhhY3QgcmF5LWNhc3QgaW4gdGhlIGNhc2Ugd2VyZSB0aGUgcHJveHkgY29udGFpbnMgYSBzaGFwZS4gVGhlXG4gICAgICAgICAqIGNhbGxiYWNrIGFsc28gcGVyZm9ybXMgdGhlIGFueSBjb2xsaXNpb24gZmlsdGVyaW5nLiBUaGlzIGhhcyBwZXJmb3JtYW5jZVxuICAgICAgICAgKiByb3VnaGx5IGVxdWFsIHRvIGsgKiBsb2cobiksIHdoZXJlIGsgaXMgdGhlIG51bWJlciBvZiBjb2xsaXNpb25zIGFuZCBuIGlzIHRoZVxuICAgICAgICAgKiBudW1iZXIgb2YgcHJveGllcyBpbiB0aGUgdHJlZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGlucHV0IFRoZSByYXktY2FzdCBpbnB1dCBkYXRhLiBUaGUgcmF5IGV4dGVuZHMgZnJvbSBgcDFgIHRvIGBwMSArIG1heEZyYWN0aW9uICogKHAyIC0gcDEpYC5cbiAgICAgICAgICogQHBhcmFtIHJheUNhc3RDYWxsYmFjayBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGZvciBlYWNoIHByb3h5IHRoYXQgaXMgaGl0IGJ5IHRoZSByYXkuXG4gICAgICAgICAqL1xuICAgICAgICBCcm9hZFBoYXNlLnByb3RvdHlwZS5yYXlDYXN0ID0gZnVuY3Rpb24gKGlucHV0LCByYXlDYXN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMubV90cmVlLnJheUNhc3QoaW5wdXQsIHJheUNhc3RDYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaGlmdCB0aGUgd29ybGQgb3JpZ2luLiBVc2VmdWwgZm9yIGxhcmdlIHdvcmxkcy4gVGhlIHNoaWZ0IGZvcm11bGEgaXM6XG4gICAgICAgICAqIHBvc2l0aW9uIC09IG5ld09yaWdpblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmV3T3JpZ2luIFRoZSBuZXcgb3JpZ2luIHdpdGggcmVzcGVjdCB0byB0aGUgb2xkIG9yaWdpblxuICAgICAgICAgKi9cbiAgICAgICAgQnJvYWRQaGFzZS5wcm90b3R5cGUuc2hpZnRPcmlnaW4gPSBmdW5jdGlvbiAobmV3T3JpZ2luKSB7XG4gICAgICAgICAgICB0aGlzLm1fdHJlZS5zaGlmdE9yaWdpbihuZXdPcmlnaW4pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgcHJveHkgd2l0aCBhbiBpbml0aWFsIEFBQkIuIFBhaXJzIGFyZSBub3QgcmVwb3J0ZWQgdW50aWwgVXBkYXRlUGFpcnNcbiAgICAgICAgICogaXMgY2FsbGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgQnJvYWRQaGFzZS5wcm90b3R5cGUuY3JlYXRlUHJveHkgPSBmdW5jdGlvbiAoYWFiYiwgdXNlckRhdGEpIHtcbiAgICAgICAgICAgIHZhciBwcm94eUlkID0gdGhpcy5tX3RyZWUuY3JlYXRlUHJveHkoYWFiYiwgdXNlckRhdGEpO1xuICAgICAgICAgICAgdGhpcy5tX3Byb3h5Q291bnQrKztcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTW92ZShwcm94eUlkKTtcbiAgICAgICAgICAgIHJldHVybiBwcm94eUlkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveSBhIHByb3h5LiBJdCBpcyB1cCB0byB0aGUgY2xpZW50IHRvIHJlbW92ZSBhbnkgcGFpcnMuXG4gICAgICAgICAqL1xuICAgICAgICBCcm9hZFBoYXNlLnByb3RvdHlwZS5kZXN0cm95UHJveHkgPSBmdW5jdGlvbiAocHJveHlJZCkge1xuICAgICAgICAgICAgdGhpcy51bmJ1ZmZlck1vdmUocHJveHlJZCk7XG4gICAgICAgICAgICB0aGlzLm1fcHJveHlDb3VudC0tO1xuICAgICAgICAgICAgdGhpcy5tX3RyZWUuZGVzdHJveVByb3h5KHByb3h5SWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbCBtb3ZlUHJveHkgYXMgbWFueSB0aW1lcyBhcyB5b3UgbGlrZSwgdGhlbiB3aGVuIHlvdSBhcmUgZG9uZSBjYWxsXG4gICAgICAgICAqIFVwZGF0ZVBhaXJzIHRvIGZpbmFsaXplZCB0aGUgcHJveHkgcGFpcnMgKGZvciB5b3VyIHRpbWUgc3RlcCkuXG4gICAgICAgICAqL1xuICAgICAgICBCcm9hZFBoYXNlLnByb3RvdHlwZS5tb3ZlUHJveHkgPSBmdW5jdGlvbiAocHJveHlJZCwgYWFiYiwgZGlzcGxhY2VtZW50KSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IHRoaXMubV90cmVlLm1vdmVQcm94eShwcm94eUlkLCBhYWJiLCBkaXNwbGFjZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlck1vdmUocHJveHlJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsIHRvIHRyaWdnZXIgYSByZS1wcm9jZXNzaW5nIG9mIGl0J3MgcGFpcnMgb24gdGhlIG5leHQgY2FsbCB0b1xuICAgICAgICAgKiBVcGRhdGVQYWlycy5cbiAgICAgICAgICovXG4gICAgICAgIEJyb2FkUGhhc2UucHJvdG90eXBlLnRvdWNoUHJveHkgPSBmdW5jdGlvbiAocHJveHlJZCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJNb3ZlKHByb3h5SWQpO1xuICAgICAgICB9O1xuICAgICAgICBCcm9hZFBoYXNlLnByb3RvdHlwZS5idWZmZXJNb3ZlID0gZnVuY3Rpb24gKHByb3h5SWQpIHtcbiAgICAgICAgICAgIHRoaXMubV9tb3ZlQnVmZmVyLnB1c2gocHJveHlJZCk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb2FkUGhhc2UucHJvdG90eXBlLnVuYnVmZmVyTW92ZSA9IGZ1bmN0aW9uIChwcm94eUlkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9tb3ZlQnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubV9tb3ZlQnVmZmVyW2ldID09PSBwcm94eUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9tb3ZlQnVmZmVyW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIHBhaXJzLiBUaGlzIHJlc3VsdHMgaW4gcGFpciBjYWxsYmFja3MuIFRoaXMgY2FuIG9ubHkgYWRkIHBhaXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgQnJvYWRQaGFzZS5wcm90b3R5cGUudXBkYXRlUGFpcnMgPSBmdW5jdGlvbiAoYWRkUGFpckNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLm1fY2FsbGJhY2sgPSBhZGRQYWlyQ2FsbGJhY2s7XG4gICAgICAgICAgICAvLyBQZXJmb3JtIHRyZWUgcXVlcmllcyBmb3IgYWxsIG1vdmluZyBwcm94aWVzLlxuICAgICAgICAgICAgd2hpbGUgKHRoaXMubV9tb3ZlQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fcXVlcnlQcm94eUlkID0gdGhpcy5tX21vdmVCdWZmZXIucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubV9xdWVyeVByb3h5SWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gcXVlcnkgdGhlIHRyZWUgd2l0aCB0aGUgZmF0IEFBQkIgc28gdGhhdFxuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGZhaWwgdG8gY3JlYXRlIGEgcGFpciB0aGF0IG1heSB0b3VjaCBsYXRlci5cbiAgICAgICAgICAgICAgICB2YXIgZmF0QUFCQiA9IHRoaXMubV90cmVlLmdldEZhdEFBQkIodGhpcy5tX3F1ZXJ5UHJveHlJZCk7XG4gICAgICAgICAgICAgICAgLy8gUXVlcnkgdHJlZSwgY3JlYXRlIHBhaXJzIGFuZCBhZGQgdGhlbSBwYWlyIGJ1ZmZlci5cbiAgICAgICAgICAgICAgICB0aGlzLm1fdHJlZS5xdWVyeShmYXRBQUJCLCB0aGlzLnF1ZXJ5Q2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHJ5IHRvIGtlZXAgdGhlIHRyZWUgYmFsYW5jZWQuXG4gICAgICAgICAgICAvLyB0aGlzLm1fdHJlZS5yZWJhbGFuY2UoNCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCcm9hZFBoYXNlO1xuICAgIH0oKSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgdmFyIFJvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqIEluaXRpYWxpemUgZnJvbSBhbiBhbmdsZSBpbiByYWRpYW5zLiAqL1xuICAgICAgICBmdW5jdGlvbiBSb3QoYW5nbGUpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSb3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSb3QoYW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbmdsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFuZ2xlKGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhbmdsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJvdChhbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldElkZW50aXR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBSb3QubmVvID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShSb3QucHJvdG90eXBlKTtcbiAgICAgICAgICAgIG9iai5zZXRBbmdsZShhbmdsZSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9O1xuICAgICAgICBSb3QuY2xvbmUgPSBmdW5jdGlvbiAocm90KSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShSb3QucHJvdG90eXBlKTtcbiAgICAgICAgICAgIG9iai5zID0gcm90LnM7XG4gICAgICAgICAgICBvYmouYyA9IHJvdC5jO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcbiAgICAgICAgUm90LmlkZW50aXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoUm90LnByb3RvdHlwZSk7XG4gICAgICAgICAgICBvYmoucyA9IDAuMDtcbiAgICAgICAgICAgIG9iai5jID0gMS4wO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcbiAgICAgICAgUm90LmlzVmFsaWQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGgkMS5pc0Zpbml0ZShvYmoucykgJiYgbWF0aCQxLmlzRmluaXRlKG9iai5jKTtcbiAgICAgICAgfTtcbiAgICAgICAgUm90LmFzc2VydCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBTZXQgdG8gdGhlIGlkZW50aXR5IHJvdGF0aW9uLiAqL1xuICAgICAgICBSb3QucHJvdG90eXBlLnNldElkZW50aXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5jID0gMS4wO1xuICAgICAgICB9O1xuICAgICAgICBSb3QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbmdsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnMgPSBhbmdsZS5zO1xuICAgICAgICAgICAgICAgIHRoaXMuYyA9IGFuZ2xlLmM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPX0VSSU4gb3B0aW1pemVcbiAgICAgICAgICAgICAgICB0aGlzLnMgPSBtYXRoJDEuc2luKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmMgPSBtYXRoJDEuY29zKGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUm90LnByb3RvdHlwZS5zZXRSb3QgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgICAgIHRoaXMucyA9IGFuZ2xlLnM7XG4gICAgICAgICAgICB0aGlzLmMgPSBhbmdsZS5jO1xuICAgICAgICB9O1xuICAgICAgICAvKiogU2V0IHVzaW5nIGFuIGFuZ2xlIGluIHJhZGlhbnMuICovXG4gICAgICAgIFJvdC5wcm90b3R5cGUuc2V0QW5nbGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE9fRVJJTiBvcHRpbWl6ZVxuICAgICAgICAgICAgdGhpcy5zID0gbWF0aCQxLnNpbihhbmdsZSk7XG4gICAgICAgICAgICB0aGlzLmMgPSBtYXRoJDEuY29zKGFuZ2xlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEdldCB0aGUgYW5nbGUgaW4gcmFkaWFucy4gKi9cbiAgICAgICAgUm90LnByb3RvdHlwZS5nZXRBbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoJDEuYXRhbjIodGhpcy5zLCB0aGlzLmMpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogR2V0IHRoZSB4LWF4aXMuICovXG4gICAgICAgIFJvdC5wcm90b3R5cGUuZ2V0WEF4aXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8odGhpcy5jLCB0aGlzLnMpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogR2V0IHRoZSB1LWF4aXMuICovXG4gICAgICAgIFJvdC5wcm90b3R5cGUuZ2V0WUF4aXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oLXRoaXMucywgdGhpcy5jKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgUm90Lm11bCA9IGZ1bmN0aW9uIChyb3QsIG0pIHtcbiAgICAgICAgICAgIGlmICgnYycgaW4gbSAmJiAncycgaW4gbSkge1xuICAgICAgICAgICAgICAgIC8vIFtxYyAtcXNdICogW3JjIC1yc10gPSBbcWMqcmMtcXMqcnMgLXFjKnJzLXFzKnJjXVxuICAgICAgICAgICAgICAgIC8vIFtxcyBxY10gW3JzIHJjXSBbcXMqcmMrcWMqcnMgLXFzKnJzK3FjKnJjXVxuICAgICAgICAgICAgICAgIC8vIHMgPSBxcyAqIHJjICsgcWMgKiByc1xuICAgICAgICAgICAgICAgIC8vIGMgPSBxYyAqIHJjIC0gcXMgKiByc1xuICAgICAgICAgICAgICAgIHZhciBxciA9IFJvdC5pZGVudGl0eSgpO1xuICAgICAgICAgICAgICAgIHFyLnMgPSByb3QucyAqIG0uYyArIHJvdC5jICogbS5zO1xuICAgICAgICAgICAgICAgIHFyLmMgPSByb3QuYyAqIG0uYyAtIHJvdC5zICogbS5zO1xuICAgICAgICAgICAgICAgIHJldHVybiBxcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCd4JyBpbiBtICYmICd5JyBpbiBtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHJvdC5jICogbS54IC0gcm90LnMgKiBtLnksIHJvdC5zICogbS54ICsgcm90LmMgKiBtLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogTXVsdGlwbHkgdHdvIHJvdGF0aW9uczogcSAqIHIgKi9cbiAgICAgICAgUm90Lm11bFJvdCA9IGZ1bmN0aW9uIChyb3QsIG0pIHtcbiAgICAgICAgICAgIC8vIFtxYyAtcXNdICogW3JjIC1yc10gPSBbcWMqcmMtcXMqcnMgLXFjKnJzLXFzKnJjXVxuICAgICAgICAgICAgLy8gW3FzIHFjXSBbcnMgcmNdIFtxcypyYytxYypycyAtcXMqcnMrcWMqcmNdXG4gICAgICAgICAgICAvLyBzID0gcXMgKiByYyArIHFjICogcnNcbiAgICAgICAgICAgIC8vIGMgPSBxYyAqIHJjIC0gcXMgKiByc1xuICAgICAgICAgICAgdmFyIHFyID0gUm90LmlkZW50aXR5KCk7XG4gICAgICAgICAgICBxci5zID0gcm90LnMgKiBtLmMgKyByb3QuYyAqIG0ucztcbiAgICAgICAgICAgIHFyLmMgPSByb3QuYyAqIG0uYyAtIHJvdC5zICogbS5zO1xuICAgICAgICAgICAgcmV0dXJuIHFyO1xuICAgICAgICB9O1xuICAgICAgICAvKiogUm90YXRlIGEgdmVjdG9yICovXG4gICAgICAgIFJvdC5tdWxWZWMyID0gZnVuY3Rpb24gKHJvdCwgbSkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHJvdC5jICogbS54IC0gcm90LnMgKiBtLnksIHJvdC5zICogbS54ICsgcm90LmMgKiBtLnkpO1xuICAgICAgICB9O1xuICAgICAgICBSb3QubXVsU3ViID0gZnVuY3Rpb24gKHJvdCwgdiwgdykge1xuICAgICAgICAgICAgdmFyIHggPSByb3QuYyAqICh2LnggLSB3LngpIC0gcm90LnMgKiAodi55IC0gdy55KTtcbiAgICAgICAgICAgIHZhciB5ID0gcm90LnMgKiAodi54IC0gdy54KSArIHJvdC5jICogKHYueSAtIHcueSk7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oeCwgeSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0eXBlZGVmXG4gICAgICAgIFJvdC5tdWxUID0gZnVuY3Rpb24gKHJvdCwgbSkge1xuICAgICAgICAgICAgaWYgKCdjJyBpbiBtICYmICdzJyBpbiBtKSB7XG4gICAgICAgICAgICAgICAgLy8gWyBxYyBxc10gKiBbcmMgLXJzXSA9IFtxYypyYytxcypycyAtcWMqcnMrcXMqcmNdXG4gICAgICAgICAgICAgICAgLy8gWy1xcyBxY10gW3JzIHJjXSBbLXFzKnJjK3FjKnJzIHFzKnJzK3FjKnJjXVxuICAgICAgICAgICAgICAgIC8vIHMgPSBxYyAqIHJzIC0gcXMgKiByY1xuICAgICAgICAgICAgICAgIC8vIGMgPSBxYyAqIHJjICsgcXMgKiByc1xuICAgICAgICAgICAgICAgIHZhciBxciA9IFJvdC5pZGVudGl0eSgpO1xuICAgICAgICAgICAgICAgIHFyLnMgPSByb3QuYyAqIG0ucyAtIHJvdC5zICogbS5jO1xuICAgICAgICAgICAgICAgIHFyLmMgPSByb3QuYyAqIG0uYyArIHJvdC5zICogbS5zO1xuICAgICAgICAgICAgICAgIHJldHVybiBxcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCd4JyBpbiBtICYmICd5JyBpbiBtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHJvdC5jICogbS54ICsgcm90LnMgKiBtLnksIC1yb3QucyAqIG0ueCArIHJvdC5jICogbS55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIFRyYW5zcG9zZSBtdWx0aXBseSB0d28gcm90YXRpb25zOiBxVCAqIHIgKi9cbiAgICAgICAgUm90Lm11bFRSb3QgPSBmdW5jdGlvbiAocm90LCBtKSB7XG4gICAgICAgICAgICAvLyBbIHFjIHFzXSAqIFtyYyAtcnNdID0gW3FjKnJjK3FzKnJzIC1xYypycytxcypyY11cbiAgICAgICAgICAgIC8vIFstcXMgcWNdIFtycyByY10gWy1xcypyYytxYypycyBxcypycytxYypyY11cbiAgICAgICAgICAgIC8vIHMgPSBxYyAqIHJzIC0gcXMgKiByY1xuICAgICAgICAgICAgLy8gYyA9IHFjICogcmMgKyBxcyAqIHJzXG4gICAgICAgICAgICB2YXIgcXIgPSBSb3QuaWRlbnRpdHkoKTtcbiAgICAgICAgICAgIHFyLnMgPSByb3QuYyAqIG0ucyAtIHJvdC5zICogbS5jO1xuICAgICAgICAgICAgcXIuYyA9IHJvdC5jICogbS5jICsgcm90LnMgKiBtLnM7XG4gICAgICAgICAgICByZXR1cm4gcXI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBJbnZlcnNlIHJvdGF0ZSBhIHZlY3RvciAqL1xuICAgICAgICBSb3QubXVsVFZlYzIgPSBmdW5jdGlvbiAocm90LCBtKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8ocm90LmMgKiBtLnggKyByb3QucyAqIG0ueSwgLXJvdC5zICogbS54ICsgcm90LmMgKiBtLnkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUm90O1xuICAgIH0oKSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQSB0cmFuc2Zvcm0gY29udGFpbnMgdHJhbnNsYXRpb24gYW5kIHJvdGF0aW9uLiBJdCBpcyB1c2VkIHRvIHJlcHJlc2VudCB0aGVcbiAgICAgKiBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgcmlnaWQgZnJhbWVzLiBJbml0aWFsaXplIHVzaW5nIGEgcG9zaXRpb24gdmVjdG9yXG4gICAgICogYW5kIGEgcm90YXRpb24uXG4gICAgICovXG4gICAgdmFyIFRyYW5zZm9ybSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVHJhbnNmb3JtKHBvc2l0aW9uLCByb3RhdGlvbikge1xuICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShwb3NpdGlvbiwgcm90YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICB0aGlzLnEgPSBSb3QuaWRlbnRpdHkoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wLnNldFZlYzIocG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiByb3RhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnEuc2V0QW5nbGUocm90YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFRyYW5zZm9ybS5jbG9uZSA9IGZ1bmN0aW9uICh4Zikge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBvYmoucCA9IFZlYzIuY2xvbmUoeGYucCk7XG4gICAgICAgICAgICBvYmoucSA9IFJvdC5jbG9uZSh4Zi5xKTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgVHJhbnNmb3JtLm5lbyA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgcm90YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgb2JqLnAgPSBWZWMyLmNsb25lKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIG9iai5xID0gUm90LmNsb25lKHJvdGF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zZm9ybS5pZGVudGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgb2JqLnAgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIG9iai5xID0gUm90LmlkZW50aXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgdG8gdGhlIGlkZW50aXR5IHRyYW5zZm9ybS5cbiAgICAgICAgICovXG4gICAgICAgIFRyYW5zZm9ybS5wcm90b3R5cGUuc2V0SWRlbnRpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnAuc2V0WmVybygpO1xuICAgICAgICAgICAgdGhpcy5xLnNldElkZW50aXR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyBiYXNlZCBvbiB0aGUgcG9zaXRpb24gYW5kIGFuZ2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgVHJhbnNmb3JtLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMucC5zZXQoYS5wKTtcbiAgICAgICAgICAgICAgICB0aGlzLnEuc2V0KGEucSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnAuc2V0KGEpO1xuICAgICAgICAgICAgICAgIHRoaXMucS5zZXQoYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyBiYXNlZCBvbiB0aGUgcG9zaXRpb24gYW5kIGFuZ2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgVHJhbnNmb3JtLnByb3RvdHlwZS5zZXROdW0gPSBmdW5jdGlvbiAocG9zaXRpb24sIHJvdGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnAuc2V0VmVjMihwb3NpdGlvbik7XG4gICAgICAgICAgICB0aGlzLnEuc2V0QW5nbGUocm90YXRpb24pO1xuICAgICAgICB9O1xuICAgICAgICBUcmFuc2Zvcm0ucHJvdG90eXBlLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh4Zikge1xuICAgICAgICAgICAgdGhpcy5wLnNldFZlYzIoeGYucCk7XG4gICAgICAgICAgICB0aGlzLnEuc2V0Um90KHhmLnEpO1xuICAgICAgICB9O1xuICAgICAgICBUcmFuc2Zvcm0uaXNWYWxpZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5pc1ZhbGlkKG9iai5wKSAmJiBSb3QuaXNWYWxpZChvYmoucSk7XG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zZm9ybS5hc3NlcnQgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICAvLyBzdGF0aWMgbXVsKGE6IFRyYW5zZm9ybSwgYjogVmVjMltdKTogVmVjMltdO1xuICAgICAgICAvLyBzdGF0aWMgbXVsKGE6IFRyYW5zZm9ybSwgYjogVHJhbnNmb3JtW10pOiBUcmFuc2Zvcm1bXTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgVHJhbnNmb3JtLm11bCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICAgICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyW2ldID0gVHJhbnNmb3JtLm11bChhLCBiW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCd4JyBpbiBiICYmICd5JyBpbiBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybS5tdWxWZWMyKGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ3AnIGluIGIgJiYgJ3EnIGluIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtLm11bFhmKGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHlwZWRlZlxuICAgICAgICBUcmFuc2Zvcm0ubXVsQWxsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IFRyYW5zZm9ybS5tdWwoYSwgYltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsIEBkZXByZWNhdGVkICovXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0eXBlZGVmXG4gICAgICAgIFRyYW5zZm9ybS5tdWxGbiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtLm11bChhLCBiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zZm9ybS5tdWxWZWMyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gKGEucS5jICogYi54IC0gYS5xLnMgKiBiLnkpICsgYS5wLng7XG4gICAgICAgICAgICB2YXIgeSA9IChhLnEucyAqIGIueCArIGEucS5jICogYi55KSArIGEucC55O1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHgsIHkpO1xuICAgICAgICB9O1xuICAgICAgICBUcmFuc2Zvcm0ubXVsWGYgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgLy8gdjIgPSBBLnEuUm90KEIucS5Sb3QodjEpICsgQi5wKSArIEEucFxuICAgICAgICAgICAgLy8gPSAoQS5xICogQi5xKS5Sb3QodjEpICsgQS5xLlJvdChCLnApICsgQS5wXG4gICAgICAgICAgICB2YXIgeGYgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgICAgIHhmLnEgPSBSb3QubXVsUm90KGEucSwgYi5xKTtcbiAgICAgICAgICAgIHhmLnAgPSBWZWMyLmFkZChSb3QubXVsVmVjMihhLnEsIGIucCksIGEucCk7XG4gICAgICAgICAgICByZXR1cm4geGY7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0eXBlZGVmXG4gICAgICAgIFRyYW5zZm9ybS5tdWxUID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmICgneCcgaW4gYiAmJiAneScgaW4gYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm0ubXVsVFZlYzIoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgncCcgaW4gYiAmJiAncScgaW4gYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm0ubXVsVFhmKGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBUcmFuc2Zvcm0ubXVsVFZlYzIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgdmFyIHB4ID0gYi54IC0gYS5wLng7XG4gICAgICAgICAgICB2YXIgcHkgPSBiLnkgLSBhLnAueTtcbiAgICAgICAgICAgIHZhciB4ID0gKGEucS5jICogcHggKyBhLnEucyAqIHB5KTtcbiAgICAgICAgICAgIHZhciB5ID0gKC1hLnEucyAqIHB4ICsgYS5xLmMgKiBweSk7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oeCwgeSk7XG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zZm9ybS5tdWxUWGYgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgLy8gdjIgPSBBLnEnICogKEIucSAqIHYxICsgQi5wIC0gQS5wKVxuICAgICAgICAgICAgLy8gPSBBLnEnICogQi5xICogdjEgKyBBLnEnICogKEIucCAtIEEucClcbiAgICAgICAgICAgIHZhciB4ZiA9IFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuICAgICAgICAgICAgeGYucS5zZXRSb3QoUm90Lm11bFRSb3QoYS5xLCBiLnEpKTtcbiAgICAgICAgICAgIHhmLnAuc2V0VmVjMihSb3QubXVsVFZlYzIoYS5xLCBWZWMyLnN1YihiLnAsIGEucCkpKTtcbiAgICAgICAgICAgIHJldHVybiB4ZjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRyYW5zZm9ybTtcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgZGVzY3JpYmVzIHRoZSBtb3Rpb24gb2YgYSBib2R5L3NoYXBlIGZvciBUT0kgY29tcHV0YXRpb24uIFNoYXBlcyBhcmVcbiAgICAgKiBkZWZpbmVkIHdpdGggcmVzcGVjdCB0byB0aGUgYm9keSBvcmlnaW4sIHdoaWNoIG1heSBub3QgY29pbmNpZGUgd2l0aCB0aGVcbiAgICAgKiBjZW50ZXIgb2YgbWFzcy4gSG93ZXZlciwgdG8gc3VwcG9ydCBkeW5hbWljcyB3ZSBtdXN0IGludGVycG9sYXRlIHRoZSBjZW50ZXJcbiAgICAgKiBvZiBtYXNzIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHZhciBTd2VlcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3dlZXAoYywgYSkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbENlbnRlciA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgdGhpcy5jID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICB0aGlzLmEgPSAwO1xuICAgICAgICAgICAgdGhpcy5hbHBoYTAgPSAwO1xuICAgICAgICAgICAgdGhpcy5jMCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgdGhpcy5hMCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgU3dlZXAucHJvdG90eXBlLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh4Zikge1xuICAgICAgICAgICAgdmFyIGMgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZiwgdGhpcy5sb2NhbENlbnRlcik7XG4gICAgICAgICAgICB0aGlzLmMuc2V0VmVjMihjKTtcbiAgICAgICAgICAgIHRoaXMuYzAuc2V0VmVjMihjKTtcbiAgICAgICAgICAgIHRoaXMuYSA9IHhmLnEuZ2V0QW5nbGUoKTtcbiAgICAgICAgICAgIHRoaXMuYTAgPSB4Zi5xLmdldEFuZ2xlKCk7XG4gICAgICAgIH07XG4gICAgICAgIFN3ZWVwLnByb3RvdHlwZS5zZXRMb2NhbENlbnRlciA9IGZ1bmN0aW9uIChsb2NhbENlbnRlciwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxDZW50ZXIuc2V0VmVjMihsb2NhbENlbnRlcik7XG4gICAgICAgICAgICB2YXIgYyA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmLCB0aGlzLmxvY2FsQ2VudGVyKTtcbiAgICAgICAgICAgIHRoaXMuYy5zZXRWZWMyKGMpO1xuICAgICAgICAgICAgdGhpcy5jMC5zZXRWZWMyKGMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBpbnRlcnBvbGF0ZWQgdHJhbnNmb3JtIGF0IGEgc3BlY2lmaWMgdGltZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHhmXG4gICAgICAgICAqIEBwYXJhbSBiZXRhIEEgZmFjdG9yIGluIFswLDFdLCB3aGVyZSAwIGluZGljYXRlcyBhbHBoYTBcbiAgICAgICAgICovXG4gICAgICAgIFN3ZWVwLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoeGYsIGJldGEpIHtcbiAgICAgICAgICAgIGlmIChiZXRhID09PSB2b2lkIDApIHsgYmV0YSA9IDA7IH1cbiAgICAgICAgICAgIHhmLnEuc2V0QW5nbGUoKDEuMCAtIGJldGEpICogdGhpcy5hMCArIGJldGEgKiB0aGlzLmEpO1xuICAgICAgICAgICAgeGYucC5zZXRDb21iaW5lKCgxLjAgLSBiZXRhKSwgdGhpcy5jMCwgYmV0YSwgdGhpcy5jKTtcbiAgICAgICAgICAgIC8vIHNoaWZ0IHRvIG9yaWdpblxuICAgICAgICAgICAgeGYucC5zdWIoUm90Lm11bFZlYzIoeGYucSwgdGhpcy5sb2NhbENlbnRlcikpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWR2YW5jZSB0aGUgc3dlZXAgZm9yd2FyZCwgeWllbGRpbmcgYSBuZXcgaW5pdGlhbCBzdGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGFscGhhIFRoZSBuZXcgaW5pdGlhbCB0aW1lXG4gICAgICAgICAqL1xuICAgICAgICBTd2VlcC5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgICAgICAgdmFyIGJldGEgPSAoYWxwaGEgLSB0aGlzLmFscGhhMCkgLyAoMS4wIC0gdGhpcy5hbHBoYTApO1xuICAgICAgICAgICAgdGhpcy5jMC5zZXRDb21iaW5lKGJldGEsIHRoaXMuYywgMSAtIGJldGEsIHRoaXMuYzApO1xuICAgICAgICAgICAgdGhpcy5hMCA9IGJldGEgKiB0aGlzLmEgKyAoMSAtIGJldGEpICogdGhpcy5hMDtcbiAgICAgICAgICAgIHRoaXMuYWxwaGEwID0gYWxwaGE7XG4gICAgICAgIH07XG4gICAgICAgIFN3ZWVwLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hMCA9IHRoaXMuYTtcbiAgICAgICAgICAgIHRoaXMuYzAuc2V0VmVjMih0aGlzLmMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogbm9ybWFsaXplIHRoZSBhbmdsZXMgaW4gcmFkaWFucyB0byBiZSBiZXR3ZWVuIC1waSBhbmQgcGkuXG4gICAgICAgICAqL1xuICAgICAgICBTd2VlcC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGEwID0gbWF0aCQxLm1vZCh0aGlzLmEwLCAtbWF0aCQxLlBJLCArbWF0aCQxLlBJKTtcbiAgICAgICAgICAgIHRoaXMuYSAtPSB0aGlzLmEwIC0gYTA7XG4gICAgICAgICAgICB0aGlzLmEwID0gYTA7XG4gICAgICAgIH07XG4gICAgICAgIFN3ZWVwLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IG5ldyBTd2VlcCgpO1xuICAgICAgICAgICAgY2xvbmUubG9jYWxDZW50ZXIuc2V0VmVjMih0aGlzLmxvY2FsQ2VudGVyKTtcbiAgICAgICAgICAgIGNsb25lLmFscGhhMCA9IHRoaXMuYWxwaGEwO1xuICAgICAgICAgICAgY2xvbmUuYTAgPSB0aGlzLmEwO1xuICAgICAgICAgICAgY2xvbmUuYSA9IHRoaXMuYTtcbiAgICAgICAgICAgIGNsb25lLmMwLnNldFZlYzIodGhpcy5jMCk7XG4gICAgICAgICAgICBjbG9uZS5jLnNldFZlYzIodGhpcy5jKTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgfTtcbiAgICAgICAgU3dlZXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsQ2VudGVyLnNldFZlYzIodGhhdC5sb2NhbENlbnRlcik7XG4gICAgICAgICAgICB0aGlzLmFscGhhMCA9IHRoYXQuYWxwaGEwO1xuICAgICAgICAgICAgdGhpcy5hMCA9IHRoYXQuYTA7XG4gICAgICAgICAgICB0aGlzLmEgPSB0aGF0LmE7XG4gICAgICAgICAgICB0aGlzLmMwLnNldFZlYzIodGhhdC5jMCk7XG4gICAgICAgICAgICB0aGlzLmMuc2V0VmVjMih0aGF0LmMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3dlZXA7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICB2YXIgVmVsb2NpdHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZlbG9jaXR5KCkge1xuICAgICAgICAgICAgdGhpcy52ID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICB0aGlzLncgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBWZWxvY2l0eTtcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIHZhciBQb3NpdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUG9zaXRpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmMgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIHRoaXMuYSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgUG9zaXRpb24ucHJvdG90eXBlLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh4ZiwgcCkge1xuICAgICAgICAgICAgeGYucS5zZXRBbmdsZSh0aGlzLmEpO1xuICAgICAgICAgICAgeGYucC5zZXRWZWMyKFZlYzIuc3ViKHRoaXMuYywgUm90Lm11bFZlYzIoeGYucSwgcCkpKTtcbiAgICAgICAgICAgIHJldHVybiB4ZjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uO1xuICAgIH0oKSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQSBzaGFwZSBpcyB1c2VkIGZvciBjb2xsaXNpb24gZGV0ZWN0aW9uLiBZb3UgY2FuIGNyZWF0ZSBhIHNoYXBlIGhvd2V2ZXIgeW91XG4gICAgICogbGlrZS4gU2hhcGVzIHVzZWQgZm9yIHNpbXVsYXRpb24gaW4gV29ybGQgYXJlIGNyZWF0ZWQgYXV0b21hdGljYWxseSB3aGVuIGFcbiAgICAgKiBGaXh0dXJlIGlzIGNyZWF0ZWQuIFNoYXBlcyBtYXkgZW5jYXBzdWxhdGUgb25lIG9yIG1vcmUgY2hpbGQgc2hhcGVzLlxuICAgICAqL1xuICAgIHZhciBTaGFwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBTaGFwZS5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB9O1xuICAgICAgICBTaGFwZS5pc1ZhbGlkID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqLm1fdHlwZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIG9iai5tX3JhZGl1cyA9PT0gJ251bWJlcic7XG4gICAgICAgIH07XG4gICAgICAgIFNoYXBlLnByb3RvdHlwZS5nZXRSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3JhZGl1cztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgdHlwZSBvZiB0aGlzIHNoYXBlLiBZb3UgY2FuIHVzZSB0aGlzIHRvIGRvd24gY2FzdCB0byB0aGUgY29uY3JldGVcbiAgICAgICAgICogc2hhcGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdGhlIHNoYXBlIHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICBTaGFwZS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdHlwZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNoYXBlO1xuICAgIH0oKSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgdmFyIEZpeHR1cmVEZWZEZWZhdWx0ID0ge1xuICAgICAgICB1c2VyRGF0YTogbnVsbCxcbiAgICAgICAgZnJpY3Rpb246IDAuMixcbiAgICAgICAgcmVzdGl0dXRpb246IDAuMCxcbiAgICAgICAgZGVuc2l0eTogMC4wLFxuICAgICAgICBpc1NlbnNvcjogZmFsc2UsXG4gICAgICAgIGZpbHRlckdyb3VwSW5kZXg6IDAsXG4gICAgICAgIGZpbHRlckNhdGVnb3J5Qml0czogMHgwMDAxLFxuICAgICAgICBmaWx0ZXJNYXNrQml0czogMHhGRkZGXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHByb3h5IGlzIHVzZWQgaW50ZXJuYWxseSB0byBjb25uZWN0IHNoYXBlIGNoaWxkcmVuIHRvIHRoZSBicm9hZC1waGFzZS5cbiAgICAgKi9cbiAgICB2YXIgRml4dHVyZVByb3h5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBGaXh0dXJlUHJveHkoZml4dHVyZSwgY2hpbGRJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5hYWJiID0gbmV3IEFBQkIoKTtcbiAgICAgICAgICAgIHRoaXMuZml4dHVyZSA9IGZpeHR1cmU7XG4gICAgICAgICAgICB0aGlzLmNoaWxkSW5kZXggPSBjaGlsZEluZGV4O1xuICAgICAgICAgICAgdGhpcy5wcm94eUlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGaXh0dXJlUHJveHk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBBIGZpeHR1cmUgaXMgdXNlZCB0byBhdHRhY2ggYSBzaGFwZSB0byBhIGJvZHkgZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb24uIEFcbiAgICAgKiBmaXh0dXJlIGluaGVyaXRzIGl0cyB0cmFuc2Zvcm0gZnJvbSBpdHMgcGFyZW50LiBGaXh0dXJlcyBob2xkIGFkZGl0aW9uYWxcbiAgICAgKiBub24tZ2VvbWV0cmljIGRhdGEgc3VjaCBhcyBmcmljdGlvbiwgY29sbGlzaW9uIGZpbHRlcnMsIGV0Yy5cbiAgICAgKlxuICAgICAqIFRvIGNyZWF0ZSBhIG5ldyBGaXh0dXJlIHVzZSB7QGxpbmsgQm9keS5jcmVhdGVGaXh0dXJlfS5cbiAgICAgKi9cbiAgICB2YXIgRml4dHVyZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqLyBmdW5jdGlvbiBGaXh0dXJlKGJvZHksIHNoYXBlLCBkZWYpIHtcbiAgICAgICAgICAgIGlmIChzaGFwZS5zaGFwZSkge1xuICAgICAgICAgICAgICAgIGRlZiA9IHNoYXBlO1xuICAgICAgICAgICAgICAgIHNoYXBlID0gc2hhcGUuc2hhcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVmID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGRlZiA9IHsgZGVuc2l0eTogZGVmIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWYgPSBvcHRpb25zKGRlZiwgRml4dHVyZURlZkRlZmF1bHQpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5tX2ZyaWN0aW9uID0gZGVmLmZyaWN0aW9uO1xuICAgICAgICAgICAgdGhpcy5tX3Jlc3RpdHV0aW9uID0gZGVmLnJlc3RpdHV0aW9uO1xuICAgICAgICAgICAgdGhpcy5tX2RlbnNpdHkgPSBkZWYuZGVuc2l0eTtcbiAgICAgICAgICAgIHRoaXMubV9pc1NlbnNvciA9IGRlZi5pc1NlbnNvcjtcbiAgICAgICAgICAgIHRoaXMubV9maWx0ZXJHcm91cEluZGV4ID0gZGVmLmZpbHRlckdyb3VwSW5kZXg7XG4gICAgICAgICAgICB0aGlzLm1fZmlsdGVyQ2F0ZWdvcnlCaXRzID0gZGVmLmZpbHRlckNhdGVnb3J5Qml0cztcbiAgICAgICAgICAgIHRoaXMubV9maWx0ZXJNYXNrQml0cyA9IGRlZi5maWx0ZXJNYXNrQml0cztcbiAgICAgICAgICAgIC8vIFRPRE8gdmFsaWRhdGUgc2hhcGVcbiAgICAgICAgICAgIHRoaXMubV9zaGFwZSA9IHNoYXBlOyAvLyAuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMubV9uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubV9wcm94aWVzID0gW107XG4gICAgICAgICAgICB0aGlzLm1fcHJveHlDb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgY2hpbGRDb3VudCA9IHRoaXMubV9zaGFwZS5nZXRDaGlsZENvdW50KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9wcm94aWVzW2ldID0gbmV3IEZpeHR1cmVQcm94eSh0aGlzLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV91c2VyRGF0YSA9IGRlZi51c2VyRGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmUtc2V0dXAgZml4dHVyZS5cbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IHRoaXMuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgdmFyIGJyb2FkUGhhc2UgPSBib2R5Lm1fd29ybGQubV9icm9hZFBoYXNlO1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95UHJveGllcyhicm9hZFBoYXNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fc2hhcGUuX3Jlc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3NoYXBlLl9yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkQ291bnQgPSB0aGlzLm1fc2hhcGUuZ2V0Q2hpbGRDb3VudCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZENvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fcHJveGllc1tpXSA9IG5ldyBGaXh0dXJlUHJveHkodGhpcywgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVByb3hpZXMoYnJvYWRQaGFzZSwgYm9keS5tX3hmKTtcbiAgICAgICAgICAgIGJvZHkucmVzZXRNYXNzRGF0YSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyaWN0aW9uOiB0aGlzLm1fZnJpY3Rpb24sXG4gICAgICAgICAgICAgICAgcmVzdGl0dXRpb246IHRoaXMubV9yZXN0aXR1dGlvbixcbiAgICAgICAgICAgICAgICBkZW5zaXR5OiB0aGlzLm1fZGVuc2l0eSxcbiAgICAgICAgICAgICAgICBpc1NlbnNvcjogdGhpcy5tX2lzU2Vuc29yLFxuICAgICAgICAgICAgICAgIGZpbHRlckdyb3VwSW5kZXg6IHRoaXMubV9maWx0ZXJHcm91cEluZGV4LFxuICAgICAgICAgICAgICAgIGZpbHRlckNhdGVnb3J5Qml0czogdGhpcy5tX2ZpbHRlckNhdGVnb3J5Qml0cyxcbiAgICAgICAgICAgICAgICBmaWx0ZXJNYXNrQml0czogdGhpcy5tX2ZpbHRlck1hc2tCaXRzLFxuICAgICAgICAgICAgICAgIHNoYXBlOiB0aGlzLm1fc2hhcGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZpeHR1cmUuX2Rlc2VyaWFsaXplID0gZnVuY3Rpb24gKGRhdGEsIGJvZHksIHJlc3RvcmUpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHJlc3RvcmUoU2hhcGUsIGRhdGEuc2hhcGUpO1xuICAgICAgICAgICAgdmFyIGZpeHR1cmUgPSBzaGFwZSAmJiBuZXcgRml4dHVyZShib2R5LCBzaGFwZSwgZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gZml4dHVyZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgdHlwZSBvZiB0aGUgY2hpbGQgc2hhcGUuIFlvdSBjYW4gdXNlIHRoaXMgdG8gZG93biBjYXN0IHRvIHRoZVxuICAgICAgICAgKiBjb25jcmV0ZSBzaGFwZS5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3NoYXBlLmdldFR5cGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY2hpbGQgc2hhcGUuIFlvdSBjYW4gbW9kaWZ5IHRoZSBjaGlsZCBzaGFwZSwgaG93ZXZlciB5b3Ugc2hvdWxkIG5vdFxuICAgICAgICAgKiBjaGFuZ2UgdGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBiZWNhdXNlIHRoaXMgd2lsbCBjcmFzaCBzb21lIGNvbGxpc2lvbiBjYWNoaW5nXG4gICAgICAgICAqIG1lY2hhbmlzbXMuIE1hbmlwdWxhdGluZyB0aGUgc2hhcGUgbWF5IGxlYWQgdG8gbm9uLXBoeXNpY2FsIGJlaGF2aW9yLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuZ2V0U2hhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3NoYXBlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzZW5zb3Igc2hhcGUgY29sbGVjdHMgY29udGFjdCBpbmZvcm1hdGlvbiBidXQgbmV2ZXIgZ2VuZXJhdGVzIGEgY29sbGlzaW9uXG4gICAgICAgICAqIHJlc3BvbnNlLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuaXNTZW5zb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2lzU2Vuc29yO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGlmIHRoaXMgZml4dHVyZSBpcyBhIHNlbnNvci5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLnNldFNlbnNvciA9IGZ1bmN0aW9uIChzZW5zb3IpIHtcbiAgICAgICAgICAgIGlmIChzZW5zb3IgIT0gdGhpcy5tX2lzU2Vuc29yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JvZHkuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2lzU2Vuc29yID0gc2Vuc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyAvKipcbiAgICAgICAgLy8gICogR2V0IHRoZSBjb250YWN0IGZpbHRlcmluZyBkYXRhLlxuICAgICAgICAvLyAgKi9cbiAgICAgICAgLy8gZ2V0RmlsdGVyRGF0YSgpIHtcbiAgICAgICAgLy8gICByZXR1cm4gdGhpcy5tX2ZpbHRlcjtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB1c2VyIGRhdGEgdGhhdCB3YXMgYXNzaWduZWQgaW4gdGhlIGZpeHR1cmUgZGVmaW5pdGlvbi4gVXNlIHRoaXMgdG9cbiAgICAgICAgICogc3RvcmUgeW91ciBhcHBsaWNhdGlvbiBzcGVjaWZpYyBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuZ2V0VXNlckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3VzZXJEYXRhO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSB1c2VyIGRhdGEuIFVzZSB0aGlzIHRvIHN0b3JlIHlvdXIgYXBwbGljYXRpb24gc3BlY2lmaWMgZGF0YS5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLnNldFVzZXJEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMubV91c2VyRGF0YSA9IGRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHBhcmVudCBib2R5IG9mIHRoaXMgZml4dHVyZS4gVGhpcyBpcyBudWxsIGlmIHRoZSBmaXh0dXJlIGlzIG5vdFxuICAgICAgICAgKiBhdHRhY2hlZC5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLmdldEJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG5leHQgZml4dHVyZSBpbiB0aGUgcGFyZW50IGJvZHkncyBmaXh0dXJlIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5nZXROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9uZXh0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBkZW5zaXR5IG9mIHRoaXMgZml4dHVyZS5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLmdldERlbnNpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2RlbnNpdHk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGRlbnNpdHkgb2YgdGhpcyBmaXh0dXJlLiBUaGlzIHdpbGwgX25vdF8gYXV0b21hdGljYWxseSBhZGp1c3QgdGhlXG4gICAgICAgICAqIG1hc3Mgb2YgdGhlIGJvZHkuIFlvdSBtdXN0IGNhbGwgQm9keS5yZXNldE1hc3NEYXRhIHRvIHVwZGF0ZSB0aGUgYm9keSdzIG1hc3MuXG4gICAgICAgICAqL1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5zZXREZW5zaXR5ID0gZnVuY3Rpb24gKGRlbnNpdHkpIHtcbiAgICAgICAgICAgIHRoaXMubV9kZW5zaXR5ID0gZGVuc2l0eTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29lZmZpY2llbnQgb2YgZnJpY3Rpb24sIHVzdWFsbHkgaW4gdGhlIHJhbmdlIFswLDFdLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuZ2V0RnJpY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2ZyaWN0aW9uO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjb2VmZmljaWVudCBvZiBmcmljdGlvbi4gVGhpcyB3aWxsIG5vdCBjaGFuZ2UgdGhlIGZyaWN0aW9uIG9mXG4gICAgICAgICAqIGV4aXN0aW5nIGNvbnRhY3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuc2V0RnJpY3Rpb24gPSBmdW5jdGlvbiAoZnJpY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubV9mcmljdGlvbiA9IGZyaWN0aW9uO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb2VmZmljaWVudCBvZiByZXN0aXR1dGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLmdldFJlc3RpdHV0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9yZXN0aXR1dGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgY29lZmZpY2llbnQgb2YgcmVzdGl0dXRpb24uIFRoaXMgd2lsbCBub3QgY2hhbmdlIHRoZSByZXN0aXR1dGlvbiBvZlxuICAgICAgICAgKiBleGlzdGluZyBjb250YWN0cy5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLnNldFJlc3RpdHV0aW9uID0gZnVuY3Rpb24gKHJlc3RpdHV0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1fcmVzdGl0dXRpb24gPSByZXN0aXR1dGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3QgYSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcyBmb3IgY29udGFpbm1lbnQgaW4gdGhpcyBmaXh0dXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUudGVzdFBvaW50ID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fc2hhcGUudGVzdFBvaW50KHRoaXMubV9ib2R5LmdldFRyYW5zZm9ybSgpLCBwKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhc3QgYSByYXkgYWdhaW5zdCB0aGlzIHNoYXBlLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uIChvdXRwdXQsIGlucHV0LCBjaGlsZEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3NoYXBlLnJheUNhc3Qob3V0cHV0LCBpbnB1dCwgdGhpcy5tX2JvZHkuZ2V0VHJhbnNmb3JtKCksIGNoaWxkSW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtYXNzIGRhdGEgZm9yIHRoaXMgZml4dHVyZS4gVGhlIG1hc3MgZGF0YSBpcyBiYXNlZCBvbiB0aGUgZGVuc2l0eSBhbmRcbiAgICAgICAgICogdGhlIHNoYXBlLiBUaGUgcm90YXRpb25hbCBpbmVydGlhIGlzIGFib3V0IHRoZSBzaGFwZSdzIG9yaWdpbi4gVGhpcyBvcGVyYXRpb25cbiAgICAgICAgICogbWF5IGJlIGV4cGVuc2l2ZS5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLmdldE1hc3NEYXRhID0gZnVuY3Rpb24gKG1hc3NEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm1fc2hhcGUuY29tcHV0ZU1hc3MobWFzc0RhdGEsIHRoaXMubV9kZW5zaXR5KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZml4dHVyZSdzIEFBQkIuIFRoaXMgQUFCQiBtYXkgYmUgZW5sYXJnZSBhbmQvb3Igc3RhbGUuIElmIHlvdSBuZWVkIGFcbiAgICAgICAgICogbW9yZSBhY2N1cmF0ZSBBQUJCLCBjb21wdXRlIGl0IHVzaW5nIHRoZSBzaGFwZSBhbmQgdGhlIGJvZHkgdHJhbnNmb3JtLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuZ2V0QUFCQiA9IGZ1bmN0aW9uIChjaGlsZEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3Byb3hpZXNbY2hpbGRJbmRleF0uYWFiYjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZXNlIHN1cHBvcnQgYm9keSBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLmNyZWF0ZVByb3hpZXMgPSBmdW5jdGlvbiAoYnJvYWRQaGFzZSwgeGYpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBwcm94aWVzIGluIHRoZSBicm9hZC1waGFzZS5cbiAgICAgICAgICAgIHRoaXMubV9wcm94eUNvdW50ID0gdGhpcy5tX3NoYXBlLmdldENoaWxkQ291bnQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX3Byb3h5Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm94eSA9IHRoaXMubV9wcm94aWVzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMubV9zaGFwZS5jb21wdXRlQUFCQihwcm94eS5hYWJiLCB4ZiwgaSk7XG4gICAgICAgICAgICAgICAgcHJveHkucHJveHlJZCA9IGJyb2FkUGhhc2UuY3JlYXRlUHJveHkocHJveHkuYWFiYiwgcHJveHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5kZXN0cm95UHJveGllcyA9IGZ1bmN0aW9uIChicm9hZFBoYXNlKSB7XG4gICAgICAgICAgICAvLyBEZXN0cm95IHByb3hpZXMgaW4gdGhlIGJyb2FkLXBoYXNlLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fcHJveHlDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3h5ID0gdGhpcy5tX3Byb3hpZXNbaV07XG4gICAgICAgICAgICAgICAgYnJvYWRQaGFzZS5kZXN0cm95UHJveHkocHJveHkucHJveHlJZCk7XG4gICAgICAgICAgICAgICAgcHJveHkucHJveHlJZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fcHJveHlDb3VudCA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoaXMgZml4dHVyZSBwcm94eSBpbiBicm9hZC1waGFzZSAod2l0aCBjb21iaW5lZCBBQUJCIG9mIGN1cnJlbnQgYW5kXG4gICAgICAgICAqIG5leHQgdHJhbnNmb3JtYXRpb24pLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuc3luY2hyb25pemUgPSBmdW5jdGlvbiAoYnJvYWRQaGFzZSwgeGYxLCB4ZjIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX3Byb3h5Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm94eSA9IHRoaXMubV9wcm94aWVzW2ldO1xuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgYW4gQUFCQiB0aGF0IGNvdmVycyB0aGUgc3dlcHQgc2hhcGUgKG1heSBtaXNzIHNvbWUgcm90YXRpb25cbiAgICAgICAgICAgICAgICAvLyBlZmZlY3QpLlxuICAgICAgICAgICAgICAgIHZhciBhYWJiMSA9IG5ldyBBQUJCKCk7XG4gICAgICAgICAgICAgICAgdmFyIGFhYmIyID0gbmV3IEFBQkIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fc2hhcGUuY29tcHV0ZUFBQkIoYWFiYjEsIHhmMSwgcHJveHkuY2hpbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3NoYXBlLmNvbXB1dGVBQUJCKGFhYmIyLCB4ZjIsIHByb3h5LmNoaWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgIHByb3h5LmFhYmIuY29tYmluZShhYWJiMSwgYWFiYjIpO1xuICAgICAgICAgICAgICAgIHZhciBkaXNwbGFjZW1lbnQgPSBWZWMyLnN1Yih4ZjIucCwgeGYxLnApO1xuICAgICAgICAgICAgICAgIGJyb2FkUGhhc2UubW92ZVByb3h5KHByb3h5LnByb3h5SWQsIHByb3h5LmFhYmIsIGRpc3BsYWNlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGNvbnRhY3QgZmlsdGVyaW5nIGRhdGEuIFRoaXMgd2lsbCBub3QgdXBkYXRlIGNvbnRhY3RzIHVudGlsIHRoZSBuZXh0XG4gICAgICAgICAqIHRpbWUgc3RlcCB3aGVuIGVpdGhlciBwYXJlbnQgYm9keSBpcyBhY3RpdmUgYW5kIGF3YWtlLiBUaGlzIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICogY2FsbHMgcmVmaWx0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5zZXRGaWx0ZXJEYXRhID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgdGhpcy5tX2ZpbHRlckdyb3VwSW5kZXggPSBmaWx0ZXIuZ3JvdXBJbmRleDtcbiAgICAgICAgICAgIHRoaXMubV9maWx0ZXJDYXRlZ29yeUJpdHMgPSBmaWx0ZXIuY2F0ZWdvcnlCaXRzO1xuICAgICAgICAgICAgdGhpcy5tX2ZpbHRlck1hc2tCaXRzID0gZmlsdGVyLm1hc2tCaXRzO1xuICAgICAgICAgICAgdGhpcy5yZWZpbHRlcigpO1xuICAgICAgICB9O1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5nZXRGaWx0ZXJHcm91cEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9maWx0ZXJHcm91cEluZGV4O1xuICAgICAgICB9O1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5zZXRGaWx0ZXJHcm91cEluZGV4ID0gZnVuY3Rpb24gKGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMubV9maWx0ZXJHcm91cEluZGV4ID0gZ3JvdXBJbmRleDtcbiAgICAgICAgfTtcbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuZ2V0RmlsdGVyQ2F0ZWdvcnlCaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9maWx0ZXJDYXRlZ29yeUJpdHM7XG4gICAgICAgIH07XG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLnNldEZpbHRlckNhdGVnb3J5Qml0cyA9IGZ1bmN0aW9uIChjYXRlZ29yeUJpdHMpIHtcbiAgICAgICAgICAgIHRoaXMubV9maWx0ZXJDYXRlZ29yeUJpdHMgPSBjYXRlZ29yeUJpdHM7XG4gICAgICAgIH07XG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLmdldEZpbHRlck1hc2tCaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9maWx0ZXJNYXNrQml0cztcbiAgICAgICAgfTtcbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuc2V0RmlsdGVyTWFza0JpdHMgPSBmdW5jdGlvbiAobWFza0JpdHMpIHtcbiAgICAgICAgICAgIHRoaXMubV9maWx0ZXJNYXNrQml0cyA9IG1hc2tCaXRzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbCB0aGlzIGlmIHlvdSB3YW50IHRvIGVzdGFibGlzaCBjb2xsaXNpb24gdGhhdCB3YXMgcHJldmlvdXNseSBkaXNhYmxlZCBieVxuICAgICAgICAgKiBDb250YWN0RmlsdGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUucmVmaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2JvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZsYWcgYXNzb2NpYXRlZCBjb250YWN0cyBmb3IgZmlsdGVyaW5nLlxuICAgICAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLm1fYm9keS5nZXRDb250YWN0TGlzdCgpO1xuICAgICAgICAgICAgd2hpbGUgKGVkZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IGVkZ2UuY29udGFjdDtcbiAgICAgICAgICAgICAgICB2YXIgZml4dHVyZUEgPSBjb250YWN0LmdldEZpeHR1cmVBKCk7XG4gICAgICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gY29udGFjdC5nZXRGaXh0dXJlQigpO1xuICAgICAgICAgICAgICAgIGlmIChmaXh0dXJlQSA9PSB0aGlzIHx8IGZpeHR1cmVCID09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdC5mbGFnRm9yRmlsdGVyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVkZ2UgPSBlZGdlLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgd29ybGQgPSB0aGlzLm1fYm9keS5nZXRXb3JsZCgpO1xuICAgICAgICAgICAgaWYgKHdvcmxkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUb3VjaCBlYWNoIHByb3h5IHNvIHRoYXQgbmV3IHBhaXJzIG1heSBiZSBjcmVhdGVkXG4gICAgICAgICAgICB2YXIgYnJvYWRQaGFzZSA9IHdvcmxkLm1fYnJvYWRQaGFzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX3Byb3h5Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIGJyb2FkUGhhc2UudG91Y2hQcm94eSh0aGlzLm1fcHJveGllc1tpXS5wcm94eUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBwcm92aWRlIGNvbGxpc2lvbiBmaWx0ZXJpbmcsIGlmIHlvdSB3YW50IGZpbmVyXG4gICAgICAgICAqIGNvbnRyb2wgb3ZlciBjb250YWN0IGNyZWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiBjb250YWN0IGNhbGN1bGF0aW9ucyBzaG91bGQgYmUgcGVyZm9ybWVkIGJldHdlZW4gdGhlc2UgdHdvXG4gICAgICAgICAqIGZpeHR1cmVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXYXJuaW5nOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyB0aGlzIGlzIG9ubHkgY2FsbGVkIHdoZW4gdGhlIEFBQkJzIGJlZ2luIHRvXG4gICAgICAgICAqIG92ZXJsYXAuXG4gICAgICAgICAqL1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5zaG91bGRDb2xsaWRlID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgICAgIGlmICh0aGF0Lm1fZmlsdGVyR3JvdXBJbmRleCA9PT0gdGhpcy5tX2ZpbHRlckdyb3VwSW5kZXggJiYgdGhhdC5tX2ZpbHRlckdyb3VwSW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5tX2ZpbHRlckdyb3VwSW5kZXggPiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbGxpZGVBID0gKHRoYXQubV9maWx0ZXJNYXNrQml0cyAmIHRoaXMubV9maWx0ZXJDYXRlZ29yeUJpdHMpICE9PSAwO1xuICAgICAgICAgICAgdmFyIGNvbGxpZGVCID0gKHRoYXQubV9maWx0ZXJDYXRlZ29yeUJpdHMgJiB0aGlzLm1fZmlsdGVyTWFza0JpdHMpICE9PSAwO1xuICAgICAgICAgICAgdmFyIGNvbGxpZGUgPSBjb2xsaWRlQSAmJiBjb2xsaWRlQjtcbiAgICAgICAgICAgIHJldHVybiBjb2xsaWRlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRml4dHVyZTtcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIHZhciBTVEFUSUMgPSAnc3RhdGljJztcbiAgICB2YXIgS0lORU1BVElDID0gJ2tpbmVtYXRpYyc7XG4gICAgdmFyIERZTkFNSUMgPSAnZHluYW1pYyc7XG4gICAgdmFyIEJvZHlEZWZEZWZhdWx0ID0ge1xuICAgICAgICB0eXBlOiBTVEFUSUMsXG4gICAgICAgIHBvc2l0aW9uOiBWZWMyLnplcm8oKSxcbiAgICAgICAgYW5nbGU6IDAuMCxcbiAgICAgICAgbGluZWFyVmVsb2NpdHk6IFZlYzIuemVybygpLFxuICAgICAgICBhbmd1bGFyVmVsb2NpdHk6IDAuMCxcbiAgICAgICAgbGluZWFyRGFtcGluZzogMC4wLFxuICAgICAgICBhbmd1bGFyRGFtcGluZzogMC4wLFxuICAgICAgICBmaXhlZFJvdGF0aW9uOiBmYWxzZSxcbiAgICAgICAgYnVsbGV0OiBmYWxzZSxcbiAgICAgICAgZ3Jhdml0eVNjYWxlOiAxLjAsXG4gICAgICAgIGFsbG93U2xlZXA6IHRydWUsXG4gICAgICAgIGF3YWtlOiB0cnVlLFxuICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgIHVzZXJEYXRhOiBudWxsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYXNzRGF0YSBUaGlzIGhvbGRzIHRoZSBtYXNzIGRhdGEgY29tcHV0ZWQgZm9yIGEgc2hhcGUuXG4gICAgICovXG4gICAgdmFyIE1hc3NEYXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNYXNzRGF0YSgpIHtcbiAgICAgICAgICAgIC8qKiBUaGUgbWFzcyBvZiB0aGUgc2hhcGUsIHVzdWFsbHkgaW4ga2lsb2dyYW1zLiAqL1xuICAgICAgICAgICAgdGhpcy5tYXNzID0gMDtcbiAgICAgICAgICAgIC8qKiBUaGUgcG9zaXRpb24gb2YgdGhlIHNoYXBlJ3MgY2VudHJvaWQgcmVsYXRpdmUgdG8gdGhlIHNoYXBlJ3Mgb3JpZ2luLiAqL1xuICAgICAgICAgICAgdGhpcy5jZW50ZXIgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIC8qKiBUaGUgcm90YXRpb25hbCBpbmVydGlhIG9mIHRoZSBzaGFwZSBhYm91dCB0aGUgbG9jYWwgb3JpZ2luLiAqL1xuICAgICAgICAgICAgdGhpcy5JID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWFzc0RhdGE7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBBIHJpZ2lkIGJvZHkgY29tcG9zZWQgb2Ygb25lIG9yIG1vcmUgZml4dHVyZXMuXG4gICAgICpcbiAgICAgKiBUbyBjcmVhdGUgYSBuZXcgQm9keSB1c2Uge0BsaW5rIFdvcmxkLmNyZWF0ZUJvZHl9LlxuICAgICAqL1xuICAgIHZhciBCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIGZ1bmN0aW9uIEJvZHkod29ybGQsIGRlZikge1xuICAgICAgICAgICAgZGVmID0gb3B0aW9ucyhkZWYsIEJvZHlEZWZEZWZhdWx0KTtcbiAgICAgICAgICAgIHRoaXMubV93b3JsZCA9IHdvcmxkO1xuICAgICAgICAgICAgdGhpcy5tX2F3YWtlRmxhZyA9IGRlZi5hd2FrZTtcbiAgICAgICAgICAgIHRoaXMubV9hdXRvU2xlZXBGbGFnID0gZGVmLmFsbG93U2xlZXA7XG4gICAgICAgICAgICB0aGlzLm1fYnVsbGV0RmxhZyA9IGRlZi5idWxsZXQ7XG4gICAgICAgICAgICB0aGlzLm1fZml4ZWRSb3RhdGlvbkZsYWcgPSBkZWYuZml4ZWRSb3RhdGlvbjtcbiAgICAgICAgICAgIHRoaXMubV9hY3RpdmVGbGFnID0gZGVmLmFjdGl2ZTtcbiAgICAgICAgICAgIHRoaXMubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm1fdG9pRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tX3VzZXJEYXRhID0gZGVmLnVzZXJEYXRhO1xuICAgICAgICAgICAgdGhpcy5tX3R5cGUgPSBkZWYudHlwZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fdHlwZSA9PSBEWU5BTUlDKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21hc3MgPSAxLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ludk1hc3MgPSAxLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbWFzcyA9IDAuMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW52TWFzcyA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJvdGF0aW9uYWwgaW5lcnRpYSBhYm91dCB0aGUgY2VudGVyIG9mIG1hc3MuXG4gICAgICAgICAgICB0aGlzLm1fSSA9IDAuMDtcbiAgICAgICAgICAgIHRoaXMubV9pbnZJID0gMC4wO1xuICAgICAgICAgICAgLy8gdGhlIGJvZHkgb3JpZ2luIHRyYW5zZm9ybVxuICAgICAgICAgICAgdGhpcy5tX3hmID0gVHJhbnNmb3JtLmlkZW50aXR5KCk7XG4gICAgICAgICAgICB0aGlzLm1feGYucCA9IFZlYzIuY2xvbmUoZGVmLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMubV94Zi5xLnNldEFuZ2xlKGRlZi5hbmdsZSk7XG4gICAgICAgICAgICAvLyB0aGUgc3dlcHQgbW90aW9uIGZvciBDQ0RcbiAgICAgICAgICAgIHRoaXMubV9zd2VlcCA9IG5ldyBTd2VlcCgpO1xuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwLnNldFRyYW5zZm9ybSh0aGlzLm1feGYpO1xuICAgICAgICAgICAgLy8gcG9zaXRpb24gYW5kIHZlbG9jaXR5IGNvcnJlY3Rpb25cbiAgICAgICAgICAgIHRoaXMuY192ZWxvY2l0eSA9IG5ldyBWZWxvY2l0eSgpO1xuICAgICAgICAgICAgdGhpcy5jX3Bvc2l0aW9uID0gbmV3IFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLm1fZm9yY2UgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIHRoaXMubV90b3JxdWUgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkgPSBWZWMyLmNsb25lKGRlZi5saW5lYXJWZWxvY2l0eSk7XG4gICAgICAgICAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ID0gZGVmLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgICAgIHRoaXMubV9saW5lYXJEYW1waW5nID0gZGVmLmxpbmVhckRhbXBpbmc7XG4gICAgICAgICAgICB0aGlzLm1fYW5ndWxhckRhbXBpbmcgPSBkZWYuYW5ndWxhckRhbXBpbmc7XG4gICAgICAgICAgICB0aGlzLm1fZ3Jhdml0eVNjYWxlID0gZGVmLmdyYXZpdHlTY2FsZTtcbiAgICAgICAgICAgIHRoaXMubV9zbGVlcFRpbWUgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLm1fam9pbnRMaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubV9jb250YWN0TGlzdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1fZml4dHVyZUxpc3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tX3ByZXYgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tX25leHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuX3NlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmaXh0dXJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgZiA9IHRoaXMubV9maXh0dXJlTGlzdDsgZjsgZiA9IGYubV9uZXh0KSB7XG4gICAgICAgICAgICAgICAgZml4dHVyZXMucHVzaChmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5tX3R5cGUsXG4gICAgICAgICAgICAgICAgYnVsbGV0OiB0aGlzLm1fYnVsbGV0RmxhZyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5tX3hmLnAsXG4gICAgICAgICAgICAgICAgYW5nbGU6IHRoaXMubV94Zi5xLmdldEFuZ2xlKCksXG4gICAgICAgICAgICAgICAgbGluZWFyVmVsb2NpdHk6IHRoaXMubV9saW5lYXJWZWxvY2l0eSxcbiAgICAgICAgICAgICAgICBhbmd1bGFyVmVsb2NpdHk6IHRoaXMubV9hbmd1bGFyVmVsb2NpdHksXG4gICAgICAgICAgICAgICAgZml4dHVyZXM6IGZpeHR1cmVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBCb2R5Ll9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhLCB3b3JsZCwgcmVzdG9yZSkge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh3b3JsZCwgZGF0YSk7XG4gICAgICAgICAgICBpZiAoZGF0YS5maXh0dXJlcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBkYXRhLmZpeHR1cmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXh0dXJlID0gcmVzdG9yZShGaXh0dXJlLCBkYXRhLmZpeHR1cmVzW2ldLCBib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5fYWRkRml4dHVyZShmaXh0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuaXNXb3JsZExvY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fd29ybGQgJiYgdGhpcy5tX3dvcmxkLmlzTG9ja2VkKCkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldFdvcmxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV93b3JsZDtcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbmV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuc2V0VXNlckRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5tX3VzZXJEYXRhID0gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0VXNlckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3VzZXJEYXRhO1xuICAgICAgICB9O1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5nZXRGaXh0dXJlTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fZml4dHVyZUxpc3Q7XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldEpvaW50TGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fam9pbnRMaXN0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2FybmluZzogdGhpcyBsaXN0IGNoYW5nZXMgZHVyaW5nIHRoZSB0aW1lIHN0ZXAgYW5kIHlvdSBtYXkgbWlzcyBzb21lXG4gICAgICAgICAqIGNvbGxpc2lvbnMgaWYgeW91IGRvbid0IHVzZSBDb250YWN0TGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5nZXRDb250YWN0TGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fY29udGFjdExpc3Q7XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLmlzU3RhdGljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV90eXBlID09IFNUQVRJQztcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuaXNEeW5hbWljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV90eXBlID09IERZTkFNSUM7XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLmlzS2luZW1hdGljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV90eXBlID09IEtJTkVNQVRJQztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgd2lsbCBhbHRlciB0aGUgbWFzcyBhbmQgdmVsb2NpdHkuXG4gICAgICAgICAqL1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5zZXRTdGF0aWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNldFR5cGUoU1RBVElDKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5zZXREeW5hbWljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRUeXBlKERZTkFNSUMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLnNldEtpbmVtYXRpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VHlwZShLSU5FTUFUSUMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3R5cGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnNldFR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNXb3JsZExvY2tlZCgpID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tX3R5cGUgPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV90eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRNYXNzRGF0YSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubV90eXBlID09IFNUQVRJQykge1xuICAgICAgICAgICAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSA9IDAuMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fc3dlZXAuZm9yd2FyZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3luY2hyb25pemVGaXh0dXJlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9mb3JjZS5zZXRaZXJvKCk7XG4gICAgICAgICAgICB0aGlzLm1fdG9ycXVlID0gMC4wO1xuICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBhdHRhY2hlZCBjb250YWN0cy5cbiAgICAgICAgICAgIHZhciBjZSA9IHRoaXMubV9jb250YWN0TGlzdDtcbiAgICAgICAgICAgIHdoaWxlIChjZSkge1xuICAgICAgICAgICAgICAgIHZhciBjZTAgPSBjZTtcbiAgICAgICAgICAgICAgICBjZSA9IGNlLm5leHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3dvcmxkLmRlc3Ryb3lDb250YWN0KGNlMC5jb250YWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9jb250YWN0TGlzdCA9IG51bGw7XG4gICAgICAgICAgICAvLyBUb3VjaCB0aGUgcHJveGllcyBzbyB0aGF0IG5ldyBjb250YWN0cyB3aWxsIGJlIGNyZWF0ZWQgKHdoZW4gYXBwcm9wcmlhdGUpXG4gICAgICAgICAgICB2YXIgYnJvYWRQaGFzZSA9IHRoaXMubV93b3JsZC5tX2Jyb2FkUGhhc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBmID0gdGhpcy5tX2ZpeHR1cmVMaXN0OyBmOyBmID0gZi5tX25leHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJveHlDb3VudCA9IGYubV9wcm94eUNvdW50O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJveHlDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyb2FkUGhhc2UudG91Y2hQcm94eShmLm1fcHJveGllc1tpXS5wcm94eUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLmlzQnVsbGV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9idWxsZXRGbGFnO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHRoaXMgYm9keSBiZSB0cmVhdGVkIGxpa2UgYSBidWxsZXQgZm9yIGNvbnRpbnVvdXMgY29sbGlzaW9uIGRldGVjdGlvbj9cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnNldEJ1bGxldCA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICB0aGlzLm1fYnVsbGV0RmxhZyA9ICEhZmxhZztcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuaXNTbGVlcGluZ0FsbG93ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2F1dG9TbGVlcEZsYWc7XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLnNldFNsZWVwaW5nQWxsb3dlZCA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICB0aGlzLm1fYXV0b1NsZWVwRmxhZyA9ICEhZmxhZztcbiAgICAgICAgICAgIGlmICh0aGlzLm1fYXV0b1NsZWVwRmxhZyA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLmlzQXdha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2F3YWtlRmxhZztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgc2xlZXAgc3RhdGUgb2YgdGhlIGJvZHkuIEEgc2xlZXBpbmcgYm9keSBoYXMgdmVyeSBsb3cgQ1BVIGNvc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBmbGFnIFNldCB0byB0cnVlIHRvIHdha2UgdGhlIGJvZHksIGZhbHNlIHRvIHB1dCBpdCB0byBzbGVlcC5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnNldEF3YWtlID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubV9hd2FrZUZsYWcgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2F3YWtlRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9zbGVlcFRpbWUgPSAwLjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2F3YWtlRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubV9zbGVlcFRpbWUgPSAwLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xpbmVhclZlbG9jaXR5LnNldFplcm8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ID0gMC4wO1xuICAgICAgICAgICAgICAgIHRoaXMubV9mb3JjZS5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3RvcnF1ZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2FjdGl2ZUZsYWc7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgYm9keS4gQW4gaW5hY3RpdmUgYm9keSBpcyBub3Qgc2ltdWxhdGVkIGFuZFxuICAgICAgICAgKiBjYW5ub3QgYmUgY29sbGlkZWQgd2l0aCBvciB3b2tlbiB1cC4gSWYgeW91IHBhc3MgYSBmbGFnIG9mIHRydWUsIGFsbCBmaXh0dXJlc1xuICAgICAgICAgKiB3aWxsIGJlIGFkZGVkIHRvIHRoZSBicm9hZC1waGFzZS4gSWYgeW91IHBhc3MgYSBmbGFnIG9mIGZhbHNlLCBhbGwgZml4dHVyZXNcbiAgICAgICAgICogd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGJyb2FkLXBoYXNlIGFuZCBhbGwgY29udGFjdHMgd2lsbCBiZSBkZXN0cm95ZWQuXG4gICAgICAgICAqIEZpeHR1cmVzIGFuZCBqb2ludHMgYXJlIG90aGVyd2lzZSB1bmFmZmVjdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBZb3UgbWF5IGNvbnRpbnVlIHRvIGNyZWF0ZS9kZXN0cm95IGZpeHR1cmVzIGFuZCBqb2ludHMgb24gaW5hY3RpdmUgYm9kaWVzLlxuICAgICAgICAgKiBGaXh0dXJlcyBvbiBhbiBpbmFjdGl2ZSBib2R5IGFyZSBpbXBsaWNpdGx5IGluYWN0aXZlIGFuZCB3aWxsIG5vdCBwYXJ0aWNpcGF0ZVxuICAgICAgICAgKiBpbiBjb2xsaXNpb25zLCByYXktY2FzdHMsIG9yIHF1ZXJpZXMuIEpvaW50cyBjb25uZWN0ZWQgdG8gYW4gaW5hY3RpdmUgYm9keVxuICAgICAgICAgKiBhcmUgaW1wbGljaXRseSBpbmFjdGl2ZS4gQW4gaW5hY3RpdmUgYm9keSBpcyBzdGlsbCBvd25lZCBieSBhIFdvcmxkIG9iamVjdFxuICAgICAgICAgKiBhbmQgcmVtYWluc1xuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgICAgIGlmIChmbGFnID09IHRoaXMubV9hY3RpdmVGbGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2FjdGl2ZUZsYWcgPSAhIWZsYWc7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2FjdGl2ZUZsYWcpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYWxsIHByb3hpZXMuXG4gICAgICAgICAgICAgICAgdmFyIGJyb2FkUGhhc2UgPSB0aGlzLm1fd29ybGQubV9icm9hZFBoYXNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7IGY7IGYgPSBmLm1fbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBmLmNyZWF0ZVByb3hpZXMoYnJvYWRQaGFzZSwgdGhpcy5tX3hmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29udGFjdHMgYXJlIGNyZWF0ZWQgdGhlIG5leHQgdGltZSBzdGVwLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRGVzdHJveSBhbGwgcHJveGllcy5cbiAgICAgICAgICAgICAgICB2YXIgYnJvYWRQaGFzZSA9IHRoaXMubV93b3JsZC5tX2Jyb2FkUGhhc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZiA9IHRoaXMubV9maXh0dXJlTGlzdDsgZjsgZiA9IGYubV9uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGYuZGVzdHJveVByb3hpZXMoYnJvYWRQaGFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERlc3Ryb3kgdGhlIGF0dGFjaGVkIGNvbnRhY3RzLlxuICAgICAgICAgICAgICAgIHZhciBjZSA9IHRoaXMubV9jb250YWN0TGlzdDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlMCA9IGNlO1xuICAgICAgICAgICAgICAgICAgICBjZSA9IGNlLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV93b3JsZC5kZXN0cm95Q29udGFjdChjZTAuY29udGFjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubV9jb250YWN0TGlzdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLmlzRml4ZWRSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fZml4ZWRSb3RhdGlvbkZsYWc7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyBib2R5IHRvIGhhdmUgZml4ZWQgcm90YXRpb24uIFRoaXMgY2F1c2VzIHRoZSBtYXNzIHRvIGJlIHJlc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuc2V0Rml4ZWRSb3RhdGlvbiA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2ZpeGVkUm90YXRpb25GbGFnID09IGZsYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fZml4ZWRSb3RhdGlvbkZsYWcgPSAhIWZsYWc7XG4gICAgICAgICAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5yZXNldE1hc3NEYXRhKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHdvcmxkIHRyYW5zZm9ybSBmb3IgdGhlIGJvZHkncyBvcmlnaW4uXG4gICAgICAgICAqL1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3hmO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keSdzIG9yaWdpbiBhbmQgcm90YXRpb24uIE1hbmlwdWxhdGluZyBhIGJvZHknc1xuICAgICAgICAgKiB0cmFuc2Zvcm0gbWF5IGNhdXNlIG5vbi1waHlzaWNhbCBiZWhhdmlvci4gTm90ZTogY29udGFjdHMgYXJlIHVwZGF0ZWQgb24gdGhlXG4gICAgICAgICAqIG5leHQgY2FsbCB0byBXb3JsZC5zdGVwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSBib2R5J3MgbG9jYWwgb3JpZ2luLlxuICAgICAgICAgKiBAcGFyYW0gYW5nbGUgVGhlIHdvcmxkIHJvdGF0aW9uIGluIHJhZGlhbnMuXG4gICAgICAgICAqL1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAocG9zaXRpb24sIGFuZ2xlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1dvcmxkTG9ja2VkKCkgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV94Zi5zZXROdW0ocG9zaXRpb24sIGFuZ2xlKTtcbiAgICAgICAgICAgIHRoaXMubV9zd2VlcC5zZXRUcmFuc2Zvcm0odGhpcy5tX3hmKTtcbiAgICAgICAgICAgIHZhciBicm9hZFBoYXNlID0gdGhpcy5tX3dvcmxkLm1fYnJvYWRQaGFzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7IGY7IGYgPSBmLm1fbmV4dCkge1xuICAgICAgICAgICAgICAgIGYuc3luY2hyb25pemUoYnJvYWRQaGFzZSwgdGhpcy5tX3hmLCB0aGlzLm1feGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5zeW5jaHJvbml6ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubV9zd2VlcC5nZXRUcmFuc2Zvcm0odGhpcy5tX3hmLCAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBmaXh0dXJlcyBpbiBicm9hZC1waGFzZS5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnN5bmNocm9uaXplRml4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeGYgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMubV9zd2VlcC5nZXRUcmFuc2Zvcm0oeGYsIDApO1xuICAgICAgICAgICAgdmFyIGJyb2FkUGhhc2UgPSB0aGlzLm1fd29ybGQubV9icm9hZFBoYXNlO1xuICAgICAgICAgICAgZm9yICh2YXIgZiA9IHRoaXMubV9maXh0dXJlTGlzdDsgZjsgZiA9IGYubV9uZXh0KSB7XG4gICAgICAgICAgICAgICAgZi5zeW5jaHJvbml6ZShicm9hZFBoYXNlLCB4ZiwgdGhpcy5tX3hmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgaW4gVE9JLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV3IHNhZmUgdGltZS4gVGhpcyBkb2Vzbid0IHN5bmMgdGhlIGJyb2FkLXBoYXNlLlxuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwLmFkdmFuY2UoYWxwaGEpO1xuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwLmMuc2V0VmVjMih0aGlzLm1fc3dlZXAuYzApO1xuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwLmEgPSB0aGlzLm1fc3dlZXAuYTA7XG4gICAgICAgICAgICB0aGlzLm1fc3dlZXAuZ2V0VHJhbnNmb3JtKHRoaXMubV94ZiwgMSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHdvcmxkIHBvc2l0aW9uIGZvciB0aGUgYm9keSdzIG9yaWdpbi5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV94Zi5wO1xuICAgICAgICB9O1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShwLCB0aGlzLm1fc3dlZXAuYSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgd29ybGQgcm90YXRpb24gYW5nbGUgaW4gcmFkaWFucy5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldEFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9zd2VlcC5hO1xuICAgICAgICB9O1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5zZXRBbmdsZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0odGhpcy5tX3hmLnAsIGFuZ2xlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiBtYXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0V29ybGRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3N3ZWVwLmM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxvY2FsIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldExvY2FsQ2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGluZWFyIHZlbG9jaXR5IG9mIHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGUgbGluZWFyIHZlbG9jaXR5IG9mIHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldExpbmVhclZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgd29ybGQgbGluZWFyIHZlbG9jaXR5IG9mIGEgd29ybGQgcG9pbnQgYXR0YWNoZWQgdG8gdGhpcyBib2R5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gd29ybGRQb2ludCBBIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0TGluZWFyVmVsb2NpdHlGcm9tV29ybGRQb2ludCA9IGZ1bmN0aW9uICh3b3JsZFBvaW50KSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxDZW50ZXIgPSBWZWMyLnN1Yih3b3JsZFBvaW50LCB0aGlzLm1fc3dlZXAuYyk7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5hZGQodGhpcy5tX2xpbmVhclZlbG9jaXR5LCBWZWMyLmNyb3NzTnVtVmVjMih0aGlzLm1fYW5ndWxhclZlbG9jaXR5LCBsb2NhbENlbnRlcikpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB3b3JsZCB2ZWxvY2l0eSBvZiBhIGxvY2FsIHBvaW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbG9jYWxQb2ludCBBIHBvaW50IGluIGxvY2FsIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0TGluZWFyVmVsb2NpdHlGcm9tTG9jYWxQb2ludCA9IGZ1bmN0aW9uIChsb2NhbFBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lYXJWZWxvY2l0eUZyb21Xb3JsZFBvaW50KHRoaXMuZ2V0V29ybGRQb2ludChsb2NhbFBvaW50KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGxpbmVhciB2ZWxvY2l0eSBvZiB0aGUgY2VudGVyIG9mIG1hc3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB2IFRoZSBuZXcgbGluZWFyIHZlbG9jaXR5IG9mIHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnNldExpbmVhclZlbG9jaXR5ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fdHlwZSA9PSBTVEFUSUMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVmVjMi5kb3QodiwgdikgPiAwLjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2xpbmVhclZlbG9jaXR5LnNldFZlYzIodik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuZ3VsYXIgdmVsb2NpdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHRoZSBhbmd1bGFyIHZlbG9jaXR5IGluIHJhZGlhbnMvc2Vjb25kLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0QW5ndWxhclZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9hbmd1bGFyVmVsb2NpdHk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGFuZ3VsYXIgdmVsb2NpdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvbWVnYSBUaGUgbmV3IGFuZ3VsYXIgdmVsb2NpdHkgaW4gcmFkaWFucy9zZWNvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5zZXRBbmd1bGFyVmVsb2NpdHkgPSBmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgaWYgKHRoaXMubV90eXBlID09IFNUQVRJQykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3ICogdyA+IDAuMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ID0gdztcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0TGluZWFyRGFtcGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbGluZWFyRGFtcGluZztcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuc2V0TGluZWFyRGFtcGluZyA9IGZ1bmN0aW9uIChsaW5lYXJEYW1waW5nKSB7XG4gICAgICAgICAgICB0aGlzLm1fbGluZWFyRGFtcGluZyA9IGxpbmVhckRhbXBpbmc7XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldEFuZ3VsYXJEYW1waW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9hbmd1bGFyRGFtcGluZztcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuc2V0QW5ndWxhckRhbXBpbmcgPSBmdW5jdGlvbiAoYW5ndWxhckRhbXBpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubV9hbmd1bGFyRGFtcGluZyA9IGFuZ3VsYXJEYW1waW5nO1xuICAgICAgICB9O1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5nZXRHcmF2aXR5U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2dyYXZpdHlTY2FsZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxlIHRoZSBncmF2aXR5IGFwcGxpZWQgdG8gdGhpcyBib2R5LlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuc2V0R3Jhdml0eVNjYWxlID0gZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLm1fZ3Jhdml0eVNjYWxlID0gc2NhbGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHRvdGFsIG1hc3Mgb2YgdGhlIGJvZHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBtYXNzLCB1c3VhbGx5IGluIGtpbG9ncmFtcyAoa2cpLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0TWFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbWFzcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcm90YXRpb25hbCBpbmVydGlhIG9mIHRoZSBib2R5IGFib3V0IHRoZSBsb2NhbCBvcmlnaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdGhlIHJvdGF0aW9uYWwgaW5lcnRpYSwgdXN1YWxseSBpbiBrZy1tXjIuXG4gICAgICAgICAqL1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5nZXRJbmVydGlhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9JICsgdGhpcy5tX21hc3NcbiAgICAgICAgICAgICAgICAqIFZlYzIuZG90KHRoaXMubV9zd2VlcC5sb2NhbENlbnRlciwgdGhpcy5tX3N3ZWVwLmxvY2FsQ2VudGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvcHkgdGhlIG1hc3MgZGF0YSBvZiB0aGUgYm9keSB0byBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0TWFzc0RhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgZGF0YS5tYXNzID0gdGhpcy5tX21hc3M7XG4gICAgICAgICAgICBkYXRhLkkgPSB0aGlzLmdldEluZXJ0aWEoKTtcbiAgICAgICAgICAgIGRhdGEuY2VudGVyLnNldFZlYzIodGhpcy5tX3N3ZWVwLmxvY2FsQ2VudGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgcmVzZXRzIHRoZSBtYXNzIHByb3BlcnRpZXMgdG8gdGhlIHN1bSBvZiB0aGUgbWFzcyBwcm9wZXJ0aWVzIG9mIHRoZVxuICAgICAgICAgKiBmaXh0dXJlcy4gVGhpcyBub3JtYWxseSBkb2VzIG5vdCBuZWVkIHRvIGJlIGNhbGxlZCB1bmxlc3MgeW91IGNhbGxlZFxuICAgICAgICAgKiBTZXRNYXNzRGF0YSB0byBvdmVycmlkZSB0aGUgbWFzcyBhbmQgeW91IGxhdGVyIHdhbnQgdG8gcmVzZXQgdGhlIG1hc3MuXG4gICAgICAgICAqL1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5yZXNldE1hc3NEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSBtYXNzIGRhdGEgZnJvbSBzaGFwZXMuIEVhY2ggc2hhcGUgaGFzIGl0cyBvd24gZGVuc2l0eS5cbiAgICAgICAgICAgIHRoaXMubV9tYXNzID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3MgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLm1fSSA9IDAuMDtcbiAgICAgICAgICAgIHRoaXMubV9pbnZJID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwLmxvY2FsQ2VudGVyLnNldFplcm8oKTtcbiAgICAgICAgICAgIC8vIFN0YXRpYyBhbmQga2luZW1hdGljIGJvZGllcyBoYXZlIHplcm8gbWFzcy5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhdGljKCkgfHwgdGhpcy5pc0tpbmVtYXRpYygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3N3ZWVwLmMwLnNldFZlYzIodGhpcy5tX3hmLnApO1xuICAgICAgICAgICAgICAgIHRoaXMubV9zd2VlcC5jLnNldFZlYzIodGhpcy5tX3hmLnApO1xuICAgICAgICAgICAgICAgIHRoaXMubV9zd2VlcC5hMCA9IHRoaXMubV9zd2VlcC5hO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgbWFzcyBvdmVyIGFsbCBmaXh0dXJlcy5cbiAgICAgICAgICAgIHZhciBsb2NhbENlbnRlciA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgZm9yICh2YXIgZiA9IHRoaXMubV9maXh0dXJlTGlzdDsgZjsgZiA9IGYubV9uZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGYubV9kZW5zaXR5ID09IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1hc3NEYXRhID0gbmV3IE1hc3NEYXRhKCk7XG4gICAgICAgICAgICAgICAgZi5nZXRNYXNzRGF0YShtYXNzRGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21hc3MgKz0gbWFzc0RhdGEubWFzcztcbiAgICAgICAgICAgICAgICBsb2NhbENlbnRlci5hZGRNdWwobWFzc0RhdGEubWFzcywgbWFzc0RhdGEuY2VudGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fSSArPSBtYXNzRGF0YS5JO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBjZW50ZXIgb2YgbWFzcy5cbiAgICAgICAgICAgIGlmICh0aGlzLm1fbWFzcyA+IDAuMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbnZNYXNzID0gMS4wIC8gdGhpcy5tX21hc3M7XG4gICAgICAgICAgICAgICAgbG9jYWxDZW50ZXIubXVsKHRoaXMubV9pbnZNYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGFsbCBkeW5hbWljIGJvZGllcyB0byBoYXZlIGEgcG9zaXRpdmUgbWFzcy5cbiAgICAgICAgICAgICAgICB0aGlzLm1fbWFzcyA9IDEuMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW52TWFzcyA9IDEuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1fSSA+IDAuMCAmJiB0aGlzLm1fZml4ZWRSb3RhdGlvbkZsYWcgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBDZW50ZXIgdGhlIGluZXJ0aWEgYWJvdXQgdGhlIGNlbnRlciBvZiBtYXNzLlxuICAgICAgICAgICAgICAgIHRoaXMubV9JIC09IHRoaXMubV9tYXNzICogVmVjMi5kb3QobG9jYWxDZW50ZXIsIGxvY2FsQ2VudGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW52SSA9IDEuMCAvIHRoaXMubV9JO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX0kgPSAwLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ludkkgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNb3ZlIGNlbnRlciBvZiBtYXNzLlxuICAgICAgICAgICAgdmFyIG9sZENlbnRlciA9IFZlYzIuY2xvbmUodGhpcy5tX3N3ZWVwLmMpO1xuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwLnNldExvY2FsQ2VudGVyKGxvY2FsQ2VudGVyLCB0aGlzLm1feGYpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIGNlbnRlciBvZiBtYXNzIHZlbG9jaXR5LlxuICAgICAgICAgICAgdGhpcy5tX2xpbmVhclZlbG9jaXR5LmFkZChWZWMyLmNyb3NzTnVtVmVjMih0aGlzLm1fYW5ndWxhclZlbG9jaXR5LCBWZWMyLnN1Yih0aGlzLm1fc3dlZXAuYywgb2xkQ2VudGVyKSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBtYXNzIHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgdGhlIG1hc3MgcHJvcGVydGllcyBvZiB0aGUgZml4dHVyZXMuIE5vdGVcbiAgICAgICAgICogdGhhdCB0aGlzIGNoYW5nZXMgdGhlIGNlbnRlciBvZiBtYXNzIHBvc2l0aW9uLiBOb3RlIHRoYXQgY3JlYXRpbmcgb3JcbiAgICAgICAgICogZGVzdHJveWluZyBmaXh0dXJlcyBjYW4gYWxzbyBhbHRlciB0aGUgbWFzcy4gVGhpcyBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0IGlmXG4gICAgICAgICAqIHRoZSBib2R5IGlzbid0IGR5bmFtaWMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBtYXNzRGF0YSBUaGUgbWFzcyBwcm9wZXJ0aWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuc2V0TWFzc0RhdGEgPSBmdW5jdGlvbiAobWFzc0RhdGEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzV29ybGRMb2NrZWQoKSA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV90eXBlICE9IERZTkFNSUMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzcyA9IDAuMDtcbiAgICAgICAgICAgIHRoaXMubV9JID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5tX2ludkkgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLm1fbWFzcyA9IG1hc3NEYXRhLm1hc3M7XG4gICAgICAgICAgICBpZiAodGhpcy5tX21hc3MgPD0gMC4wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21hc3MgPSAxLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzcyA9IDEuMCAvIHRoaXMubV9tYXNzO1xuICAgICAgICAgICAgaWYgKG1hc3NEYXRhLkkgPiAwLjAgJiYgdGhpcy5tX2ZpeGVkUm90YXRpb25GbGFnID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX0kgPSBtYXNzRGF0YS5JIC0gdGhpcy5tX21hc3NcbiAgICAgICAgICAgICAgICAgICAgKiBWZWMyLmRvdChtYXNzRGF0YS5jZW50ZXIsIG1hc3NEYXRhLmNlbnRlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ludkkgPSAxLjAgLyB0aGlzLm1fSTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1vdmUgY2VudGVyIG9mIG1hc3MuXG4gICAgICAgICAgICB2YXIgb2xkQ2VudGVyID0gVmVjMi5jbG9uZSh0aGlzLm1fc3dlZXAuYyk7XG4gICAgICAgICAgICB0aGlzLm1fc3dlZXAuc2V0TG9jYWxDZW50ZXIobWFzc0RhdGEuY2VudGVyLCB0aGlzLm1feGYpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIGNlbnRlciBvZiBtYXNzIHZlbG9jaXR5LlxuICAgICAgICAgICAgdGhpcy5tX2xpbmVhclZlbG9jaXR5LmFkZChWZWMyLmNyb3NzTnVtVmVjMih0aGlzLm1fYW5ndWxhclZlbG9jaXR5LCBWZWMyLnN1Yih0aGlzLm1fc3dlZXAuYywgb2xkQ2VudGVyKSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgYSBmb3JjZSBhdCBhIHdvcmxkIHBvaW50LiBJZiB0aGUgZm9yY2UgaXMgbm90IGFwcGxpZWQgYXQgdGhlIGNlbnRlciBvZlxuICAgICAgICAgKiBtYXNzLCBpdCB3aWxsIGdlbmVyYXRlIGEgdG9ycXVlIGFuZCBhZmZlY3QgdGhlIGFuZ3VsYXIgdmVsb2NpdHkuIFRoaXMgd2FrZXNcbiAgICAgICAgICogdXAgdGhlIGJvZHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBmb3JjZSBUaGUgd29ybGQgZm9yY2UgdmVjdG9yLCB1c3VhbGx5IGluIE5ld3RvbnMgKE4pLlxuICAgICAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvZiBhcHBsaWNhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHdha2UgQWxzbyB3YWtlIHVwIHRoZSBib2R5XG4gICAgICAgICAqL1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24gKGZvcmNlLCBwb2ludCwgd2FrZSkge1xuICAgICAgICAgICAgaWYgKHdha2UgPT09IHZvaWQgMCkgeyB3YWtlID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV90eXBlICE9IERZTkFNSUMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FrZSAmJiB0aGlzLm1fYXdha2VGbGFnID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbid0IGFjY3VtdWxhdGUgYSBmb3JjZSBpZiB0aGUgYm9keSBpcyBzbGVlcGluZy5cbiAgICAgICAgICAgIGlmICh0aGlzLm1fYXdha2VGbGFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ZvcmNlLmFkZChmb3JjZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3RvcnF1ZSArPSBWZWMyLmNyb3NzVmVjMlZlYzIoVmVjMi5zdWIocG9pbnQsIHRoaXMubV9zd2VlcC5jKSwgZm9yY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgYSBmb3JjZSB0byB0aGUgY2VudGVyIG9mIG1hc3MuIFRoaXMgd2FrZXMgdXAgdGhlIGJvZHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBmb3JjZSBUaGUgd29ybGQgZm9yY2UgdmVjdG9yLCB1c3VhbGx5IGluIE5ld3RvbnMgKE4pLlxuICAgICAgICAgKiBAcGFyYW0gd2FrZSBBbHNvIHdha2UgdXAgdGhlIGJvZHlcbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmFwcGx5Rm9yY2VUb0NlbnRlciA9IGZ1bmN0aW9uIChmb3JjZSwgd2FrZSkge1xuICAgICAgICAgICAgaWYgKHdha2UgPT09IHZvaWQgMCkgeyB3YWtlID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV90eXBlICE9IERZTkFNSUMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FrZSAmJiB0aGlzLm1fYXdha2VGbGFnID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbid0IGFjY3VtdWxhdGUgYSBmb3JjZSBpZiB0aGUgYm9keSBpcyBzbGVlcGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMubV9hd2FrZUZsYWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fZm9yY2UuYWRkKGZvcmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IGEgdG9ycXVlLiBUaGlzIGFmZmVjdHMgdGhlIGFuZ3VsYXIgdmVsb2NpdHkgd2l0aG91dCBhZmZlY3RpbmcgdGhlXG4gICAgICAgICAqIGxpbmVhciB2ZWxvY2l0eSBvZiB0aGUgY2VudGVyIG9mIG1hc3MuIFRoaXMgd2FrZXMgdXAgdGhlIGJvZHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0b3JxdWUgQWJvdXQgdGhlIHotYXhpcyAob3V0IG9mIHRoZSBzY3JlZW4pLCB1c3VhbGx5IGluIE4tbS5cbiAgICAgICAgICogQHBhcmFtIHdha2UgQWxzbyB3YWtlIHVwIHRoZSBib2R5XG4gICAgICAgICAqL1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5hcHBseVRvcnF1ZSA9IGZ1bmN0aW9uICh0b3JxdWUsIHdha2UpIHtcbiAgICAgICAgICAgIGlmICh3YWtlID09PSB2b2lkIDApIHsgd2FrZSA9IHRydWU7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1fdHlwZSAhPSBEWU5BTUlDKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdha2UgJiYgdGhpcy5tX2F3YWtlRmxhZyA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb24ndCBhY2N1bXVsYXRlIGEgZm9yY2UgaWYgdGhlIGJvZHkgaXMgc2xlZXBpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLm1fYXdha2VGbGFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3RvcnF1ZSArPSB0b3JxdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSBhbiBpbXB1bHNlIGF0IGEgcG9pbnQuIFRoaXMgaW1tZWRpYXRlbHkgbW9kaWZpZXMgdGhlIHZlbG9jaXR5LiBJdCBhbHNvXG4gICAgICAgICAqIG1vZGlmaWVzIHRoZSBhbmd1bGFyIHZlbG9jaXR5IGlmIHRoZSBwb2ludCBvZiBhcHBsaWNhdGlvbiBpcyBub3QgYXQgdGhlXG4gICAgICAgICAqIGNlbnRlciBvZiBtYXNzLiBUaGlzIHdha2VzIHVwIHRoZSBib2R5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1wdWxzZSBUaGUgd29ybGQgaW1wdWxzZSB2ZWN0b3IsIHVzdWFsbHkgaW4gTi1zZWNvbmRzIG9yIGtnLW0vcy5cbiAgICAgICAgICogQHBhcmFtIHBvaW50IFRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb2YgYXBwbGljYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB3YWtlIEFsc28gd2FrZSB1cCB0aGUgYm9keVxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuYXBwbHlMaW5lYXJJbXB1bHNlID0gZnVuY3Rpb24gKGltcHVsc2UsIHBvaW50LCB3YWtlKSB7XG4gICAgICAgICAgICBpZiAod2FrZSA9PT0gdm9pZCAwKSB7IHdha2UgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5tX3R5cGUgIT0gRFlOQU1JQykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3YWtlICYmIHRoaXMubV9hd2FrZUZsYWcgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG9uJ3QgYWNjdW11bGF0ZSB2ZWxvY2l0eSBpZiB0aGUgYm9keSBpcyBzbGVlcGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMubV9hd2FrZUZsYWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkuYWRkTXVsKHRoaXMubV9pbnZNYXNzLCBpbXB1bHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ICs9IHRoaXMubV9pbnZJICogVmVjMi5jcm9zc1ZlYzJWZWMyKFZlYzIuc3ViKHBvaW50LCB0aGlzLm1fc3dlZXAuYyksIGltcHVsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgYW4gYW5ndWxhciBpbXB1bHNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1wdWxzZSBUaGUgYW5ndWxhciBpbXB1bHNlIGluIHVuaXRzIG9mIGtnKm0qbS9zXG4gICAgICAgICAqIEBwYXJhbSB3YWtlIEFsc28gd2FrZSB1cCB0aGUgYm9keVxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuYXBwbHlBbmd1bGFySW1wdWxzZSA9IGZ1bmN0aW9uIChpbXB1bHNlLCB3YWtlKSB7XG4gICAgICAgICAgICBpZiAod2FrZSA9PT0gdm9pZCAwKSB7IHdha2UgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5tX3R5cGUgIT0gRFlOQU1JQykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3YWtlICYmIHRoaXMubV9hd2FrZUZsYWcgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG9uJ3QgYWNjdW11bGF0ZSB2ZWxvY2l0eSBpZiB0aGUgYm9keSBpcyBzbGVlcGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMubV9hd2FrZUZsYWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ICs9IHRoaXMubV9pbnZJICogaW1wdWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZCB0byBwcmV2ZW50IGNvbm5lY3RlZCBib2RpZXMgKGJ5IGpvaW50cykgZnJvbSBjb2xsaWRpbmcsXG4gICAgICAgICAqIGRlcGVuZGluZyBvbiB0aGUgam9pbnQncyBjb2xsaWRlQ29ubmVjdGVkIGZsYWcuXG4gICAgICAgICAqL1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5zaG91bGRDb2xsaWRlID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgICAgIC8vIEF0IGxlYXN0IG9uZSBib2R5IHNob3VsZCBiZSBkeW5hbWljLlxuICAgICAgICAgICAgaWYgKHRoaXMubV90eXBlICE9IERZTkFNSUMgJiYgdGhhdC5tX3R5cGUgIT0gRFlOQU1JQykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvZXMgYSBqb2ludCBwcmV2ZW50IGNvbGxpc2lvbj9cbiAgICAgICAgICAgIGZvciAodmFyIGpuID0gdGhpcy5tX2pvaW50TGlzdDsgam47IGpuID0gam4ubmV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChqbi5vdGhlciA9PSB0aGF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqbi5qb2ludC5tX2NvbGxpZGVDb25uZWN0ZWQgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsIFVzZWQgZm9yIGRlc2VyaWFsaXplLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuX2FkZEZpeHR1cmUgPSBmdW5jdGlvbiAoZml4dHVyZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNXb3JsZExvY2tlZCgpID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1fYWN0aXZlRmxhZykge1xuICAgICAgICAgICAgICAgIHZhciBicm9hZFBoYXNlID0gdGhpcy5tX3dvcmxkLm1fYnJvYWRQaGFzZTtcbiAgICAgICAgICAgICAgICBmaXh0dXJlLmNyZWF0ZVByb3hpZXMoYnJvYWRQaGFzZSwgdGhpcy5tX3hmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpeHR1cmUubV9uZXh0ID0gdGhpcy5tX2ZpeHR1cmVMaXN0O1xuICAgICAgICAgICAgdGhpcy5tX2ZpeHR1cmVMaXN0ID0gZml4dHVyZTtcbiAgICAgICAgICAgIC8vIEFkanVzdCBtYXNzIHByb3BlcnRpZXMgaWYgbmVlZGVkLlxuICAgICAgICAgICAgaWYgKGZpeHR1cmUubV9kZW5zaXR5ID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldE1hc3NEYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMZXQgdGhlIHdvcmxkIGtub3cgd2UgaGF2ZSBhIG5ldyBmaXh0dXJlLiBUaGlzIHdpbGwgY2F1c2UgbmV3IGNvbnRhY3RzXG4gICAgICAgICAgICAvLyB0byBiZSBjcmVhdGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgdGltZSBzdGVwLlxuICAgICAgICAgICAgdGhpcy5tX3dvcmxkLm1fbmV3Rml4dHVyZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZml4dHVyZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgQm9keS5wcm90b3R5cGUuY3JlYXRlRml4dHVyZSA9IGZ1bmN0aW9uIChzaGFwZSwgZml4ZGVmKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1dvcmxkTG9ja2VkKCkgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpeHR1cmUgPSBuZXcgRml4dHVyZSh0aGlzLCBzaGFwZSwgZml4ZGVmKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZEZpeHR1cmUoZml4dHVyZSk7XG4gICAgICAgICAgICByZXR1cm4gZml4dHVyZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3kgYSBmaXh0dXJlLiBUaGlzIHJlbW92ZXMgdGhlIGZpeHR1cmUgZnJvbSB0aGUgYnJvYWQtcGhhc2UgYW5kIGRlc3Ryb3lzXG4gICAgICAgICAqIGFsbCBjb250YWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaXh0dXJlLiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSBhZGp1c3QgdGhlXG4gICAgICAgICAqIG1hc3Mgb2YgdGhlIGJvZHkgaWYgdGhlIGJvZHkgaXMgZHluYW1pYyBhbmQgdGhlIGZpeHR1cmUgaGFzIHBvc2l0aXZlIGRlbnNpdHkuXG4gICAgICAgICAqIEFsbCBmaXh0dXJlcyBhdHRhY2hlZCB0byBhIGJvZHkgYXJlIGltcGxpY2l0bHkgZGVzdHJveWVkIHdoZW4gdGhlIGJvZHkgaXNcbiAgICAgICAgICogZGVzdHJveWVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXYXJuaW5nOiBUaGlzIGZ1bmN0aW9uIGlzIGxvY2tlZCBkdXJpbmcgY2FsbGJhY2tzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZml4dHVyZSBUaGUgZml4dHVyZSB0byBiZSByZW1vdmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZGVzdHJveUZpeHR1cmUgPSBmdW5jdGlvbiAoZml4dHVyZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNXb3JsZExvY2tlZCgpID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tX2ZpeHR1cmVMaXN0ID09PSBmaXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ZpeHR1cmVMaXN0ID0gZml4dHVyZS5tX25leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubV9maXh0dXJlTGlzdDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm1fbmV4dCA9PT0gZml4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tX25leHQgPSBmaXh0dXJlLm1fbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm1fbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZXN0cm95IGFueSBjb250YWN0cyBhc3NvY2lhdGVkIHdpdGggdGhlIGZpeHR1cmUuXG4gICAgICAgICAgICB2YXIgZWRnZSA9IHRoaXMubV9jb250YWN0TGlzdDtcbiAgICAgICAgICAgIHdoaWxlIChlZGdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBlZGdlLmNvbnRhY3Q7XG4gICAgICAgICAgICAgICAgZWRnZSA9IGVkZ2UubmV4dDtcbiAgICAgICAgICAgICAgICB2YXIgZml4dHVyZUEgPSBjLmdldEZpeHR1cmVBKCk7XG4gICAgICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gYy5nZXRGaXh0dXJlQigpO1xuICAgICAgICAgICAgICAgIGlmIChmaXh0dXJlID09IGZpeHR1cmVBIHx8IGZpeHR1cmUgPT0gZml4dHVyZUIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBkZXN0cm95cyB0aGUgY29udGFjdCBhbmQgcmVtb3ZlcyBpdCBmcm9tXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYm9keSdzIGNvbnRhY3QgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3dvcmxkLmRlc3Ryb3lDb250YWN0KGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1fYWN0aXZlRmxhZykge1xuICAgICAgICAgICAgICAgIHZhciBicm9hZFBoYXNlID0gdGhpcy5tX3dvcmxkLm1fYnJvYWRQaGFzZTtcbiAgICAgICAgICAgICAgICBmaXh0dXJlLmRlc3Ryb3lQcm94aWVzKGJyb2FkUGhhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZml4dHVyZS5tX2JvZHkgPSBudWxsO1xuICAgICAgICAgICAgZml4dHVyZS5tX25leHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tX3dvcmxkLnB1Ymxpc2goJ3JlbW92ZS1maXh0dXJlJywgZml4dHVyZSk7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgbWFzcyBkYXRhLlxuICAgICAgICAgICAgdGhpcy5yZXNldE1hc3NEYXRhKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvcnJlc3BvbmRpbmcgd29ybGQgcG9pbnQgb2YgYSBsb2NhbCBwb2ludC5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldFdvcmxkUG9pbnQgPSBmdW5jdGlvbiAobG9jYWxQb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybS5tdWxWZWMyKHRoaXMubV94ZiwgbG9jYWxQb2ludCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvcnJlc3BvbmRpbmcgd29ybGQgdmVjdG9yIG9mIGEgbG9jYWwgdmVjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0V29ybGRWZWN0b3IgPSBmdW5jdGlvbiAobG9jYWxWZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBSb3QubXVsVmVjMih0aGlzLm1feGYucSwgbG9jYWxWZWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgY29ycmVzcG9uZGluZyBsb2NhbCBwb2ludCBvZiBhIHdvcmxkIHBvaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0TG9jYWxQb2ludCA9IGZ1bmN0aW9uICh3b3JsZFBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtLm11bFRWZWMyKHRoaXMubV94Ziwgd29ybGRQb2ludCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjb3JyZXNwb25kaW5nIGxvY2FsIHZlY3RvciBvZiBhIHdvcmxkIHZlY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldExvY2FsVmVjdG9yID0gZnVuY3Rpb24gKHdvcmxkVmVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUm90Lm11bFRWZWMyKHRoaXMubV94Zi5xLCB3b3JsZFZlY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN0YXRpYyBib2R5IGRvZXMgbm90IG1vdmUgdW5kZXIgc2ltdWxhdGlvbiBhbmQgYmVoYXZlcyBhcyBpZiBpdCBoYXMgaW5maW5pdGUgbWFzcy5cbiAgICAgICAgICogSW50ZXJuYWxseSwgemVybyBpcyBzdG9yZWQgZm9yIHRoZSBtYXNzIGFuZCB0aGUgaW52ZXJzZSBtYXNzLlxuICAgICAgICAgKiBTdGF0aWMgYm9kaWVzIGNhbiBiZSBtb3ZlZCBtYW51YWxseSBieSB0aGUgdXNlci5cbiAgICAgICAgICogQSBzdGF0aWMgYm9keSBoYXMgemVybyB2ZWxvY2l0eS5cbiAgICAgICAgICogU3RhdGljIGJvZGllcyBkbyBub3QgY29sbGlkZSB3aXRoIG90aGVyIHN0YXRpYyBvciBraW5lbWF0aWMgYm9kaWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5TVEFUSUMgPSAnc3RhdGljJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEga2luZW1hdGljIGJvZHkgbW92ZXMgdW5kZXIgc2ltdWxhdGlvbiBhY2NvcmRpbmcgdG8gaXRzIHZlbG9jaXR5LlxuICAgICAgICAgKiBLaW5lbWF0aWMgYm9kaWVzIGRvIG5vdCByZXNwb25kIHRvIGZvcmNlcy5cbiAgICAgICAgICogVGhleSBjYW4gYmUgbW92ZWQgbWFudWFsbHkgYnkgdGhlIHVzZXIsIGJ1dCBub3JtYWxseSBhIGtpbmVtYXRpYyBib2R5IGlzIG1vdmVkIGJ5IHNldHRpbmcgaXRzIHZlbG9jaXR5LlxuICAgICAgICAgKiBBIGtpbmVtYXRpYyBib2R5IGJlaGF2ZXMgYXMgaWYgaXQgaGFzIGluZmluaXRlIG1hc3MsIGhvd2V2ZXIsIHplcm8gaXMgc3RvcmVkIGZvciB0aGUgbWFzcyBhbmQgdGhlIGludmVyc2UgbWFzcy5cbiAgICAgICAgICogS2luZW1hdGljIGJvZGllcyBkbyBub3QgY29sbGlkZSB3aXRoIG90aGVyIGtpbmVtYXRpYyBvciBzdGF0aWMgYm9kaWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5LSU5FTUFUSUMgPSAna2luZW1hdGljJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZHluYW1pYyBib2R5IGlzIGZ1bGx5IHNpbXVsYXRlZC5cbiAgICAgICAgICogVGhleSBjYW4gYmUgbW92ZWQgbWFudWFsbHkgYnkgdGhlIHVzZXIsIGJ1dCBub3JtYWxseSB0aGV5IG1vdmUgYWNjb3JkaW5nIHRvIGZvcmNlcy5cbiAgICAgICAgICogQSBkeW5hbWljIGJvZHkgY2FuIGNvbGxpZGUgd2l0aCBhbGwgYm9keSB0eXBlcy5cbiAgICAgICAgICogQSBkeW5hbWljIGJvZHkgYWx3YXlzIGhhcyBmaW5pdGUsIG5vbi16ZXJvIG1hc3MuXG4gICAgICAgICAqIElmIHlvdSB0cnkgdG8gc2V0IHRoZSBtYXNzIG9mIGEgZHluYW1pYyBib2R5IHRvIHplcm8sIGl0IHdpbGwgYXV0b21hdGljYWxseSBhY3F1aXJlIGEgbWFzcyBvZiBvbmUga2lsb2dyYW0gYW5kIGl0IHdvbid0IHJvdGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkuRFlOQU1JQyA9ICdkeW5hbWljJztcbiAgICAgICAgcmV0dXJuIEJvZHk7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBIDItYnktMiBtYXRyaXguIFN0b3JlZCBpbiBjb2x1bW4tbWFqb3Igb3JkZXIuXG4gICAgICovXG4gICAgdmFyIE1hdDIyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHlwZWRlZlxuICAgICAgICBmdW5jdGlvbiBNYXQyMihhLCBiLCBjLCBkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ID0gVmVjMi5jbG9uZShhKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV5ID0gVmVjMi5jbG9uZShiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXggPSBWZWMyLm5lbyhhLCBjKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV5ID0gVmVjMi5uZW8oYiwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5leSA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTWF0MjIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBNYXQyMi5pc1ZhbGlkID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBWZWMyLmlzVmFsaWQob2JqLmV4KSAmJiBWZWMyLmlzVmFsaWQob2JqLmV5KTtcbiAgICAgICAgfTtcbiAgICAgICAgTWF0MjIuYXNzZXJ0ID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgTWF0MjIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYyA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAmJiB0eXBlb2YgZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4LnNldE51bShhLCBjKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV5LnNldE51bShiLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4LnNldFZlYzIoYSk7XG4gICAgICAgICAgICAgICAgdGhpcy5leS5zZXRWZWMyKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leC5zZXRWZWMyKGEuZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXkuc2V0VmVjMihhLmV5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgO1xuICAgICAgICB9O1xuICAgICAgICBNYXQyMi5wcm90b3R5cGUuc2V0SWRlbnRpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmV4LnggPSAxLjA7XG4gICAgICAgICAgICB0aGlzLmV5LnggPSAwLjA7XG4gICAgICAgICAgICB0aGlzLmV4LnkgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLmV5LnkgPSAxLjA7XG4gICAgICAgIH07XG4gICAgICAgIE1hdDIyLnByb3RvdHlwZS5zZXRaZXJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5leC54ID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5leS54ID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5leC55ID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5leS55ID0gMC4wO1xuICAgICAgICB9O1xuICAgICAgICBNYXQyMi5wcm90b3R5cGUuZ2V0SW52ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5leC54O1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmV5Lng7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuZXgueTtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5leS55O1xuICAgICAgICAgICAgdmFyIGRldCA9IGEgKiBkIC0gYiAqIGM7XG4gICAgICAgICAgICBpZiAoZGV0ICE9PSAwLjApIHtcbiAgICAgICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW14ID0gbmV3IE1hdDIyKCk7XG4gICAgICAgICAgICBpbXguZXgueCA9IGRldCAqIGQ7XG4gICAgICAgICAgICBpbXguZXkueCA9IC1kZXQgKiBiO1xuICAgICAgICAgICAgaW14LmV4LnkgPSAtZGV0ICogYztcbiAgICAgICAgICAgIGlteC5leS55ID0gZGV0ICogYTtcbiAgICAgICAgICAgIHJldHVybiBpbXg7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb2x2ZSBBICogeCA9IGIsIHdoZXJlIGIgaXMgYSBjb2x1bW4gdmVjdG9yLiBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW5cbiAgICAgICAgICogY29tcHV0aW5nIHRoZSBpbnZlcnNlIGluIG9uZS1zaG90IGNhc2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgTWF0MjIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5leC54O1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmV5Lng7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuZXgueTtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5leS55O1xuICAgICAgICAgICAgdmFyIGRldCA9IGEgKiBkIC0gYiAqIGM7XG4gICAgICAgICAgICBpZiAoZGV0ICE9PSAwLjApIHtcbiAgICAgICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdyA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgdy54ID0gZGV0ICogKGQgKiB2LnggLSBiICogdi55KTtcbiAgICAgICAgICAgIHcueSA9IGRldCAqIChhICogdi55IC0gYyAqIHYueCk7XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgTWF0MjIubXVsID0gZnVuY3Rpb24gKG14LCB2KSB7XG4gICAgICAgICAgICBpZiAodiAmJiAneCcgaW4gdiAmJiAneScgaW4gdikge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gbXguZXgueCAqIHYueCArIG14LmV5LnggKiB2Lnk7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBteC5leC55ICogdi54ICsgbXguZXkueSAqIHYueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2ICYmICdleCcgaW4gdiAmJiAnZXknIGluIHYpIHsgLy8gTWF0MjJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gbmV3IE1hdDIyKFZlYzIubXVsKG14LCB2LmV4KSwgVmVjMi5tdWwobXgsIHYuZXkpKTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IG14LmV4LnggKiB2LmV4LnggKyBteC5leS54ICogdi5leC55O1xuICAgICAgICAgICAgICAgIHZhciBiID0gbXguZXgueCAqIHYuZXkueCArIG14LmV5LnggKiB2LmV5Lnk7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBteC5leC55ICogdi5leC54ICsgbXguZXkueSAqIHYuZXgueTtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IG14LmV4LnkgKiB2LmV5LnggKyBteC5leS55ICogdi5leS55O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWF0MjIoYSwgYiwgYywgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE1hdDIyLm11bFZlYzIgPSBmdW5jdGlvbiAobXgsIHYpIHtcbiAgICAgICAgICAgIHZhciB4ID0gbXguZXgueCAqIHYueCArIG14LmV5LnggKiB2Lnk7XG4gICAgICAgICAgICB2YXIgeSA9IG14LmV4LnkgKiB2LnggKyBteC5leS55ICogdi55O1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHgsIHkpO1xuICAgICAgICB9O1xuICAgICAgICBNYXQyMi5tdWxNYXQyMiA9IGZ1bmN0aW9uIChteCwgdikge1xuICAgICAgICAgICAgLy8gcmV0dXJuIG5ldyBNYXQyMihWZWMyLm11bChteCwgdi5leCksIFZlYzIubXVsKG14LCB2LmV5KSk7XG4gICAgICAgICAgICB2YXIgYSA9IG14LmV4LnggKiB2LmV4LnggKyBteC5leS54ICogdi5leC55O1xuICAgICAgICAgICAgdmFyIGIgPSBteC5leC54ICogdi5leS54ICsgbXguZXkueCAqIHYuZXkueTtcbiAgICAgICAgICAgIHZhciBjID0gbXguZXgueSAqIHYuZXgueCArIG14LmV5LnkgKiB2LmV4Lnk7XG4gICAgICAgICAgICB2YXIgZCA9IG14LmV4LnkgKiB2LmV5LnggKyBteC5leS55ICogdi5leS55O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXQyMihhLCBiLCBjLCBkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgTWF0MjIubXVsVCA9IGZ1bmN0aW9uIChteCwgdikge1xuICAgICAgICAgICAgaWYgKHYgJiYgJ3gnIGluIHYgJiYgJ3knIGluIHYpIHsgLy8gVmVjMlxuICAgICAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyhWZWMyLmRvdCh2LCBteC5leCksIFZlYzIuZG90KHYsIG14LmV5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2ICYmICdleCcgaW4gdiAmJiAnZXknIGluIHYpIHsgLy8gTWF0MjJcbiAgICAgICAgICAgICAgICB2YXIgYzEgPSBWZWMyLm5lbyhWZWMyLmRvdChteC5leCwgdi5leCksIFZlYzIuZG90KG14LmV5LCB2LmV4KSk7XG4gICAgICAgICAgICAgICAgdmFyIGMyID0gVmVjMi5uZW8oVmVjMi5kb3QobXguZXgsIHYuZXkpLCBWZWMyLmRvdChteC5leSwgdi5leSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWF0MjIoYzEsIGMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTWF0MjIubXVsVFZlYzIgPSBmdW5jdGlvbiAobXgsIHYpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyhWZWMyLmRvdCh2LCBteC5leCksIFZlYzIuZG90KHYsIG14LmV5KSk7XG4gICAgICAgIH07XG4gICAgICAgIE1hdDIyLm11bFRNYXQyMiA9IGZ1bmN0aW9uIChteCwgdikge1xuICAgICAgICAgICAgdmFyIGMxID0gVmVjMi5uZW8oVmVjMi5kb3QobXguZXgsIHYuZXgpLCBWZWMyLmRvdChteC5leSwgdi5leCkpO1xuICAgICAgICAgICAgdmFyIGMyID0gVmVjMi5uZW8oVmVjMi5kb3QobXguZXgsIHYuZXkpLCBWZWMyLmRvdChteC5leSwgdi5leSkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXQyMihjMSwgYzIpO1xuICAgICAgICB9O1xuICAgICAgICBNYXQyMi5hYnMgPSBmdW5jdGlvbiAobXgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0MjIoVmVjMi5hYnMobXguZXgpLCBWZWMyLmFicyhteC5leSkpO1xuICAgICAgICB9O1xuICAgICAgICBNYXQyMi5hZGQgPSBmdW5jdGlvbiAobXgxLCBteDIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0MjIoVmVjMi5hZGQobXgxLmV4LCBteDIuZXgpLCBWZWMyLmFkZChteDEuZXksIG14Mi5leSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTWF0MjI7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICB2YXIgTWFuaWZvbGRUeXBlO1xuICAgIChmdW5jdGlvbiAoTWFuaWZvbGRUeXBlKSB7XG4gICAgICAgIE1hbmlmb2xkVHlwZVtNYW5pZm9sZFR5cGVbXCJlX2NpcmNsZXNcIl0gPSAwXSA9IFwiZV9jaXJjbGVzXCI7XG4gICAgICAgIE1hbmlmb2xkVHlwZVtNYW5pZm9sZFR5cGVbXCJlX2ZhY2VBXCJdID0gMV0gPSBcImVfZmFjZUFcIjtcbiAgICAgICAgTWFuaWZvbGRUeXBlW01hbmlmb2xkVHlwZVtcImVfZmFjZUJcIl0gPSAyXSA9IFwiZV9mYWNlQlwiO1xuICAgIH0pKE1hbmlmb2xkVHlwZSB8fCAoTWFuaWZvbGRUeXBlID0ge30pKTtcbiAgICB2YXIgQ29udGFjdEZlYXR1cmVUeXBlO1xuICAgIChmdW5jdGlvbiAoQ29udGFjdEZlYXR1cmVUeXBlKSB7XG4gICAgICAgIENvbnRhY3RGZWF0dXJlVHlwZVtDb250YWN0RmVhdHVyZVR5cGVbXCJlX3ZlcnRleFwiXSA9IDBdID0gXCJlX3ZlcnRleFwiO1xuICAgICAgICBDb250YWN0RmVhdHVyZVR5cGVbQ29udGFjdEZlYXR1cmVUeXBlW1wiZV9mYWNlXCJdID0gMV0gPSBcImVfZmFjZVwiO1xuICAgIH0pKENvbnRhY3RGZWF0dXJlVHlwZSB8fCAoQ29udGFjdEZlYXR1cmVUeXBlID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBzdGF0ZSBvZiBjb250YWN0IHBvaW50cy5cbiAgICAgKi9cbiAgICB2YXIgUG9pbnRTdGF0ZTtcbiAgICAoZnVuY3Rpb24gKFBvaW50U3RhdGUpIHtcbiAgICAgICAgLyoqIFBvaW50IGRvZXMgbm90IGV4aXN0ICovXG4gICAgICAgIFBvaW50U3RhdGVbUG9pbnRTdGF0ZVtcIm51bGxTdGF0ZVwiXSA9IDBdID0gXCJudWxsU3RhdGVcIjtcbiAgICAgICAgLyoqIFBvaW50IHdhcyBhZGRlZCBpbiB0aGUgdXBkYXRlICovXG4gICAgICAgIFBvaW50U3RhdGVbUG9pbnRTdGF0ZVtcImFkZFN0YXRlXCJdID0gMV0gPSBcImFkZFN0YXRlXCI7XG4gICAgICAgIC8qKiBQb2ludCBwZXJzaXN0ZWQgYWNyb3NzIHRoZSB1cGRhdGUgKi9cbiAgICAgICAgUG9pbnRTdGF0ZVtQb2ludFN0YXRlW1wicGVyc2lzdFN0YXRlXCJdID0gMl0gPSBcInBlcnNpc3RTdGF0ZVwiO1xuICAgICAgICAvKiogUG9pbnQgd2FzIHJlbW92ZWQgaW4gdGhlIHVwZGF0ZSAqL1xuICAgICAgICBQb2ludFN0YXRlW1BvaW50U3RhdGVbXCJyZW1vdmVTdGF0ZVwiXSA9IDNdID0gXCJyZW1vdmVTdGF0ZVwiO1xuICAgIH0pKFBvaW50U3RhdGUgfHwgKFBvaW50U3RhdGUgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGNvbXB1dGluZyBjb250YWN0IG1hbmlmb2xkcy5cbiAgICAgKi9cbiAgICB2YXIgQ2xpcFZlcnRleCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2xpcFZlcnRleCgpIHtcbiAgICAgICAgICAgIHRoaXMudiA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgdGhpcy5pZCA9IG5ldyBDb250YWN0SUQoKTtcbiAgICAgICAgfVxuICAgICAgICBDbGlwVmVydGV4LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdGhpcy52LnNldFZlYzIoby52KTtcbiAgICAgICAgICAgIHRoaXMuaWQuc2V0KG8uaWQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ2xpcFZlcnRleDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEEgbWFuaWZvbGQgZm9yIHR3byB0b3VjaGluZyBjb252ZXggc2hhcGVzLiBNYW5pZm9sZHMgYXJlIGNyZWF0ZWQgaW4gYGV2YWx1YXRlYFxuICAgICAqIG1ldGhvZCBvZiBDb250YWN0IHN1YmNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBTdXBwb3J0ZWQgbWFuaWZvbGQgdHlwZXMgYXJlIGVfZmFjZUEgb3IgZV9mYWNlQiBmb3IgY2xpcCBwb2ludCB2ZXJzdXMgcGxhbmVcbiAgICAgKiB3aXRoIHJhZGl1cyBhbmQgZV9jaXJjbGVzIHBvaW50IHZlcnN1cyBwb2ludCB3aXRoIHJhZGl1cy5cbiAgICAgKlxuICAgICAqIFdlIHN0b3JlIGNvbnRhY3RzIGluIHRoaXMgd2F5IHNvIHRoYXQgcG9zaXRpb24gY29ycmVjdGlvbiBjYW4gYWNjb3VudCBmb3JcbiAgICAgKiBtb3ZlbWVudCwgd2hpY2ggaXMgY3JpdGljYWwgZm9yIGNvbnRpbnVvdXMgcGh5c2ljcy4gQWxsIGNvbnRhY3Qgc2NlbmFyaW9zXG4gICAgICogbXVzdCBiZSBleHByZXNzZWQgaW4gb25lIG9mIHRoZXNlIHR5cGVzLiBUaGlzIHN0cnVjdHVyZSBpcyBzdG9yZWQgYWNyb3NzIHRpbWVcbiAgICAgKiBzdGVwcywgc28gd2Uga2VlcCBpdCBzbWFsbC5cbiAgICAgKlxuICAgICAqIEBwcm9wIHR5cGUgZV9jaXJjbGUsIGVfZmFjZUEsIGVfZmFjZUJcbiAgICAgKiBAcHJvcCBsb2NhbFBvaW50IFVzYWdlIGRlcGVuZHMgb24gbWFuaWZvbGQgdHlwZTo8YnI+XG4gICAgICogICAgICAgZV9jaXJjbGVzOiB0aGUgbG9jYWwgY2VudGVyIG9mIGNpcmNsZUEgPGJyPlxuICAgICAqICAgICAgIGVfZmFjZUE6IHRoZSBjZW50ZXIgb2YgZmFjZUEgPGJyPlxuICAgICAqICAgICAgIGVfZmFjZUI6IHRoZSBjZW50ZXIgb2YgZmFjZUJcbiAgICAgKiBAcHJvcCBsb2NhbE5vcm1hbCBVc2FnZSBkZXBlbmRzIG9uIG1hbmlmb2xkIHR5cGU6PGJyPlxuICAgICAqICAgICAgIGVfY2lyY2xlczogbm90IHVzZWQgPGJyPlxuICAgICAqICAgICAgIGVfZmFjZUE6IHRoZSBub3JtYWwgb24gcG9seWdvbkEgPGJyPlxuICAgICAqICAgICAgIGVfZmFjZUI6IHRoZSBub3JtYWwgb24gcG9seWdvbkJcbiAgICAgKiBAcHJvcCBwb2ludHMgVGhlIHBvaW50cyBvZiBjb250YWN0IHtNYW5pZm9sZFBvaW50W119XG4gICAgICogQHByb3AgcG9pbnRDb3VudCBUaGUgbnVtYmVyIG9mIG1hbmlmb2xkIHBvaW50c1xuICAgICAqL1xuICAgIHZhciBNYW5pZm9sZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTWFuaWZvbGQoKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsTm9ybWFsID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICB0aGlzLmxvY2FsUG9pbnQgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gW25ldyBNYW5pZm9sZFBvaW50KCksIG5ldyBNYW5pZm9sZFBvaW50KCldO1xuICAgICAgICAgICAgdGhpcy5wb2ludENvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRXZhbHVhdGUgdGhlIG1hbmlmb2xkIHdpdGggc3VwcGxpZWQgdHJhbnNmb3Jtcy4gVGhpcyBhc3N1bWVzIG1vZGVzdCBtb3Rpb25cbiAgICAgICAgICogZnJvbSB0aGUgb3JpZ2luYWwgc3RhdGUuIFRoaXMgZG9lcyBub3QgY2hhbmdlIHRoZSBwb2ludCBjb3VudCwgaW1wdWxzZXMsIGV0Yy5cbiAgICAgICAgICogVGhlIHJhZGlpIG11c3QgY29tZSBmcm9tIHRoZSBzaGFwZXMgdGhhdCBnZW5lcmF0ZWQgdGhlIG1hbmlmb2xkLlxuICAgICAgICAgKi9cbiAgICAgICAgTWFuaWZvbGQucHJvdG90eXBlLmdldFdvcmxkTWFuaWZvbGQgPSBmdW5jdGlvbiAod20sIHhmQSwgcmFkaXVzQSwgeGZCLCByYWRpdXNCKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludENvdW50ID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3bSA9IHdtIHx8IG5ldyBXb3JsZE1hbmlmb2xkKCk7XG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gd20ubm9ybWFsO1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHdtLnBvaW50cztcbiAgICAgICAgICAgIHZhciBzZXBhcmF0aW9ucyA9IHdtLnNlcGFyYXRpb25zO1xuICAgICAgICAgICAgLy8gVE9ETzogaW1wcm92ZVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE1hbmlmb2xkVHlwZS5lX2NpcmNsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsID0gVmVjMi5uZW8oMS4wLCAwLjApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRBID0gVHJhbnNmb3JtLm11bFZlYzIoeGZBLCB0aGlzLmxvY2FsUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRCID0gVHJhbnNmb3JtLm11bFZlYzIoeGZCLCB0aGlzLnBvaW50c1swXS5sb2NhbFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBWZWMyLnN1Yihwb2ludEIsIHBvaW50QSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChWZWMyLmxlbmd0aFNxdWFyZWQoZGlzdCkgPiBtYXRoJDEuRVBTSUxPTiAqIG1hdGgkMS5FUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwuc2V0VmVjMihkaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY0EgPSBwb2ludEEuY2xvbmUoKS5hZGRNdWwocmFkaXVzQSwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNCID0gcG9pbnRCLmNsb25lKCkuYWRkTXVsKC1yYWRpdXNCLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF0gPSBWZWMyLm1pZChjQSwgY0IpO1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0aW9uc1swXSA9IFZlYzIuZG90KFZlYzIuc3ViKGNCLCBjQSksIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5sZW5ndGggPSAxO1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0aW9ucy5sZW5ndGggPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBNYW5pZm9sZFR5cGUuZV9mYWNlQToge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWwgPSBSb3QubXVsVmVjMih4ZkEucSwgdGhpcy5sb2NhbE5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwbGFuZVBvaW50ID0gVHJhbnNmb3JtLm11bFZlYzIoeGZBLCB0aGlzLmxvY2FsUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xpcFBvaW50ID0gVHJhbnNmb3JtLm11bFZlYzIoeGZCLCB0aGlzLnBvaW50c1tpXS5sb2NhbFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjQSA9IFZlYzIuY2xvbmUoY2xpcFBvaW50KS5hZGRNdWwocmFkaXVzQSAtIFZlYzIuZG90KFZlYzIuc3ViKGNsaXBQb2ludCwgcGxhbmVQb2ludCksIG5vcm1hbCksIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY0IgPSBWZWMyLmNsb25lKGNsaXBQb2ludCkuc3ViTXVsKHJhZGl1c0IsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbaV0gPSBWZWMyLm1pZChjQSwgY0IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGlvbnNbaV0gPSBWZWMyLmRvdChWZWMyLnN1YihjQiwgY0EpLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5sZW5ndGggPSB0aGlzLnBvaW50Q291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRpb25zLmxlbmd0aCA9IHRoaXMucG9pbnRDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgTWFuaWZvbGRUeXBlLmVfZmFjZUI6IHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsID0gUm90Lm11bFZlYzIoeGZCLnEsIHRoaXMubG9jYWxOb3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGxhbmVQb2ludCA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQiwgdGhpcy5sb2NhbFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXBQb2ludCA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQSwgdGhpcy5wb2ludHNbaV0ubG9jYWxQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY0IgPSBWZWMyLmNvbWJpbmUoMSwgY2xpcFBvaW50LCByYWRpdXNCIC0gVmVjMi5kb3QoVmVjMi5zdWIoY2xpcFBvaW50LCBwbGFuZVBvaW50KSwgbm9ybWFsKSwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjQSA9IFZlYzIuY29tYmluZSgxLCBjbGlwUG9pbnQsIC1yYWRpdXNBLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzW2ldID0gVmVjMi5taWQoY0EsIGNCKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRpb25zW2ldID0gVmVjMi5kb3QoVmVjMi5zdWIoY0EsIGNCKSwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb2ludHMubGVuZ3RoID0gdGhpcy5wb2ludENvdW50O1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0aW9ucy5sZW5ndGggPSB0aGlzLnBvaW50Q291bnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBub3JtYWwgcG9pbnRzIGZyb20gQSB0byBCLlxuICAgICAgICAgICAgICAgICAgICBub3JtYWwubXVsKC0xKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd20ubm9ybWFsID0gbm9ybWFsO1xuICAgICAgICAgICAgd20ucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICAgICAgd20uc2VwYXJhdGlvbnMgPSBzZXBhcmF0aW9ucztcbiAgICAgICAgICAgIHJldHVybiB3bTtcbiAgICAgICAgfTtcbiAgICAgICAgTWFuaWZvbGQuY2xpcFNlZ21lbnRUb0xpbmUgPSBjbGlwU2VnbWVudFRvTGluZTtcbiAgICAgICAgTWFuaWZvbGQuQ2xpcFZlcnRleCA9IENsaXBWZXJ0ZXg7XG4gICAgICAgIE1hbmlmb2xkLmdldFBvaW50U3RhdGVzID0gZ2V0UG9pbnRTdGF0ZXM7XG4gICAgICAgIE1hbmlmb2xkLlBvaW50U3RhdGUgPSBQb2ludFN0YXRlO1xuICAgICAgICByZXR1cm4gTWFuaWZvbGQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBBIG1hbmlmb2xkIHBvaW50IGlzIGEgY29udGFjdCBwb2ludCBiZWxvbmdpbmcgdG8gYSBjb250YWN0IG1hbmlmb2xkLiBJdCBob2xkc1xuICAgICAqIGRldGFpbHMgcmVsYXRlZCB0byB0aGUgZ2VvbWV0cnkgYW5kIGR5bmFtaWNzIG9mIHRoZSBjb250YWN0IHBvaW50cy5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RydWN0dXJlIGlzIHN0b3JlZCBhY3Jvc3MgdGltZSBzdGVwcywgc28gd2Uga2VlcCBpdCBzbWFsbC5cbiAgICAgKlxuICAgICAqIE5vdGU6IGltcHVsc2VzIGFyZSB1c2VkIGZvciBpbnRlcm5hbCBjYWNoaW5nIGFuZCBtYXkgbm90IHByb3ZpZGUgcmVsaWFibGVcbiAgICAgKiBjb250YWN0IGZvcmNlcywgZXNwZWNpYWxseSBmb3IgaGlnaCBzcGVlZCBjb2xsaXNpb25zLlxuICAgICAqL1xuICAgIHZhciBNYW5pZm9sZFBvaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNYW5pZm9sZFBvaW50KCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVc2FnZSBkZXBlbmRzIG9uIG1hbmlmb2xkIHR5cGUuXG4gICAgICAgICAgICAgKiAgICAgICBlX2NpcmNsZXM6IHRoZSBsb2NhbCBjZW50ZXIgb2YgY2lyY2xlQixcbiAgICAgICAgICAgICAqICAgICAgIGVfZmFjZUE6IHRoZSBsb2NhbCBjZW50ZXIgb2YgY2lybGNlQiBvciB0aGUgY2xpcCBwb2ludCBvZiBwb2x5Z29uQixcbiAgICAgICAgICAgICAqICAgICAgIGVfZmFjZUI6IHRoZSBjbGlwIHBvaW50IG9mIHBvbHlnb25BLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmxvY2FsUG9pbnQgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIG5vbi1wZW5ldHJhdGlvbiBpbXB1bHNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubm9ybWFsSW1wdWxzZSA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBmcmljdGlvbiBpbXB1bHNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudGFuZ2VudEltcHVsc2UgPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVbmlxdWVseSBpZGVudGlmaWVzIGEgY29udGFjdCBwb2ludCBiZXR3ZWVuIHR3byBzaGFwZXMgdG8gZmFjaWxhdGF0ZSB3YXJtIHN0YXJ0aW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaWQgPSBuZXcgQ29udGFjdElEKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hbmlmb2xkUG9pbnQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBDb250YWN0IGlkcyB0byBmYWNpbGl0YXRlIHdhcm0gc3RhcnRpbmcuXG4gICAgICovXG4gICAgdmFyIENvbnRhY3RJRCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29udGFjdElEKCkge1xuICAgICAgICAgICAgdGhpcy5jZiA9IG5ldyBDb250YWN0RmVhdHVyZSgpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWN0SUQucHJvdG90eXBlLCBcImtleVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVzZWQgdG8gcXVpY2tseSBjb21wYXJlIGNvbnRhY3QgaWRzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jZi5pbmRleEEgKyB0aGlzLmNmLmluZGV4QiAqIDQgKyB0aGlzLmNmLnR5cGVBICogMTYgKyB0aGlzLmNmLnR5cGVCICogNjQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIENvbnRhY3RJRC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIC8vIHRoaXMua2V5ID0gby5rZXk7XG4gICAgICAgICAgICB0aGlzLmNmLnNldChvLmNmKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbnRhY3RJRDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBmZWF0dXJlcyB0aGF0IGludGVyc2VjdCB0byBmb3JtIHRoZSBjb250YWN0IHBvaW50LlxuICAgICAqL1xuICAgIHZhciBDb250YWN0RmVhdHVyZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29udGFjdEZlYXR1cmUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgQ29udGFjdEZlYXR1cmUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4QSA9IG8uaW5kZXhBO1xuICAgICAgICAgICAgdGhpcy5pbmRleEIgPSBvLmluZGV4QjtcbiAgICAgICAgICAgIHRoaXMudHlwZUEgPSBvLnR5cGVBO1xuICAgICAgICAgICAgdGhpcy50eXBlQiA9IG8udHlwZUI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDb250YWN0RmVhdHVyZTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBjb21wdXRlIHRoZSBjdXJyZW50IHN0YXRlIG9mIGEgY29udGFjdCBtYW5pZm9sZC5cbiAgICAgKi9cbiAgICB2YXIgV29ybGRNYW5pZm9sZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gV29ybGRNYW5pZm9sZCgpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV29ybGQgY29udGFjdCBwb2ludCAocG9pbnQgb2YgaW50ZXJzZWN0aW9uKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IFtdOyAvLyBbbWF4TWFuaWZvbGRQb2ludHNdXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgbmVnYXRpdmUgdmFsdWUgaW5kaWNhdGVzIG92ZXJsYXAsIGluIG1ldGVyc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnNlcGFyYXRpb25zID0gW107IC8vIFttYXhNYW5pZm9sZFBvaW50c11cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gV29ybGRNYW5pZm9sZDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIHBvaW50IHN0YXRlcyBnaXZlbiB0d28gbWFuaWZvbGRzLiBUaGUgc3RhdGVzIHBlcnRhaW4gdG8gdGhlXG4gICAgICogdHJhbnNpdGlvbiBmcm9tIG1hbmlmb2xkMSB0byBtYW5pZm9sZDIuIFNvIHN0YXRlMSBpcyBlaXRoZXIgcGVyc2lzdCBvciByZW1vdmVcbiAgICAgKiB3aGlsZSBzdGF0ZTIgaXMgZWl0aGVyIGFkZCBvciBwZXJzaXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBvaW50U3RhdGVzKHN0YXRlMSwgc3RhdGUyLCBtYW5pZm9sZDEsIG1hbmlmb2xkMikge1xuICAgICAgICAvLyBzdGF0ZTEsIHN0YXRlMjogUG9pbnRTdGF0ZVtTZXR0aW5ncy5tYXhNYW5pZm9sZFBvaW50c11cbiAgICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBTZXR0aW5ncy5tYXhNYW5pZm9sZFBvaW50czsgKytpKSB7XG4gICAgICAgIC8vIHN0YXRlMVtpXSA9IFBvaW50U3RhdGUubnVsbFN0YXRlO1xuICAgICAgICAvLyBzdGF0ZTJbaV0gPSBQb2ludFN0YXRlLm51bGxTdGF0ZTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBEZXRlY3QgcGVyc2lzdHMgYW5kIHJlbW92ZXMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFuaWZvbGQxLnBvaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGlkID0gbWFuaWZvbGQxLnBvaW50c1tpXS5pZDtcbiAgICAgICAgICAgIHN0YXRlMVtpXSA9IFBvaW50U3RhdGUucmVtb3ZlU3RhdGU7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hbmlmb2xkMi5wb2ludENvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAobWFuaWZvbGQyLnBvaW50c1tqXS5pZC5rZXkgPT0gaWQua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlMVtpXSA9IFBvaW50U3RhdGUucGVyc2lzdFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGV0ZWN0IHBlcnNpc3RzIGFuZCBhZGRzLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hbmlmb2xkMi5wb2ludENvdW50OyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IG1hbmlmb2xkMi5wb2ludHNbaV0uaWQ7XG4gICAgICAgICAgICBzdGF0ZTJbaV0gPSBQb2ludFN0YXRlLmFkZFN0YXRlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYW5pZm9sZDEucG9pbnRDb3VudDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbmlmb2xkMS5wb2ludHNbal0uaWQua2V5ID09IGlkLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTJbaV0gPSBQb2ludFN0YXRlLnBlcnNpc3RTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsaXBwaW5nIGZvciBjb250YWN0IG1hbmlmb2xkcy4gU3V0aGVybGFuZC1Ib2RnbWFuIGNsaXBwaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsaXBTZWdtZW50VG9MaW5lKHZPdXQsIHZJbiwgbm9ybWFsLCBvZmZzZXQsIHZlcnRleEluZGV4QSkge1xuICAgICAgICAvLyBTdGFydCB3aXRoIG5vIG91dHB1dCBwb2ludHNcbiAgICAgICAgdmFyIG51bU91dCA9IDA7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2Ugb2YgZW5kIHBvaW50cyB0byB0aGUgbGluZVxuICAgICAgICB2YXIgZGlzdGFuY2UwID0gVmVjMi5kb3Qobm9ybWFsLCB2SW5bMF0udikgLSBvZmZzZXQ7XG4gICAgICAgIHZhciBkaXN0YW5jZTEgPSBWZWMyLmRvdChub3JtYWwsIHZJblsxXS52KSAtIG9mZnNldDtcbiAgICAgICAgLy8gSWYgdGhlIHBvaW50cyBhcmUgYmVoaW5kIHRoZSBwbGFuZVxuICAgICAgICBpZiAoZGlzdGFuY2UwIDw9IDAuMClcbiAgICAgICAgICAgIHZPdXRbbnVtT3V0KytdLnNldCh2SW5bMF0pO1xuICAgICAgICBpZiAoZGlzdGFuY2UxIDw9IDAuMClcbiAgICAgICAgICAgIHZPdXRbbnVtT3V0KytdLnNldCh2SW5bMV0pO1xuICAgICAgICAvLyBJZiB0aGUgcG9pbnRzIGFyZSBvbiBkaWZmZXJlbnQgc2lkZXMgb2YgdGhlIHBsYW5lXG4gICAgICAgIGlmIChkaXN0YW5jZTAgKiBkaXN0YW5jZTEgPCAwLjApIHtcbiAgICAgICAgICAgIC8vIEZpbmQgaW50ZXJzZWN0aW9uIHBvaW50IG9mIGVkZ2UgYW5kIHBsYW5lXG4gICAgICAgICAgICB2YXIgaW50ZXJwID0gZGlzdGFuY2UwIC8gKGRpc3RhbmNlMCAtIGRpc3RhbmNlMSk7XG4gICAgICAgICAgICB2T3V0W251bU91dF0udi5zZXRDb21iaW5lKDEgLSBpbnRlcnAsIHZJblswXS52LCBpbnRlcnAsIHZJblsxXS52KTtcbiAgICAgICAgICAgIC8vIFZlcnRleEEgaXMgaGl0dGluZyBlZGdlQi5cbiAgICAgICAgICAgIHZPdXRbbnVtT3V0XS5pZC5jZi5pbmRleEEgPSB2ZXJ0ZXhJbmRleEE7XG4gICAgICAgICAgICB2T3V0W251bU91dF0uaWQuY2YuaW5kZXhCID0gdkluWzBdLmlkLmNmLmluZGV4QjtcbiAgICAgICAgICAgIHZPdXRbbnVtT3V0XS5pZC5jZi50eXBlQSA9IENvbnRhY3RGZWF0dXJlVHlwZS5lX3ZlcnRleDtcbiAgICAgICAgICAgIHZPdXRbbnVtT3V0XS5pZC5jZi50eXBlQiA9IENvbnRhY3RGZWF0dXJlVHlwZS5lX2ZhY2U7XG4gICAgICAgICAgICArK251bU91dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtT3V0O1xuICAgIH1cblxuICAgIHZhciBzdGF0cyQxID0ge1xuICAgICAgICBnamtDYWxsczogMCxcbiAgICAgICAgZ2prSXRlcnM6IDAsXG4gICAgICAgIGdqa01heEl0ZXJzOiAwLFxuICAgICAgICB0b2lUaW1lOiAwLFxuICAgICAgICB0b2lNYXhUaW1lOiAwLFxuICAgICAgICB0b2lDYWxsczogMCxcbiAgICAgICAgdG9pSXRlcnM6IDAsXG4gICAgICAgIHRvaU1heEl0ZXJzOiAwLFxuICAgICAgICB0b2lSb290SXRlcnM6IDAsXG4gICAgICAgIHRvaU1heFJvb3RJdGVyczogMCxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChuZXdsaW5lKSB7XG4gICAgICAgICAgICBuZXdsaW5lID0gdHlwZW9mIG5ld2xpbmUgPT09ICdzdHJpbmcnID8gbmV3bGluZSA6ICdcXG4nO1xuICAgICAgICAgICAgdmFyIHN0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZm9yLWluXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tuYW1lXzFdICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0aGlzW25hbWVfMV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBuYW1lXzEgKyAnOiAnICsgdGhpc1tuYW1lXzFdICsgbmV3bGluZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBHSksgdXNpbmcgVm9yb25vaSByZWdpb25zIChDaHJpc3RlciBFcmljc29uKSBhbmQgQmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgc3RhdHMkMS5namtDYWxscyA9IDA7XG4gICAgc3RhdHMkMS5namtJdGVycyA9IDA7XG4gICAgc3RhdHMkMS5namtNYXhJdGVycyA9IDA7XG4gICAgLyoqXG4gICAgICogSW5wdXQgZm9yIERpc3RhbmNlLiBZb3UgaGF2ZSB0byBvcHRpb24gdG8gdXNlIHRoZSBzaGFwZSByYWRpaSBpbiB0aGVcbiAgICAgKiBjb21wdXRhdGlvbi4gRXZlblxuICAgICAqL1xuICAgIHZhciBEaXN0YW5jZUlucHV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEaXN0YW5jZUlucHV0KCkge1xuICAgICAgICAgICAgdGhpcy5wcm94eUEgPSBuZXcgRGlzdGFuY2VQcm94eSgpO1xuICAgICAgICAgICAgdGhpcy5wcm94eUIgPSBuZXcgRGlzdGFuY2VQcm94eSgpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1BID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnVzZVJhZGlpID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERpc3RhbmNlSW5wdXQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBPdXRwdXQgZm9yIERpc3RhbmNlLlxuICAgICAqXG4gICAgICogQHByb3Age1ZlYzJ9IHBvaW50QSBjbG9zZXN0IHBvaW50IG9uIHNoYXBlQVxuICAgICAqIEBwcm9wIHtWZWMyfSBwb2ludEIgY2xvc2VzdCBwb2ludCBvbiBzaGFwZUJcbiAgICAgKiBAcHJvcCBkaXN0YW5jZVxuICAgICAqIEBwcm9wIGl0ZXJhdGlvbnMgbnVtYmVyIG9mIEdKSyBpdGVyYXRpb25zIHVzZWRcbiAgICAgKi9cbiAgICB2YXIgRGlzdGFuY2VPdXRwdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERpc3RhbmNlT3V0cHV0KCkge1xuICAgICAgICAgICAgdGhpcy5wb2ludEEgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIHRoaXMucG9pbnRCID0gVmVjMi56ZXJvKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERpc3RhbmNlT3V0cHV0O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogVXNlZCB0byB3YXJtIHN0YXJ0IERpc3RhbmNlLiBTZXQgY291bnQgdG8gemVybyBvbiBmaXJzdCBjYWxsLlxuICAgICAqXG4gICAgICogQHByb3Age251bWJlcn0gbWV0cmljIGxlbmd0aCBvciBhcmVhXG4gICAgICogQHByb3Age2FycmF5fSBpbmRleEEgdmVydGljZXMgb24gc2hhcGUgQVxuICAgICAqIEBwcm9wIHthcnJheX0gaW5kZXhCIHZlcnRpY2VzIG9uIHNoYXBlIEJcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBjb3VudFxuICAgICAqL1xuICAgIHZhciBTaW1wbGV4Q2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNpbXBsZXhDYWNoZSgpIHtcbiAgICAgICAgICAgIHRoaXMubWV0cmljID0gMDtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhBID0gW107XG4gICAgICAgICAgICB0aGlzLmluZGV4QiA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNpbXBsZXhDYWNoZTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIGNsb3Nlc3QgcG9pbnRzIGJldHdlZW4gdHdvIHNoYXBlcy4gU3VwcG9ydHMgYW55IGNvbWJpbmF0aW9uIG9mOlxuICAgICAqIENpcmNsZVNoYXBlLCBQb2x5Z29uU2hhcGUsIEVkZ2VTaGFwZS4gVGhlIHNpbXBsZXggY2FjaGUgaXMgaW5wdXQvb3V0cHV0LiBPblxuICAgICAqIHRoZSBmaXJzdCBjYWxsIHNldCBTaW1wbGV4Q2FjaGUuY291bnQgdG8gemVyby5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaXN0YW5jZShvdXRwdXQsIGNhY2hlLCBpbnB1dCkge1xuICAgICAgICArK3N0YXRzJDEuZ2prQ2FsbHM7XG4gICAgICAgIHZhciBwcm94eUEgPSBpbnB1dC5wcm94eUE7XG4gICAgICAgIHZhciBwcm94eUIgPSBpbnB1dC5wcm94eUI7XG4gICAgICAgIHZhciB4ZkEgPSBpbnB1dC50cmFuc2Zvcm1BO1xuICAgICAgICB2YXIgeGZCID0gaW5wdXQudHJhbnNmb3JtQjtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgc2ltcGxleC5cbiAgICAgICAgdmFyIHNpbXBsZXggPSBuZXcgU2ltcGxleCgpO1xuICAgICAgICBzaW1wbGV4LnJlYWRDYWNoZShjYWNoZSwgcHJveHlBLCB4ZkEsIHByb3h5QiwgeGZCKTtcbiAgICAgICAgLy8gR2V0IHNpbXBsZXggdmVydGljZXMgYXMgYW4gYXJyYXkuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHNpbXBsZXgubV92O1xuICAgICAgICB2YXIga19tYXhJdGVycyA9IFNldHRpbmdzLm1heERpc3RuY2VJdGVyYXRpb25zO1xuICAgICAgICAvLyBUaGVzZSBzdG9yZSB0aGUgdmVydGljZXMgb2YgdGhlIGxhc3Qgc2ltcGxleCBzbyB0aGF0IHdlXG4gICAgICAgIC8vIGNhbiBjaGVjayBmb3IgZHVwbGljYXRlcyBhbmQgcHJldmVudCBjeWNsaW5nLlxuICAgICAgICB2YXIgc2F2ZUEgPSBbXTtcbiAgICAgICAgdmFyIHNhdmVCID0gW107IC8vIGludFszXVxuICAgICAgICB2YXIgc2F2ZUNvdW50ID0gMDtcbiAgICAgICAgLy8gTWFpbiBpdGVyYXRpb24gbG9vcC5cbiAgICAgICAgdmFyIGl0ZXIgPSAwO1xuICAgICAgICB3aGlsZSAoaXRlciA8IGtfbWF4SXRlcnMpIHtcbiAgICAgICAgICAgIC8vIENvcHkgc2ltcGxleCBzbyB3ZSBjYW4gaWRlbnRpZnkgZHVwbGljYXRlcy5cbiAgICAgICAgICAgIHNhdmVDb3VudCA9IHNpbXBsZXgubV9jb3VudDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2F2ZUNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICBzYXZlQVtpXSA9IHZlcnRpY2VzW2ldLmluZGV4QTtcbiAgICAgICAgICAgICAgICBzYXZlQltpXSA9IHZlcnRpY2VzW2ldLmluZGV4QjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpbXBsZXguc29sdmUoKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgMyBwb2ludHMsIHRoZW4gdGhlIG9yaWdpbiBpcyBpbiB0aGUgY29ycmVzcG9uZGluZyB0cmlhbmdsZS5cbiAgICAgICAgICAgIGlmIChzaW1wbGV4Lm1fY291bnQgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgY2xvc2VzdCBwb2ludC5cbiAgICAgICAgICAgIHZhciBwID0gc2ltcGxleC5nZXRDbG9zZXN0UG9pbnQoKTtcbiAgICAgICAgICAgIHAubGVuZ3RoU3F1YXJlZCgpO1xuICAgICAgICAgICAgLy8gR2V0IHNlYXJjaCBkaXJlY3Rpb24uXG4gICAgICAgICAgICB2YXIgZCA9IHNpbXBsZXguZ2V0U2VhcmNoRGlyZWN0aW9uKCk7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIHNlYXJjaCBkaXJlY3Rpb24gaXMgbnVtZXJpY2FsbHkgZml0LlxuICAgICAgICAgICAgaWYgKGQubGVuZ3RoU3F1YXJlZCgpIDwgbWF0aCQxLkVQU0lMT04gKiBtYXRoJDEuRVBTSUxPTikge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvcmlnaW4gaXMgcHJvYmFibHkgY29udGFpbmVkIGJ5IGEgbGluZSBzZWdtZW50XG4gICAgICAgICAgICAgICAgLy8gb3IgdHJpYW5nbGUuIFRodXMgdGhlIHNoYXBlcyBhcmUgb3ZlcmxhcHBlZC5cbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCByZXR1cm4gemVybyBoZXJlIGV2ZW4gdGhvdWdoIHRoZXJlIG1heSBiZSBvdmVybGFwLlxuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlIHNpbXBsZXggaXMgYSBwb2ludCwgc2VnbWVudCwgb3IgdHJpYW5nbGUgaXQgaXMgZGlmZmljdWx0XG4gICAgICAgICAgICAgICAgLy8gdG8gZGV0ZXJtaW5lIGlmIHRoZSBvcmlnaW4gaXMgY29udGFpbmVkIGluIHRoZSBDU08gb3IgdmVyeSBjbG9zZSB0byBpdC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgYSB0ZW50YXRpdmUgbmV3IHNpbXBsZXggdmVydGV4IHVzaW5nIHN1cHBvcnQgcG9pbnRzLlxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzW3NpbXBsZXgubV9jb3VudF07IC8vIFNpbXBsZXhWZXJ0ZXhcbiAgICAgICAgICAgIHZlcnRleC5pbmRleEEgPSBwcm94eUEuZ2V0U3VwcG9ydChSb3QubXVsVFZlYzIoeGZBLnEsIFZlYzIubmVnKGQpKSk7XG4gICAgICAgICAgICB2ZXJ0ZXgud0EgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkEsIHByb3h5QS5nZXRWZXJ0ZXgodmVydGV4LmluZGV4QSkpO1xuICAgICAgICAgICAgdmVydGV4LmluZGV4QiA9IHByb3h5Qi5nZXRTdXBwb3J0KFJvdC5tdWxUVmVjMih4ZkIucSwgZCkpO1xuICAgICAgICAgICAgdmVydGV4LndCID0gVHJhbnNmb3JtLm11bFZlYzIoeGZCLCBwcm94eUIuZ2V0VmVydGV4KHZlcnRleC5pbmRleEIpKTtcbiAgICAgICAgICAgIHZlcnRleC53ID0gVmVjMi5zdWIodmVydGV4LndCLCB2ZXJ0ZXgud0EpO1xuICAgICAgICAgICAgLy8gSXRlcmF0aW9uIGNvdW50IGlzIGVxdWF0ZWQgdG8gdGhlIG51bWJlciBvZiBzdXBwb3J0IHBvaW50IGNhbGxzLlxuICAgICAgICAgICAgKytpdGVyO1xuICAgICAgICAgICAgKytzdGF0cyQxLmdqa0l0ZXJzO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZSBzdXBwb3J0IHBvaW50cy4gVGhpcyBpcyB0aGUgbWFpbiB0ZXJtaW5hdGlvblxuICAgICAgICAgICAgLy8gY3JpdGVyaWEuXG4gICAgICAgICAgICB2YXIgZHVwbGljYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhdmVDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcnRleC5pbmRleEEgPT09IHNhdmVBW2ldICYmIHZlcnRleC5pbmRleEIgPT09IHNhdmVCW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgZHVwbGljYXRlIHN1cHBvcnQgcG9pbnQgd2UgbXVzdCBleGl0IHRvIGF2b2lkIGN5Y2xpbmcuXG4gICAgICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOZXcgdmVydGV4IGlzIG9rIGFuZCBuZWVkZWQuXG4gICAgICAgICAgICArK3NpbXBsZXgubV9jb3VudDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0cyQxLmdqa01heEl0ZXJzID0gbWF0aCQxLm1heChzdGF0cyQxLmdqa01heEl0ZXJzLCBpdGVyKTtcbiAgICAgICAgLy8gUHJlcGFyZSBvdXRwdXQuXG4gICAgICAgIHNpbXBsZXguZ2V0V2l0bmVzc1BvaW50cyhvdXRwdXQucG9pbnRBLCBvdXRwdXQucG9pbnRCKTtcbiAgICAgICAgb3V0cHV0LmRpc3RhbmNlID0gVmVjMi5kaXN0YW5jZShvdXRwdXQucG9pbnRBLCBvdXRwdXQucG9pbnRCKTtcbiAgICAgICAgb3V0cHV0Lml0ZXJhdGlvbnMgPSBpdGVyO1xuICAgICAgICAvLyBDYWNoZSB0aGUgc2ltcGxleC5cbiAgICAgICAgc2ltcGxleC53cml0ZUNhY2hlKGNhY2hlKTtcbiAgICAgICAgLy8gQXBwbHkgcmFkaWkgaWYgcmVxdWVzdGVkLlxuICAgICAgICBpZiAoaW5wdXQudXNlUmFkaWkpIHtcbiAgICAgICAgICAgIHZhciByQSA9IHByb3h5QS5tX3JhZGl1cztcbiAgICAgICAgICAgIHZhciByQiA9IHByb3h5Qi5tX3JhZGl1cztcbiAgICAgICAgICAgIGlmIChvdXRwdXQuZGlzdGFuY2UgPiByQSArIHJCICYmIG91dHB1dC5kaXN0YW5jZSA+IG1hdGgkMS5FUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgLy8gU2hhcGVzIGFyZSBzdGlsbCBubyBvdmVybGFwcGVkLlxuICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHdpdG5lc3MgcG9pbnRzIHRvIHRoZSBvdXRlciBzdXJmYWNlLlxuICAgICAgICAgICAgICAgIG91dHB1dC5kaXN0YW5jZSAtPSByQSArIHJCO1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBWZWMyLnN1YihvdXRwdXQucG9pbnRCLCBvdXRwdXQucG9pbnRBKTtcbiAgICAgICAgICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnBvaW50QS5hZGRNdWwockEsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnBvaW50Qi5zdWJNdWwockIsIG5vcm1hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTaGFwZXMgYXJlIG92ZXJsYXBwZWQgd2hlbiByYWRpaSBhcmUgY29uc2lkZXJlZC5cbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSB3aXRuZXNzIHBvaW50cyB0byB0aGUgbWlkZGxlLlxuICAgICAgICAgICAgICAgIHZhciBwID0gVmVjMi5taWQob3V0cHV0LnBvaW50QSwgb3V0cHV0LnBvaW50Qik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnBvaW50QS5zZXRWZWMyKHApO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wb2ludEIuc2V0VmVjMihwKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuZGlzdGFuY2UgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBkaXN0YW5jZSBwcm94eSBpcyB1c2VkIGJ5IHRoZSBHSksgYWxnb3JpdGhtLiBJdCBlbmNhcHN1bGF0ZXMgYW55IHNoYXBlLlxuICAgICAqL1xuICAgIHZhciBEaXN0YW5jZVByb3h5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEaXN0YW5jZVByb3h5KCkge1xuICAgICAgICAgICAgdGhpcy5tX2J1ZmZlciA9IFtdOyAvLyBWZWMyWzJdXG4gICAgICAgICAgICB0aGlzLm1fdmVydGljZXMgPSBbXTsgLy8gVmVjMltdXG4gICAgICAgICAgICB0aGlzLm1fY291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5tX3JhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgdmVydGV4IGNvdW50LlxuICAgICAgICAgKi9cbiAgICAgICAgRGlzdGFuY2VQcm94eS5wcm90b3R5cGUuZ2V0VmVydGV4Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2NvdW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgdmVydGV4IGJ5IGluZGV4LiBVc2VkIGJ5IERpc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgRGlzdGFuY2VQcm94eS5wcm90b3R5cGUuZ2V0VmVydGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3ZlcnRpY2VzW2luZGV4XTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgc3VwcG9ydGluZyB2ZXJ0ZXggaW5kZXggaW4gdGhlIGdpdmVuIGRpcmVjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIERpc3RhbmNlUHJveHkucHJvdG90eXBlLmdldFN1cHBvcnQgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdmFyIGJlc3RJbmRleCA9IDA7XG4gICAgICAgICAgICB2YXIgYmVzdFZhbHVlID0gVmVjMi5kb3QodGhpcy5tX3ZlcnRpY2VzWzBdLCBkKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBWZWMyLmRvdCh0aGlzLm1fdmVydGljZXNbaV0sIGQpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IGJlc3RWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBiZXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmVzdEluZGV4O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBzdXBwb3J0aW5nIHZlcnRleCBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgRGlzdGFuY2VQcm94eS5wcm90b3R5cGUuZ2V0U3VwcG9ydFZlcnRleCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3ZlcnRpY2VzW3RoaXMuZ2V0U3VwcG9ydChkKV07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSBwcm94eSB1c2luZyB0aGUgZ2l2ZW4gc2hhcGUuIFRoZSBzaGFwZSBtdXN0IHJlbWFpbiBpbiBzY29wZVxuICAgICAgICAgKiB3aGlsZSB0aGUgcHJveHkgaXMgaW4gdXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgRGlzdGFuY2VQcm94eS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHNoYXBlLCBpbmRleCkge1xuICAgICAgICAgICAgc2hhcGUuY29tcHV0ZURpc3RhbmNlUHJveHkodGhpcywgaW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGlzdGFuY2VQcm94eTtcbiAgICB9KCkpO1xuICAgIHZhciBTaW1wbGV4VmVydGV4ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTaW1wbGV4VmVydGV4KCkge1xuICAgICAgICAgICAgLyoqIHN1cHBvcnQgcG9pbnQgaW4gcHJveHlBICovXG4gICAgICAgICAgICB0aGlzLndBID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAvKiogc3VwcG9ydCBwb2ludCBpbiBwcm94eUIgKi9cbiAgICAgICAgICAgIHRoaXMud0IgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIC8qKiB3QiAtIHdBOyAqL1xuICAgICAgICAgICAgdGhpcy53ID0gVmVjMi56ZXJvKCk7XG4gICAgICAgIH1cbiAgICAgICAgU2ltcGxleFZlcnRleC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhBID0gdi5pbmRleEE7XG4gICAgICAgICAgICB0aGlzLmluZGV4QiA9IHYuaW5kZXhCO1xuICAgICAgICAgICAgdGhpcy53QSA9IFZlYzIuY2xvbmUodi53QSk7XG4gICAgICAgICAgICB0aGlzLndCID0gVmVjMi5jbG9uZSh2LndCKTtcbiAgICAgICAgICAgIHRoaXMudyA9IFZlYzIuY2xvbmUodi53KTtcbiAgICAgICAgICAgIHRoaXMuYSA9IHYuYTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNpbXBsZXhWZXJ0ZXg7XG4gICAgfSgpKTtcbiAgICB2YXIgU2ltcGxleCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2ltcGxleCgpIHtcbiAgICAgICAgICAgIHRoaXMubV92MSA9IG5ldyBTaW1wbGV4VmVydGV4KCk7XG4gICAgICAgICAgICB0aGlzLm1fdjIgPSBuZXcgU2ltcGxleFZlcnRleCgpO1xuICAgICAgICAgICAgdGhpcy5tX3YzID0gbmV3IFNpbXBsZXhWZXJ0ZXgoKTtcbiAgICAgICAgICAgIHRoaXMubV92ID0gW3RoaXMubV92MSwgdGhpcy5tX3YyLCB0aGlzLm1fdjNdO1xuICAgICAgICAgICAgdGhpcy5tX2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgU2ltcGxleC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2NvdW50ID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIitcIiArIHRoaXMubV9jb3VudCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3YxLmEsIHRoaXMubV92MS53QS54LCB0aGlzLm1fdjEud0EueSwgdGhpcy5tX3YxLndCLngsIHRoaXMubV92MS53Qi55LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fdjIuYSwgdGhpcy5tX3YyLndBLngsIHRoaXMubV92Mi53QS55LCB0aGlzLm1fdjIud0IueCwgdGhpcy5tX3YyLndCLnksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV92My5hLCB0aGlzLm1fdjMud0EueCwgdGhpcy5tX3YzLndBLnksIHRoaXMubV92My53Qi54LCB0aGlzLm1fdjMud0IueVxuICAgICAgICAgICAgICAgIF0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubV9jb3VudCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXCIrXCIgKyB0aGlzLm1fY291bnQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV92MS5hLCB0aGlzLm1fdjEud0EueCwgdGhpcy5tX3YxLndBLnksIHRoaXMubV92MS53Qi54LCB0aGlzLm1fdjEud0IueSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3YyLmEsIHRoaXMubV92Mi53QS54LCB0aGlzLm1fdjIud0EueSwgdGhpcy5tX3YyLndCLngsIHRoaXMubV92Mi53Qi55XG4gICAgICAgICAgICAgICAgXS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tX2NvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIitcIiArIHRoaXMubV9jb3VudCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3YxLmEsIHRoaXMubV92MS53QS54LCB0aGlzLm1fdjEud0EueSwgdGhpcy5tX3YxLndCLngsIHRoaXMubV92MS53Qi55XG4gICAgICAgICAgICAgICAgXS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiK1wiICsgdGhpcy5tX2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTaW1wbGV4LnByb3RvdHlwZS5yZWFkQ2FjaGUgPSBmdW5jdGlvbiAoY2FjaGUsIHByb3h5QSwgdHJhbnNmb3JtQSwgcHJveHlCLCB0cmFuc2Zvcm1CKSB7XG4gICAgICAgICAgICAvLyBDb3B5IGRhdGEgZnJvbSBjYWNoZS5cbiAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IGNhY2hlLmNvdW50O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5tX3ZbaV07XG4gICAgICAgICAgICAgICAgdi5pbmRleEEgPSBjYWNoZS5pbmRleEFbaV07XG4gICAgICAgICAgICAgICAgdi5pbmRleEIgPSBjYWNoZS5pbmRleEJbaV07XG4gICAgICAgICAgICAgICAgdmFyIHdBTG9jYWwgPSBwcm94eUEuZ2V0VmVydGV4KHYuaW5kZXhBKTtcbiAgICAgICAgICAgICAgICB2YXIgd0JMb2NhbCA9IHByb3h5Qi5nZXRWZXJ0ZXgodi5pbmRleEIpO1xuICAgICAgICAgICAgICAgIHYud0EgPSBUcmFuc2Zvcm0ubXVsVmVjMih0cmFuc2Zvcm1BLCB3QUxvY2FsKTtcbiAgICAgICAgICAgICAgICB2LndCID0gVHJhbnNmb3JtLm11bFZlYzIodHJhbnNmb3JtQiwgd0JMb2NhbCk7XG4gICAgICAgICAgICAgICAgdi53ID0gVmVjMi5zdWIodi53Qiwgdi53QSk7XG4gICAgICAgICAgICAgICAgdi5hID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbmV3IHNpbXBsZXggbWV0cmljLCBpZiBpdCBpcyBzdWJzdGFudGlhbGx5IGRpZmZlcmVudCB0aGFuXG4gICAgICAgICAgICAvLyBvbGQgbWV0cmljIHRoZW4gZmx1c2ggdGhlIHNpbXBsZXguXG4gICAgICAgICAgICBpZiAodGhpcy5tX2NvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXRyaWMxID0gY2FjaGUubWV0cmljO1xuICAgICAgICAgICAgICAgIHZhciBtZXRyaWMyID0gdGhpcy5nZXRNZXRyaWMoKTtcbiAgICAgICAgICAgICAgICBpZiAobWV0cmljMiA8IDAuNSAqIG1ldHJpYzEgfHwgMi4wICogbWV0cmljMSA8IG1ldHJpYzJcbiAgICAgICAgICAgICAgICAgICAgfHwgbWV0cmljMiA8IG1hdGgkMS5FUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBzaW1wbGV4LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBjYWNoZSBpcyBlbXB0eSBvciBpbnZhbGlkLi4uXG4gICAgICAgICAgICBpZiAodGhpcy5tX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLm1fdlswXTtcbiAgICAgICAgICAgICAgICB2LmluZGV4QSA9IDA7XG4gICAgICAgICAgICAgICAgdi5pbmRleEIgPSAwO1xuICAgICAgICAgICAgICAgIHZhciB3QUxvY2FsID0gcHJveHlBLmdldFZlcnRleCgwKTtcbiAgICAgICAgICAgICAgICB2YXIgd0JMb2NhbCA9IHByb3h5Qi5nZXRWZXJ0ZXgoMCk7XG4gICAgICAgICAgICAgICAgdi53QSA9IFRyYW5zZm9ybS5tdWxWZWMyKHRyYW5zZm9ybUEsIHdBTG9jYWwpO1xuICAgICAgICAgICAgICAgIHYud0IgPSBUcmFuc2Zvcm0ubXVsVmVjMih0cmFuc2Zvcm1CLCB3QkxvY2FsKTtcbiAgICAgICAgICAgICAgICB2LncgPSBWZWMyLnN1Yih2LndCLCB2LndBKTtcbiAgICAgICAgICAgICAgICB2LmEgPSAxLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU2ltcGxleC5wcm90b3R5cGUud3JpdGVDYWNoZSA9IGZ1bmN0aW9uIChjYWNoZSkge1xuICAgICAgICAgICAgY2FjaGUubWV0cmljID0gdGhpcy5nZXRNZXRyaWMoKTtcbiAgICAgICAgICAgIGNhY2hlLmNvdW50ID0gdGhpcy5tX2NvdW50O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIGNhY2hlLmluZGV4QVtpXSA9IHRoaXMubV92W2ldLmluZGV4QTtcbiAgICAgICAgICAgICAgICBjYWNoZS5pbmRleEJbaV0gPSB0aGlzLm1fdltpXS5pbmRleEI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFNpbXBsZXgucHJvdG90eXBlLmdldFNlYXJjaERpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5tX2NvdW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi5uZWcodGhpcy5tX3YxLncpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZTEyID0gVmVjMi5zdWIodGhpcy5tX3YyLncsIHRoaXMubV92MS53KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNnbiA9IFZlYzIuY3Jvc3NWZWMyVmVjMihlMTIsIFZlYzIubmVnKHRoaXMubV92MS53KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZ24gPiAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9yaWdpbiBpcyBsZWZ0IG9mIGUxMi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBWZWMyLmNyb3NzTnVtVmVjMigxLjAsIGUxMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcmlnaW4gaXMgcmlnaHQgb2YgZTEyLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZlYzIuY3Jvc3NWZWMyTnVtKGUxMiwgMS4wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFNpbXBsZXgucHJvdG90eXBlLmdldENsb3Nlc3RQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5tX2NvdW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi5jbG9uZSh0aGlzLm1fdjEudyk7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi5jb21iaW5lKHRoaXMubV92MS5hLCB0aGlzLm1fdjEudywgdGhpcy5tX3YyLmEsIHRoaXMubV92Mi53KTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFNpbXBsZXgucHJvdG90eXBlLmdldFdpdG5lc3NQb2ludHMgPSBmdW5jdGlvbiAocEEsIHBCKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMubV9jb3VudCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBwQS5zZXRWZWMyKHRoaXMubV92MS53QSk7XG4gICAgICAgICAgICAgICAgICAgIHBCLnNldFZlYzIodGhpcy5tX3YxLndCKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBwQS5zZXRDb21iaW5lKHRoaXMubV92MS5hLCB0aGlzLm1fdjEud0EsIHRoaXMubV92Mi5hLCB0aGlzLm1fdjIud0EpO1xuICAgICAgICAgICAgICAgICAgICBwQi5zZXRDb21iaW5lKHRoaXMubV92MS5hLCB0aGlzLm1fdjEud0IsIHRoaXMubV92Mi5hLCB0aGlzLm1fdjIud0IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHBBLnNldENvbWJpbmUodGhpcy5tX3YxLmEsIHRoaXMubV92MS53QSwgdGhpcy5tX3YyLmEsIHRoaXMubV92Mi53QSk7XG4gICAgICAgICAgICAgICAgICAgIHBBLmFkZE11bCh0aGlzLm1fdjMuYSwgdGhpcy5tX3YzLndBKTtcbiAgICAgICAgICAgICAgICAgICAgcEIuc2V0VmVjMihwQSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTaW1wbGV4LnByb3RvdHlwZS5nZXRNZXRyaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMubV9jb3VudCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi5kaXN0YW5jZSh0aGlzLm1fdjEudywgdGhpcy5tX3YyLncpO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZlYzIuY3Jvc3NWZWMyVmVjMihWZWMyLnN1Yih0aGlzLm1fdjIudywgdGhpcy5tX3YxLncpLCBWZWMyLnN1Yih0aGlzLm1fdjMudywgdGhpcy5tX3YxLncpKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTaW1wbGV4LnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5tX2NvdW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29sdmUyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2x2ZTMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFNvbHZlIGEgbGluZSBzZWdtZW50IHVzaW5nIGJhcnljZW50cmljIGNvb3JkaW5hdGVzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBwID0gYTEgKiB3MSArIGEyICogdzJcbiAgICAgICAgLy8gYTEgKyBhMiA9IDFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIHZlY3RvciBmcm9tIHRoZSBvcmlnaW4gdG8gdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIGxpbmUgaXNcbiAgICAgICAgLy8gcGVycGVuZGljdWxhciB0byB0aGUgbGluZS5cbiAgICAgICAgLy8gZTEyID0gdzIgLSB3MVxuICAgICAgICAvLyBkb3QocCwgZSkgPSAwXG4gICAgICAgIC8vIGExICogZG90KHcxLCBlKSArIGEyICogZG90KHcyLCBlKSA9IDBcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMi1ieS0yIGxpbmVhciBzeXN0ZW1cbiAgICAgICAgLy8gWzEgMSBdW2ExXSA9IFsxXVxuICAgICAgICAvLyBbdzEuZTEyIHcyLmUxMl1bYTJdID0gWzBdXG4gICAgICAgIC8vXG4gICAgICAgIC8vIERlZmluZVxuICAgICAgICAvLyBkMTJfMSA9IGRvdCh3MiwgZTEyKVxuICAgICAgICAvLyBkMTJfMiA9IC1kb3QodzEsIGUxMilcbiAgICAgICAgLy8gZDEyID0gZDEyXzEgKyBkMTJfMlxuICAgICAgICAvL1xuICAgICAgICAvLyBTb2x1dGlvblxuICAgICAgICAvLyBhMSA9IGQxMl8xIC8gZDEyXG4gICAgICAgIC8vIGEyID0gZDEyXzIgLyBkMTJcbiAgICAgICAgU2ltcGxleC5wcm90b3R5cGUuc29sdmUyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHcxID0gdGhpcy5tX3YxLnc7XG4gICAgICAgICAgICB2YXIgdzIgPSB0aGlzLm1fdjIudztcbiAgICAgICAgICAgIHZhciBlMTIgPSBWZWMyLnN1Yih3MiwgdzEpO1xuICAgICAgICAgICAgLy8gdzEgcmVnaW9uXG4gICAgICAgICAgICB2YXIgZDEyXzIgPSAtVmVjMi5kb3QodzEsIGUxMik7XG4gICAgICAgICAgICBpZiAoZDEyXzIgPD0gMC4wKSB7XG4gICAgICAgICAgICAgICAgLy8gYTIgPD0gMCwgc28gd2UgY2xhbXAgaXQgdG8gMFxuICAgICAgICAgICAgICAgIHRoaXMubV92MS5hID0gMS4wO1xuICAgICAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdzIgcmVnaW9uXG4gICAgICAgICAgICB2YXIgZDEyXzEgPSBWZWMyLmRvdCh3MiwgZTEyKTtcbiAgICAgICAgICAgIGlmIChkMTJfMSA8PSAwLjApIHtcbiAgICAgICAgICAgICAgICAvLyBhMSA8PSAwLCBzbyB3ZSBjbGFtcCBpdCB0byAwXG4gICAgICAgICAgICAgICAgdGhpcy5tX3YyLmEgPSAxLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdjEuc2V0KHRoaXMubV92Mik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTXVzdCBiZSBpbiBlMTIgcmVnaW9uLlxuICAgICAgICAgICAgdmFyIGludl9kMTIgPSAxLjAgLyAoZDEyXzEgKyBkMTJfMik7XG4gICAgICAgICAgICB0aGlzLm1fdjEuYSA9IGQxMl8xICogaW52X2QxMjtcbiAgICAgICAgICAgIHRoaXMubV92Mi5hID0gZDEyXzIgKiBpbnZfZDEyO1xuICAgICAgICAgICAgdGhpcy5tX2NvdW50ID0gMjtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUG9zc2libGUgcmVnaW9uczpcbiAgICAgICAgLy8gLSBwb2ludHNbMl1cbiAgICAgICAgLy8gLSBlZGdlIHBvaW50c1swXS1wb2ludHNbMl1cbiAgICAgICAgLy8gLSBlZGdlIHBvaW50c1sxXS1wb2ludHNbMl1cbiAgICAgICAgLy8gLSBpbnNpZGUgdGhlIHRyaWFuZ2xlXG4gICAgICAgIFNpbXBsZXgucHJvdG90eXBlLnNvbHZlMyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3MSA9IHRoaXMubV92MS53O1xuICAgICAgICAgICAgdmFyIHcyID0gdGhpcy5tX3YyLnc7XG4gICAgICAgICAgICB2YXIgdzMgPSB0aGlzLm1fdjMudztcbiAgICAgICAgICAgIC8vIEVkZ2UxMlxuICAgICAgICAgICAgLy8gWzEgMSBdW2ExXSA9IFsxXVxuICAgICAgICAgICAgLy8gW3cxLmUxMiB3Mi5lMTJdW2EyXSA9IFswXVxuICAgICAgICAgICAgLy8gYTMgPSAwXG4gICAgICAgICAgICB2YXIgZTEyID0gVmVjMi5zdWIodzIsIHcxKTtcbiAgICAgICAgICAgIHZhciB3MWUxMiA9IFZlYzIuZG90KHcxLCBlMTIpO1xuICAgICAgICAgICAgdmFyIHcyZTEyID0gVmVjMi5kb3QodzIsIGUxMik7XG4gICAgICAgICAgICB2YXIgZDEyXzEgPSB3MmUxMjtcbiAgICAgICAgICAgIHZhciBkMTJfMiA9IC13MWUxMjtcbiAgICAgICAgICAgIC8vIEVkZ2UxM1xuICAgICAgICAgICAgLy8gWzEgMSBdW2ExXSA9IFsxXVxuICAgICAgICAgICAgLy8gW3cxLmUxMyB3My5lMTNdW2EzXSA9IFswXVxuICAgICAgICAgICAgLy8gYTIgPSAwXG4gICAgICAgICAgICB2YXIgZTEzID0gVmVjMi5zdWIodzMsIHcxKTtcbiAgICAgICAgICAgIHZhciB3MWUxMyA9IFZlYzIuZG90KHcxLCBlMTMpO1xuICAgICAgICAgICAgdmFyIHczZTEzID0gVmVjMi5kb3QodzMsIGUxMyk7XG4gICAgICAgICAgICB2YXIgZDEzXzEgPSB3M2UxMztcbiAgICAgICAgICAgIHZhciBkMTNfMiA9IC13MWUxMztcbiAgICAgICAgICAgIC8vIEVkZ2UyM1xuICAgICAgICAgICAgLy8gWzEgMSBdW2EyXSA9IFsxXVxuICAgICAgICAgICAgLy8gW3cyLmUyMyB3My5lMjNdW2EzXSA9IFswXVxuICAgICAgICAgICAgLy8gYTEgPSAwXG4gICAgICAgICAgICB2YXIgZTIzID0gVmVjMi5zdWIodzMsIHcyKTtcbiAgICAgICAgICAgIHZhciB3MmUyMyA9IFZlYzIuZG90KHcyLCBlMjMpO1xuICAgICAgICAgICAgdmFyIHczZTIzID0gVmVjMi5kb3QodzMsIGUyMyk7XG4gICAgICAgICAgICB2YXIgZDIzXzEgPSB3M2UyMztcbiAgICAgICAgICAgIHZhciBkMjNfMiA9IC13MmUyMztcbiAgICAgICAgICAgIC8vIFRyaWFuZ2xlMTIzXG4gICAgICAgICAgICB2YXIgbjEyMyA9IFZlYzIuY3Jvc3NWZWMyVmVjMihlMTIsIGUxMyk7XG4gICAgICAgICAgICB2YXIgZDEyM18xID0gbjEyMyAqIFZlYzIuY3Jvc3NWZWMyVmVjMih3MiwgdzMpO1xuICAgICAgICAgICAgdmFyIGQxMjNfMiA9IG4xMjMgKiBWZWMyLmNyb3NzVmVjMlZlYzIodzMsIHcxKTtcbiAgICAgICAgICAgIHZhciBkMTIzXzMgPSBuMTIzICogVmVjMi5jcm9zc1ZlYzJWZWMyKHcxLCB3Mik7XG4gICAgICAgICAgICAvLyB3MSByZWdpb25cbiAgICAgICAgICAgIGlmIChkMTJfMiA8PSAwLjAgJiYgZDEzXzIgPD0gMC4wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3YxLmEgPSAxLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlMTJcbiAgICAgICAgICAgIGlmIChkMTJfMSA+IDAuMCAmJiBkMTJfMiA+IDAuMCAmJiBkMTIzXzMgPD0gMC4wKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludl9kMTIgPSAxLjAgLyAoZDEyXzEgKyBkMTJfMik7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3YxLmEgPSBkMTJfMSAqIGludl9kMTI7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3YyLmEgPSBkMTJfMiAqIGludl9kMTI7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2NvdW50ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlMTNcbiAgICAgICAgICAgIGlmIChkMTNfMSA+IDAuMCAmJiBkMTNfMiA+IDAuMCAmJiBkMTIzXzIgPD0gMC4wKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludl9kMTMgPSAxLjAgLyAoZDEzXzEgKyBkMTNfMik7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3YxLmEgPSBkMTNfMSAqIGludl9kMTM7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3YzLmEgPSBkMTNfMiAqIGludl9kMTM7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2NvdW50ID0gMjtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdjIuc2V0KHRoaXMubV92Myk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdzIgcmVnaW9uXG4gICAgICAgICAgICBpZiAoZDEyXzEgPD0gMC4wICYmIGQyM18yIDw9IDAuMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV92Mi5hID0gMS4wO1xuICAgICAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3YxLnNldCh0aGlzLm1fdjIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHczIHJlZ2lvblxuICAgICAgICAgICAgaWYgKGQxM18xIDw9IDAuMCAmJiBkMjNfMSA8PSAwLjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdjMuYSA9IDEuMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fY291bnQgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMubV92MS5zZXQodGhpcy5tX3YzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlMjNcbiAgICAgICAgICAgIGlmIChkMjNfMSA+IDAuMCAmJiBkMjNfMiA+IDAuMCAmJiBkMTIzXzEgPD0gMC4wKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludl9kMjMgPSAxLjAgLyAoZDIzXzEgKyBkMjNfMik7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3YyLmEgPSBkMjNfMSAqIGludl9kMjM7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3YzLmEgPSBkMjNfMiAqIGludl9kMjM7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2NvdW50ID0gMjtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdjEuc2V0KHRoaXMubV92Myk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTXVzdCBiZSBpbiB0cmlhbmdsZTEyM1xuICAgICAgICAgICAgdmFyIGludl9kMTIzID0gMS4wIC8gKGQxMjNfMSArIGQxMjNfMiArIGQxMjNfMyk7XG4gICAgICAgICAgICB0aGlzLm1fdjEuYSA9IGQxMjNfMSAqIGludl9kMTIzO1xuICAgICAgICAgICAgdGhpcy5tX3YyLmEgPSBkMTIzXzIgKiBpbnZfZDEyMztcbiAgICAgICAgICAgIHRoaXMubV92My5hID0gZDEyM18zICogaW52X2QxMjM7XG4gICAgICAgICAgICB0aGlzLm1fY291bnQgPSAzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU2ltcGxleDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0d28gZ2VuZXJpYyBzaGFwZXMgb3ZlcmxhcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZXN0T3ZlcmxhcChzaGFwZUEsIGluZGV4QSwgc2hhcGVCLCBpbmRleEIsIHhmQSwgeGZCKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IG5ldyBEaXN0YW5jZUlucHV0KCk7XG4gICAgICAgIGlucHV0LnByb3h5QS5zZXQoc2hhcGVBLCBpbmRleEEpO1xuICAgICAgICBpbnB1dC5wcm94eUIuc2V0KHNoYXBlQiwgaW5kZXhCKTtcbiAgICAgICAgaW5wdXQudHJhbnNmb3JtQSA9IHhmQTtcbiAgICAgICAgaW5wdXQudHJhbnNmb3JtQiA9IHhmQjtcbiAgICAgICAgaW5wdXQudXNlUmFkaWkgPSB0cnVlO1xuICAgICAgICB2YXIgY2FjaGUgPSBuZXcgU2ltcGxleENhY2hlKCk7XG4gICAgICAgIHZhciBvdXRwdXQgPSBuZXcgRGlzdGFuY2VPdXRwdXQoKTtcbiAgICAgICAgRGlzdGFuY2Uob3V0cHV0LCBjYWNoZSwgaW5wdXQpO1xuICAgICAgICByZXR1cm4gb3V0cHV0LmRpc3RhbmNlIDwgMTAuMCAqIG1hdGgkMS5FUFNJTE9OO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBIGNvbnRhY3QgZWRnZSBpcyB1c2VkIHRvIGNvbm5lY3QgYm9kaWVzIGFuZCBjb250YWN0cyB0b2dldGhlciBpbiBhIGNvbnRhY3RcbiAgICAgKiBncmFwaCB3aGVyZSBlYWNoIGJvZHkgaXMgYSBub2RlIGFuZCBlYWNoIGNvbnRhY3QgaXMgYW4gZWRnZS4gQSBjb250YWN0IGVkZ2VcbiAgICAgKiBiZWxvbmdzIHRvIGEgZG91Ymx5IGxpbmtlZCBsaXN0IG1haW50YWluZWQgaW4gZWFjaCBhdHRhY2hlZCBib2R5LiBFYWNoXG4gICAgICogY29udGFjdCBoYXMgdHdvIGNvbnRhY3Qgbm9kZXMsIG9uZSBmb3IgZWFjaCBhdHRhY2hlZCBib2R5LlxuICAgICAqXG4gICAgICogQHByb3Age0NvbnRhY3R9IGNvbnRhY3QgVGhlIGNvbnRhY3RcbiAgICAgKiBAcHJvcCB7Q29udGFjdEVkZ2V9IHByZXYgVGhlIHByZXZpb3VzIGNvbnRhY3QgZWRnZSBpbiB0aGUgYm9keSdzIGNvbnRhY3QgbGlzdFxuICAgICAqIEBwcm9wIHtDb250YWN0RWRnZX0gbmV4dCBUaGUgbmV4dCBjb250YWN0IGVkZ2UgaW4gdGhlIGJvZHkncyBjb250YWN0IGxpc3RcbiAgICAgKiBAcHJvcCB7Qm9keX0gb3RoZXIgUHJvdmlkZXMgcXVpY2sgYWNjZXNzIHRvIHRoZSBvdGhlciBib2R5IGF0dGFjaGVkLlxuICAgICAqL1xuICAgIHZhciBDb250YWN0RWRnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29udGFjdEVkZ2UoY29udGFjdCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWN0ID0gY29udGFjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29udGFjdEVkZ2U7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBGcmljdGlvbiBtaXhpbmcgbGF3LiBUaGUgaWRlYSBpcyB0byBhbGxvdyBlaXRoZXIgZml4dHVyZSB0byBkcml2ZSB0aGVcbiAgICAgKiByZXN0aXR1dGlvbiB0byB6ZXJvLiBGb3IgZXhhbXBsZSwgYW55dGhpbmcgc2xpZGVzIG9uIGljZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhGcmljdGlvbihmcmljdGlvbjEsIGZyaWN0aW9uMikge1xuICAgICAgICByZXR1cm4gbWF0aCQxLnNxcnQoZnJpY3Rpb24xICogZnJpY3Rpb24yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdGl0dXRpb24gbWl4aW5nIGxhdy4gVGhlIGlkZWEgaXMgYWxsb3cgZm9yIGFueXRoaW5nIHRvIGJvdW5jZSBvZmYgYW5cbiAgICAgKiBpbmVsYXN0aWMgc3VyZmFjZS4gRm9yIGV4YW1wbGUsIGEgc3VwZXJiYWxsIGJvdW5jZXMgb24gYW55dGhpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4UmVzdGl0dXRpb24ocmVzdGl0dXRpb24xLCByZXN0aXR1dGlvbjIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3RpdHV0aW9uMSA+IHJlc3RpdHV0aW9uMiA/IHJlc3RpdHV0aW9uMSA6IHJlc3RpdHV0aW9uMjtcbiAgICB9XG4gICAgLy8gVE9ETzogbW92ZSB0aGlzIHRvIFNldHRpbmdzP1xuICAgIHZhciBzX3JlZ2lzdGVycyA9IFtdO1xuICAgIC8vIFRPRE86IG1lcmdlIHdpdGggTWFuaWZvbGRQb2ludD9cbiAgICB2YXIgVmVsb2NpdHlDb25zdHJhaW50UG9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZlbG9jaXR5Q29uc3RyYWludFBvaW50KCkge1xuICAgICAgICAgICAgdGhpcy5yQSA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgdGhpcy5yQiA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxJbXB1bHNlID0gMDtcbiAgICAgICAgICAgIHRoaXMudGFuZ2VudEltcHVsc2UgPSAwO1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxNYXNzID0gMDtcbiAgICAgICAgICAgIHRoaXMudGFuZ2VudE1hc3MgPSAwO1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eUJpYXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBWZWxvY2l0eUNvbnN0cmFpbnRQb2ludDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyBtYW5hZ2VzIGNvbnRhY3QgYmV0d2VlbiB0d28gc2hhcGVzLiBBIGNvbnRhY3QgZXhpc3RzIGZvciBlYWNoXG4gICAgICogb3ZlcmxhcHBpbmcgQUFCQiBpbiB0aGUgYnJvYWQtcGhhc2UgKGV4Y2VwdCBpZiBmaWx0ZXJlZCkuIFRoZXJlZm9yZSBhIGNvbnRhY3RcbiAgICAgKiBvYmplY3QgbWF5IGV4aXN0IHRoYXQgaGFzIG5vIGNvbnRhY3QgcG9pbnRzLlxuICAgICAqL1xuICAgIHZhciBDb250YWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb250YWN0KGZBLCBpbmRleEEsIGZCLCBpbmRleEIsIGV2YWx1YXRlRmNuKSB7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLm1fbWFuaWZvbGQgPSBuZXcgTWFuaWZvbGQoKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMubV9wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMubV9uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMubV90b2kgPSAxLjA7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLm1fdG9pQ291bnQgPSAwO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCBUaGlzIGNvbnRhY3QgaGFzIGEgdmFsaWQgVE9JIGluIG1fdG9pICovXG4gICAgICAgICAgICB0aGlzLm1fdG9pRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5tX3RhbmdlbnRTcGVlZCA9IDAuMDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgVGhpcyBjb250YWN0IGNhbiBiZSBkaXNhYmxlZCAoYnkgdXNlcikgKi9cbiAgICAgICAgICAgIHRoaXMubV9lbmFibGVkRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAvKiogQGludGVybmFsIFVzZWQgd2hlbiBjcmF3bGluZyBjb250YWN0IGdyYXBoIHdoZW4gZm9ybWluZyBpc2xhbmRzLiAqL1xuICAgICAgICAgICAgdGhpcy5tX2lzbGFuZEZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgU2V0IHdoZW4gdGhlIHNoYXBlcyBhcmUgdG91Y2hpbmcuICovXG4gICAgICAgICAgICB0aGlzLm1fdG91Y2hpbmdGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAvKiogQGludGVybmFsIFRoaXMgY29udGFjdCBuZWVkcyBmaWx0ZXJpbmcgYmVjYXVzZSBhIGZpeHR1cmUgZmlsdGVyIHdhcyBjaGFuZ2VkLiAqL1xuICAgICAgICAgICAgdGhpcy5tX2ZpbHRlckZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgVGhpcyBidWxsZXQgY29udGFjdCBoYWQgYSBUT0kgZXZlbnQgKi9cbiAgICAgICAgICAgIHRoaXMubV9idWxsZXRIaXRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAvKiogQGludGVybmFsIENvbnRhY3QgcmVwb3J0aW5nIGltcHVsc2Ugb2JqZWN0IGNhY2hlICovXG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZSA9IG5ldyBDb250YWN0SW1wdWxzZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIFZlbG9jaXR5Q29uc3RyYWludFxuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqLyB0aGlzLnZfcG9pbnRzID0gW107IC8vIFttYXhNYW5pZm9sZFBvaW50c107XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMudl9ub3JtYWwgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy52X25vcm1hbE1hc3MgPSBuZXcgTWF0MjIoKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy52X0sgPSBuZXcgTWF0MjIoKTtcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uQ29uc3RyYWludFxuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqLyB0aGlzLnBfbG9jYWxQb2ludHMgPSBbXTsgLy8gW21heE1hbmlmb2xkUG9pbnRzXTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy5wX2xvY2FsTm9ybWFsID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMucF9sb2NhbFBvaW50ID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMucF9sb2NhbENlbnRlckEgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy5wX2xvY2FsQ2VudGVyQiA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgLy8gTm9kZXMgZm9yIGNvbm5lY3RpbmcgYm9kaWVzLlxuICAgICAgICAgICAgdGhpcy5tX25vZGVBID0gbmV3IENvbnRhY3RFZGdlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5tX25vZGVCID0gbmV3IENvbnRhY3RFZGdlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5tX2ZpeHR1cmVBID0gZkE7XG4gICAgICAgICAgICB0aGlzLm1fZml4dHVyZUIgPSBmQjtcbiAgICAgICAgICAgIHRoaXMubV9pbmRleEEgPSBpbmRleEE7XG4gICAgICAgICAgICB0aGlzLm1faW5kZXhCID0gaW5kZXhCO1xuICAgICAgICAgICAgdGhpcy5tX2V2YWx1YXRlRmNuID0gZXZhbHVhdGVGY247XG4gICAgICAgICAgICB0aGlzLm1fZnJpY3Rpb24gPSBtaXhGcmljdGlvbih0aGlzLm1fZml4dHVyZUEubV9mcmljdGlvbiwgdGhpcy5tX2ZpeHR1cmVCLm1fZnJpY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5tX3Jlc3RpdHV0aW9uID0gbWl4UmVzdGl0dXRpb24odGhpcy5tX2ZpeHR1cmVBLm1fcmVzdGl0dXRpb24sIHRoaXMubV9maXh0dXJlQi5tX3Jlc3RpdHV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBDb250YWN0LnByb3RvdHlwZS5pbml0Q29uc3RyYWludCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB2YXIgZml4dHVyZUEgPSB0aGlzLm1fZml4dHVyZUE7XG4gICAgICAgICAgICB2YXIgZml4dHVyZUIgPSB0aGlzLm1fZml4dHVyZUI7XG4gICAgICAgICAgICB2YXIgc2hhcGVBID0gZml4dHVyZUEuZ2V0U2hhcGUoKTtcbiAgICAgICAgICAgIHZhciBzaGFwZUIgPSBmaXh0dXJlQi5nZXRTaGFwZSgpO1xuICAgICAgICAgICAgdmFyIGJvZHlBID0gZml4dHVyZUEuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgdmFyIGJvZHlCID0gZml4dHVyZUIuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgdmFyIG1hbmlmb2xkID0gdGhpcy5nZXRNYW5pZm9sZCgpO1xuICAgICAgICAgICAgdmFyIHBvaW50Q291bnQgPSBtYW5pZm9sZC5wb2ludENvdW50O1xuICAgICAgICAgICAgdGhpcy52X2ludk1hc3NBID0gYm9keUEubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy52X2ludk1hc3NCID0gYm9keUIubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy52X2ludklBID0gYm9keUEubV9pbnZJO1xuICAgICAgICAgICAgdGhpcy52X2ludklCID0gYm9keUIubV9pbnZJO1xuICAgICAgICAgICAgdGhpcy52X2ZyaWN0aW9uID0gdGhpcy5tX2ZyaWN0aW9uO1xuICAgICAgICAgICAgdGhpcy52X3Jlc3RpdHV0aW9uID0gdGhpcy5tX3Jlc3RpdHV0aW9uO1xuICAgICAgICAgICAgdGhpcy52X3RhbmdlbnRTcGVlZCA9IHRoaXMubV90YW5nZW50U3BlZWQ7XG4gICAgICAgICAgICB0aGlzLnZfcG9pbnRDb3VudCA9IHBvaW50Q291bnQ7XG4gICAgICAgICAgICB0aGlzLnZfSy5zZXRaZXJvKCk7XG4gICAgICAgICAgICB0aGlzLnZfbm9ybWFsTWFzcy5zZXRaZXJvKCk7XG4gICAgICAgICAgICB0aGlzLnBfaW52TWFzc0EgPSBib2R5QS5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLnBfaW52TWFzc0IgPSBib2R5Qi5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLnBfaW52SUEgPSBib2R5QS5tX2ludkk7XG4gICAgICAgICAgICB0aGlzLnBfaW52SUIgPSBib2R5Qi5tX2ludkk7XG4gICAgICAgICAgICB0aGlzLnBfbG9jYWxDZW50ZXJBID0gVmVjMi5jbG9uZShib2R5QS5tX3N3ZWVwLmxvY2FsQ2VudGVyKTtcbiAgICAgICAgICAgIHRoaXMucF9sb2NhbENlbnRlckIgPSBWZWMyLmNsb25lKGJvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXIpO1xuICAgICAgICAgICAgdGhpcy5wX3JhZGl1c0EgPSBzaGFwZUEubV9yYWRpdXM7XG4gICAgICAgICAgICB0aGlzLnBfcmFkaXVzQiA9IHNoYXBlQi5tX3JhZGl1cztcbiAgICAgICAgICAgIHRoaXMucF90eXBlID0gbWFuaWZvbGQudHlwZTtcbiAgICAgICAgICAgIHRoaXMucF9sb2NhbE5vcm1hbCA9IFZlYzIuY2xvbmUobWFuaWZvbGQubG9jYWxOb3JtYWwpO1xuICAgICAgICAgICAgdGhpcy5wX2xvY2FsUG9pbnQgPSBWZWMyLmNsb25lKG1hbmlmb2xkLmxvY2FsUG9pbnQpO1xuICAgICAgICAgICAgdGhpcy5wX3BvaW50Q291bnQgPSBwb2ludENvdW50O1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2ludENvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgY3AgPSBtYW5pZm9sZC5wb2ludHNbal07XG4gICAgICAgICAgICAgICAgdmFyIHZjcCA9IHRoaXMudl9wb2ludHNbal0gPSBuZXcgVmVsb2NpdHlDb25zdHJhaW50UG9pbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmNwLm5vcm1hbEltcHVsc2UgPSBzdGVwLmR0UmF0aW8gKiBjcC5ub3JtYWxJbXB1bHNlO1xuICAgICAgICAgICAgICAgICAgICB2Y3AudGFuZ2VudEltcHVsc2UgPSBzdGVwLmR0UmF0aW8gKiBjcC50YW5nZW50SW1wdWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZjcC5ub3JtYWxJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB2Y3AudGFuZ2VudEltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZjcC5yQS5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgdmNwLnJCLnNldFplcm8oKTtcbiAgICAgICAgICAgICAgICB2Y3Aubm9ybWFsTWFzcyA9IDAuMDtcbiAgICAgICAgICAgICAgICB2Y3AudGFuZ2VudE1hc3MgPSAwLjA7XG4gICAgICAgICAgICAgICAgdmNwLnZlbG9jaXR5QmlhcyA9IDAuMDtcbiAgICAgICAgICAgICAgICB0aGlzLnBfbG9jYWxQb2ludHNbal0gPSBWZWMyLmNsb25lKGNwLmxvY2FsUG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb250YWN0IG1hbmlmb2xkLiBEbyBub3QgbW9kaWZ5IHRoZSBtYW5pZm9sZCB1bmxlc3MgeW91IHVuZGVyc3RhbmRcbiAgICAgICAgICogdGhlIGludGVybmFscyBvZiB0aGUgbGlicmFyeS5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmdldE1hbmlmb2xkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9tYW5pZm9sZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgd29ybGQgbWFuaWZvbGQuXG4gICAgICAgICAqL1xuICAgICAgICBDb250YWN0LnByb3RvdHlwZS5nZXRXb3JsZE1hbmlmb2xkID0gZnVuY3Rpb24gKHdvcmxkTWFuaWZvbGQpIHtcbiAgICAgICAgICAgIHZhciBib2R5QSA9IHRoaXMubV9maXh0dXJlQS5nZXRCb2R5KCk7XG4gICAgICAgICAgICB2YXIgYm9keUIgPSB0aGlzLm1fZml4dHVyZUIuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgdmFyIHNoYXBlQSA9IHRoaXMubV9maXh0dXJlQS5nZXRTaGFwZSgpO1xuICAgICAgICAgICAgdmFyIHNoYXBlQiA9IHRoaXMubV9maXh0dXJlQi5nZXRTaGFwZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9tYW5pZm9sZC5nZXRXb3JsZE1hbmlmb2xkKHdvcmxkTWFuaWZvbGQsIGJvZHlBLmdldFRyYW5zZm9ybSgpLCBzaGFwZUEubV9yYWRpdXMsIGJvZHlCLmdldFRyYW5zZm9ybSgpLCBzaGFwZUIubV9yYWRpdXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlL2Rpc2FibGUgdGhpcyBjb250YWN0LiBUaGlzIGNhbiBiZSB1c2VkIGluc2lkZSB0aGUgcHJlLXNvbHZlIGNvbnRhY3RcbiAgICAgICAgICogbGlzdGVuZXIuIFRoZSBjb250YWN0IGlzIG9ubHkgZGlzYWJsZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUgc3RlcCAob3Igc3ViLXN0ZXBcbiAgICAgICAgICogaW4gY29udGludW91cyBjb2xsaXNpb25zKS5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLnNldEVuYWJsZWQgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICAgICAgdGhpcy5tX2VuYWJsZWRGbGFnID0gISFmbGFnO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFzIHRoaXMgY29udGFjdCBiZWVuIGRpc2FibGVkP1xuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9lbmFibGVkRmxhZztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoaXMgY29udGFjdCB0b3VjaGluZz9cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmlzVG91Y2hpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3RvdWNoaW5nRmxhZztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbmV4dCBjb250YWN0IGluIHRoZSB3b3JsZCdzIGNvbnRhY3QgbGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX25leHQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZml4dHVyZSBBIGluIHRoaXMgY29udGFjdC5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmdldEZpeHR1cmVBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9maXh0dXJlQTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBmaXh0dXJlIEIgaW4gdGhpcyBjb250YWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuZ2V0Rml4dHVyZUIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2ZpeHR1cmVCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjaGlsZCBwcmltaXRpdmUgaW5kZXggZm9yIGZpeHR1cmUgQS5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmdldENoaWxkSW5kZXhBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9pbmRleEE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNoaWxkIHByaW1pdGl2ZSBpbmRleCBmb3IgZml4dHVyZSBCLlxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuZ2V0Q2hpbGRJbmRleEIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2luZGV4QjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgdGhpcyBjb250YWN0IGZvciBmaWx0ZXJpbmcuIEZpbHRlcmluZyB3aWxsIG9jY3VyIHRoZSBuZXh0IHRpbWUgc3RlcC5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmZsYWdGb3JGaWx0ZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm1fZmlsdGVyRmxhZyA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBmcmljdGlvbiBtaXh0dXJlLiBZb3UgY2FuIGNhbGwgdGhpcyBpblxuICAgICAgICAgKiBDb250YWN0TGlzdGVuZXIucHJlU29sdmUuIFRoaXMgdmFsdWUgcGVyc2lzdHMgdW50aWwgc2V0IG9yIHJlc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuc2V0RnJpY3Rpb24gPSBmdW5jdGlvbiAoZnJpY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubV9mcmljdGlvbiA9IGZyaWN0aW9uO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmcmljdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmdldEZyaWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9mcmljdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0IHRoZSBmcmljdGlvbiBtaXh0dXJlIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUucmVzZXRGcmljdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubV9mcmljdGlvbiA9IG1peEZyaWN0aW9uKHRoaXMubV9maXh0dXJlQS5tX2ZyaWN0aW9uLCB0aGlzLm1fZml4dHVyZUIubV9mcmljdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCByZXN0aXR1dGlvbiBtaXh0dXJlLiBZb3UgY2FuIGNhbGwgdGhpcyBpblxuICAgICAgICAgKiBDb250YWN0TGlzdGVuZXIucHJlU29sdmUuIFRoZSB2YWx1ZSBwZXJzaXN0cyB1bnRpbCB5b3Ugc2V0IG9yIHJlc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuc2V0UmVzdGl0dXRpb24gPSBmdW5jdGlvbiAocmVzdGl0dXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubV9yZXN0aXR1dGlvbiA9IHJlc3RpdHV0aW9uO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByZXN0aXR1dGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmdldFJlc3RpdHV0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9yZXN0aXR1dGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0IHRoZSByZXN0aXR1dGlvbiB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLnJlc2V0UmVzdGl0dXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm1fcmVzdGl0dXRpb24gPSBtaXhSZXN0aXR1dGlvbih0aGlzLm1fZml4dHVyZUEubV9yZXN0aXR1dGlvbiwgdGhpcy5tX2ZpeHR1cmVCLm1fcmVzdGl0dXRpb24pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBkZXNpcmVkIHRhbmdlbnQgc3BlZWQgZm9yIGEgY29udmV5b3IgYmVsdCBiZWhhdmlvci4gSW4gbWV0ZXJzIHBlclxuICAgICAgICAgKiBzZWNvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBDb250YWN0LnByb3RvdHlwZS5zZXRUYW5nZW50U3BlZWQgPSBmdW5jdGlvbiAoc3BlZWQpIHtcbiAgICAgICAgICAgIHRoaXMubV90YW5nZW50U3BlZWQgPSBzcGVlZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZGVzaXJlZCB0YW5nZW50IHNwZWVkLiBJbiBtZXRlcnMgcGVyIHNlY29uZC5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmdldFRhbmdlbnRTcGVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdGFuZ2VudFNwZWVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGJ5IFVwZGF0ZSBtZXRob2QsIGFuZCBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAobWFuaWZvbGQsIHhmQSwgeGZCKSB7XG4gICAgICAgICAgICB0aGlzLm1fZXZhbHVhdGVGY24obWFuaWZvbGQsIHhmQSwgdGhpcy5tX2ZpeHR1cmVBLCB0aGlzLm1faW5kZXhBLCB4ZkIsIHRoaXMubV9maXh0dXJlQiwgdGhpcy5tX2luZGV4Qik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBjb250YWN0IG1hbmlmb2xkIGFuZCB0b3VjaGluZyBzdGF0dXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IGRvIG5vdCBhc3N1bWUgdGhlIGZpeHR1cmUgQUFCQnMgYXJlIG92ZXJsYXBwaW5nIG9yIGFyZSB2YWxpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxpc3RlbmVyLmJlZ2luQ29udGFjdFxuICAgICAgICAgKiBAcGFyYW0gbGlzdGVuZXIuZW5kQ29udGFjdFxuICAgICAgICAgKiBAcGFyYW0gbGlzdGVuZXIucHJlU29sdmVcbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgLy8gUmUtZW5hYmxlIHRoaXMgY29udGFjdC5cbiAgICAgICAgICAgIHRoaXMubV9lbmFibGVkRmxhZyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgdG91Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciB3YXNUb3VjaGluZyA9IHRoaXMubV90b3VjaGluZ0ZsYWc7XG4gICAgICAgICAgICB2YXIgc2Vuc29yQSA9IHRoaXMubV9maXh0dXJlQS5pc1NlbnNvcigpO1xuICAgICAgICAgICAgdmFyIHNlbnNvckIgPSB0aGlzLm1fZml4dHVyZUIuaXNTZW5zb3IoKTtcbiAgICAgICAgICAgIHZhciBzZW5zb3IgPSBzZW5zb3JBIHx8IHNlbnNvckI7XG4gICAgICAgICAgICB2YXIgYm9keUEgPSB0aGlzLm1fZml4dHVyZUEuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgdmFyIGJvZHlCID0gdGhpcy5tX2ZpeHR1cmVCLmdldEJvZHkoKTtcbiAgICAgICAgICAgIHZhciB4ZkEgPSBib2R5QS5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHZhciB4ZkIgPSBib2R5Qi5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHZhciBvbGRNYW5pZm9sZDtcbiAgICAgICAgICAgIC8vIElzIHRoaXMgY29udGFjdCBhIHNlbnNvcj9cbiAgICAgICAgICAgIGlmIChzZW5zb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGVBID0gdGhpcy5tX2ZpeHR1cmVBLmdldFNoYXBlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlQiA9IHRoaXMubV9maXh0dXJlQi5nZXRTaGFwZSgpO1xuICAgICAgICAgICAgICAgIHRvdWNoaW5nID0gdGVzdE92ZXJsYXAoc2hhcGVBLCB0aGlzLm1faW5kZXhBLCBzaGFwZUIsIHRoaXMubV9pbmRleEIsIHhmQSwgeGZCKTtcbiAgICAgICAgICAgICAgICAvLyBTZW5zb3JzIGRvbid0IGdlbmVyYXRlIG1hbmlmb2xkcy5cbiAgICAgICAgICAgICAgICB0aGlzLm1fbWFuaWZvbGQucG9pbnRDb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHJldXNlIG1hbmlmb2xkXG4gICAgICAgICAgICAgICAgb2xkTWFuaWZvbGQgPSB0aGlzLm1fbWFuaWZvbGQ7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21hbmlmb2xkID0gbmV3IE1hbmlmb2xkKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmFsdWF0ZSh0aGlzLm1fbWFuaWZvbGQsIHhmQSwgeGZCKTtcbiAgICAgICAgICAgICAgICB0b3VjaGluZyA9IHRoaXMubV9tYW5pZm9sZC5wb2ludENvdW50ID4gMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaCBvbGQgY29udGFjdCBpZHMgdG8gbmV3IGNvbnRhY3QgaWRzIGFuZCBjb3B5IHRoZVxuICAgICAgICAgICAgICAgIC8vIHN0b3JlZCBpbXB1bHNlcyB0byB3YXJtIHN0YXJ0IHRoZSBzb2x2ZXIuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fbWFuaWZvbGQucG9pbnRDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBubXAgPSB0aGlzLm1fbWFuaWZvbGQucG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBubXAubm9ybWFsSW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgbm1wLnRhbmdlbnRJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9sZE1hbmlmb2xkLnBvaW50Q291bnQ7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9tcCA9IG9sZE1hbmlmb2xkLnBvaW50c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbXAuaWQua2V5ID09IG5tcC5pZC5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBubXAubm9ybWFsSW1wdWxzZSA9IG9tcC5ub3JtYWxJbXB1bHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5tcC50YW5nZW50SW1wdWxzZSA9IG9tcC50YW5nZW50SW1wdWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG91Y2hpbmcgIT0gd2FzVG91Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV90b3VjaGluZ0ZsYWcgPSB0b3VjaGluZztcbiAgICAgICAgICAgIGlmICghd2FzVG91Y2hpbmcgJiYgdG91Y2hpbmcgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5iZWdpbkNvbnRhY3QodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FzVG91Y2hpbmcgJiYgIXRvdWNoaW5nICYmIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuZW5kQ29udGFjdCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2Vuc29yICYmIHRvdWNoaW5nICYmIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIucHJlU29sdmUodGhpcywgb2xkTWFuaWZvbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBDb250YWN0LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc29sdmVQb3NpdGlvbkNvbnN0cmFpbnQoc3RlcCk7XG4gICAgICAgIH07XG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLnNvbHZlUG9zaXRpb25Db25zdHJhaW50VE9JID0gZnVuY3Rpb24gKHN0ZXAsIHRvaUEsIHRvaUIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb2x2ZVBvc2l0aW9uQ29uc3RyYWludChzdGVwLCB0b2lBLCB0b2lCKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuX3NvbHZlUG9zaXRpb25Db25zdHJhaW50ID0gZnVuY3Rpb24gKHN0ZXAsIHRvaUEsIHRvaUIpIHtcbiAgICAgICAgICAgIHZhciB0b2kgPSAhIXRvaUEgJiYgISF0b2lCO1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVBID0gdGhpcy5tX2ZpeHR1cmVBO1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gdGhpcy5tX2ZpeHR1cmVCO1xuICAgICAgICAgICAgdmFyIGJvZHlBID0gZml4dHVyZUEuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgdmFyIGJvZHlCID0gZml4dHVyZUIuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgYm9keUEuY192ZWxvY2l0eTtcbiAgICAgICAgICAgIGJvZHlCLmNfdmVsb2NpdHk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25BID0gYm9keUEuY19wb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkIgPSBib2R5Qi5jX3Bvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGxvY2FsQ2VudGVyQSA9IFZlYzIuY2xvbmUodGhpcy5wX2xvY2FsQ2VudGVyQSk7XG4gICAgICAgICAgICB2YXIgbG9jYWxDZW50ZXJCID0gVmVjMi5jbG9uZSh0aGlzLnBfbG9jYWxDZW50ZXJCKTtcbiAgICAgICAgICAgIHZhciBtQSA9IDAuMDtcbiAgICAgICAgICAgIHZhciBpQSA9IDAuMDtcbiAgICAgICAgICAgIGlmICghdG9pIHx8IChib2R5QSA9PSB0b2lBIHx8IGJvZHlBID09IHRvaUIpKSB7XG4gICAgICAgICAgICAgICAgbUEgPSB0aGlzLnBfaW52TWFzc0E7XG4gICAgICAgICAgICAgICAgaUEgPSB0aGlzLnBfaW52SUE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbUIgPSAwLjA7XG4gICAgICAgICAgICB2YXIgaUIgPSAwLjA7XG4gICAgICAgICAgICBpZiAoIXRvaSB8fCAoYm9keUIgPT0gdG9pQSB8fCBib2R5QiA9PSB0b2lCKSkge1xuICAgICAgICAgICAgICAgIG1CID0gdGhpcy5wX2ludk1hc3NCO1xuICAgICAgICAgICAgICAgIGlCID0gdGhpcy5wX2ludklCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNBID0gVmVjMi5jbG9uZShwb3NpdGlvbkEuYyk7XG4gICAgICAgICAgICB2YXIgYUEgPSBwb3NpdGlvbkEuYTtcbiAgICAgICAgICAgIHZhciBjQiA9IFZlYzIuY2xvbmUocG9zaXRpb25CLmMpO1xuICAgICAgICAgICAgdmFyIGFCID0gcG9zaXRpb25CLmE7XG4gICAgICAgICAgICB2YXIgbWluU2VwYXJhdGlvbiA9IDAuMDtcbiAgICAgICAgICAgIC8vIFNvbHZlIG5vcm1hbCBjb25zdHJhaW50c1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnBfcG9pbnRDb3VudDsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhmQSA9IFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuICAgICAgICAgICAgICAgIHZhciB4ZkIgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgICAgICAgICB4ZkEucS5zZXRBbmdsZShhQSk7XG4gICAgICAgICAgICAgICAgeGZCLnEuc2V0QW5nbGUoYUIpO1xuICAgICAgICAgICAgICAgIHhmQS5wID0gVmVjMi5zdWIoY0EsIFJvdC5tdWxWZWMyKHhmQS5xLCBsb2NhbENlbnRlckEpKTtcbiAgICAgICAgICAgICAgICB4ZkIucCA9IFZlYzIuc3ViKGNCLCBSb3QubXVsVmVjMih4ZkIucSwgbG9jYWxDZW50ZXJCKSk7XG4gICAgICAgICAgICAgICAgLy8gUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZFxuICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0aW9uID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wX3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNYW5pZm9sZFR5cGUuZV9jaXJjbGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRBID0gVHJhbnNmb3JtLm11bFZlYzIoeGZBLCB0aGlzLnBfbG9jYWxQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRCID0gVHJhbnNmb3JtLm11bFZlYzIoeGZCLCB0aGlzLnBfbG9jYWxQb2ludHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsID0gVmVjMi5zdWIocG9pbnRCLCBwb2ludEEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBWZWMyLmNvbWJpbmUoMC41LCBwb2ludEEsIDAuNSwgcG9pbnRCKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRpb24gPSBWZWMyLmRvdChWZWMyLnN1Yihwb2ludEIsIHBvaW50QSksIG5vcm1hbCkgLSB0aGlzLnBfcmFkaXVzQSAtIHRoaXMucF9yYWRpdXNCO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNYW5pZm9sZFR5cGUuZV9mYWNlQToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsID0gUm90Lm11bFZlYzIoeGZBLnEsIHRoaXMucF9sb2NhbE5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGxhbmVQb2ludCA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQSwgdGhpcy5wX2xvY2FsUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXBQb2ludCA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQiwgdGhpcy5wX2xvY2FsUG9pbnRzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRpb24gPSBWZWMyLmRvdChWZWMyLnN1YihjbGlwUG9pbnQsIHBsYW5lUG9pbnQpLCBub3JtYWwpIC0gdGhpcy5wX3JhZGl1c0EgLSB0aGlzLnBfcmFkaXVzQjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gY2xpcFBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNYW5pZm9sZFR5cGUuZV9mYWNlQjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsID0gUm90Lm11bFZlYzIoeGZCLnEsIHRoaXMucF9sb2NhbE5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGxhbmVQb2ludCA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQiwgdGhpcy5wX2xvY2FsUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXBQb2ludCA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQSwgdGhpcy5wX2xvY2FsUG9pbnRzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRpb24gPSBWZWMyLmRvdChWZWMyLnN1YihjbGlwUG9pbnQsIHBsYW5lUG9pbnQpLCBub3JtYWwpIC0gdGhpcy5wX3JhZGl1c0EgLSB0aGlzLnBfcmFkaXVzQjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gY2xpcFBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIG5vcm1hbCBwb2ludHMgZnJvbSBBIHRvIEJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbC5tdWwoLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJBID0gVmVjMi5zdWIocG9pbnQsIGNBKTtcbiAgICAgICAgICAgICAgICB2YXIgckIgPSBWZWMyLnN1Yihwb2ludCwgY0IpO1xuICAgICAgICAgICAgICAgIC8vIFRyYWNrIG1heCBjb25zdHJhaW50IGVycm9yLlxuICAgICAgICAgICAgICAgIG1pblNlcGFyYXRpb24gPSBtYXRoJDEubWluKG1pblNlcGFyYXRpb24sIHNlcGFyYXRpb24pO1xuICAgICAgICAgICAgICAgIHZhciBiYXVtZ2FydGUgPSB0b2kgPyBTZXR0aW5ncy50b2lCYXVnYXJ0ZSA6IFNldHRpbmdzLmJhdW1nYXJ0ZTtcbiAgICAgICAgICAgICAgICB2YXIgbGluZWFyU2xvcCA9IFNldHRpbmdzLmxpbmVhclNsb3A7XG4gICAgICAgICAgICAgICAgdmFyIG1heExpbmVhckNvcnJlY3Rpb24gPSBTZXR0aW5ncy5tYXhMaW5lYXJDb3JyZWN0aW9uO1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgY29ycmVjdGlvbnMgYW5kIGFsbG93IHNsb3AuXG4gICAgICAgICAgICAgICAgdmFyIEMgPSBtYXRoJDEuY2xhbXAoYmF1bWdhcnRlICogKHNlcGFyYXRpb24gKyBsaW5lYXJTbG9wKSwgLW1heExpbmVhckNvcnJlY3Rpb24sIDAuMCk7XG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MuXG4gICAgICAgICAgICAgICAgdmFyIHJuQSA9IFZlYzIuY3Jvc3NWZWMyVmVjMihyQSwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICB2YXIgcm5CID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHJCLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgIHZhciBLID0gbUEgKyBtQiArIGlBICogcm5BICogcm5BICsgaUIgKiBybkIgKiBybkI7XG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBub3JtYWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlID0gSyA+IDAuMCA/IC1DIC8gSyA6IDAuMDtcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIubXVsTnVtVmVjMihpbXB1bHNlLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgIGNBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgICAgICAgICAgYUEgLT0gaUEgKiBWZWMyLmNyb3NzVmVjMlZlYzIockEsIFApO1xuICAgICAgICAgICAgICAgIGNCLmFkZE11bChtQiwgUCk7XG4gICAgICAgICAgICAgICAgYUIgKz0gaUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIockIsIFApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zaXRpb25BLmMuc2V0VmVjMihjQSk7XG4gICAgICAgICAgICBwb3NpdGlvbkEuYSA9IGFBO1xuICAgICAgICAgICAgcG9zaXRpb25CLmMuc2V0VmVjMihjQik7XG4gICAgICAgICAgICBwb3NpdGlvbkIuYSA9IGFCO1xuICAgICAgICAgICAgcmV0dXJuIG1pblNlcGFyYXRpb247XG4gICAgICAgIH07XG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmluaXRWZWxvY2l0eUNvbnN0cmFpbnQgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVBID0gdGhpcy5tX2ZpeHR1cmVBO1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gdGhpcy5tX2ZpeHR1cmVCO1xuICAgICAgICAgICAgdmFyIGJvZHlBID0gZml4dHVyZUEuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgdmFyIGJvZHlCID0gZml4dHVyZUIuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgdmFyIHZlbG9jaXR5QSA9IGJvZHlBLmNfdmVsb2NpdHk7XG4gICAgICAgICAgICB2YXIgdmVsb2NpdHlCID0gYm9keUIuY192ZWxvY2l0eTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkEgPSBib2R5QS5jX3Bvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uQiA9IGJvZHlCLmNfcG9zaXRpb247XG4gICAgICAgICAgICB2YXIgcmFkaXVzQSA9IHRoaXMucF9yYWRpdXNBO1xuICAgICAgICAgICAgdmFyIHJhZGl1c0IgPSB0aGlzLnBfcmFkaXVzQjtcbiAgICAgICAgICAgIHZhciBtYW5pZm9sZCA9IHRoaXMuZ2V0TWFuaWZvbGQoKTtcbiAgICAgICAgICAgIHZhciBtQSA9IHRoaXMudl9pbnZNYXNzQTtcbiAgICAgICAgICAgIHZhciBtQiA9IHRoaXMudl9pbnZNYXNzQjtcbiAgICAgICAgICAgIHZhciBpQSA9IHRoaXMudl9pbnZJQTtcbiAgICAgICAgICAgIHZhciBpQiA9IHRoaXMudl9pbnZJQjtcbiAgICAgICAgICAgIHZhciBsb2NhbENlbnRlckEgPSBWZWMyLmNsb25lKHRoaXMucF9sb2NhbENlbnRlckEpO1xuICAgICAgICAgICAgdmFyIGxvY2FsQ2VudGVyQiA9IFZlYzIuY2xvbmUodGhpcy5wX2xvY2FsQ2VudGVyQik7XG4gICAgICAgICAgICB2YXIgY0EgPSBWZWMyLmNsb25lKHBvc2l0aW9uQS5jKTtcbiAgICAgICAgICAgIHZhciBhQSA9IHBvc2l0aW9uQS5hO1xuICAgICAgICAgICAgdmFyIHZBID0gVmVjMi5jbG9uZSh2ZWxvY2l0eUEudik7XG4gICAgICAgICAgICB2YXIgd0EgPSB2ZWxvY2l0eUEudztcbiAgICAgICAgICAgIHZhciBjQiA9IFZlYzIuY2xvbmUocG9zaXRpb25CLmMpO1xuICAgICAgICAgICAgdmFyIGFCID0gcG9zaXRpb25CLmE7XG4gICAgICAgICAgICB2YXIgdkIgPSBWZWMyLmNsb25lKHZlbG9jaXR5Qi52KTtcbiAgICAgICAgICAgIHZhciB3QiA9IHZlbG9jaXR5Qi53O1xuICAgICAgICAgICAgdmFyIHhmQSA9IFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuICAgICAgICAgICAgdmFyIHhmQiA9IFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuICAgICAgICAgICAgeGZBLnEuc2V0QW5nbGUoYUEpO1xuICAgICAgICAgICAgeGZCLnEuc2V0QW5nbGUoYUIpO1xuICAgICAgICAgICAgeGZBLnAuc2V0Q29tYmluZSgxLCBjQSwgLTEsIFJvdC5tdWxWZWMyKHhmQS5xLCBsb2NhbENlbnRlckEpKTtcbiAgICAgICAgICAgIHhmQi5wLnNldENvbWJpbmUoMSwgY0IsIC0xLCBSb3QubXVsVmVjMih4ZkIucSwgbG9jYWxDZW50ZXJCKSk7XG4gICAgICAgICAgICB2YXIgd29ybGRNYW5pZm9sZCA9IG1hbmlmb2xkLmdldFdvcmxkTWFuaWZvbGQobnVsbCwgeGZBLCByYWRpdXNBLCB4ZkIsIHJhZGl1c0IpO1xuICAgICAgICAgICAgdGhpcy52X25vcm1hbC5zZXRWZWMyKHdvcmxkTWFuaWZvbGQubm9ybWFsKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy52X3BvaW50Q291bnQ7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2Y3AgPSB0aGlzLnZfcG9pbnRzW2pdOyAvLyBWZWxvY2l0eUNvbnN0cmFpbnRQb2ludFxuICAgICAgICAgICAgICAgIHZjcC5yQS5zZXRWZWMyKFZlYzIuc3ViKHdvcmxkTWFuaWZvbGQucG9pbnRzW2pdLCBjQSkpO1xuICAgICAgICAgICAgICAgIHZjcC5yQi5zZXRWZWMyKFZlYzIuc3ViKHdvcmxkTWFuaWZvbGQucG9pbnRzW2pdLCBjQikpO1xuICAgICAgICAgICAgICAgIHZhciBybkEgPSBWZWMyLmNyb3NzVmVjMlZlYzIodmNwLnJBLCB0aGlzLnZfbm9ybWFsKTtcbiAgICAgICAgICAgICAgICB2YXIgcm5CID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHZjcC5yQiwgdGhpcy52X25vcm1hbCk7XG4gICAgICAgICAgICAgICAgdmFyIGtOb3JtYWwgPSBtQSArIG1CICsgaUEgKiBybkEgKiBybkEgKyBpQiAqIHJuQiAqIHJuQjtcbiAgICAgICAgICAgICAgICB2Y3Aubm9ybWFsTWFzcyA9IGtOb3JtYWwgPiAwLjAgPyAxLjAgLyBrTm9ybWFsIDogMC4wO1xuICAgICAgICAgICAgICAgIHZhciB0YW5nZW50ID0gVmVjMi5jcm9zc1ZlYzJOdW0odGhpcy52X25vcm1hbCwgMS4wKTtcbiAgICAgICAgICAgICAgICB2YXIgcnRBID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHZjcC5yQSwgdGFuZ2VudCk7XG4gICAgICAgICAgICAgICAgdmFyIHJ0QiA9IFZlYzIuY3Jvc3NWZWMyVmVjMih2Y3AuckIsIHRhbmdlbnQpO1xuICAgICAgICAgICAgICAgIHZhciBrVGFuZ2VudCA9IG1BICsgbUIgKyBpQSAqIHJ0QSAqIHJ0QSArIGlCICogcnRCICogcnRCO1xuICAgICAgICAgICAgICAgIHZjcC50YW5nZW50TWFzcyA9IGtUYW5nZW50ID4gMC4wID8gMS4wIC8ga1RhbmdlbnQgOiAwLjA7XG4gICAgICAgICAgICAgICAgLy8gU2V0dXAgYSB2ZWxvY2l0eSBiaWFzIGZvciByZXN0aXR1dGlvbi5cbiAgICAgICAgICAgICAgICB2Y3AudmVsb2NpdHlCaWFzID0gMC4wO1xuICAgICAgICAgICAgICAgIHZhciB2UmVsID0gVmVjMi5kb3QodGhpcy52X25vcm1hbCwgdkIpXG4gICAgICAgICAgICAgICAgICAgICsgVmVjMi5kb3QodGhpcy52X25vcm1hbCwgVmVjMi5jcm9zc051bVZlYzIod0IsIHZjcC5yQikpXG4gICAgICAgICAgICAgICAgICAgIC0gVmVjMi5kb3QodGhpcy52X25vcm1hbCwgdkEpXG4gICAgICAgICAgICAgICAgICAgIC0gVmVjMi5kb3QodGhpcy52X25vcm1hbCwgVmVjMi5jcm9zc051bVZlYzIod0EsIHZjcC5yQSkpO1xuICAgICAgICAgICAgICAgIGlmICh2UmVsIDwgLVNldHRpbmdzLnZlbG9jaXR5VGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZjcC52ZWxvY2l0eUJpYXMgPSAtdGhpcy52X3Jlc3RpdHV0aW9uICogdlJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHR3byBwb2ludHMsIHRoZW4gcHJlcGFyZSB0aGUgYmxvY2sgc29sdmVyLlxuICAgICAgICAgICAgaWYgKHRoaXMudl9wb2ludENvdW50ID09IDIgJiYgc3RlcC5ibG9ja1NvbHZlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZjcDEgPSB0aGlzLnZfcG9pbnRzWzBdOyAvLyBWZWxvY2l0eUNvbnN0cmFpbnRQb2ludFxuICAgICAgICAgICAgICAgIHZhciB2Y3AyID0gdGhpcy52X3BvaW50c1sxXTsgLy8gVmVsb2NpdHlDb25zdHJhaW50UG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgcm4xQSA9IFZlYzIuY3Jvc3NWZWMyVmVjMih2Y3AxLnJBLCB0aGlzLnZfbm9ybWFsKTtcbiAgICAgICAgICAgICAgICB2YXIgcm4xQiA9IFZlYzIuY3Jvc3NWZWMyVmVjMih2Y3AxLnJCLCB0aGlzLnZfbm9ybWFsKTtcbiAgICAgICAgICAgICAgICB2YXIgcm4yQSA9IFZlYzIuY3Jvc3NWZWMyVmVjMih2Y3AyLnJBLCB0aGlzLnZfbm9ybWFsKTtcbiAgICAgICAgICAgICAgICB2YXIgcm4yQiA9IFZlYzIuY3Jvc3NWZWMyVmVjMih2Y3AyLnJCLCB0aGlzLnZfbm9ybWFsKTtcbiAgICAgICAgICAgICAgICB2YXIgazExID0gbUEgKyBtQiArIGlBICogcm4xQSAqIHJuMUEgKyBpQiAqIHJuMUIgKiBybjFCO1xuICAgICAgICAgICAgICAgIHZhciBrMjIgPSBtQSArIG1CICsgaUEgKiBybjJBICogcm4yQSArIGlCICogcm4yQiAqIHJuMkI7XG4gICAgICAgICAgICAgICAgdmFyIGsxMiA9IG1BICsgbUIgKyBpQSAqIHJuMUEgKiBybjJBICsgaUIgKiBybjFCICogcm4yQjtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgYSByZWFzb25hYmxlIGNvbmRpdGlvbiBudW1iZXIuXG4gICAgICAgICAgICAgICAgdmFyIGtfbWF4Q29uZGl0aW9uTnVtYmVyID0gMTAwMC4wO1xuICAgICAgICAgICAgICAgIGlmIChrMTEgKiBrMTEgPCBrX21heENvbmRpdGlvbk51bWJlciAqIChrMTEgKiBrMjIgLSBrMTIgKiBrMTIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEsgaXMgc2FmZSB0byBpbnZlcnQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudl9LLmV4LnNldE51bShrMTEsIGsxMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudl9LLmV5LnNldE51bShrMTIsIGsyMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudl9ub3JtYWxNYXNzLnNldCh0aGlzLnZfSy5nZXRJbnZlcnNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvbnN0cmFpbnRzIGFyZSByZWR1bmRhbnQsIGp1c3QgdXNlIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ET19FUklOIHVzZSBkZWVwZXN0P1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZfcG9pbnRDb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zaXRpb25BLmMuc2V0VmVjMihjQSk7XG4gICAgICAgICAgICBwb3NpdGlvbkEuYSA9IGFBO1xuICAgICAgICAgICAgdmVsb2NpdHlBLnYuc2V0VmVjMih2QSk7XG4gICAgICAgICAgICB2ZWxvY2l0eUEudyA9IHdBO1xuICAgICAgICAgICAgcG9zaXRpb25CLmMuc2V0VmVjMihjQik7XG4gICAgICAgICAgICBwb3NpdGlvbkIuYSA9IGFCO1xuICAgICAgICAgICAgdmVsb2NpdHlCLnYuc2V0VmVjMih2Qik7XG4gICAgICAgICAgICB2ZWxvY2l0eUIudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICBDb250YWN0LnByb3RvdHlwZS53YXJtU3RhcnRDb25zdHJhaW50ID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciBmaXh0dXJlQSA9IHRoaXMubV9maXh0dXJlQTtcbiAgICAgICAgICAgIHZhciBmaXh0dXJlQiA9IHRoaXMubV9maXh0dXJlQjtcbiAgICAgICAgICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLmdldEJvZHkoKTtcbiAgICAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLmdldEJvZHkoKTtcbiAgICAgICAgICAgIHZhciB2ZWxvY2l0eUEgPSBib2R5QS5jX3ZlbG9jaXR5O1xuICAgICAgICAgICAgdmFyIHZlbG9jaXR5QiA9IGJvZHlCLmNfdmVsb2NpdHk7XG4gICAgICAgICAgICBib2R5QS5jX3Bvc2l0aW9uO1xuICAgICAgICAgICAgYm9keUIuY19wb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBtQSA9IHRoaXMudl9pbnZNYXNzQTtcbiAgICAgICAgICAgIHZhciBpQSA9IHRoaXMudl9pbnZJQTtcbiAgICAgICAgICAgIHZhciBtQiA9IHRoaXMudl9pbnZNYXNzQjtcbiAgICAgICAgICAgIHZhciBpQiA9IHRoaXMudl9pbnZJQjtcbiAgICAgICAgICAgIHZhciB2QSA9IFZlYzIuY2xvbmUodmVsb2NpdHlBLnYpO1xuICAgICAgICAgICAgdmFyIHdBID0gdmVsb2NpdHlBLnc7XG4gICAgICAgICAgICB2YXIgdkIgPSBWZWMyLmNsb25lKHZlbG9jaXR5Qi52KTtcbiAgICAgICAgICAgIHZhciB3QiA9IHZlbG9jaXR5Qi53O1xuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHRoaXMudl9ub3JtYWw7XG4gICAgICAgICAgICB2YXIgdGFuZ2VudCA9IFZlYzIuY3Jvc3NWZWMyTnVtKG5vcm1hbCwgMS4wKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy52X3BvaW50Q291bnQ7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2Y3AgPSB0aGlzLnZfcG9pbnRzW2pdOyAvLyBWZWxvY2l0eUNvbnN0cmFpbnRQb2ludFxuICAgICAgICAgICAgICAgIHZhciBQID0gVmVjMi5jb21iaW5lKHZjcC5ub3JtYWxJbXB1bHNlLCBub3JtYWwsIHZjcC50YW5nZW50SW1wdWxzZSwgdGFuZ2VudCk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBWZWMyLmNyb3NzVmVjMlZlYzIodmNwLnJBLCBQKTtcbiAgICAgICAgICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogVmVjMi5jcm9zc1ZlYzJWZWMyKHZjcC5yQiwgUCk7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZlbG9jaXR5QS52LnNldFZlYzIodkEpO1xuICAgICAgICAgICAgdmVsb2NpdHlBLncgPSB3QTtcbiAgICAgICAgICAgIHZlbG9jaXR5Qi52LnNldFZlYzIodkIpO1xuICAgICAgICAgICAgdmVsb2NpdHlCLncgPSB3QjtcbiAgICAgICAgfTtcbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuc3RvcmVDb25zdHJhaW50SW1wdWxzZXMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIG1hbmlmb2xkID0gdGhpcy5tX21hbmlmb2xkO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZfcG9pbnRDb3VudDsgKytqKSB7XG4gICAgICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzW2pdLm5vcm1hbEltcHVsc2UgPSB0aGlzLnZfcG9pbnRzW2pdLm5vcm1hbEltcHVsc2U7XG4gICAgICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzW2pdLnRhbmdlbnRJbXB1bHNlID0gdGhpcy52X3BvaW50c1tqXS50YW5nZW50SW1wdWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnQgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIGJvZHlBID0gdGhpcy5tX2ZpeHR1cmVBLm1fYm9keTtcbiAgICAgICAgICAgIHZhciBib2R5QiA9IHRoaXMubV9maXh0dXJlQi5tX2JvZHk7XG4gICAgICAgICAgICB2YXIgdmVsb2NpdHlBID0gYm9keUEuY192ZWxvY2l0eTtcbiAgICAgICAgICAgIGJvZHlBLmNfcG9zaXRpb247XG4gICAgICAgICAgICB2YXIgdmVsb2NpdHlCID0gYm9keUIuY192ZWxvY2l0eTtcbiAgICAgICAgICAgIGJvZHlCLmNfcG9zaXRpb247XG4gICAgICAgICAgICB2YXIgbUEgPSB0aGlzLnZfaW52TWFzc0E7XG4gICAgICAgICAgICB2YXIgaUEgPSB0aGlzLnZfaW52SUE7XG4gICAgICAgICAgICB2YXIgbUIgPSB0aGlzLnZfaW52TWFzc0I7XG4gICAgICAgICAgICB2YXIgaUIgPSB0aGlzLnZfaW52SUI7XG4gICAgICAgICAgICB2YXIgdkEgPSBWZWMyLmNsb25lKHZlbG9jaXR5QS52KTtcbiAgICAgICAgICAgIHZhciB3QSA9IHZlbG9jaXR5QS53O1xuICAgICAgICAgICAgdmFyIHZCID0gVmVjMi5jbG9uZSh2ZWxvY2l0eUIudik7XG4gICAgICAgICAgICB2YXIgd0IgPSB2ZWxvY2l0eUIudztcbiAgICAgICAgICAgIHZhciBub3JtYWwgPSB0aGlzLnZfbm9ybWFsO1xuICAgICAgICAgICAgdmFyIHRhbmdlbnQgPSBWZWMyLmNyb3NzVmVjMk51bShub3JtYWwsIDEuMCk7XG4gICAgICAgICAgICB2YXIgZnJpY3Rpb24gPSB0aGlzLnZfZnJpY3Rpb247XG4gICAgICAgICAgICAvLyBTb2x2ZSB0YW5nZW50IGNvbnN0cmFpbnRzIGZpcnN0IGJlY2F1c2Ugbm9uLXBlbmV0cmF0aW9uIGlzIG1vcmUgaW1wb3J0YW50XG4gICAgICAgICAgICAvLyB0aGFuIGZyaWN0aW9uLlxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZfcG9pbnRDb3VudDsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZjcCA9IHRoaXMudl9wb2ludHNbal07IC8vIFZlbG9jaXR5Q29uc3RyYWludFBvaW50XG4gICAgICAgICAgICAgICAgLy8gUmVsYXRpdmUgdmVsb2NpdHkgYXQgY29udGFjdFxuICAgICAgICAgICAgICAgIHZhciBkdiA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgICAgIGR2LmFkZENvbWJpbmUoMSwgdkIsIDEsIFZlYzIuY3Jvc3NOdW1WZWMyKHdCLCB2Y3AuckIpKTtcbiAgICAgICAgICAgICAgICBkdi5zdWJDb21iaW5lKDEsIHZBLCAxLCBWZWMyLmNyb3NzTnVtVmVjMih3QSwgdmNwLnJBKSk7XG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0YW5nZW50IGZvcmNlXG4gICAgICAgICAgICAgICAgdmFyIHZ0ID0gVmVjMi5kb3QoZHYsIHRhbmdlbnQpIC0gdGhpcy52X3RhbmdlbnRTcGVlZDtcbiAgICAgICAgICAgICAgICB2YXIgbGFtYmRhID0gdmNwLnRhbmdlbnRNYXNzICogKC12dCk7XG4gICAgICAgICAgICAgICAgLy8gQ2xhbXAgdGhlIGFjY3VtdWxhdGVkIGZvcmNlXG4gICAgICAgICAgICAgICAgdmFyIG1heEZyaWN0aW9uID0gZnJpY3Rpb24gKiB2Y3Aubm9ybWFsSW1wdWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3SW1wdWxzZSA9IG1hdGgkMS5jbGFtcCh2Y3AudGFuZ2VudEltcHVsc2UgKyBsYW1iZGEsIC1tYXhGcmljdGlvbiwgbWF4RnJpY3Rpb24pO1xuICAgICAgICAgICAgICAgIGxhbWJkYSA9IG5ld0ltcHVsc2UgLSB2Y3AudGFuZ2VudEltcHVsc2U7XG4gICAgICAgICAgICAgICAgdmNwLnRhbmdlbnRJbXB1bHNlID0gbmV3SW1wdWxzZTtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBjb250YWN0IGltcHVsc2VcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIubXVsTnVtVmVjMihsYW1iZGEsIHRhbmdlbnQpO1xuICAgICAgICAgICAgICAgIHZBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBWZWMyLmNyb3NzVmVjMlZlYzIodmNwLnJBLCBQKTtcbiAgICAgICAgICAgICAgICB2Qi5hZGRNdWwobUIsIFApO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogVmVjMi5jcm9zc1ZlYzJWZWMyKHZjcC5yQiwgUCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb2x2ZSBub3JtYWwgY29uc3RyYWludHNcbiAgICAgICAgICAgIGlmICh0aGlzLnZfcG9pbnRDb3VudCA9PSAxIHx8IHN0ZXAuYmxvY2tTb2x2ZSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52X3BvaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmNwID0gdGhpcy52X3BvaW50c1tpXTsgLy8gVmVsb2NpdHlDb25zdHJhaW50UG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVsYXRpdmUgdmVsb2NpdHkgYXQgY29udGFjdFxuICAgICAgICAgICAgICAgICAgICB2YXIgZHYgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgICAgICAgICAgZHYuYWRkQ29tYmluZSgxLCB2QiwgMSwgVmVjMi5jcm9zc051bVZlYzIod0IsIHZjcC5yQikpO1xuICAgICAgICAgICAgICAgICAgICBkdi5zdWJDb21iaW5lKDEsIHZBLCAxLCBWZWMyLmNyb3NzTnVtVmVjMih3QSwgdmNwLnJBKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgbm9ybWFsIGltcHVsc2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZuID0gVmVjMi5kb3QoZHYsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYW1iZGEgPSAtdmNwLm5vcm1hbE1hc3MgKiAodm4gLSB2Y3AudmVsb2NpdHlCaWFzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xhbXAgdGhlIGFjY3VtdWxhdGVkIGltcHVsc2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0ltcHVsc2UgPSBtYXRoJDEubWF4KHZjcC5ub3JtYWxJbXB1bHNlICsgbGFtYmRhLCAwLjApO1xuICAgICAgICAgICAgICAgICAgICBsYW1iZGEgPSBuZXdJbXB1bHNlIC0gdmNwLm5vcm1hbEltcHVsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZjcC5ub3JtYWxJbXB1bHNlID0gbmV3SW1wdWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgY29udGFjdCBpbXB1bHNlXG4gICAgICAgICAgICAgICAgICAgIHZhciBQID0gVmVjMi5tdWxOdW1WZWMyKGxhbWJkYSwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgdkEuc3ViTXVsKG1BLCBQKTtcbiAgICAgICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBWZWMyLmNyb3NzVmVjMlZlYzIodmNwLnJBLCBQKTtcbiAgICAgICAgICAgICAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICAgICAgd0IgKz0gaUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIodmNwLnJCLCBQKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCbG9jayBzb2x2ZXIgZGV2ZWxvcGVkIGluIGNvbGxhYm9yYXRpb24gd2l0aCBEaXJrIEdyZWdvcml1cyAoYmFjayBpblxuICAgICAgICAgICAgICAgIC8vIDAxLzA3IG9uIEJveDJEX0xpdGUpLlxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBtaW5pIExDUCBmb3IgdGhpcyBjb250YWN0IHBhdGNoXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyB2biA9IEEgKiB4ICsgYiwgdm4gPj0gMCwgLCB2biA+PSAwLCB4ID49IDAgYW5kIHZuX2kgKiB4X2kgPSAwIHdpdGggaSA9XG4gICAgICAgICAgICAgICAgLy8gMS4uMlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQSA9IEogKiBXICogSlQgYW5kIEogPSAoIC1uLCAtcjEgeCBuLCBuLCByMiB4IG4gKVxuICAgICAgICAgICAgICAgIC8vIGIgPSB2bjAgLSB2ZWxvY2l0eUJpYXNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzeXN0ZW0gaXMgc29sdmVkIHVzaW5nIHRoZSBcIlRvdGFsIGVudW1lcmF0aW9uIG1ldGhvZFwiIChzLiBNdXJ0eSkuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbXBsZW1lbnRhcnkgY29uc3RyYWludCB2bl9pICogeF9pXG4gICAgICAgICAgICAgICAgLy8gaW1wbGllcyB0aGF0IHdlIG11c3QgaGF2ZSBpbiBhbnkgc29sdXRpb24gZWl0aGVyIHZuX2kgPSAwIG9yIHhfaSA9IDAuXG4gICAgICAgICAgICAgICAgLy8gU28gZm9yIHRoZSAyRCBjb250YWN0IHByb2JsZW0gdGhlIGNhc2VzXG4gICAgICAgICAgICAgICAgLy8gdm4xID0gMCBhbmQgdm4yID0gMCwgeDEgPSAwIGFuZCB4MiA9IDAsIHgxID0gMCBhbmQgdm4yID0gMCwgeDIgPSAwIGFuZFxuICAgICAgICAgICAgICAgIC8vIHZuMSA9IDAgbmVlZCB0byBiZSB0ZXN0ZWQuIFRoZSBmaXJzdCB2YWxpZFxuICAgICAgICAgICAgICAgIC8vIHNvbHV0aW9uIHRoYXQgc2F0aXNmaWVzIHRoZSBwcm9ibGVtIGlzIGNob3Nlbi5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIGFjY291bnQgb2YgdGhlIGFjY3VtdWxhdGVkIGltcHVsc2UgJ2EnIChiZWNhdXNlIG9mIHRoZVxuICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGl2ZSBuYXR1cmUgb2YgdGhlIHNvbHZlciB3aGljaCBvbmx5IHJlcXVpcmVzXG4gICAgICAgICAgICAgICAgLy8gdGhhdCB0aGUgYWNjdW11bGF0ZWQgaW1wdWxzZSBpcyBjbGFtcGVkIGFuZCBub3QgdGhlIGluY3JlbWVudGFsXG4gICAgICAgICAgICAgICAgLy8gaW1wdWxzZSkgd2UgY2hhbmdlIHRoZSBpbXB1bHNlIHZhcmlhYmxlICh4X2kpLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gU3Vic3RpdHV0ZTpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIHggPSBhICsgZFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gYSA6PSBvbGQgdG90YWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgIC8vIHggOj0gbmV3IHRvdGFsIGltcHVsc2VcbiAgICAgICAgICAgICAgICAvLyBkIDo9IGluY3JlbWVudGFsIGltcHVsc2VcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEZvciB0aGUgY3VycmVudCBpdGVyYXRpb24gd2UgZXh0ZW5kIHRoZSBmb3JtdWxhIGZvciB0aGUgaW5jcmVtZW50YWxcbiAgICAgICAgICAgICAgICAvLyBpbXB1bHNlXG4gICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSB0aGUgbmV3IHRvdGFsIGltcHVsc2U6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyB2biA9IEEgKiBkICsgYlxuICAgICAgICAgICAgICAgIC8vID0gQSAqICh4IC0gYSkgKyBiXG4gICAgICAgICAgICAgICAgLy8gPSBBICogeCArIGIgLSBBICogYVxuICAgICAgICAgICAgICAgIC8vID0gQSAqIHggKyBiJ1xuICAgICAgICAgICAgICAgIC8vIGInID0gYiAtIEEgKiBhO1xuICAgICAgICAgICAgICAgIHZhciB2Y3AxID0gdGhpcy52X3BvaW50c1swXTsgLy8gVmVsb2NpdHlDb25zdHJhaW50UG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgdmNwMiA9IHRoaXMudl9wb2ludHNbMV07IC8vIFZlbG9jaXR5Q29uc3RyYWludFBvaW50XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBWZWMyLm5lbyh2Y3AxLm5vcm1hbEltcHVsc2UsIHZjcDIubm9ybWFsSW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgLy8gUmVsYXRpdmUgdmVsb2NpdHkgYXQgY29udGFjdFxuICAgICAgICAgICAgICAgIHZhciBkdjEgPSBWZWMyLnplcm8oKS5hZGQodkIpLmFkZChWZWMyLmNyb3NzTnVtVmVjMih3QiwgdmNwMS5yQikpLnN1Yih2QSkuc3ViKFZlYzIuY3Jvc3NOdW1WZWMyKHdBLCB2Y3AxLnJBKSk7XG4gICAgICAgICAgICAgICAgdmFyIGR2MiA9IFZlYzIuemVybygpLmFkZCh2QikuYWRkKFZlYzIuY3Jvc3NOdW1WZWMyKHdCLCB2Y3AyLnJCKSkuc3ViKHZBKS5zdWIoVmVjMi5jcm9zc051bVZlYzIod0EsIHZjcDIuckEpKTtcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG5vcm1hbCB2ZWxvY2l0eVxuICAgICAgICAgICAgICAgIHZhciB2bjEgPSBWZWMyLmRvdChkdjEsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgdmFyIHZuMiA9IFZlYzIuZG90KGR2Miwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IFZlYzIubmVvKHZuMSAtIHZjcDEudmVsb2NpdHlCaWFzLCB2bjIgLSB2Y3AyLnZlbG9jaXR5Qmlhcyk7XG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBiJ1xuICAgICAgICAgICAgICAgIGIuc3ViKE1hdDIyLm11bFZlYzIodGhpcy52X0ssIGEpKTtcbiAgICAgICAgICAgICAgICAvLyBOT1RfVVNFRChrX2Vycm9yVG9sKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBDYXNlIDE6IHZuID0gMFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAwID0gQSAqIHggKyBiJ1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBTb2x2ZSBmb3IgeDpcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8geCA9IC0gaW52KEEpICogYidcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBNYXQyMi5tdWxWZWMyKHRoaXMudl9ub3JtYWxNYXNzLCBiKS5uZWcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgueCA+PSAwLjAgJiYgeC55ID49IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmNyZW1lbnRhbCBpbXB1bHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IFZlYzIuc3ViKHgsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgaW5jcmVtZW50YWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFAxID0gVmVjMi5tdWxOdW1WZWMyKGQueCwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBQMiA9IFZlYzIubXVsTnVtVmVjMihkLnksIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2QS5zdWJDb21iaW5lKG1BLCBQMSwgbUEsIFAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdBIC09IGlBICogKFZlYzIuY3Jvc3NWZWMyVmVjMih2Y3AxLnJBLCBQMSkgKyBWZWMyLmNyb3NzVmVjMlZlYzIodmNwMi5yQSwgUDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZCLmFkZENvbWJpbmUobUIsIFAxLCBtQiwgUDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd0IgKz0gaUIgKiAoVmVjMi5jcm9zc1ZlYzJWZWMyKHZjcDEuckIsIFAxKSArIFZlYzIuY3Jvc3NWZWMyVmVjMih2Y3AyLnJCLCBQMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmNwMS5ub3JtYWxJbXB1bHNlID0geC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmNwMi5ub3JtYWxJbXB1bHNlID0geC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FzZSAyOiB2bjEgPSAwIGFuZCB4MiA9IDBcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gMCA9IGExMSAqIHgxICsgYTEyICogMCArIGIxJ1xuICAgICAgICAgICAgICAgICAgICAvLyB2bjIgPSBhMjEgKiB4MSArIGEyMiAqIDAgKyBiMidcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgeC54ID0gLXZjcDEubm9ybWFsTWFzcyAqIGIueDtcbiAgICAgICAgICAgICAgICAgICAgeC55ID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB2bjEgPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIHZuMiA9IHRoaXMudl9LLmV4LnkgKiB4LnggKyBiLnk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4LnggPj0gMC4wICYmIHZuMiA+PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5jcmVtZW50YWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBWZWMyLnN1Yih4LCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGluY3JlbWVudGFsIGltcHVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBQMSA9IFZlYzIubXVsTnVtVmVjMihkLngsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgUDIgPSBWZWMyLm11bE51bVZlYzIoZC55LCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdkEuc3ViQ29tYmluZShtQSwgUDEsIG1BLCBQMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIChWZWMyLmNyb3NzVmVjMlZlYzIodmNwMS5yQSwgUDEpICsgVmVjMi5jcm9zc1ZlYzJWZWMyKHZjcDIuckEsIFAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2Qi5hZGRDb21iaW5lKG1CLCBQMSwgbUIsIFAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdCICs9IGlCICogKFZlYzIuY3Jvc3NWZWMyVmVjMih2Y3AxLnJCLCBQMSkgKyBWZWMyLmNyb3NzVmVjMlZlYzIodmNwMi5yQiwgUDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZjcDEubm9ybWFsSW1wdWxzZSA9IHgueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZjcDIubm9ybWFsSW1wdWxzZSA9IHgueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIENhc2UgMzogdm4yID0gMCBhbmQgeDEgPSAwXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIHZuMSA9IGExMSAqIDAgKyBhMTIgKiB4MiArIGIxJ1xuICAgICAgICAgICAgICAgICAgICAvLyAwID0gYTIxICogMCArIGEyMiAqIHgyICsgYjInXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIHgueCA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgeC55ID0gLXZjcDIubm9ybWFsTWFzcyAqIGIueTtcbiAgICAgICAgICAgICAgICAgICAgdm4xID0gdGhpcy52X0suZXkueCAqIHgueSArIGIueDtcbiAgICAgICAgICAgICAgICAgICAgdm4yID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeC55ID49IDAuMCAmJiB2bjEgPj0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN1YnN0aXR1dGUgZm9yIHRoZSBpbmNyZW1lbnRhbCBpbXB1bHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IFZlYzIuc3ViKHgsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgaW5jcmVtZW50YWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFAxID0gVmVjMi5tdWxOdW1WZWMyKGQueCwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBQMiA9IFZlYzIubXVsTnVtVmVjMihkLnksIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2QS5zdWJDb21iaW5lKG1BLCBQMSwgbUEsIFAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdBIC09IGlBICogKFZlYzIuY3Jvc3NWZWMyVmVjMih2Y3AxLnJBLCBQMSkgKyBWZWMyLmNyb3NzVmVjMlZlYzIodmNwMi5yQSwgUDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZCLmFkZENvbWJpbmUobUIsIFAxLCBtQiwgUDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd0IgKz0gaUIgKiAoVmVjMi5jcm9zc1ZlYzJWZWMyKHZjcDEuckIsIFAxKSArIFZlYzIuY3Jvc3NWZWMyVmVjMih2Y3AyLnJCLCBQMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmNwMS5ub3JtYWxJbXB1bHNlID0geC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmNwMi5ub3JtYWxJbXB1bHNlID0geC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FzZSA0OiB4MSA9IDAgYW5kIHgyID0gMFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyB2bjEgPSBiMVxuICAgICAgICAgICAgICAgICAgICAvLyB2bjIgPSBiMjtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgeC54ID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB4LnkgPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIHZuMSA9IGIueDtcbiAgICAgICAgICAgICAgICAgICAgdm4yID0gYi55O1xuICAgICAgICAgICAgICAgICAgICBpZiAodm4xID49IDAuMCAmJiB2bjIgPj0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN1YnN0aXR1dGUgZm9yIHRoZSBpbmNyZW1lbnRhbCBpbXB1bHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IFZlYzIuc3ViKHgsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgaW5jcmVtZW50YWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFAxID0gVmVjMi5tdWxOdW1WZWMyKGQueCwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBQMiA9IFZlYzIubXVsTnVtVmVjMihkLnksIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2QS5zdWJDb21iaW5lKG1BLCBQMSwgbUEsIFAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdBIC09IGlBICogKFZlYzIuY3Jvc3NWZWMyVmVjMih2Y3AxLnJBLCBQMSkgKyBWZWMyLmNyb3NzVmVjMlZlYzIodmNwMi5yQSwgUDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZCLmFkZENvbWJpbmUobUIsIFAxLCBtQiwgUDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd0IgKz0gaUIgKiAoVmVjMi5jcm9zc1ZlYzJWZWMyKHZjcDEuckIsIFAxKSArIFZlYzIuY3Jvc3NWZWMyVmVjMih2Y3AyLnJCLCBQMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmNwMS5ub3JtYWxJbXB1bHNlID0geC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmNwMi5ub3JtYWxJbXB1bHNlID0geC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gc29sdXRpb24sIGdpdmUgdXAuIFRoaXMgaXMgaGl0IHNvbWV0aW1lcywgYnV0IGl0IGRvZXNuJ3Qgc2VlbSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXR0ZXIuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZlbG9jaXR5QS52LnNldFZlYzIodkEpO1xuICAgICAgICAgICAgdmVsb2NpdHlBLncgPSB3QTtcbiAgICAgICAgICAgIHZlbG9jaXR5Qi52LnNldFZlYzIodkIpO1xuICAgICAgICAgICAgdmVsb2NpdHlCLncgPSB3QjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5hZGRUeXBlID0gZnVuY3Rpb24gKHR5cGUxLCB0eXBlMiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHNfcmVnaXN0ZXJzW3R5cGUxXSA9IHNfcmVnaXN0ZXJzW3R5cGUxXSB8fCB7fTtcbiAgICAgICAgICAgIHNfcmVnaXN0ZXJzW3R5cGUxXVt0eXBlMl0gPSBjYWxsYmFjaztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5jcmVhdGUgPSBmdW5jdGlvbiAoZml4dHVyZUEsIGluZGV4QSwgZml4dHVyZUIsIGluZGV4Qikge1xuICAgICAgICAgICAgdmFyIHR5cGVBID0gZml4dHVyZUEuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgdmFyIHR5cGVCID0gZml4dHVyZUIuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgLy8gVE9ETzogcG9vbCBjb250YWN0c1xuICAgICAgICAgICAgdmFyIGNvbnRhY3Q7XG4gICAgICAgICAgICB2YXIgZXZhbHVhdGVGY247XG4gICAgICAgICAgICBpZiAoZXZhbHVhdGVGY24gPSBzX3JlZ2lzdGVyc1t0eXBlQV0gJiYgc19yZWdpc3RlcnNbdHlwZUFdW3R5cGVCXSkge1xuICAgICAgICAgICAgICAgIGNvbnRhY3QgPSBuZXcgQ29udGFjdChmaXh0dXJlQSwgaW5kZXhBLCBmaXh0dXJlQiwgaW5kZXhCLCBldmFsdWF0ZUZjbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmFsdWF0ZUZjbiA9IHNfcmVnaXN0ZXJzW3R5cGVCXSAmJiBzX3JlZ2lzdGVyc1t0eXBlQl1bdHlwZUFdKSB7XG4gICAgICAgICAgICAgICAgY29udGFjdCA9IG5ldyBDb250YWN0KGZpeHR1cmVCLCBpbmRleEIsIGZpeHR1cmVBLCBpbmRleEEsIGV2YWx1YXRlRmNuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29udGFjdCBjcmVhdGlvbiBtYXkgc3dhcCBmaXh0dXJlcy5cbiAgICAgICAgICAgIGZpeHR1cmVBID0gY29udGFjdC5nZXRGaXh0dXJlQSgpO1xuICAgICAgICAgICAgZml4dHVyZUIgPSBjb250YWN0LmdldEZpeHR1cmVCKCk7XG4gICAgICAgICAgICBpbmRleEEgPSBjb250YWN0LmdldENoaWxkSW5kZXhBKCk7XG4gICAgICAgICAgICBpbmRleEIgPSBjb250YWN0LmdldENoaWxkSW5kZXhCKCk7XG4gICAgICAgICAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5nZXRCb2R5KCk7XG4gICAgICAgICAgICB2YXIgYm9keUIgPSBmaXh0dXJlQi5nZXRCb2R5KCk7XG4gICAgICAgICAgICAvLyBDb25uZWN0IHRvIGJvZHkgQVxuICAgICAgICAgICAgY29udGFjdC5tX25vZGVBLmNvbnRhY3QgPSBjb250YWN0O1xuICAgICAgICAgICAgY29udGFjdC5tX25vZGVBLm90aGVyID0gYm9keUI7XG4gICAgICAgICAgICBjb250YWN0Lm1fbm9kZUEucHJldiA9IG51bGw7XG4gICAgICAgICAgICBjb250YWN0Lm1fbm9kZUEubmV4dCA9IGJvZHlBLm1fY29udGFjdExpc3Q7XG4gICAgICAgICAgICBpZiAoYm9keUEubV9jb250YWN0TGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYm9keUEubV9jb250YWN0TGlzdC5wcmV2ID0gY29udGFjdC5tX25vZGVBO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keUEubV9jb250YWN0TGlzdCA9IGNvbnRhY3QubV9ub2RlQTtcbiAgICAgICAgICAgIC8vIENvbm5lY3QgdG8gYm9keSBCXG4gICAgICAgICAgICBjb250YWN0Lm1fbm9kZUIuY29udGFjdCA9IGNvbnRhY3Q7XG4gICAgICAgICAgICBjb250YWN0Lm1fbm9kZUIub3RoZXIgPSBib2R5QTtcbiAgICAgICAgICAgIGNvbnRhY3QubV9ub2RlQi5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRhY3QubV9ub2RlQi5uZXh0ID0gYm9keUIubV9jb250YWN0TGlzdDtcbiAgICAgICAgICAgIGlmIChib2R5Qi5tX2NvbnRhY3RMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBib2R5Qi5tX2NvbnRhY3RMaXN0LnByZXYgPSBjb250YWN0Lm1fbm9kZUI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5Qi5tX2NvbnRhY3RMaXN0ID0gY29udGFjdC5tX25vZGVCO1xuICAgICAgICAgICAgLy8gV2FrZSB1cCB0aGUgYm9kaWVzXG4gICAgICAgICAgICBpZiAoZml4dHVyZUEuaXNTZW5zb3IoKSA9PSBmYWxzZSAmJiBmaXh0dXJlQi5pc1NlbnNvcigpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGFjdDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5kZXN0cm95ID0gZnVuY3Rpb24gKGNvbnRhY3QsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICB2YXIgZml4dHVyZUEgPSBjb250YWN0Lm1fZml4dHVyZUE7XG4gICAgICAgICAgICB2YXIgZml4dHVyZUIgPSBjb250YWN0Lm1fZml4dHVyZUI7XG4gICAgICAgICAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5nZXRCb2R5KCk7XG4gICAgICAgICAgICB2YXIgYm9keUIgPSBmaXh0dXJlQi5nZXRCb2R5KCk7XG4gICAgICAgICAgICBpZiAoY29udGFjdC5pc1RvdWNoaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5lbmRDb250YWN0KGNvbnRhY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYm9keSAxXG4gICAgICAgICAgICBpZiAoY29udGFjdC5tX25vZGVBLnByZXYpIHtcbiAgICAgICAgICAgICAgICBjb250YWN0Lm1fbm9kZUEucHJldi5uZXh0ID0gY29udGFjdC5tX25vZGVBLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGFjdC5tX25vZGVBLm5leHQpIHtcbiAgICAgICAgICAgICAgICBjb250YWN0Lm1fbm9kZUEubmV4dC5wcmV2ID0gY29udGFjdC5tX25vZGVBLnByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGFjdC5tX25vZGVBID09IGJvZHlBLm1fY29udGFjdExpc3QpIHtcbiAgICAgICAgICAgICAgICBib2R5QS5tX2NvbnRhY3RMaXN0ID0gY29udGFjdC5tX25vZGVBLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBib2R5IDJcbiAgICAgICAgICAgIGlmIChjb250YWN0Lm1fbm9kZUIucHJldikge1xuICAgICAgICAgICAgICAgIGNvbnRhY3QubV9ub2RlQi5wcmV2Lm5leHQgPSBjb250YWN0Lm1fbm9kZUIubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250YWN0Lm1fbm9kZUIubmV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnRhY3QubV9ub2RlQi5uZXh0LnByZXYgPSBjb250YWN0Lm1fbm9kZUIucHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250YWN0Lm1fbm9kZUIgPT0gYm9keUIubV9jb250YWN0TGlzdCkge1xuICAgICAgICAgICAgICAgIGJvZHlCLm1fY29udGFjdExpc3QgPSBjb250YWN0Lm1fbm9kZUIubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250YWN0Lm1fbWFuaWZvbGQucG9pbnRDb3VudCA+IDAgJiYgZml4dHVyZUEuaXNTZW5zb3IoKSA9PSBmYWxzZVxuICAgICAgICAgICAgICAgICYmIGZpeHR1cmVCLmlzU2Vuc29yKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpeHR1cmVBLmdldFR5cGUoKTtcbiAgICAgICAgICAgIGZpeHR1cmVCLmdldFR5cGUoKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IGRlc3Ryb3lGY24gPSBzX3JlZ2lzdGVyc1t0eXBlQV1bdHlwZUJdLmRlc3Ryb3lGY247XG4gICAgICAgICAgICAvLyBpZiAodHlwZW9mIGRlc3Ryb3lGY24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vICAgZGVzdHJveUZjbihjb250YWN0KTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbnRhY3Q7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBIGpvaW50IGVkZ2UgaXMgdXNlZCB0byBjb25uZWN0IGJvZGllcyBhbmQgam9pbnRzIHRvZ2V0aGVyIGluIGEgam9pbnQgZ3JhcGhcbiAgICAgKiB3aGVyZSBlYWNoIGJvZHkgaXMgYSBub2RlIGFuZCBlYWNoIGpvaW50IGlzIGFuIGVkZ2UuIEEgam9pbnQgZWRnZSBiZWxvbmdzIHRvXG4gICAgICogYSBkb3VibHkgbGlua2VkIGxpc3QgbWFpbnRhaW5lZCBpbiBlYWNoIGF0dGFjaGVkIGJvZHkuIEVhY2ggam9pbnQgaGFzIHR3b1xuICAgICAqIGpvaW50IG5vZGVzLCBvbmUgZm9yIGVhY2ggYXR0YWNoZWQgYm9keS5cbiAgICAgKi9cbiAgICB2YXIgSm9pbnRFZGdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBKb2ludEVkZ2UoKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHByb3ZpZGVzIHF1aWNrIGFjY2VzcyB0byB0aGUgb3RoZXIgYm9keSBhdHRhY2hlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5vdGhlciA9IG51bGw7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHRoZSBqb2ludFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmpvaW50ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcHJldiB0aGUgcHJldmlvdXMgam9pbnQgZWRnZSBpbiB0aGUgYm9keSdzIGpvaW50IGxpc3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogdGhlIG5leHQgam9pbnQgZWRnZSBpbiB0aGUgYm9keSdzIGpvaW50IGxpc3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSm9pbnRFZGdlO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogVGhlIGJhc2Ugam9pbnQgY2xhc3MuIEpvaW50cyBhcmUgdXNlZCB0byBjb25zdHJhaW50IHR3byBib2RpZXMgdG9nZXRoZXIgaW5cbiAgICAgKiB2YXJpb3VzIGZhc2hpb25zLiBTb21lIGpvaW50cyBhbHNvIGZlYXR1cmUgbGltaXRzIGFuZCBtb3RvcnMuXG4gICAgICovXG4gICAgdmFyIEpvaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBKb2ludChkZWYsIGJvZHlBLCBib2R5Qikge1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqLyB0aGlzLm1fdHlwZSA9ICd1bmtub3duLWpvaW50JztcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy5tX3ByZXYgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqLyB0aGlzLm1fbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMubV9lZGdlQSA9IG5ldyBKb2ludEVkZ2UoKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy5tX2VkZ2VCID0gbmV3IEpvaW50RWRnZSgpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqLyB0aGlzLm1faXNsYW5kRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgYm9keUEgPSAnYm9keUEnIGluIGRlZiA/IGRlZi5ib2R5QSA6IGJvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSAnYm9keUInIGluIGRlZiA/IGRlZi5ib2R5QiA6IGJvZHlCO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBID0gYm9keUE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIgPSBib2R5QjtcbiAgICAgICAgICAgIHRoaXMubV9jb2xsaWRlQ29ubmVjdGVkID0gISFkZWYuY29sbGlkZUNvbm5lY3RlZDtcbiAgICAgICAgICAgIHRoaXMubV91c2VyRGF0YSA9IGRlZi51c2VyRGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnQtY3V0IGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBlaXRoZXIgYm9keSBpcyBpbmFjdGl2ZS5cbiAgICAgICAgICovXG4gICAgICAgIEpvaW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuaXNBY3RpdmUoKSAmJiB0aGlzLm1fYm9keUIuaXNBY3RpdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgdHlwZSBvZiB0aGUgY29uY3JldGUgam9pbnQuXG4gICAgICAgICAqL1xuICAgICAgICBKb2ludC5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdHlwZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZmlyc3QgYm9keSBhdHRhY2hlZCB0byB0aGlzIGpvaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgSm9pbnQucHJvdG90eXBlLmdldEJvZHlBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgc2Vjb25kIGJvZHkgYXR0YWNoZWQgdG8gdGhpcyBqb2ludC5cbiAgICAgICAgICovXG4gICAgICAgIEpvaW50LnByb3RvdHlwZS5nZXRCb2R5QiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG5leHQgam9pbnQgdGhlIHdvcmxkIGpvaW50IGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBKb2ludC5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbmV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgSm9pbnQucHJvdG90eXBlLmdldFVzZXJEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV91c2VyRGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgSm9pbnQucHJvdG90eXBlLnNldFVzZXJEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMubV91c2VyRGF0YSA9IGRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY29sbGlkZSBjb25uZWN0ZWQuIE5vdGU6IG1vZGlmeWluZyB0aGUgY29sbGlkZSBjb25uZWN0IGZsYWcgd29uJ3Qgd29ya1xuICAgICAgICAgKiBjb3JyZWN0bHkgYmVjYXVzZSB0aGUgZmxhZyBpcyBvbmx5IGNoZWNrZWQgd2hlbiBmaXh0dXJlIEFBQkJzIGJlZ2luIHRvXG4gICAgICAgICAqIG92ZXJsYXAuXG4gICAgICAgICAqL1xuICAgICAgICBKb2ludC5wcm90b3R5cGUuZ2V0Q29sbGlkZUNvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fY29sbGlkZUNvbm5lY3RlZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNoaWZ0IHRoZSBvcmlnaW4gZm9yIGFueSBwb2ludHMgc3RvcmVkIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgSm9pbnQucHJvdG90eXBlLnNoaWZ0T3JpZ2luID0gZnVuY3Rpb24gKG5ld09yaWdpbikgeyB9O1xuICAgICAgICByZXR1cm4gSm9pbnQ7XG4gICAgfSgpKTtcblxuICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgIH07XG4gICAgdmFyIGRpZmYgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRpbWU7XG4gICAgfTtcbiAgICB2YXIgVGltZXIgPSB7XG4gICAgICAgIG5vdzogbm93LFxuICAgICAgICBkaWZmOiBkaWZmLFxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogSW5wdXQgcGFyYW1ldGVycyBmb3IgVGltZU9mSW1wYWN0LlxuICAgICAqL1xuICAgIHZhciBUT0lJbnB1dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVE9JSW5wdXQoKSB7XG4gICAgICAgICAgICB0aGlzLnByb3h5QSA9IG5ldyBEaXN0YW5jZVByb3h5KCk7XG4gICAgICAgICAgICB0aGlzLnByb3h5QiA9IG5ldyBEaXN0YW5jZVByb3h5KCk7XG4gICAgICAgICAgICB0aGlzLnN3ZWVwQSA9IG5ldyBTd2VlcCgpO1xuICAgICAgICAgICAgdGhpcy5zd2VlcEIgPSBuZXcgU3dlZXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVE9JSW5wdXQ7XG4gICAgfSgpKTtcbiAgICB2YXIgVE9JT3V0cHV0U3RhdGU7XG4gICAgKGZ1bmN0aW9uIChUT0lPdXRwdXRTdGF0ZSkge1xuICAgICAgICBUT0lPdXRwdXRTdGF0ZVtUT0lPdXRwdXRTdGF0ZVtcImVfdW5rbm93blwiXSA9IDBdID0gXCJlX3Vua25vd25cIjtcbiAgICAgICAgVE9JT3V0cHV0U3RhdGVbVE9JT3V0cHV0U3RhdGVbXCJlX2ZhaWxlZFwiXSA9IDFdID0gXCJlX2ZhaWxlZFwiO1xuICAgICAgICBUT0lPdXRwdXRTdGF0ZVtUT0lPdXRwdXRTdGF0ZVtcImVfb3ZlcmxhcHBlZFwiXSA9IDJdID0gXCJlX292ZXJsYXBwZWRcIjtcbiAgICAgICAgVE9JT3V0cHV0U3RhdGVbVE9JT3V0cHV0U3RhdGVbXCJlX3RvdWNoaW5nXCJdID0gM10gPSBcImVfdG91Y2hpbmdcIjtcbiAgICAgICAgVE9JT3V0cHV0U3RhdGVbVE9JT3V0cHV0U3RhdGVbXCJlX3NlcGFyYXRlZFwiXSA9IDRdID0gXCJlX3NlcGFyYXRlZFwiO1xuICAgIH0pKFRPSU91dHB1dFN0YXRlIHx8IChUT0lPdXRwdXRTdGF0ZSA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogT3V0cHV0IHBhcmFtZXRlcnMgZm9yIFRpbWVPZkltcGFjdC5cbiAgICAgKi9cbiAgICB2YXIgVE9JT3V0cHV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUT0lPdXRwdXQoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRPSU91dHB1dDtcbiAgICB9KCkpO1xuICAgIHN0YXRzJDEudG9pVGltZSA9IDA7XG4gICAgc3RhdHMkMS50b2lNYXhUaW1lID0gMDtcbiAgICBzdGF0cyQxLnRvaUNhbGxzID0gMDtcbiAgICBzdGF0cyQxLnRvaUl0ZXJzID0gMDtcbiAgICBzdGF0cyQxLnRvaU1heEl0ZXJzID0gMDtcbiAgICBzdGF0cyQxLnRvaVJvb3RJdGVycyA9IDA7XG4gICAgc3RhdHMkMS50b2lNYXhSb290SXRlcnMgPSAwO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIHVwcGVyIGJvdW5kIG9uIHRpbWUgYmVmb3JlIHR3byBzaGFwZXMgcGVuZXRyYXRlLiBUaW1lIGlzXG4gICAgICogcmVwcmVzZW50ZWQgYXMgYSBmcmFjdGlvbiBiZXR3ZWVuIFswLHRNYXhdLiBUaGlzIHVzZXMgYSBzd2VwdCBzZXBhcmF0aW5nIGF4aXNcbiAgICAgKiBhbmQgbWF5IG1pc3Mgc29tZSBpbnRlcm1lZGlhdGUsIG5vbi10dW5uZWxpbmcgY29sbGlzaW9uLiBJZiB5b3UgY2hhbmdlIHRoZVxuICAgICAqIHRpbWUgaW50ZXJ2YWwsIHlvdSBzaG91bGQgY2FsbCB0aGlzIGZ1bmN0aW9uIGFnYWluLlxuICAgICAqXG4gICAgICogTm90ZTogdXNlIERpc3RhbmNlIHRvIGNvbXB1dGUgdGhlIGNvbnRhY3QgcG9pbnQgYW5kIG5vcm1hbCBhdCB0aGUgdGltZSBvZlxuICAgICAqIGltcGFjdC5cbiAgICAgKlxuICAgICAqIENDRCB2aWEgdGhlIGxvY2FsIHNlcGFyYXRpbmcgYXhpcyBtZXRob2QuIFRoaXMgc2Vla3MgcHJvZ3Jlc3Npb24gYnkgY29tcHV0aW5nXG4gICAgICogdGhlIGxhcmdlc3QgdGltZSBhdCB3aGljaCBzZXBhcmF0aW9uIGlzIG1haW50YWluZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGltZU9mSW1wYWN0KG91dHB1dCwgaW5wdXQpIHtcbiAgICAgICAgdmFyIHRpbWVyID0gVGltZXIubm93KCk7XG4gICAgICAgICsrc3RhdHMkMS50b2lDYWxscztcbiAgICAgICAgb3V0cHV0LnN0YXRlID0gVE9JT3V0cHV0U3RhdGUuZV91bmtub3duO1xuICAgICAgICBvdXRwdXQudCA9IGlucHV0LnRNYXg7XG4gICAgICAgIHZhciBwcm94eUEgPSBpbnB1dC5wcm94eUE7IC8vIERpc3RhbmNlUHJveHlcbiAgICAgICAgdmFyIHByb3h5QiA9IGlucHV0LnByb3h5QjsgLy8gRGlzdGFuY2VQcm94eVxuICAgICAgICB2YXIgc3dlZXBBID0gaW5wdXQuc3dlZXBBOyAvLyBTd2VlcFxuICAgICAgICB2YXIgc3dlZXBCID0gaW5wdXQuc3dlZXBCOyAvLyBTd2VlcFxuICAgICAgICAvLyBMYXJnZSByb3RhdGlvbnMgY2FuIG1ha2UgdGhlIHJvb3QgZmluZGVyIGZhaWwsIHNvIHdlIG5vcm1hbGl6ZSB0aGVcbiAgICAgICAgLy8gc3dlZXAgYW5nbGVzLlxuICAgICAgICBzd2VlcEEubm9ybWFsaXplKCk7XG4gICAgICAgIHN3ZWVwQi5ub3JtYWxpemUoKTtcbiAgICAgICAgdmFyIHRNYXggPSBpbnB1dC50TWF4O1xuICAgICAgICB2YXIgdG90YWxSYWRpdXMgPSBwcm94eUEubV9yYWRpdXMgKyBwcm94eUIubV9yYWRpdXM7XG4gICAgICAgIHZhciB0YXJnZXQgPSBtYXRoJDEubWF4KFNldHRpbmdzLmxpbmVhclNsb3AsIHRvdGFsUmFkaXVzIC0gMy4wICogU2V0dGluZ3MubGluZWFyU2xvcCk7XG4gICAgICAgIHZhciB0b2xlcmFuY2UgPSAwLjI1ICogU2V0dGluZ3MubGluZWFyU2xvcDtcbiAgICAgICAgdmFyIHQxID0gMC4wO1xuICAgICAgICB2YXIga19tYXhJdGVyYXRpb25zID0gU2V0dGluZ3MubWF4VE9JSXRlcmF0aW9ucztcbiAgICAgICAgdmFyIGl0ZXIgPSAwO1xuICAgICAgICAvLyBQcmVwYXJlIGlucHV0IGZvciBkaXN0YW5jZSBxdWVyeS5cbiAgICAgICAgdmFyIGNhY2hlID0gbmV3IFNpbXBsZXhDYWNoZSgpO1xuICAgICAgICB2YXIgZGlzdGFuY2VJbnB1dCA9IG5ldyBEaXN0YW5jZUlucHV0KCk7XG4gICAgICAgIGRpc3RhbmNlSW5wdXQucHJveHlBID0gaW5wdXQucHJveHlBO1xuICAgICAgICBkaXN0YW5jZUlucHV0LnByb3h5QiA9IGlucHV0LnByb3h5QjtcbiAgICAgICAgZGlzdGFuY2VJbnB1dC51c2VSYWRpaSA9IGZhbHNlO1xuICAgICAgICAvLyBUaGUgb3V0ZXIgbG9vcCBwcm9ncmVzc2l2ZWx5IGF0dGVtcHRzIHRvIGNvbXB1dGUgbmV3IHNlcGFyYXRpbmcgYXhlcy5cbiAgICAgICAgLy8gVGhpcyBsb29wIHRlcm1pbmF0ZXMgd2hlbiBhbiBheGlzIGlzIHJlcGVhdGVkIChubyBwcm9ncmVzcyBpcyBtYWRlKS5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciB4ZkEgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgICAgIHZhciB4ZkIgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgICAgIHN3ZWVwQS5nZXRUcmFuc2Zvcm0oeGZBLCB0MSk7XG4gICAgICAgICAgICBzd2VlcEIuZ2V0VHJhbnNmb3JtKHhmQiwgdDEpO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHNoYXBlcy4gV2UgY2FuIGFsc28gdXNlIHRoZSByZXN1bHRzXG4gICAgICAgICAgICAvLyB0byBnZXQgYSBzZXBhcmF0aW5nIGF4aXMuXG4gICAgICAgICAgICBkaXN0YW5jZUlucHV0LnRyYW5zZm9ybUEgPSB4ZkE7XG4gICAgICAgICAgICBkaXN0YW5jZUlucHV0LnRyYW5zZm9ybUIgPSB4ZkI7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2VPdXRwdXQgPSBuZXcgRGlzdGFuY2VPdXRwdXQoKTtcbiAgICAgICAgICAgIERpc3RhbmNlKGRpc3RhbmNlT3V0cHV0LCBjYWNoZSwgZGlzdGFuY2VJbnB1dCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2hhcGVzIGFyZSBvdmVybGFwcGVkLCB3ZSBnaXZlIHVwIG9uIGNvbnRpbnVvdXMgY29sbGlzaW9uLlxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlT3V0cHV0LmRpc3RhbmNlIDw9IDAuMCkge1xuICAgICAgICAgICAgICAgIC8vIEZhaWx1cmUhXG4gICAgICAgICAgICAgICAgb3V0cHV0LnN0YXRlID0gVE9JT3V0cHV0U3RhdGUuZV9vdmVybGFwcGVkO1xuICAgICAgICAgICAgICAgIG91dHB1dC50ID0gMC4wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlT3V0cHV0LmRpc3RhbmNlIDwgdGFyZ2V0ICsgdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gVmljdG9yeSFcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3RhdGUgPSBUT0lPdXRwdXRTdGF0ZS5lX3RvdWNoaW5nO1xuICAgICAgICAgICAgICAgIG91dHB1dC50ID0gdDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBzZXBhcmF0aW5nIGF4aXMuXG4gICAgICAgICAgICB2YXIgZmNuID0gbmV3IFNlcGFyYXRpb25GdW5jdGlvbigpO1xuICAgICAgICAgICAgZmNuLmluaXRpYWxpemUoY2FjaGUsIHByb3h5QSwgc3dlZXBBLCBwcm94eUIsIHN3ZWVwQiwgdDEpO1xuICAgICAgICAgICAgLy8gaWYgKGZhbHNlKSB7XG4gICAgICAgICAgICAvLyAgIC8vIER1bXAgdGhlIGN1cnZlIHNlZW4gYnkgdGhlIHJvb3QgZmluZGVyXG4gICAgICAgICAgICAvLyAgIGNvbnN0IE4gPSAxMDA7XG4gICAgICAgICAgICAvLyAgIGNvbnN0IGR4ID0gMS4wIC8gTjtcbiAgICAgICAgICAgIC8vICAgY29uc3QgeHMgPSBbXTsgLy8gWyBOICsgMSBdO1xuICAgICAgICAgICAgLy8gICBjb25zdCBmcyA9IFtdOyAvLyBbIE4gKyAxIF07XG4gICAgICAgICAgICAvLyAgIGNvbnN0IHggPSAwLjA7XG4gICAgICAgICAgICAvLyAgIGZvciAoY29uc3QgaSA9IDA7IGkgPD0gTjsgKytpKSB7XG4gICAgICAgICAgICAvLyAgICAgc3dlZXBBLmdldFRyYW5zZm9ybSh4ZkEsIHgpO1xuICAgICAgICAgICAgLy8gICAgIHN3ZWVwQi5nZXRUcmFuc2Zvcm0oeGZCLCB4KTtcbiAgICAgICAgICAgIC8vICAgICBjb25zdCBmID0gZmNuLmV2YWx1YXRlKHhmQSwgeGZCKSAtIHRhcmdldDtcbiAgICAgICAgICAgIC8vICAgICBwcmludGYoXCIlZyAlZ1xcblwiLCB4LCBmKTtcbiAgICAgICAgICAgIC8vICAgICB4c1tpXSA9IHg7XG4gICAgICAgICAgICAvLyAgICAgZnNbaV0gPSBmO1xuICAgICAgICAgICAgLy8gICAgIHggKz0gZHg7XG4gICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIFRPSSBvbiB0aGUgc2VwYXJhdGluZyBheGlzLiBXZSBkbyB0aGlzIGJ5IHN1Y2Nlc3NpdmVseVxuICAgICAgICAgICAgLy8gcmVzb2x2aW5nIHRoZSBkZWVwZXN0IHBvaW50LiBUaGlzIGxvb3AgaXMgYm91bmRlZCBieSB0aGUgbnVtYmVyIG9mXG4gICAgICAgICAgICAvLyB2ZXJ0aWNlcy5cbiAgICAgICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgdDIgPSB0TWF4O1xuICAgICAgICAgICAgdmFyIHB1c2hCYWNrSXRlciA9IDA7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGRlZXBlc3QgcG9pbnQgYXQgdDIuIFN0b3JlIHRoZSB3aXRuZXNzIHBvaW50IGluZGljZXMuXG4gICAgICAgICAgICAgICAgdmFyIHMyID0gZmNuLmZpbmRNaW5TZXBhcmF0aW9uKHQyKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBpbmRleEEgPSBmY24uaW5kZXhBO1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IGluZGV4QiA9IGZjbi5pbmRleEI7XG4gICAgICAgICAgICAgICAgLy8gSXMgdGhlIGZpbmFsIGNvbmZpZ3VyYXRpb24gc2VwYXJhdGVkP1xuICAgICAgICAgICAgICAgIGlmIChzMiA+IHRhcmdldCArIHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBWaWN0b3J5IVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3RhdGUgPSBUT0lPdXRwdXRTdGF0ZS5lX3NlcGFyYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnQgPSB0TWF4O1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhcyB0aGUgc2VwYXJhdGlvbiByZWFjaGVkIHRvbGVyYW5jZT9cbiAgICAgICAgICAgICAgICBpZiAoczIgPiB0YXJnZXQgLSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgc3dlZXBzXG4gICAgICAgICAgICAgICAgICAgIHQxID0gdDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBpbml0aWFsIHNlcGFyYXRpb24gb2YgdGhlIHdpdG5lc3MgcG9pbnRzLlxuICAgICAgICAgICAgICAgIHZhciBzMSA9IGZjbi5ldmFsdWF0ZSh0MSk7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgaW5kZXhBID0gZmNuLmluZGV4QTtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBpbmRleEIgPSBmY24uaW5kZXhCO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBpbml0aWFsIG92ZXJsYXAuIFRoaXMgbWlnaHQgaGFwcGVuIGlmIHRoZSByb290IGZpbmRlclxuICAgICAgICAgICAgICAgIC8vIHJ1bnMgb3V0IG9mIGl0ZXJhdGlvbnMuXG4gICAgICAgICAgICAgICAgaWYgKHMxIDwgdGFyZ2V0IC0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zdGF0ZSA9IFRPSU91dHB1dFN0YXRlLmVfZmFpbGVkO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQudCA9IHQxO1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB0b3VjaGluZ1xuICAgICAgICAgICAgICAgIGlmIChzMSA8PSB0YXJnZXQgKyB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmljdG9yeSEgdDEgc2hvdWxkIGhvbGQgdGhlIFRPSSAoY291bGQgYmUgMC4wKS5cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnN0YXRlID0gVE9JT3V0cHV0U3RhdGUuZV90b3VjaGluZztcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnQgPSB0MTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIDFEIHJvb3Qgb2Y6IGYoeCkgLSB0YXJnZXQgPSAwXG4gICAgICAgICAgICAgICAgdmFyIHJvb3RJdGVyQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBhMSA9IHQxO1xuICAgICAgICAgICAgICAgIHZhciBhMiA9IHQyO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhIG1peCBvZiB0aGUgc2VjYW50IHJ1bGUgYW5kIGJpc2VjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290SXRlckNvdW50ICYgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VjYW50IHJ1bGUgdG8gaW1wcm92ZSBjb252ZXJnZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBhMSArICh0YXJnZXQgLSBzMSkgKiAoYTIgLSBhMSkgLyAoczIgLSBzMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCaXNlY3Rpb24gdG8gZ3VhcmFudGVlIHByb2dyZXNzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IDAuNSAqIChhMSArIGEyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICArK3Jvb3RJdGVyQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICsrc3RhdHMkMS50b2lSb290SXRlcnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gZmNuLmV2YWx1YXRlKHQpO1xuICAgICAgICAgICAgICAgICAgICBmY24uaW5kZXhBO1xuICAgICAgICAgICAgICAgICAgICBmY24uaW5kZXhCO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0aCQxLmFicyhzIC0gdGFyZ2V0KSA8IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdDIgaG9sZHMgYSB0ZW50YXRpdmUgdmFsdWUgZm9yIHQxXG4gICAgICAgICAgICAgICAgICAgICAgICB0MiA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgd2UgY29udGludWUgdG8gYnJhY2tldCB0aGUgcm9vdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgPiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGExID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMyID0gcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocm9vdEl0ZXJDb3VudCA9PT0gNTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRzJDEudG9pTWF4Um9vdEl0ZXJzID0gbWF0aCQxLm1heChzdGF0cyQxLnRvaU1heFJvb3RJdGVycywgcm9vdEl0ZXJDb3VudCk7XG4gICAgICAgICAgICAgICAgKytwdXNoQmFja0l0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHB1c2hCYWNrSXRlciA9PT0gU2V0dGluZ3MubWF4UG9seWdvblZlcnRpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsraXRlcjtcbiAgICAgICAgICAgICsrc3RhdHMkMS50b2lJdGVycztcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlciA9PT0ga19tYXhJdGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gUm9vdCBmaW5kZXIgZ290IHN0dWNrLiBTZW1pLXZpY3RvcnkuXG4gICAgICAgICAgICAgICAgb3V0cHV0LnN0YXRlID0gVE9JT3V0cHV0U3RhdGUuZV9mYWlsZWQ7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnQgPSB0MTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0cyQxLnRvaU1heEl0ZXJzID0gbWF0aCQxLm1heChzdGF0cyQxLnRvaU1heEl0ZXJzLCBpdGVyKTtcbiAgICAgICAgdmFyIHRpbWUgPSBUaW1lci5kaWZmKHRpbWVyKTtcbiAgICAgICAgc3RhdHMkMS50b2lNYXhUaW1lID0gbWF0aCQxLm1heChzdGF0cyQxLnRvaU1heFRpbWUsIHRpbWUpO1xuICAgICAgICBzdGF0cyQxLnRvaVRpbWUgKz0gdGltZTtcbiAgICB9XG4gICAgdmFyIFNlcGFyYXRpb25GdW5jdGlvblR5cGU7XG4gICAgKGZ1bmN0aW9uIChTZXBhcmF0aW9uRnVuY3Rpb25UeXBlKSB7XG4gICAgICAgIFNlcGFyYXRpb25GdW5jdGlvblR5cGVbU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZVtcImVfcG9pbnRzXCJdID0gMV0gPSBcImVfcG9pbnRzXCI7XG4gICAgICAgIFNlcGFyYXRpb25GdW5jdGlvblR5cGVbU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZVtcImVfZmFjZUFcIl0gPSAyXSA9IFwiZV9mYWNlQVwiO1xuICAgICAgICBTZXBhcmF0aW9uRnVuY3Rpb25UeXBlW1NlcGFyYXRpb25GdW5jdGlvblR5cGVbXCJlX2ZhY2VCXCJdID0gM10gPSBcImVfZmFjZUJcIjtcbiAgICB9KShTZXBhcmF0aW9uRnVuY3Rpb25UeXBlIHx8IChTZXBhcmF0aW9uRnVuY3Rpb25UeXBlID0ge30pKTtcbiAgICB2YXIgU2VwYXJhdGlvbkZ1bmN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTZXBhcmF0aW9uRnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLm1fcHJveHlBID0gbmV3IERpc3RhbmNlUHJveHkoKTtcbiAgICAgICAgICAgIHRoaXMubV9wcm94eUIgPSBuZXcgRGlzdGFuY2VQcm94eSgpO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsUG9pbnQgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIHRoaXMubV9heGlzID0gVmVjMi56ZXJvKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ET19FUklOIG1pZ2h0IG5vdCBuZWVkIHRvIHJldHVybiB0aGUgc2VwYXJhdGlvblxuICAgICAgICBTZXBhcmF0aW9uRnVuY3Rpb24ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoY2FjaGUsIHByb3h5QSwgc3dlZXBBLCBwcm94eUIsIHN3ZWVwQiwgdDEpIHtcbiAgICAgICAgICAgIHRoaXMubV9wcm94eUEgPSBwcm94eUE7XG4gICAgICAgICAgICB0aGlzLm1fcHJveHlCID0gcHJveHlCO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gY2FjaGUuY291bnQ7XG4gICAgICAgICAgICB0aGlzLm1fc3dlZXBBID0gc3dlZXBBO1xuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwQiA9IHN3ZWVwQjtcbiAgICAgICAgICAgIHZhciB4ZkEgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgICAgIHZhciB4ZkIgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMubV9zd2VlcEEuZ2V0VHJhbnNmb3JtKHhmQSwgdDEpO1xuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwQi5nZXRUcmFuc2Zvcm0oeGZCLCB0MSk7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdHlwZSA9IFNlcGFyYXRpb25GdW5jdGlvblR5cGUuZV9wb2ludHM7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUG9pbnRBID0gdGhpcy5tX3Byb3h5QS5nZXRWZXJ0ZXgoY2FjaGUuaW5kZXhBWzBdKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQb2ludEIgPSB0aGlzLm1fcHJveHlCLmdldFZlcnRleChjYWNoZS5pbmRleEJbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBwb2ludEEgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkEsIGxvY2FsUG9pbnRBKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRCID0gVHJhbnNmb3JtLm11bFZlYzIoeGZCLCBsb2NhbFBvaW50Qik7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2F4aXMuc2V0Q29tYmluZSgxLCBwb2ludEIsIC0xLCBwb2ludEEpO1xuICAgICAgICAgICAgICAgIHZhciBzID0gdGhpcy5tX2F4aXMubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjYWNoZS5pbmRleEFbMF0gPT09IGNhY2hlLmluZGV4QVsxXSkge1xuICAgICAgICAgICAgICAgIC8vIFR3byBwb2ludHMgb24gQiBhbmQgb25lIG9uIEEuXG4gICAgICAgICAgICAgICAgdGhpcy5tX3R5cGUgPSBTZXBhcmF0aW9uRnVuY3Rpb25UeXBlLmVfZmFjZUI7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUG9pbnRCMSA9IHByb3h5Qi5nZXRWZXJ0ZXgoY2FjaGUuaW5kZXhCWzBdKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQb2ludEIyID0gcHJveHlCLmdldFZlcnRleChjYWNoZS5pbmRleEJbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMubV9heGlzID0gVmVjMi5jcm9zc1ZlYzJOdW0oVmVjMi5zdWIobG9jYWxQb2ludEIyLCBsb2NhbFBvaW50QjEpLCAxLjApO1xuICAgICAgICAgICAgICAgIHRoaXMubV9heGlzLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBSb3QubXVsVmVjMih4ZkIucSwgdGhpcy5tX2F4aXMpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbFBvaW50ID0gVmVjMi5taWQobG9jYWxQb2ludEIxLCBsb2NhbFBvaW50QjIpO1xuICAgICAgICAgICAgICAgIHZhciBwb2ludEIgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkIsIHRoaXMubV9sb2NhbFBvaW50KTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQb2ludEEgPSBwcm94eUEuZ2V0VmVydGV4KGNhY2hlLmluZGV4QVswXSk7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50QSA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQSwgbG9jYWxQb2ludEEpO1xuICAgICAgICAgICAgICAgIHZhciBzID0gVmVjMi5kb3QocG9pbnRBLCBub3JtYWwpIC0gVmVjMi5kb3QocG9pbnRCLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgIGlmIChzIDwgMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9heGlzID0gVmVjMi5uZWcodGhpcy5tX2F4aXMpO1xuICAgICAgICAgICAgICAgICAgICBzID0gLXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHdvIHBvaW50cyBvbiBBIGFuZCBvbmUgb3IgdHdvIHBvaW50cyBvbiBCLlxuICAgICAgICAgICAgICAgIHRoaXMubV90eXBlID0gU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZS5lX2ZhY2VBO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhbFBvaW50QTEgPSB0aGlzLm1fcHJveHlBLmdldFZlcnRleChjYWNoZS5pbmRleEFbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhbFBvaW50QTIgPSB0aGlzLm1fcHJveHlBLmdldFZlcnRleChjYWNoZS5pbmRleEFbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMubV9heGlzID0gVmVjMi5jcm9zc1ZlYzJOdW0oVmVjMi5zdWIobG9jYWxQb2ludEEyLCBsb2NhbFBvaW50QTEpLCAxLjApO1xuICAgICAgICAgICAgICAgIHRoaXMubV9heGlzLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBSb3QubXVsVmVjMih4ZkEucSwgdGhpcy5tX2F4aXMpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbFBvaW50ID0gVmVjMi5taWQobG9jYWxQb2ludEExLCBsb2NhbFBvaW50QTIpO1xuICAgICAgICAgICAgICAgIHZhciBwb2ludEEgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkEsIHRoaXMubV9sb2NhbFBvaW50KTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQb2ludEIgPSB0aGlzLm1fcHJveHlCLmdldFZlcnRleChjYWNoZS5pbmRleEJbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBwb2ludEIgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkIsIGxvY2FsUG9pbnRCKTtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IFZlYzIuZG90KHBvaW50Qiwgbm9ybWFsKSAtIFZlYzIuZG90KHBvaW50QSwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICBpZiAocyA8IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fYXhpcyA9IFZlYzIubmVnKHRoaXMubV9heGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcyA9IC1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU2VwYXJhdGlvbkZ1bmN0aW9uLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24gKGZpbmQsIHQpIHtcbiAgICAgICAgICAgIC8vIEl0IHdhcyBmaW5kTWluU2VwYXJhdGlvbiBhbmQgZXZhbHVhdGVcbiAgICAgICAgICAgIHZhciB4ZkEgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgICAgIHZhciB4ZkIgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMubV9zd2VlcEEuZ2V0VHJhbnNmb3JtKHhmQSwgdCk7XG4gICAgICAgICAgICB0aGlzLm1fc3dlZXBCLmdldFRyYW5zZm9ybSh4ZkIsIHQpO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLm1fdHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZS5lX3BvaW50czoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXNBID0gUm90Lm11bFRWZWMyKHhmQS5xLCB0aGlzLm1fYXhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhpc0IgPSBSb3QubXVsVFZlYzIoeGZCLnEsIFZlYzIubmVnKHRoaXMubV9heGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4QSA9IHRoaXMubV9wcm94eUEuZ2V0U3VwcG9ydChheGlzQSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4QiA9IHRoaXMubV9wcm94eUIuZ2V0U3VwcG9ydChheGlzQik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsUG9pbnRBID0gdGhpcy5tX3Byb3h5QS5nZXRWZXJ0ZXgodGhpcy5pbmRleEEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxQb2ludEIgPSB0aGlzLm1fcHJveHlCLmdldFZlcnRleCh0aGlzLmluZGV4Qik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludEEgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkEsIGxvY2FsUG9pbnRBKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50QiA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQiwgbG9jYWxQb2ludEIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VwID0gVmVjMi5kb3QocG9pbnRCLCB0aGlzLm1fYXhpcykgLSBWZWMyLmRvdChwb2ludEEsIHRoaXMubV9heGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTZXBhcmF0aW9uRnVuY3Rpb25UeXBlLmVfZmFjZUE6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IFJvdC5tdWxWZWMyKHhmQS5xLCB0aGlzLm1fYXhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludEEgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkEsIHRoaXMubV9sb2NhbFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheGlzQiA9IFJvdC5tdWxUVmVjMih4ZkIucSwgVmVjMi5uZWcobm9ybWFsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4QSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleEIgPSB0aGlzLm1fcHJveHlCLmdldFN1cHBvcnQoYXhpc0IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbFBvaW50QiA9IHRoaXMubV9wcm94eUIuZ2V0VmVydGV4KHRoaXMuaW5kZXhCKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50QiA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQiwgbG9jYWxQb2ludEIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VwID0gVmVjMi5kb3QocG9pbnRCLCBub3JtYWwpIC0gVmVjMi5kb3QocG9pbnRBLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFNlcGFyYXRpb25GdW5jdGlvblR5cGUuZV9mYWNlQjoge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gUm90Lm11bFZlYzIoeGZCLnEsIHRoaXMubV9heGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50QiA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQiwgdGhpcy5tX2xvY2FsUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXNBID0gUm90Lm11bFRWZWMyKHhmQS5xLCBWZWMyLm5lZyhub3JtYWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhCID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4QSA9IHRoaXMubV9wcm94eUEuZ2V0U3VwcG9ydChheGlzQSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsUG9pbnRBID0gdGhpcy5tX3Byb3h5QS5nZXRWZXJ0ZXgodGhpcy5pbmRleEEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRBID0gVHJhbnNmb3JtLm11bFZlYzIoeGZBLCBsb2NhbFBvaW50QSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXAgPSBWZWMyLmRvdChwb2ludEEsIG5vcm1hbCkgLSBWZWMyLmRvdChwb2ludEIsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4QSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleEIgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTZXBhcmF0aW9uRnVuY3Rpb24ucHJvdG90eXBlLmZpbmRNaW5TZXBhcmF0aW9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGUodHJ1ZSwgdCk7XG4gICAgICAgIH07XG4gICAgICAgIFNlcGFyYXRpb25GdW5jdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZShmYWxzZSwgdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTZXBhcmF0aW9uRnVuY3Rpb247XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICB2YXIgVGltZVN0ZXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRpbWVTdGVwKCkge1xuICAgICAgICAgICAgLyoqIHRpbWUgc3RlcCAqL1xuICAgICAgICAgICAgdGhpcy5kdCA9IDA7XG4gICAgICAgICAgICAvKiogaW52ZXJzZSB0aW1lIHN0ZXAgKDAgaWYgZHQgPT0gMCkgKi9cbiAgICAgICAgICAgIHRoaXMuaW52X2R0ID0gMDtcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHlJdGVyYXRpb25zID0gMDtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25JdGVyYXRpb25zID0gMDtcbiAgICAgICAgICAgIHRoaXMud2FybVN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmJsb2NrU29sdmUgPSB0cnVlO1xuICAgICAgICAgICAgLyoqIHRpbWVzdGVwIHJhdGlvIGZvciB2YXJpYWJsZSB0aW1lc3RlcCAqL1xuICAgICAgICAgICAgdGhpcy5pbnZfZHQwID0gMC4wO1xuICAgICAgICAgICAgLyoqIGR0ICogaW52X2R0MCAqL1xuICAgICAgICAgICAgdGhpcy5kdFJhdGlvID0gMTtcbiAgICAgICAgfVxuICAgICAgICBUaW1lU3RlcC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR0ID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZfZHQwID0gdGhpcy5pbnZfZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICAgICAgICB0aGlzLmludl9kdCA9IGR0ID09IDAgPyAwIDogMSAvIGR0O1xuICAgICAgICAgICAgdGhpcy5kdFJhdGlvID0gZHQgKiB0aGlzLmludl9kdDA7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUaW1lU3RlcDtcbiAgICB9KCkpO1xuICAgIC8vIHJldXNlXG4gICAgdmFyIHNfc3ViU3RlcCA9IG5ldyBUaW1lU3RlcCgpO1xuICAgIC8qKlxuICAgICAqIENvbnRhY3QgaW1wdWxzZXMgZm9yIHJlcG9ydGluZy4gSW1wdWxzZXMgYXJlIHVzZWQgaW5zdGVhZCBvZiBmb3JjZXMgYmVjYXVzZVxuICAgICAqIHN1Yi1zdGVwIGZvcmNlcyBtYXkgYXBwcm9hY2ggaW5maW5pdHkgZm9yIHJpZ2lkIGJvZHkgY29sbGlzaW9ucy4gVGhlc2UgbWF0Y2hcbiAgICAgKiB1cCBvbmUtdG8tb25lIHdpdGggdGhlIGNvbnRhY3QgcG9pbnRzIGluIE1hbmlmb2xkLlxuICAgICAqL1xuICAgIHZhciBDb250YWN0SW1wdWxzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29udGFjdEltcHVsc2UoY29udGFjdCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWN0ID0gY29udGFjdDtcbiAgICAgICAgICAgIHRoaXMubm9ybWFscyA9IFtdO1xuICAgICAgICAgICAgdGhpcy50YW5nZW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWN0SW1wdWxzZS5wcm90b3R5cGUsIFwibm9ybWFsSW1wdWxzZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLmNvbnRhY3Q7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbHMgPSB0aGlzLm5vcm1hbHM7XG4gICAgICAgICAgICAgICAgbm9ybWFscy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgY29udGFjdC52X3BvaW50cy5sZW5ndGg7ICsrcCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxzLnB1c2goY29udGFjdC52X3BvaW50c1twXS5ub3JtYWxJbXB1bHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWN0SW1wdWxzZS5wcm90b3R5cGUsIFwidGFuZ2VudEltcHVsc2VzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWN0ID0gdGhpcy5jb250YWN0O1xuICAgICAgICAgICAgICAgIHZhciB0YW5nZW50cyA9IHRoaXMudGFuZ2VudHM7XG4gICAgICAgICAgICAgICAgdGFuZ2VudHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IGNvbnRhY3Qudl9wb2ludHMubGVuZ3RoOyArK3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFuZ2VudHMucHVzaChjb250YWN0LnZfcG9pbnRzW3BdLnRhbmdlbnRJbXB1bHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhbmdlbnRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQ29udGFjdEltcHVsc2U7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbmQgc29sdmVzIGlzbGFuZHMuIEFuIGlzbGFuZCBpcyBhIGNvbm5lY3RlZCBzdWJzZXQgb2YgdGhlIHdvcmxkLlxuICAgICAqL1xuICAgIHZhciBTb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNvbHZlcih3b3JsZCkge1xuICAgICAgICAgICAgdGhpcy5tX3dvcmxkID0gd29ybGQ7XG4gICAgICAgICAgICB0aGlzLm1fc3RhY2sgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubV9ib2RpZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubV9jb250YWN0cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5tX2pvaW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm1fc3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMubV9ib2RpZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMubV9jb250YWN0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5tX2pvaW50cy5sZW5ndGggPSAwO1xuICAgICAgICB9O1xuICAgICAgICBTb2x2ZXIucHJvdG90eXBlLmFkZEJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICAgICAgdGhpcy5tX2JvZGllcy5wdXNoKGJvZHkpO1xuICAgICAgICAgICAgLy8gd2h5P1xuICAgICAgICAgICAgLy8gYm9keS5jX3Bvc2l0aW9uLmMuc2V0WmVybygpO1xuICAgICAgICAgICAgLy8gYm9keS5jX3Bvc2l0aW9uLmEgPSAwO1xuICAgICAgICAgICAgLy8gYm9keS5jX3ZlbG9jaXR5LnYuc2V0WmVybygpO1xuICAgICAgICAgICAgLy8gYm9keS5jX3ZlbG9jaXR5LncgPSAwO1xuICAgICAgICB9O1xuICAgICAgICBTb2x2ZXIucHJvdG90eXBlLmFkZENvbnRhY3QgPSBmdW5jdGlvbiAoY29udGFjdCkge1xuICAgICAgICAgICAgdGhpcy5tX2NvbnRhY3RzLnB1c2goY29udGFjdCk7XG4gICAgICAgIH07XG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUuYWRkSm9pbnQgPSBmdW5jdGlvbiAoam9pbnQpIHtcbiAgICAgICAgICAgIHRoaXMubV9qb2ludHMucHVzaChqb2ludCk7XG4gICAgICAgIH07XG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUuc29sdmVXb3JsZCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB2YXIgd29ybGQgPSB0aGlzLm1fd29ybGQ7XG4gICAgICAgICAgICAvLyBDbGVhciBhbGwgdGhlIGlzbGFuZCBmbGFncy5cbiAgICAgICAgICAgIGZvciAodmFyIGIgPSB3b3JsZC5tX2JvZHlMaXN0OyBiOyBiID0gYi5tX25leHQpIHtcbiAgICAgICAgICAgICAgICBiLm1faXNsYW5kRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IHdvcmxkLm1fY29udGFjdExpc3Q7IGM7IGMgPSBjLm1fbmV4dCkge1xuICAgICAgICAgICAgICAgIGMubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gd29ybGQubV9qb2ludExpc3Q7IGo7IGogPSBqLm1fbmV4dCkge1xuICAgICAgICAgICAgICAgIGoubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWlsZCBhbmQgc2ltdWxhdGUgYWxsIGF3YWtlIGlzbGFuZHMuXG4gICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLm1fc3RhY2s7XG4gICAgICAgICAgICBmb3IgKHZhciBzZWVkID0gd29ybGQubV9ib2R5TGlzdDsgc2VlZDsgc2VlZCA9IHNlZWQubV9uZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZWQubV9pc2xhbmRGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VlZC5pc0F3YWtlKCkgPT0gZmFsc2UgfHwgc2VlZC5pc0FjdGl2ZSgpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgc2VlZCBjYW4gYmUgZHluYW1pYyBvciBraW5lbWF0aWMuXG4gICAgICAgICAgICAgICAgaWYgKHNlZWQuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgaXNsYW5kIGFuZCBzdGFjay5cbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChzZWVkKTtcbiAgICAgICAgICAgICAgICBzZWVkLm1faXNsYW5kRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBhIGRlcHRoIGZpcnN0IHNlYXJjaCAoREZTKSBvbiB0aGUgY29uc3RyYWludCBncmFwaC5cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHcmFiIHRoZSBuZXh0IGJvZHkgb2ZmIHRoZSBzdGFjayBhbmQgYWRkIGl0IHRvIHRoZSBpc2xhbmQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQm9keShiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBib2R5IGlzIGF3YWtlLlxuICAgICAgICAgICAgICAgICAgICBiLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUbyBrZWVwIGlzbGFuZHMgYXMgc21hbGwgYXMgcG9zc2libGUsIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSBpc2xhbmRzIGFjcm9zcyBzdGF0aWMgYm9kaWVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYi5pc1N0YXRpYygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTZWFyY2ggYWxsIGNvbnRhY3RzIGNvbm5lY3RlZCB0byB0aGlzIGJvZHkuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNlID0gYi5tX2NvbnRhY3RMaXN0OyBjZTsgY2UgPSBjZS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IGNlLmNvbnRhY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYXMgdGhpcyBjb250YWN0IGFscmVhZHkgYmVlbiBhZGRlZCB0byBhbiBpc2xhbmQ/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdC5tX2lzbGFuZEZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgY29udGFjdCBzb2xpZCBhbmQgdG91Y2hpbmc/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdC5pc0VuYWJsZWQoKSA9PSBmYWxzZSB8fCBjb250YWN0LmlzVG91Y2hpbmcoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBzZW5zb3JzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbnNvckEgPSBjb250YWN0Lm1fZml4dHVyZUEubV9pc1NlbnNvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZW5zb3JCID0gY29udGFjdC5tX2ZpeHR1cmVCLm1faXNTZW5zb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Vuc29yQSB8fCBzZW5zb3JCKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENvbnRhY3QoY29udGFjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0Lm1faXNsYW5kRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjZS5vdGhlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhcyB0aGUgb3RoZXIgYm9keSBhbHJlYWR5IGFkZGVkIHRvIHRoaXMgaXNsYW5kP1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyLm1faXNsYW5kRmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KHN0YWNrLmxlbmd0aCA8IHdvcmxkLm1fYm9keUNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gob3RoZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIubV9pc2xhbmRGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTZWFyY2ggYWxsIGpvaW50cyBjb25uZWN0IHRvIHRoaXMgYm9keS5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgamUgPSBiLm1fam9pbnRMaXN0OyBqZTsgamUgPSBqZS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoamUuam9pbnQubV9pc2xhbmRGbGFnID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGplLm90aGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc2ltdWxhdGUgam9pbnRzIGNvbm5lY3RlZCB0byBpbmFjdGl2ZSBib2RpZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXIuaXNBY3RpdmUoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRKb2ludChqZS5qb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqZS5qb2ludC5tX2lzbGFuZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyLm1faXNsYW5kRmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KHN0YWNrLmxlbmd0aCA8IHdvcmxkLm1fYm9keUNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gob3RoZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIubV9pc2xhbmRGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNvbHZlSXNsYW5kKHN0ZXApO1xuICAgICAgICAgICAgICAgIC8vIFBvc3Qgc29sdmUgY2xlYW51cC5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9ib2RpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgc3RhdGljIGJvZGllcyB0byBwYXJ0aWNpcGF0ZSBpbiBvdGhlciBpc2xhbmRzLlxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBhcmUgdGhleSBhZGRlZCBhdCBhbGw/XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5tX2JvZGllc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5tX2lzbGFuZEZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5zb2x2ZUlzbGFuZCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICAvLyBCMjogSXNsYW5kIFNvbHZlXG4gICAgICAgICAgICB2YXIgd29ybGQgPSB0aGlzLm1fd29ybGQ7XG4gICAgICAgICAgICB2YXIgZ3Jhdml0eSA9IHdvcmxkLm1fZ3Jhdml0eTtcbiAgICAgICAgICAgIHZhciBhbGxvd1NsZWVwID0gd29ybGQubV9hbGxvd1NsZWVwO1xuICAgICAgICAgICAgdmFyIGggPSBzdGVwLmR0O1xuICAgICAgICAgICAgLy8gSW50ZWdyYXRlIHZlbG9jaXRpZXMgYW5kIGFwcGx5IGRhbXBpbmcuIEluaXRpYWxpemUgdGhlIGJvZHkgc3RhdGUuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9ib2RpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IHRoaXMubV9ib2RpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBWZWMyLmNsb25lKGJvZHkubV9zd2VlcC5jKTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGJvZHkubV9zd2VlcC5hO1xuICAgICAgICAgICAgICAgIHZhciB2ID0gVmVjMi5jbG9uZShib2R5Lm1fbGluZWFyVmVsb2NpdHkpO1xuICAgICAgICAgICAgICAgIHZhciB3ID0gYm9keS5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBwb3NpdGlvbnMgZm9yIGNvbnRpbnVvdXMgY29sbGlzaW9uLlxuICAgICAgICAgICAgICAgIGJvZHkubV9zd2VlcC5jMC5zZXRWZWMyKGJvZHkubV9zd2VlcC5jKTtcbiAgICAgICAgICAgICAgICBib2R5Lm1fc3dlZXAuYTAgPSBib2R5Lm1fc3dlZXAuYTtcbiAgICAgICAgICAgICAgICBpZiAoYm9keS5pc0R5bmFtaWMoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnRlZ3JhdGUgdmVsb2NpdGllcy5cbiAgICAgICAgICAgICAgICAgICAgdi5hZGRNdWwoaCAqIGJvZHkubV9ncmF2aXR5U2NhbGUsIGdyYXZpdHkpO1xuICAgICAgICAgICAgICAgICAgICB2LmFkZE11bChoICogYm9keS5tX2ludk1hc3MsIGJvZHkubV9mb3JjZSk7XG4gICAgICAgICAgICAgICAgICAgIHcgKz0gaCAqIGJvZHkubV9pbnZJICogYm9keS5tX3RvcnF1ZTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIDxwcmU+XG4gICAgICAgICAgICAgICAgICAgICAqIEFwcGx5IGRhbXBpbmcuXG4gICAgICAgICAgICAgICAgICAgICAqIE9ERTogZHYvZHQgKyBjICogdiA9IDBcbiAgICAgICAgICAgICAgICAgICAgICogU29sdXRpb246IHYodCkgPSB2MCAqIGV4cCgtYyAqIHQpXG4gICAgICAgICAgICAgICAgICAgICAqIFRpbWUgc3RlcDogdih0ICsgZHQpID0gdjAgKiBleHAoLWMgKiAodCArIGR0KSkgPSB2MCAqIGV4cCgtYyAqIHQpICogZXhwKC1jICogZHQpID0gdiAqIGV4cCgtYyAqIGR0KVxuICAgICAgICAgICAgICAgICAgICAgKiB2MiA9IGV4cCgtYyAqIGR0KSAqIHYxXG4gICAgICAgICAgICAgICAgICAgICAqIFBhZGUgYXBwcm94aW1hdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICogdjIgPSB2MSAqIDEgLyAoMSArIGMgKiBkdClcbiAgICAgICAgICAgICAgICAgICAgICogPC9wcmU+XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2Lm11bCgxLjAgLyAoMS4wICsgaCAqIGJvZHkubV9saW5lYXJEYW1waW5nKSk7XG4gICAgICAgICAgICAgICAgICAgIHcgKj0gMS4wIC8gKDEuMCArIGggKiBib2R5Lm1fYW5ndWxhckRhbXBpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib2R5LmNfcG9zaXRpb24uYyA9IGM7XG4gICAgICAgICAgICAgICAgYm9keS5jX3Bvc2l0aW9uLmEgPSBhO1xuICAgICAgICAgICAgICAgIGJvZHkuY192ZWxvY2l0eS52ID0gdjtcbiAgICAgICAgICAgICAgICBib2R5LmNfdmVsb2NpdHkudyA9IHc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9jb250YWN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWN0ID0gdGhpcy5tX2NvbnRhY3RzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnRhY3QuaW5pdENvbnN0cmFpbnQoc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9jb250YWN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWN0ID0gdGhpcy5tX2NvbnRhY3RzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnRhY3QuaW5pdFZlbG9jaXR5Q29uc3RyYWludChzdGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgICAgICAgIC8vIFdhcm0gc3RhcnQuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY29udGFjdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLm1fY29udGFjdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3Qud2FybVN0YXJ0Q29uc3RyYWludChzdGVwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9qb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgam9pbnQgPSB0aGlzLm1fam9pbnRzW2ldO1xuICAgICAgICAgICAgICAgIGpvaW50LmluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29sdmUgdmVsb2NpdHkgY29uc3RyYWludHNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcC52ZWxvY2l0eUl0ZXJhdGlvbnM7ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5tX2pvaW50cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgam9pbnQgPSB0aGlzLm1fam9pbnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBqb2ludC5zb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMoc3RlcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5tX2NvbnRhY3RzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWN0ID0gdGhpcy5tX2NvbnRhY3RzW2pdO1xuICAgICAgICAgICAgICAgICAgICBjb250YWN0LnNvbHZlVmVsb2NpdHlDb25zdHJhaW50KHN0ZXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3JlIGltcHVsc2VzIGZvciB3YXJtIHN0YXJ0aW5nXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9jb250YWN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWN0ID0gdGhpcy5tX2NvbnRhY3RzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnRhY3Quc3RvcmVDb25zdHJhaW50SW1wdWxzZXMoc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbnRlZ3JhdGUgcG9zaXRpb25zXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9ib2RpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IHRoaXMubV9ib2RpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBWZWMyLmNsb25lKGJvZHkuY19wb3NpdGlvbi5jKTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGJvZHkuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgICAgIHZhciB2ID0gVmVjMi5jbG9uZShib2R5LmNfdmVsb2NpdHkudik7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBib2R5LmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgbGFyZ2UgdmVsb2NpdGllc1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IFZlYzIubXVsTnVtVmVjMihoLCB2KTtcbiAgICAgICAgICAgICAgICBpZiAoVmVjMi5sZW5ndGhTcXVhcmVkKHRyYW5zbGF0aW9uKSA+IFNldHRpbmdzLm1heFRyYW5zbGF0aW9uU3F1YXJlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBTZXR0aW5ncy5tYXhUcmFuc2xhdGlvbiAvIHRyYW5zbGF0aW9uLmxlbmd0aCgpO1xuICAgICAgICAgICAgICAgICAgICB2Lm11bChyYXRpbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IGggKiB3O1xuICAgICAgICAgICAgICAgIGlmIChyb3RhdGlvbiAqIHJvdGF0aW9uID4gU2V0dGluZ3MubWF4Um90YXRpb25TcXVhcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IFNldHRpbmdzLm1heFJvdGF0aW9uIC8gbWF0aCQxLmFicyhyb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHcgKj0gcmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEludGVncmF0ZVxuICAgICAgICAgICAgICAgIGMuYWRkTXVsKGgsIHYpO1xuICAgICAgICAgICAgICAgIGEgKz0gaCAqIHc7XG4gICAgICAgICAgICAgICAgYm9keS5jX3Bvc2l0aW9uLmMuc2V0VmVjMihjKTtcbiAgICAgICAgICAgICAgICBib2R5LmNfcG9zaXRpb24uYSA9IGE7XG4gICAgICAgICAgICAgICAgYm9keS5jX3ZlbG9jaXR5LnYuc2V0VmVjMih2KTtcbiAgICAgICAgICAgICAgICBib2R5LmNfdmVsb2NpdHkudyA9IHc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb2x2ZSBwb3NpdGlvbiBjb25zdHJhaW50c1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uU29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ZXAucG9zaXRpb25JdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluU2VwYXJhdGlvbiA9IDAuMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubV9jb250YWN0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IHRoaXMubV9jb250YWN0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRpb24gPSBjb250YWN0LnNvbHZlUG9zaXRpb25Db25zdHJhaW50KHN0ZXApO1xuICAgICAgICAgICAgICAgICAgICBtaW5TZXBhcmF0aW9uID0gbWF0aCQxLm1pbihtaW5TZXBhcmF0aW9uLCBzZXBhcmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgZXhwZWN0IG1pblNwZXBhcmF0aW9uID49IC1TZXR0aW5ncy5saW5lYXJTbG9wIGJlY2F1c2Ugd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAvLyBwdXNoIHRoZSBzZXBhcmF0aW9uIGFib3ZlIC1TZXR0aW5ncy5saW5lYXJTbG9wLlxuICAgICAgICAgICAgICAgIHZhciBjb250YWN0c09rYXkgPSBtaW5TZXBhcmF0aW9uID49IC0zLjAgKiBTZXR0aW5ncy5saW5lYXJTbG9wO1xuICAgICAgICAgICAgICAgIHZhciBqb2ludHNPa2F5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubV9qb2ludHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGpvaW50ID0gdGhpcy5tX2pvaW50c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGpvaW50T2theSA9IGpvaW50LnNvbHZlUG9zaXRpb25Db25zdHJhaW50cyhzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgam9pbnRzT2theSA9IGpvaW50c09rYXkgJiYgam9pbnRPa2F5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udGFjdHNPa2F5ICYmIGpvaW50c09rYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgcG9zaXRpb24gZXJyb3JzIGFyZSBzbWFsbC5cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Tb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb3B5IHN0YXRlIGJ1ZmZlcnMgYmFjayB0byB0aGUgYm9kaWVzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9ib2RpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IHRoaXMubV9ib2RpZXNbaV07XG4gICAgICAgICAgICAgICAgYm9keS5tX3N3ZWVwLmMuc2V0VmVjMihib2R5LmNfcG9zaXRpb24uYyk7XG4gICAgICAgICAgICAgICAgYm9keS5tX3N3ZWVwLmEgPSBib2R5LmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgICAgICBib2R5Lm1fbGluZWFyVmVsb2NpdHkuc2V0VmVjMihib2R5LmNfdmVsb2NpdHkudik7XG4gICAgICAgICAgICAgICAgYm9keS5tX2FuZ3VsYXJWZWxvY2l0eSA9IGJvZHkuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgICAgIGJvZHkuc3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucG9zdFNvbHZlSXNsYW5kKCk7XG4gICAgICAgICAgICBpZiAoYWxsb3dTbGVlcCkge1xuICAgICAgICAgICAgICAgIHZhciBtaW5TbGVlcFRpbWUgPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICB2YXIgbGluVG9sU3FyID0gU2V0dGluZ3MubGluZWFyU2xlZXBUb2xlcmFuY2VTcXI7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ1RvbFNxciA9IFNldHRpbmdzLmFuZ3VsYXJTbGVlcFRvbGVyYW5jZVNxcjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9ib2RpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keS5pc1N0YXRpYygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKGJvZHkubV9hdXRvU2xlZXBGbGFnID09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGJvZHkubV9hbmd1bGFyVmVsb2NpdHkgKiBib2R5Lm1fYW5ndWxhclZlbG9jaXR5ID4gYW5nVG9sU3FyKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKFZlYzIubGVuZ3RoU3F1YXJlZChib2R5Lm1fbGluZWFyVmVsb2NpdHkpID4gbGluVG9sU3FyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5tX3NsZWVwVGltZSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblNsZWVwVGltZSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkubV9zbGVlcFRpbWUgKz0gaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblNsZWVwVGltZSA9IG1hdGgkMS5taW4obWluU2xlZXBUaW1lLCBib2R5Lm1fc2xlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWluU2xlZXBUaW1lID49IFNldHRpbmdzLnRpbWVUb1NsZWVwICYmIHBvc2l0aW9uU29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2JvZGllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5zZXRBd2FrZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5wcmludEJvZGllcyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2JvZGllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5tX2JvZGllc1tpXTtcbiAgICAgICAgICAgICAgICBjb21tb24uZGVidWcodGFnLCBiLmNfcG9zaXRpb24uYSwgYi5jX3Bvc2l0aW9uLmMueCwgYi5jX3Bvc2l0aW9uLmMueSwgYi5jX3ZlbG9jaXR5LncsIGIuY192ZWxvY2l0eS52LngsIGIuY192ZWxvY2l0eS52LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCBUT0kgY29udGFjdHMgYW5kIHNvbHZlIHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICBTb2x2ZXIucHJvdG90eXBlLnNvbHZlV29ybGRUT0kgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIHdvcmxkID0gdGhpcy5tX3dvcmxkO1xuICAgICAgICAgICAgaWYgKHdvcmxkLm1fc3RlcENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IHdvcmxkLm1fYm9keUxpc3Q7IGI7IGIgPSBiLm1fbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBiLm1faXNsYW5kRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBiLm1fc3dlZXAuYWxwaGEwID0gMC4wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gd29ybGQubV9jb250YWN0TGlzdDsgYzsgYyA9IGMubV9uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWRhdGUgVE9JXG4gICAgICAgICAgICAgICAgICAgIGMubV90b2lGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGMubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGMubV90b2lDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGMubV90b2kgPSAxLjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluZCBUT0kgZXZlbnRzIGFuZCBzb2x2ZSB0aGVtLlxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBUT0kuXG4gICAgICAgICAgICAgICAgdmFyIG1pbkNvbnRhY3QgPSBudWxsOyAvLyBDb250YWN0XG4gICAgICAgICAgICAgICAgdmFyIG1pbkFscGhhID0gMS4wO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSB3b3JsZC5tX2NvbnRhY3RMaXN0OyBjOyBjID0gYy5tX25leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXMgdGhpcyBjb250YWN0IGRpc2FibGVkP1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5pc0VuYWJsZWQoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBleGNlc3NpdmUgc3ViLXN0ZXBwaW5nLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYy5tX3RvaUNvdW50ID4gU2V0dGluZ3MubWF4U3ViU3RlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbHBoYSA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMubV90b2lGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNvbnRhY3QgaGFzIGEgdmFsaWQgY2FjaGVkIFRPSS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gYy5tX3RvaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmQV8xID0gYy5nZXRGaXh0dXJlQSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZCXzEgPSBjLmdldEZpeHR1cmVCKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGVyZSBhIHNlbnNvcj9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmQV8xLmlzU2Vuc29yKCkgfHwgZkJfMS5pc1NlbnNvcigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYkFfMSA9IGZBXzEuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJCXzEgPSBmQl8xLmdldEJvZHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmVBID0gYkFfMS5pc0F3YWtlKCkgJiYgIWJBXzEuaXNTdGF0aWMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmVCID0gYkJfMS5pc0F3YWtlKCkgJiYgIWJCXzEuaXNTdGF0aWMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElzIGF0IGxlYXN0IG9uZSBib2R5IGFjdGl2ZSAoYXdha2UgYW5kIGR5bmFtaWMgb3Iga2luZW1hdGljKT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVBID09IGZhbHNlICYmIGFjdGl2ZUIgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xsaWRlQSA9IGJBXzEuaXNCdWxsZXQoKSB8fCAhYkFfMS5pc0R5bmFtaWMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xsaWRlQiA9IGJCXzEuaXNCdWxsZXQoKSB8fCAhYkJfMS5pc0R5bmFtaWMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFyZSB0aGVzZSB0d28gbm9uLWJ1bGxldCBkeW5hbWljIGJvZGllcz9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsaWRlQSA9PSBmYWxzZSAmJiBjb2xsaWRlQiA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgVE9JIGZvciB0aGlzIGNvbnRhY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXQgdGhlIHN3ZWVwcyBvbnRvIHRoZSBzYW1lIHRpbWUgaW50ZXJ2YWwuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxwaGEwID0gYkFfMS5tX3N3ZWVwLmFscGhhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiQV8xLm1fc3dlZXAuYWxwaGEwIDwgYkJfMS5tX3N3ZWVwLmFscGhhMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMCA9IGJCXzEubV9zd2VlcC5hbHBoYTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkFfMS5tX3N3ZWVwLmFkdmFuY2UoYWxwaGEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJCXzEubV9zd2VlcC5hbHBoYTAgPCBiQV8xLm1fc3dlZXAuYWxwaGEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEwID0gYkFfMS5tX3N3ZWVwLmFscGhhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQl8xLm1fc3dlZXAuYWR2YW5jZShhbHBoYTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4QSA9IGMuZ2V0Q2hpbGRJbmRleEEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleEIgPSBjLmdldENoaWxkSW5kZXhCKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiQV8xLm1fc3dlZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBiQl8xLm1fc3dlZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSB0aW1lIG9mIGltcGFjdCBpbiBpbnRlcnZhbCBbMCwgbWluVE9JXVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gbmV3IFRPSUlucHV0KCk7IC8vIFRPRE86IHJldXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5wcm94eUEuc2V0KGZBXzEuZ2V0U2hhcGUoKSwgaW5kZXhBKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnByb3h5Qi5zZXQoZkJfMS5nZXRTaGFwZSgpLCBpbmRleEIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc3dlZXBBLnNldChiQV8xLm1fc3dlZXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc3dlZXBCLnNldChiQl8xLm1fc3dlZXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQudE1heCA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBuZXcgVE9JT3V0cHV0KCk7IC8vIFRPRE86IHJldXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBUaW1lT2ZJbXBhY3Qob3V0cHV0LCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCZXRhIGlzIHRoZSBmcmFjdGlvbiBvZiB0aGUgcmVtYWluaW5nIHBvcnRpb24gb2YgdGhlIFt0aW1lP10uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmV0YSA9IG91dHB1dC50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5zdGF0ZSA9PSBUT0lPdXRwdXRTdGF0ZS5lX3RvdWNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBtYXRoJDEubWluKGFscGhhMCArICgxLjAgLSBhbHBoYTApICogYmV0YSwgMS4wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYy5tX3RvaSA9IGFscGhhO1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5tX3RvaUZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYSA8IG1pbkFscGhhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBtaW5pbXVtIFRPSSBmb3VuZCBzbyBmYXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5Db250YWN0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkFscGhhID0gYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1pbkNvbnRhY3QgPT0gbnVsbCB8fCAxLjAgLSAxMC4wICogbWF0aCQxLkVQU0lMT04gPCBtaW5BbHBoYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBtb3JlIFRPSSBldmVudHMuIERvbmUhXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkLm1fc3RlcENvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIGJvZGllcyB0byB0aGUgVE9JLlxuICAgICAgICAgICAgICAgIHZhciBmQSA9IG1pbkNvbnRhY3QuZ2V0Rml4dHVyZUEoKTtcbiAgICAgICAgICAgICAgICB2YXIgZkIgPSBtaW5Db250YWN0LmdldEZpeHR1cmVCKCk7XG4gICAgICAgICAgICAgICAgdmFyIGJBID0gZkEuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgICAgIHZhciBiQiA9IGZCLmdldEJvZHkoKTtcbiAgICAgICAgICAgICAgICB2YXIgYmFja3VwMSA9IGJBLm1fc3dlZXAuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB2YXIgYmFja3VwMiA9IGJCLm1fc3dlZXAuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBiQS5hZHZhbmNlKG1pbkFscGhhKTtcbiAgICAgICAgICAgICAgICBiQi5hZHZhbmNlKG1pbkFscGhhKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgVE9JIGNvbnRhY3QgbGlrZWx5IGhhcyBzb21lIG5ldyBjb250YWN0IHBvaW50cy5cbiAgICAgICAgICAgICAgICBtaW5Db250YWN0LnVwZGF0ZSh3b3JsZCk7XG4gICAgICAgICAgICAgICAgbWluQ29udGFjdC5tX3RvaUZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICArK21pbkNvbnRhY3QubV90b2lDb3VudDtcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGUgY29udGFjdCBzb2xpZD9cbiAgICAgICAgICAgICAgICBpZiAobWluQ29udGFjdC5pc0VuYWJsZWQoKSA9PSBmYWxzZSB8fCBtaW5Db250YWN0LmlzVG91Y2hpbmcoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBzd2VlcHMuXG4gICAgICAgICAgICAgICAgICAgIG1pbkNvbnRhY3Quc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGJBLm1fc3dlZXAuc2V0KGJhY2t1cDEpO1xuICAgICAgICAgICAgICAgICAgICBiQi5tX3N3ZWVwLnNldChiYWNrdXAyKTtcbiAgICAgICAgICAgICAgICAgICAgYkEuc3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICAgICAgYkIuc3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJBLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgICAgIGJCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBpc2xhbmRcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCb2R5KGJBKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJvZHkoYkIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29udGFjdChtaW5Db250YWN0KTtcbiAgICAgICAgICAgICAgICBiQS5tX2lzbGFuZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJCLm1faXNsYW5kRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWluQ29udGFjdC5tX2lzbGFuZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIEdldCBjb250YWN0cyBvbiBib2R5QSBhbmQgYm9keUIuXG4gICAgICAgICAgICAgICAgdmFyIGJvZGllcyA9IFtiQSwgYkJdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keS5pc0R5bmFtaWMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY2UgPSBib2R5Lm1fY29udGFjdExpc3Q7IGNlOyBjZSA9IGNlLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5tX2JvZHlDb3VudCA9PSB0aGlzLm1fYm9keUNhcGFjaXR5KSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMubV9jb250YWN0Q291bnQgPT0gdGhpcy5tX2NvbnRhY3RDYXBhY2l0eSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250YWN0ID0gY2UuY29udGFjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYXMgdGhpcyBjb250YWN0IGFscmVhZHkgYmVlbiBhZGRlZCB0byB0aGUgaXNsYW5kP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWN0Lm1faXNsYW5kRmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGQgaWYgZWl0aGVyIGlzIHN0YXRpYywga2luZW1hdGljIG9yIGJ1bGxldC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjZS5vdGhlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXIuaXNEeW5hbWljKCkgJiYgIWJvZHkuaXNCdWxsZXQoKSAmJiAhb3RoZXIuaXNCdWxsZXQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBzZW5zb3JzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZW5zb3JBID0gY29udGFjdC5tX2ZpeHR1cmVBLm1faXNTZW5zb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbnNvckIgPSBjb250YWN0Lm1fZml4dHVyZUIubV9pc1NlbnNvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Vuc29yQSB8fCBzZW5zb3JCKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUZW50YXRpdmVseSBhZHZhbmNlIHRoZSBib2R5IHRvIHRoZSBUT0kuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhY2t1cCA9IG90aGVyLm1fc3dlZXAuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXIubV9pc2xhbmRGbGFnID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLmFkdmFuY2UobWluQWxwaGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbnRhY3QgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdC51cGRhdGUod29ybGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhcyB0aGUgY29udGFjdCBkaXNhYmxlZCBieSB0aGUgdXNlcj9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcmUgdGhlcmUgY29udGFjdCBwb2ludHM/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhY3QuaXNFbmFibGVkKCkgPT0gZmFsc2UgfHwgY29udGFjdC5pc1RvdWNoaW5nKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIubV9zd2VlcC5zZXQoYmFja3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIuc3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29udGFjdCB0byB0aGUgaXNsYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdC5tX2lzbGFuZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29udGFjdChjb250YWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYXMgdGhlIG90aGVyIGJvZHkgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoZSBpc2xhbmQ/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyLm1faXNsYW5kRmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBvdGhlciBib2R5IHRvIHRoZSBpc2xhbmQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIubV9pc2xhbmRGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyLmlzU3RhdGljKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQm9keShvdGhlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc19zdWJTdGVwLnJlc2V0KCgxLjAgLSBtaW5BbHBoYSkgKiBzdGVwLmR0KTtcbiAgICAgICAgICAgICAgICBzX3N1YlN0ZXAuZHRSYXRpbyA9IDEuMDtcbiAgICAgICAgICAgICAgICBzX3N1YlN0ZXAucG9zaXRpb25JdGVyYXRpb25zID0gMjA7XG4gICAgICAgICAgICAgICAgc19zdWJTdGVwLnZlbG9jaXR5SXRlcmF0aW9ucyA9IHN0ZXAudmVsb2NpdHlJdGVyYXRpb25zO1xuICAgICAgICAgICAgICAgIHNfc3ViU3RlcC53YXJtU3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvbHZlSXNsYW5kVE9JKHNfc3ViU3RlcCwgYkEsIGJCKTtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBpc2xhbmQgZmxhZ3MgYW5kIHN5bmNocm9uaXplIGJyb2FkLXBoYXNlIHByb3hpZXMuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fYm9kaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gdGhpcy5tX2JvZGllc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5tX2lzbGFuZEZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFib2R5LmlzRHluYW1pYygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBib2R5LnN5bmNocm9uaXplRml4dHVyZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSBhbGwgY29udGFjdCBUT0lzIG9uIHRoaXMgZGlzcGxhY2VkIGJvZHkuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNlID0gYm9keS5tX2NvbnRhY3RMaXN0OyBjZTsgY2UgPSBjZS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZS5jb250YWN0Lm1fdG9pRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2UuY29udGFjdC5tX2lzbGFuZEZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb21taXQgZml4dHVyZSBwcm94eSBtb3ZlbWVudHMgdG8gdGhlIGJyb2FkLXBoYXNlIHNvIHRoYXQgbmV3IGNvbnRhY3RzXG4gICAgICAgICAgICAgICAgLy8gYXJlIGNyZWF0ZWQuXG4gICAgICAgICAgICAgICAgLy8gQWxzbywgc29tZSBjb250YWN0cyBjYW4gYmUgZGVzdHJveWVkLlxuICAgICAgICAgICAgICAgIHdvcmxkLmZpbmROZXdDb250YWN0cygpO1xuICAgICAgICAgICAgICAgIGlmICh3b3JsZC5tX3N1YlN0ZXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmxkLm1fc3RlcENvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiLCBjOyBcbiAgICAgICAgfTtcbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5zb2x2ZUlzbGFuZFRPSSA9IGZ1bmN0aW9uIChzdWJTdGVwLCB0b2lBLCB0b2lCKSB7XG4gICAgICAgICAgICB0aGlzLm1fd29ybGQ7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBib2R5IHN0YXRlLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fYm9kaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgIGJvZHkuY19wb3NpdGlvbi5jLnNldFZlYzIoYm9keS5tX3N3ZWVwLmMpO1xuICAgICAgICAgICAgICAgIGJvZHkuY19wb3NpdGlvbi5hID0gYm9keS5tX3N3ZWVwLmE7XG4gICAgICAgICAgICAgICAgYm9keS5jX3ZlbG9jaXR5LnYuc2V0VmVjMihib2R5Lm1fbGluZWFyVmVsb2NpdHkpO1xuICAgICAgICAgICAgICAgIGJvZHkuY192ZWxvY2l0eS53ID0gYm9keS5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnRhY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLm1fY29udGFjdHNbaV07XG4gICAgICAgICAgICAgICAgY29udGFjdC5pbml0Q29uc3RyYWludChzdWJTdGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbHZlIHBvc2l0aW9uIGNvbnN0cmFpbnRzLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJTdGVwLnBvc2l0aW9uSXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pblNlcGFyYXRpb24gPSAwLjA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLm1fY29udGFjdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLm1fY29udGFjdHNbal07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0aW9uID0gY29udGFjdC5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludFRPSShzdWJTdGVwLCB0b2lBLCB0b2lCKTtcbiAgICAgICAgICAgICAgICAgICAgbWluU2VwYXJhdGlvbiA9IG1hdGgkMS5taW4obWluU2VwYXJhdGlvbiwgc2VwYXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IGV4cGVjdCBtaW5TcGVwYXJhdGlvbiA+PSAtU2V0dGluZ3MubGluZWFyU2xvcCBiZWNhdXNlIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gcHVzaCB0aGUgc2VwYXJhdGlvbiBhYm92ZSAtU2V0dGluZ3MubGluZWFyU2xvcC5cbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdHNPa2F5ID0gbWluU2VwYXJhdGlvbiA+PSAtMS41ICogU2V0dGluZ3MubGluZWFyU2xvcDtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFjdHNPa2F5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpLCBjOyBcbiAgICAgICAgICAgIC8vIExlYXAgb2YgZmFpdGggdG8gbmV3IHNhZmUgc3RhdGUuXG4gICAgICAgICAgICB0b2lBLm1fc3dlZXAuYzAuc2V0VmVjMih0b2lBLmNfcG9zaXRpb24uYyk7XG4gICAgICAgICAgICB0b2lBLm1fc3dlZXAuYTAgPSB0b2lBLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHRvaUIubV9zd2VlcC5jMC5zZXRWZWMyKHRvaUIuY19wb3NpdGlvbi5jKTtcbiAgICAgICAgICAgIHRvaUIubV9zd2VlcC5hMCA9IHRvaUIuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgLy8gTm8gd2FybSBzdGFydGluZyBpcyBuZWVkZWQgZm9yIFRPSSBldmVudHMgYmVjYXVzZSB3YXJtXG4gICAgICAgICAgICAvLyBzdGFydGluZyBpbXB1bHNlcyB3ZXJlIGFwcGxpZWQgaW4gdGhlIGRpc2NyZXRlIHNvbHZlci5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnRhY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLm1fY29udGFjdHNbaV07XG4gICAgICAgICAgICAgICAgY29udGFjdC5pbml0VmVsb2NpdHlDb25zdHJhaW50KHN1YlN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29sdmUgdmVsb2NpdHkgY29uc3RyYWludHMuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YlN0ZXAudmVsb2NpdHlJdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubV9jb250YWN0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IHRoaXMubV9jb250YWN0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdC5zb2x2ZVZlbG9jaXR5Q29uc3RyYWludChzdWJTdGVwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb24ndCBzdG9yZSB0aGUgVE9JIGNvbnRhY3QgZm9yY2VzIGZvciB3YXJtIHN0YXJ0aW5nXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXkgY2FuIGJlIHF1aXRlIGxhcmdlLlxuICAgICAgICAgICAgdmFyIGggPSBzdWJTdGVwLmR0O1xuICAgICAgICAgICAgLy8gSW50ZWdyYXRlIHBvc2l0aW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fYm9kaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBjID0gVmVjMi5jbG9uZShib2R5LmNfcG9zaXRpb24uYyk7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBib2R5LmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IFZlYzIuY2xvbmUoYm9keS5jX3ZlbG9jaXR5LnYpO1xuICAgICAgICAgICAgICAgIHZhciB3ID0gYm9keS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGxhcmdlIHZlbG9jaXRpZXNcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSBWZWMyLm11bE51bVZlYzIoaCwgdik7XG4gICAgICAgICAgICAgICAgaWYgKFZlYzIuZG90KHRyYW5zbGF0aW9uLCB0cmFuc2xhdGlvbikgPiBTZXR0aW5ncy5tYXhUcmFuc2xhdGlvblNxdWFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gU2V0dGluZ3MubWF4VHJhbnNsYXRpb24gLyB0cmFuc2xhdGlvbi5sZW5ndGgoKTtcbiAgICAgICAgICAgICAgICAgICAgdi5tdWwocmF0aW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSBoICogdztcbiAgICAgICAgICAgICAgICBpZiAocm90YXRpb24gKiByb3RhdGlvbiA+IFNldHRpbmdzLm1heFJvdGF0aW9uU3F1YXJlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBTZXR0aW5ncy5tYXhSb3RhdGlvbiAvIG1hdGgkMS5hYnMocm90YXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB3ICo9IHJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbnRlZ3JhdGVcbiAgICAgICAgICAgICAgICBjLmFkZE11bChoLCB2KTtcbiAgICAgICAgICAgICAgICBhICs9IGggKiB3O1xuICAgICAgICAgICAgICAgIGJvZHkuY19wb3NpdGlvbi5jID0gYztcbiAgICAgICAgICAgICAgICBib2R5LmNfcG9zaXRpb24uYSA9IGE7XG4gICAgICAgICAgICAgICAgYm9keS5jX3ZlbG9jaXR5LnYgPSB2O1xuICAgICAgICAgICAgICAgIGJvZHkuY192ZWxvY2l0eS53ID0gdztcbiAgICAgICAgICAgICAgICAvLyBTeW5jIGJvZGllc1xuICAgICAgICAgICAgICAgIGJvZHkubV9zd2VlcC5jID0gYztcbiAgICAgICAgICAgICAgICBib2R5Lm1fc3dlZXAuYSA9IGE7XG4gICAgICAgICAgICAgICAgYm9keS5tX2xpbmVhclZlbG9jaXR5ID0gdjtcbiAgICAgICAgICAgICAgICBib2R5Lm1fYW5ndWxhclZlbG9jaXR5ID0gdztcbiAgICAgICAgICAgICAgICBib2R5LnN5bmNocm9uaXplVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvc3RTb2x2ZUlzbGFuZCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUucG9zdFNvbHZlSXNsYW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB0aGlzLm1fY29udGFjdHMubGVuZ3RoOyArK2MpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IHRoaXMubV9jb250YWN0c1tjXTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fd29ybGQucG9zdFNvbHZlKGNvbnRhY3QsIGNvbnRhY3QubV9pbXB1bHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNvbHZlcjtcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIHZhciBXb3JsZERlZkRlZmF1bHQgPSB7XG4gICAgICAgIGdyYXZpdHk6IFZlYzIuemVybygpLFxuICAgICAgICBhbGxvd1NsZWVwOiB0cnVlLFxuICAgICAgICB3YXJtU3RhcnRpbmc6IHRydWUsXG4gICAgICAgIGNvbnRpbnVvdXNQaHlzaWNzOiB0cnVlLFxuICAgICAgICBzdWJTdGVwcGluZzogZmFsc2UsXG4gICAgICAgIGJsb2NrU29sdmU6IHRydWUsXG4gICAgICAgIHZlbG9jaXR5SXRlcmF0aW9uczogOCxcbiAgICAgICAgcG9zaXRpb25JdGVyYXRpb25zOiAzXG4gICAgfTtcbiAgICB2YXIgV29ybGQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gZGVmIFdvcmxkIGRlZmluaXRpb24gb3IgZ3Jhdml0eSB2ZWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBXb3JsZChkZWYpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLnNfc3RlcCA9IG5ldyBUaW1lU3RlcCgpOyAvLyByZXVzZVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICAgICAqIENhbGxiYWNrIGZvciBicm9hZC1waGFzZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVDb250YWN0ID0gZnVuY3Rpb24gKHByb3h5QSwgcHJveHlCKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpeHR1cmVBID0gcHJveHlBLmZpeHR1cmU7XG4gICAgICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gcHJveHlCLmZpeHR1cmU7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4QSA9IHByb3h5QS5jaGlsZEluZGV4O1xuICAgICAgICAgICAgICAgIHZhciBpbmRleEIgPSBwcm94eUIuY2hpbGRJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5nZXRCb2R5KCk7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHlCID0gZml4dHVyZUIuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgICAgIC8vIEFyZSB0aGUgZml4dHVyZXMgb24gdGhlIHNhbWUgYm9keT9cbiAgICAgICAgICAgICAgICBpZiAoYm9keUEgPT0gYm9keUIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPX0VSSU4gdXNlIGEgaGFzaCB0YWJsZSB0byByZW1vdmUgYSBwb3RlbnRpYWwgYm90dGxlbmVjayB3aGVuIGJvdGhcbiAgICAgICAgICAgICAgICAvLyBib2RpZXMgaGF2ZSBhIGxvdCBvZiBjb250YWN0cy5cbiAgICAgICAgICAgICAgICAvLyBEb2VzIGEgY29udGFjdCBhbHJlYWR5IGV4aXN0P1xuICAgICAgICAgICAgICAgIHZhciBlZGdlID0gYm9keUIuZ2V0Q29udGFjdExpc3QoKTsgLy8gQ29udGFjdEVkZ2VcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWRnZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZS5vdGhlciA9PSBib2R5QSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZBID0gZWRnZS5jb250YWN0LmdldEZpeHR1cmVBKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZkIgPSBlZGdlLmNvbnRhY3QuZ2V0Rml4dHVyZUIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpQSA9IGVkZ2UuY29udGFjdC5nZXRDaGlsZEluZGV4QSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlCID0gZWRnZS5jb250YWN0LmdldENoaWxkSW5kZXhCKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZkEgPT0gZml4dHVyZUEgJiYgZkIgPT0gZml4dHVyZUIgJiYgaUEgPT0gaW5kZXhBICYmIGlCID09IGluZGV4Qikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgY29udGFjdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZkEgPT0gZml4dHVyZUIgJiYgZkIgPT0gZml4dHVyZUEgJiYgaUEgPT0gaW5kZXhCICYmIGlCID09IGluZGV4QSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgY29udGFjdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWRnZSA9IGVkZ2UubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJvZHlCLnNob3VsZENvbGxpZGUoYm9keUEpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpeHR1cmVCLnNob3VsZENvbGxpZGUoZml4dHVyZUEpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgZmFjdG9yeS5cbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IENvbnRhY3QuY3JlYXRlKGZpeHR1cmVBLCBpbmRleEEsIGZpeHR1cmVCLCBpbmRleEIpO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWN0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgaW50byB0aGUgd29ybGQuXG4gICAgICAgICAgICAgICAgY29udGFjdC5tX3ByZXYgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5tX2NvbnRhY3RMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdC5tX25leHQgPSBfdGhpcy5tX2NvbnRhY3RMaXN0O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tX2NvbnRhY3RMaXN0Lm1fcHJldiA9IGNvbnRhY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLm1fY29udGFjdExpc3QgPSBjb250YWN0O1xuICAgICAgICAgICAgICAgICsrX3RoaXMubV9jb250YWN0Q291bnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdvcmxkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV29ybGQoZGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWYgJiYgVmVjMi5pc1ZhbGlkKGRlZikpIHtcbiAgICAgICAgICAgICAgICBkZWYgPSB7IGdyYXZpdHk6IGRlZiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmID0gb3B0aW9ucyhkZWYsIFdvcmxkRGVmRGVmYXVsdCk7XG4gICAgICAgICAgICB0aGlzLm1fc29sdmVyID0gbmV3IFNvbHZlcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubV9icm9hZFBoYXNlID0gbmV3IEJyb2FkUGhhc2UoKTtcbiAgICAgICAgICAgIHRoaXMubV9jb250YWN0TGlzdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1fY29udGFjdENvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5TGlzdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUNvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMubV9qb2ludExpc3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tX2pvaW50Q291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5tX3N0ZXBDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1fYWxsb3dTbGVlcCA9IGRlZi5hbGxvd1NsZWVwO1xuICAgICAgICAgICAgdGhpcy5tX2dyYXZpdHkgPSBWZWMyLmNsb25lKGRlZi5ncmF2aXR5KTtcbiAgICAgICAgICAgIHRoaXMubV9jbGVhckZvcmNlcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1fbmV3Rml4dHVyZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIGZvciBkZWJ1Z2dpbmcgdGhlIHNvbHZlci5cbiAgICAgICAgICAgIHRoaXMubV93YXJtU3RhcnRpbmcgPSBkZWYud2FybVN0YXJ0aW5nO1xuICAgICAgICAgICAgdGhpcy5tX2NvbnRpbnVvdXNQaHlzaWNzID0gZGVmLmNvbnRpbnVvdXNQaHlzaWNzO1xuICAgICAgICAgICAgdGhpcy5tX3N1YlN0ZXBwaW5nID0gZGVmLnN1YlN0ZXBwaW5nO1xuICAgICAgICAgICAgdGhpcy5tX2Jsb2NrU29sdmUgPSBkZWYuYmxvY2tTb2x2ZTtcbiAgICAgICAgICAgIHRoaXMubV92ZWxvY2l0eUl0ZXJhdGlvbnMgPSBkZWYudmVsb2NpdHlJdGVyYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5tX3Bvc2l0aW9uSXRlcmF0aW9ucyA9IGRlZi5wb3NpdGlvbkl0ZXJhdGlvbnM7XG4gICAgICAgICAgICB0aGlzLm1fdCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuX3NlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib2RpZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBqb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSB0aGlzLmdldEJvZHlMaXN0KCk7IGI7IGIgPSBiLmdldE5leHQoKSkge1xuICAgICAgICAgICAgICAgIGJvZGllcy5wdXNoKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHRoaXMuZ2V0Sm9pbnRMaXN0KCk7IGo7IGogPSBqLmdldE5leHQoKSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGouX3NlcmlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBqb2ludHMucHVzaChqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdyYXZpdHk6IHRoaXMubV9ncmF2aXR5LFxuICAgICAgICAgICAgICAgIGJvZGllczogYm9kaWVzLFxuICAgICAgICAgICAgICAgIGpvaW50czogam9pbnRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBXb3JsZC5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSwgY29udGV4dCwgcmVzdG9yZSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKGRhdGEuZ3Jhdml0eSk7XG4gICAgICAgICAgICBpZiAoZGF0YS5ib2RpZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZGF0YS5ib2RpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ybGQuX2FkZEJvZHkocmVzdG9yZShCb2R5LCBkYXRhLmJvZGllc1tpXSwgd29ybGQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5qb2ludHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZGF0YS5qb2ludHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgd29ybGQuY3JlYXRlSm9pbnQocmVzdG9yZShKb2ludCwgZGF0YS5qb2ludHNbaV0sIHdvcmxkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdvcmxkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB3b3JsZCBib2R5IGxpc3QuIFdpdGggdGhlIHJldHVybmVkIGJvZHksIHVzZSBCb2R5LmdldE5leHQgdG8gZ2V0IHRoZVxuICAgICAgICAgKiBuZXh0IGJvZHkgaW4gdGhlIHdvcmxkIGxpc3QuIEEgbnVsbCBib2R5IGluZGljYXRlcyB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBoZWFkIG9mIHRoZSB3b3JsZCBib2R5IGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZ2V0Qm9keUxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlMaXN0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB3b3JsZCBqb2ludCBsaXN0LiBXaXRoIHRoZSByZXR1cm5lZCBqb2ludCwgdXNlIEpvaW50LmdldE5leHQgdG8gZ2V0XG4gICAgICAgICAqIHRoZSBuZXh0IGpvaW50IGluIHRoZSB3b3JsZCBsaXN0LiBBIG51bGwgam9pbnQgaW5kaWNhdGVzIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdGhlIGhlYWQgb2YgdGhlIHdvcmxkIGpvaW50IGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZ2V0Sm9pbnRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9qb2ludExpc3Q7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHdvcmxkIGNvbnRhY3QgbGlzdC4gV2l0aCB0aGUgcmV0dXJuZWQgY29udGFjdCwgdXNlIENvbnRhY3QuZ2V0TmV4dCB0b1xuICAgICAgICAgKiBnZXQgdGhlIG5leHQgY29udGFjdCBpbiB0aGUgd29ybGQgbGlzdC4gQSBudWxsIGNvbnRhY3QgaW5kaWNhdGVzIHRoZSBlbmQgb2ZcbiAgICAgICAgICogdGhlIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdhcm5pbmc6IGNvbnRhY3RzIGFyZSBjcmVhdGVkIGFuZCBkZXN0cm95ZWQgaW4gdGhlIG1pZGRsZSBvZiBhIHRpbWUgc3RlcC5cbiAgICAgICAgICogVXNlIENvbnRhY3RMaXN0ZW5lciB0byBhdm9pZCBtaXNzaW5nIGNvbnRhY3RzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBoZWFkIG9mIHRoZSB3b3JsZCBjb250YWN0IGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZ2V0Q29udGFjdExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2NvbnRhY3RMaXN0O1xuICAgICAgICB9O1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZ2V0Qm9keUNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Q291bnQ7XG4gICAgICAgIH07XG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5nZXRKb2ludENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9qb2ludENvdW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBudW1iZXIgb2YgY29udGFjdHMgKGVhY2ggbWF5IGhhdmUgMCBvciBtb3JlIGNvbnRhY3QgcG9pbnRzKS5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5nZXRDb250YWN0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2NvbnRhY3RDb3VudDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYW5nZSB0aGUgZ2xvYmFsIGdyYXZpdHkgdmVjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLnNldEdyYXZpdHkgPSBmdW5jdGlvbiAoZ3Jhdml0eSkge1xuICAgICAgICAgICAgdGhpcy5tX2dyYXZpdHkgPSBncmF2aXR5O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBnbG9iYWwgZ3Jhdml0eSB2ZWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZ2V0R3Jhdml0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fZ3Jhdml0eTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSB3b3JsZCBsb2NrZWQgKGluIHRoZSBtaWRkbGUgb2YgYSB0aW1lIHN0ZXApLlxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLmlzTG9ja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sb2NrZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGUvZGlzYWJsZSBzbGVlcC5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5zZXRBbGxvd1NsZWVwaW5nID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgICAgIGlmIChmbGFnID09IHRoaXMubV9hbGxvd1NsZWVwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2FsbG93U2xlZXAgPSBmbGFnO1xuICAgICAgICAgICAgaWYgKHRoaXMubV9hbGxvd1NsZWVwID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IHRoaXMubV9ib2R5TGlzdDsgYjsgYiA9IGIubV9uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZ2V0QWxsb3dTbGVlcGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYWxsb3dTbGVlcDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZS9kaXNhYmxlIHdhcm0gc3RhcnRpbmcuIEZvciB0ZXN0aW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLnNldFdhcm1TdGFydGluZyA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICB0aGlzLm1fd2FybVN0YXJ0aW5nID0gZmxhZztcbiAgICAgICAgfTtcbiAgICAgICAgV29ybGQucHJvdG90eXBlLmdldFdhcm1TdGFydGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fd2FybVN0YXJ0aW5nO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlL2Rpc2FibGUgY29udGludW91cyBwaHlzaWNzLiBGb3IgdGVzdGluZy5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5zZXRDb250aW51b3VzUGh5c2ljcyA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICB0aGlzLm1fY29udGludW91c1BoeXNpY3MgPSBmbGFnO1xuICAgICAgICB9O1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZ2V0Q29udGludW91c1BoeXNpY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2NvbnRpbnVvdXNQaHlzaWNzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlL2Rpc2FibGUgc2luZ2xlIHN0ZXBwZWQgY29udGludW91cyBwaHlzaWNzLiBGb3IgdGVzdGluZy5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5zZXRTdWJTdGVwcGluZyA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICB0aGlzLm1fc3ViU3RlcHBpbmcgPSBmbGFnO1xuICAgICAgICB9O1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZ2V0U3ViU3RlcHBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3N1YlN0ZXBwaW5nO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGZsYWcgdG8gY29udHJvbCBhdXRvbWF0aWMgY2xlYXJpbmcgb2YgZm9yY2VzIGFmdGVyIGVhY2ggdGltZSBzdGVwLlxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLnNldEF1dG9DbGVhckZvcmNlcyA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICB0aGlzLm1fY2xlYXJGb3JjZXMgPSBmbGFnO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmbGFnIHRoYXQgY29udHJvbHMgYXV0b21hdGljIGNsZWFyaW5nIG9mIGZvcmNlcyBhZnRlciBlYWNoIHRpbWUgc3RlcC5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5nZXRBdXRvQ2xlYXJGb3JjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2NsZWFyRm9yY2VzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFudWFsbHkgY2xlYXIgdGhlIGZvcmNlIGJ1ZmZlciBvbiBhbGwgYm9kaWVzLiBCeSBkZWZhdWx0LCBmb3JjZXMgYXJlIGNsZWFyZWRcbiAgICAgICAgICogYXV0b21hdGljYWxseSBhZnRlciBlYWNoIGNhbGwgdG8gc3RlcC4gVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgbW9kaWZpZWQgYnlcbiAgICAgICAgICogY2FsbGluZyBzZXRBdXRvQ2xlYXJGb3JjZXMuIFRoZSBwdXJwb3NlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdG8gc3VwcG9ydFxuICAgICAgICAgKiBzdWItc3RlcHBpbmcuIFN1Yi1zdGVwcGluZyBpcyBvZnRlbiB1c2VkIHRvIG1haW50YWluIGEgZml4ZWQgc2l6ZWQgdGltZSBzdGVwXG4gICAgICAgICAqIHVuZGVyIGEgdmFyaWFibGUgZnJhbWUtcmF0ZS4gV2hlbiB5b3UgcGVyZm9ybSBzdWItc3RlcHBpbmcgeW91IHdpbGwgZGlzYWJsZVxuICAgICAgICAgKiBhdXRvIGNsZWFyaW5nIG9mIGZvcmNlcyBhbmQgaW5zdGVhZCBjYWxsIGNsZWFyRm9yY2VzIGFmdGVyIGFsbCBzdWItc3RlcHMgYXJlXG4gICAgICAgICAqIGNvbXBsZXRlIGluIG9uZSBwYXNzIG9mIHlvdXIgZ2FtZSBsb29wLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUge0BsaW5rIFdvcmxkLnNldEF1dG9DbGVhckZvcmNlc31cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5jbGVhckZvcmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGJvZHkgPSB0aGlzLm1fYm9keUxpc3Q7IGJvZHk7IGJvZHkgPSBib2R5LmdldE5leHQoKSkge1xuICAgICAgICAgICAgICAgIGJvZHkubV9mb3JjZS5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgYm9keS5tX3RvcnF1ZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFF1ZXJ5IHRoZSB3b3JsZCBmb3IgYWxsIGZpeHR1cmVzIHRoYXQgcG90ZW50aWFsbHkgb3ZlcmxhcCB0aGUgcHJvdmlkZWQgQUFCQi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGFhYmIgVGhlIHF1ZXJ5IGJveC5cbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIENhbGxlZCBmb3IgZWFjaCBmaXh0dXJlIGZvdW5kIGluIHRoZSBxdWVyeSBBQUJCLiBJdCBtYXkgcmV0dXJuIGBmYWxzZWAgdG8gdGVybWluYXRlIHRoZSBxdWVyeS5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5xdWVyeUFBQkIgPSBmdW5jdGlvbiAoYWFiYiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBicm9hZFBoYXNlID0gdGhpcy5tX2Jyb2FkUGhhc2U7XG4gICAgICAgICAgICB0aGlzLm1fYnJvYWRQaGFzZS5xdWVyeShhYWJiLCBmdW5jdGlvbiAocHJveHlJZCkge1xuICAgICAgICAgICAgICAgIHZhciBwcm94eSA9IGJyb2FkUGhhc2UuZ2V0VXNlckRhdGEocHJveHlJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHByb3h5LmZpeHR1cmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSYXktY2FzdCB0aGUgd29ybGQgZm9yIGFsbCBmaXh0dXJlcyBpbiB0aGUgcGF0aCBvZiB0aGUgcmF5LiBZb3VyIGNhbGxiYWNrXG4gICAgICAgICAqIGNvbnRyb2xzIHdoZXRoZXIgeW91IGdldCB0aGUgY2xvc2VzdCBwb2ludCwgYW55IHBvaW50LCBvciBuLXBvaW50cy4gVGhlXG4gICAgICAgICAqIHJheS1jYXN0IGlnbm9yZXMgc2hhcGVzIHRoYXQgY29udGFpbiB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwb2ludDEgVGhlIHJheSBzdGFydGluZyBwb2ludFxuICAgICAgICAgKiBAcGFyYW0gcG9pbnQyIFRoZSByYXkgZW5kaW5nIHBvaW50XG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayBBIHVzZXIgaW1wbGVtZW50ZWQgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uIChwb2ludDEsIHBvaW50MiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBicm9hZFBoYXNlID0gdGhpcy5tX2Jyb2FkUGhhc2U7XG4gICAgICAgICAgICB0aGlzLm1fYnJvYWRQaGFzZS5yYXlDYXN0KHtcbiAgICAgICAgICAgICAgICBtYXhGcmFjdGlvbjogMS4wLFxuICAgICAgICAgICAgICAgIHAxOiBwb2ludDEsXG4gICAgICAgICAgICAgICAgcDI6IHBvaW50MlxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGlucHV0LCBwcm94eUlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3h5ID0gYnJvYWRQaGFzZS5nZXRVc2VyRGF0YShwcm94eUlkKTtcbiAgICAgICAgICAgICAgICB2YXIgZml4dHVyZSA9IHByb3h5LmZpeHR1cmU7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcHJveHkuY2hpbGRJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IHt9OyAvLyBUT0RPIEdDXG4gICAgICAgICAgICAgICAgdmFyIGhpdCA9IGZpeHR1cmUucmF5Q2FzdChvdXRwdXQsIGlucHV0LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhY3Rpb24gPSBvdXRwdXQuZnJhY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IFZlYzIuYWRkKFZlYzIubXVsTnVtVmVjMigoMS4wIC0gZnJhY3Rpb24pLCBpbnB1dC5wMSksIFZlYzIubXVsTnVtVmVjMihmcmFjdGlvbiwgaW5wdXQucDIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGZpeHR1cmUsIHBvaW50LCBvdXRwdXQubm9ybWFsLCBmcmFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dC5tYXhGcmFjdGlvbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBudW1iZXIgb2YgYnJvYWQtcGhhc2UgcHJveGllcy5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5nZXRQcm94eUNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9icm9hZFBoYXNlLmdldFByb3h5Q291bnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgaGVpZ2h0IG9mIGJyb2FkLXBoYXNlIGR5bmFtaWMgdHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5nZXRUcmVlSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9icm9hZFBoYXNlLmdldFRyZWVIZWlnaHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYmFsYW5jZSBvZiBicm9hZC1waGFzZSBkeW5hbWljIHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZ2V0VHJlZUJhbGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2Jyb2FkUGhhc2UuZ2V0VHJlZUJhbGFuY2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcXVhbGl0eSBtZXRyaWMgb2YgYnJvYWQtcGhhc2UgZHluYW1pYyB0cmVlLiBUaGUgc21hbGxlciB0aGUgYmV0dGVyLlxuICAgICAgICAgKiBUaGUgbWluaW11bSBpcyAxLlxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLmdldFRyZWVRdWFsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9icm9hZFBoYXNlLmdldFRyZWVRdWFsaXR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaGlmdCB0aGUgd29ybGQgb3JpZ2luLiBVc2VmdWwgZm9yIGxhcmdlIHdvcmxkcy4gVGhlIGJvZHkgc2hpZnQgZm9ybXVsYSBpczpcbiAgICAgICAgICogcG9zaXRpb24gLT0gbmV3T3JpZ2luXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuZXdPcmlnaW4gVGhlIG5ldyBvcmlnaW4gd2l0aCByZXNwZWN0IHRvIHRoZSBvbGQgb3JpZ2luXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuc2hpZnRPcmlnaW4gPSBmdW5jdGlvbiAobmV3T3JpZ2luKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2xvY2tlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGIgPSB0aGlzLm1fYm9keUxpc3Q7IGI7IGIgPSBiLm1fbmV4dCkge1xuICAgICAgICAgICAgICAgIGIubV94Zi5wLnN1YihuZXdPcmlnaW4pO1xuICAgICAgICAgICAgICAgIGIubV9zd2VlcC5jMC5zdWIobmV3T3JpZ2luKTtcbiAgICAgICAgICAgICAgICBiLm1fc3dlZXAuYy5zdWIobmV3T3JpZ2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSB0aGlzLm1fam9pbnRMaXN0OyBqOyBqID0gai5tX25leHQpIHtcbiAgICAgICAgICAgICAgICBqLnNoaWZ0T3JpZ2luKG5ld09yaWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYnJvYWRQaGFzZS5zaGlmdE9yaWdpbihuZXdPcmlnaW4pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsIFVzZWQgZm9yIGRlc2VyaWFsaXplLlxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLl9hZGRCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdG8gd29ybGQgZG91Ymx5IGxpbmtlZCBsaXN0LlxuICAgICAgICAgICAgYm9keS5tX3ByZXYgPSBudWxsO1xuICAgICAgICAgICAgYm9keS5tX25leHQgPSB0aGlzLm1fYm9keUxpc3Q7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2JvZHlMaXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JvZHlMaXN0Lm1fcHJldiA9IGJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUxpc3QgPSBib2R5O1xuICAgICAgICAgICAgKyt0aGlzLm1fYm9keUNvdW50O1xuICAgICAgICB9O1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHlwZWRlZlxuICAgICAgICBXb3JsZC5wcm90b3R5cGUuY3JlYXRlQm9keSA9IGZ1bmN0aW9uIChhcmcxLCBhcmcyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVmID0ge307XG4gICAgICAgICAgICBpZiAoIWFyZzEpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKFZlYzIuaXNWYWxpZChhcmcxKSkge1xuICAgICAgICAgICAgICAgIGRlZiA9IHsgcG9zaXRpb246IGFyZzEsIGFuZ2xlOiBhcmcyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBkZWYgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh0aGlzLCBkZWYpO1xuICAgICAgICAgICAgdGhpcy5fYWRkQm9keShib2R5KTtcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9O1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHlwZWRlZlxuICAgICAgICBXb3JsZC5wcm90b3R5cGUuY3JlYXRlRHluYW1pY0JvZHkgPSBmdW5jdGlvbiAoYXJnMSwgYXJnMikge1xuICAgICAgICAgICAgdmFyIGRlZiA9IHt9O1xuICAgICAgICAgICAgaWYgKCFhcmcxKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChWZWMyLmlzVmFsaWQoYXJnMSkpIHtcbiAgICAgICAgICAgICAgICBkZWYgPSB7IHBvc2l0aW9uOiBhcmcxLCBhbmdsZTogYXJnMiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZGVmID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZi50eXBlID0gJ2R5bmFtaWMnO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQm9keShkZWYpO1xuICAgICAgICB9O1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHlwZWRlZlxuICAgICAgICBXb3JsZC5wcm90b3R5cGUuY3JlYXRlS2luZW1hdGljQm9keSA9IGZ1bmN0aW9uIChhcmcxLCBhcmcyKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0ge307XG4gICAgICAgICAgICBpZiAoIWFyZzEpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKFZlYzIuaXNWYWxpZChhcmcxKSkge1xuICAgICAgICAgICAgICAgIGRlZiA9IHsgcG9zaXRpb246IGFyZzEsIGFuZ2xlOiBhcmcyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBkZWYgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmLnR5cGUgPSAna2luZW1hdGljJztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUJvZHkoZGVmKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3kgYSByaWdpZCBib2R5IGdpdmVuIGEgZGVmaW5pdGlvbi4gTm8gcmVmZXJlbmNlIHRvIHRoZSBkZWZpbml0aW9uIGlzXG4gICAgICAgICAqIHJldGFpbmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXYXJuaW5nOiBUaGlzIGF1dG9tYXRpY2FsbHkgZGVsZXRlcyBhbGwgYXNzb2NpYXRlZCBzaGFwZXMgYW5kIGpvaW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogV2FybmluZzogVGhpcyBmdW5jdGlvbiBpcyBsb2NrZWQgZHVyaW5nIGNhbGxiYWNrcy5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5kZXN0cm95Qm9keSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIubV9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWxldGUgdGhlIGF0dGFjaGVkIGpvaW50cy5cbiAgICAgICAgICAgIHZhciBqZSA9IGIubV9qb2ludExpc3Q7XG4gICAgICAgICAgICB3aGlsZSAoamUpIHtcbiAgICAgICAgICAgICAgICB2YXIgamUwID0gamU7XG4gICAgICAgICAgICAgICAgamUgPSBqZS5uZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCgncmVtb3ZlLWpvaW50JywgamUwLmpvaW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lKb2ludChqZTAuam9pbnQpO1xuICAgICAgICAgICAgICAgIGIubV9qb2ludExpc3QgPSBqZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIubV9qb2ludExpc3QgPSBudWxsO1xuICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBhdHRhY2hlZCBjb250YWN0cy5cbiAgICAgICAgICAgIHZhciBjZSA9IGIubV9jb250YWN0TGlzdDtcbiAgICAgICAgICAgIHdoaWxlIChjZSkge1xuICAgICAgICAgICAgICAgIHZhciBjZTAgPSBjZTtcbiAgICAgICAgICAgICAgICBjZSA9IGNlLm5leHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95Q29udGFjdChjZTAuY29udGFjdCk7XG4gICAgICAgICAgICAgICAgYi5tX2NvbnRhY3RMaXN0ID0gY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLm1fY29udGFjdExpc3QgPSBudWxsO1xuICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBhdHRhY2hlZCBmaXh0dXJlcy4gVGhpcyBkZXN0cm95cyBicm9hZC1waGFzZSBwcm94aWVzLlxuICAgICAgICAgICAgdmFyIGYgPSBiLm1fZml4dHVyZUxpc3Q7XG4gICAgICAgICAgICB3aGlsZSAoZikge1xuICAgICAgICAgICAgICAgIHZhciBmMCA9IGY7XG4gICAgICAgICAgICAgICAgZiA9IGYubV9uZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCgncmVtb3ZlLWZpeHR1cmUnLCBmMCk7XG4gICAgICAgICAgICAgICAgZjAuZGVzdHJveVByb3hpZXModGhpcy5tX2Jyb2FkUGhhc2UpO1xuICAgICAgICAgICAgICAgIGIubV9maXh0dXJlTGlzdCA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLm1fZml4dHVyZUxpc3QgPSBudWxsO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHdvcmxkIGJvZHkgbGlzdC5cbiAgICAgICAgICAgIGlmIChiLm1fcHJldikge1xuICAgICAgICAgICAgICAgIGIubV9wcmV2Lm1fbmV4dCA9IGIubV9uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIubV9uZXh0KSB7XG4gICAgICAgICAgICAgICAgYi5tX25leHQubV9wcmV2ID0gYi5tX3ByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiA9PSB0aGlzLm1fYm9keUxpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYm9keUxpc3QgPSBiLm1fbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIubV9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAgICAgLS10aGlzLm1fYm9keUNvdW50O1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKCdyZW1vdmUtYm9keScsIGIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBqb2ludCB0byBjb25zdHJhaW4gYm9kaWVzIHRvZ2V0aGVyLiBObyByZWZlcmVuY2UgdG8gdGhlIGRlZmluaXRpb25cbiAgICAgICAgICogaXMgcmV0YWluZWQuIFRoaXMgbWF5IGNhdXNlIHRoZSBjb25uZWN0ZWQgYm9kaWVzIHRvIGNlYXNlIGNvbGxpZGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogV2FybmluZzogVGhpcyBmdW5jdGlvbiBpcyBsb2NrZWQgZHVyaW5nIGNhbGxiYWNrcy5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5jcmVhdGVKb2ludCA9IGZ1bmN0aW9uIChqb2ludCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29ubmVjdCB0byB0aGUgd29ybGQgbGlzdC5cbiAgICAgICAgICAgIGpvaW50Lm1fcHJldiA9IG51bGw7XG4gICAgICAgICAgICBqb2ludC5tX25leHQgPSB0aGlzLm1fam9pbnRMaXN0O1xuICAgICAgICAgICAgaWYgKHRoaXMubV9qb2ludExpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fam9pbnRMaXN0Lm1fcHJldiA9IGpvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2pvaW50TGlzdCA9IGpvaW50O1xuICAgICAgICAgICAgKyt0aGlzLm1fam9pbnRDb3VudDtcbiAgICAgICAgICAgIC8vIENvbm5lY3QgdG8gdGhlIGJvZGllcycgZG91Ymx5IGxpbmtlZCBsaXN0cy5cbiAgICAgICAgICAgIGpvaW50Lm1fZWRnZUEuam9pbnQgPSBqb2ludDtcbiAgICAgICAgICAgIGpvaW50Lm1fZWRnZUEub3RoZXIgPSBqb2ludC5tX2JvZHlCO1xuICAgICAgICAgICAgam9pbnQubV9lZGdlQS5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIGpvaW50Lm1fZWRnZUEubmV4dCA9IGpvaW50Lm1fYm9keUEubV9qb2ludExpc3Q7XG4gICAgICAgICAgICBpZiAoam9pbnQubV9ib2R5QS5tX2pvaW50TGlzdClcbiAgICAgICAgICAgICAgICBqb2ludC5tX2JvZHlBLm1fam9pbnRMaXN0LnByZXYgPSBqb2ludC5tX2VkZ2VBO1xuICAgICAgICAgICAgam9pbnQubV9ib2R5QS5tX2pvaW50TGlzdCA9IGpvaW50Lm1fZWRnZUE7XG4gICAgICAgICAgICBqb2ludC5tX2VkZ2VCLmpvaW50ID0gam9pbnQ7XG4gICAgICAgICAgICBqb2ludC5tX2VkZ2VCLm90aGVyID0gam9pbnQubV9ib2R5QTtcbiAgICAgICAgICAgIGpvaW50Lm1fZWRnZUIucHJldiA9IG51bGw7XG4gICAgICAgICAgICBqb2ludC5tX2VkZ2VCLm5leHQgPSBqb2ludC5tX2JvZHlCLm1fam9pbnRMaXN0O1xuICAgICAgICAgICAgaWYgKGpvaW50Lm1fYm9keUIubV9qb2ludExpc3QpXG4gICAgICAgICAgICAgICAgam9pbnQubV9ib2R5Qi5tX2pvaW50TGlzdC5wcmV2ID0gam9pbnQubV9lZGdlQjtcbiAgICAgICAgICAgIGpvaW50Lm1fYm9keUIubV9qb2ludExpc3QgPSBqb2ludC5tX2VkZ2VCO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGpvaW50IHByZXZlbnRzIGNvbGxpc2lvbnMsIHRoZW4gZmxhZyBhbnkgY29udGFjdHMgZm9yIGZpbHRlcmluZy5cbiAgICAgICAgICAgIGlmIChqb2ludC5tX2NvbGxpZGVDb25uZWN0ZWQgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlZGdlID0gam9pbnQubV9ib2R5Qi5nZXRDb250YWN0TGlzdCgpOyBlZGdlOyBlZGdlID0gZWRnZS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGdlLm90aGVyID09IGpvaW50Lm1fYm9keUEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsYWcgdGhlIGNvbnRhY3QgZm9yIGZpbHRlcmluZyBhdCB0aGUgbmV4dCB0aW1lIHN0ZXAgKHdoZXJlIGVpdGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm9keSBpcyBhd2FrZSkuXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlLmNvbnRhY3QuZmxhZ0ZvckZpbHRlcmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90ZTogY3JlYXRpbmcgYSBqb2ludCBkb2Vzbid0IHdha2UgdGhlIGJvZGllcy5cbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3kgYSBqb2ludC4gVGhpcyBtYXkgY2F1c2UgdGhlIGNvbm5lY3RlZCBib2RpZXMgdG8gYmVnaW4gY29sbGlkaW5nLlxuICAgICAgICAgKiBXYXJuaW5nOiBUaGlzIGZ1bmN0aW9uIGlzIGxvY2tlZCBkdXJpbmcgY2FsbGJhY2tzLlxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLmRlc3Ryb3lKb2ludCA9IGZ1bmN0aW9uIChqb2ludCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBkb3VibHkgbGlua2VkIGxpc3QuXG4gICAgICAgICAgICBpZiAoam9pbnQubV9wcmV2KSB7XG4gICAgICAgICAgICAgICAgam9pbnQubV9wcmV2Lm1fbmV4dCA9IGpvaW50Lm1fbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqb2ludC5tX25leHQpIHtcbiAgICAgICAgICAgICAgICBqb2ludC5tX25leHQubV9wcmV2ID0gam9pbnQubV9wcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpvaW50ID09IHRoaXMubV9qb2ludExpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fam9pbnRMaXN0ID0gam9pbnQubV9uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGlzY29ubmVjdCBmcm9tIGJvZGllcy5cbiAgICAgICAgICAgIHZhciBib2R5QSA9IGpvaW50Lm1fYm9keUE7XG4gICAgICAgICAgICB2YXIgYm9keUIgPSBqb2ludC5tX2JvZHlCO1xuICAgICAgICAgICAgLy8gV2FrZSB1cCBjb25uZWN0ZWQgYm9kaWVzLlxuICAgICAgICAgICAgYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICBib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGJvZHkgMS5cbiAgICAgICAgICAgIGlmIChqb2ludC5tX2VkZ2VBLnByZXYpIHtcbiAgICAgICAgICAgICAgICBqb2ludC5tX2VkZ2VBLnByZXYubmV4dCA9IGpvaW50Lm1fZWRnZUEubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqb2ludC5tX2VkZ2VBLm5leHQpIHtcbiAgICAgICAgICAgICAgICBqb2ludC5tX2VkZ2VBLm5leHQucHJldiA9IGpvaW50Lm1fZWRnZUEucHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqb2ludC5tX2VkZ2VBID09IGJvZHlBLm1fam9pbnRMaXN0KSB7XG4gICAgICAgICAgICAgICAgYm9keUEubV9qb2ludExpc3QgPSBqb2ludC5tX2VkZ2VBLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqb2ludC5tX2VkZ2VBLnByZXYgPSBudWxsO1xuICAgICAgICAgICAgam9pbnQubV9lZGdlQS5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGJvZHkgMlxuICAgICAgICAgICAgaWYgKGpvaW50Lm1fZWRnZUIucHJldikge1xuICAgICAgICAgICAgICAgIGpvaW50Lm1fZWRnZUIucHJldi5uZXh0ID0gam9pbnQubV9lZGdlQi5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpvaW50Lm1fZWRnZUIubmV4dCkge1xuICAgICAgICAgICAgICAgIGpvaW50Lm1fZWRnZUIubmV4dC5wcmV2ID0gam9pbnQubV9lZGdlQi5wcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpvaW50Lm1fZWRnZUIgPT0gYm9keUIubV9qb2ludExpc3QpIHtcbiAgICAgICAgICAgICAgICBib2R5Qi5tX2pvaW50TGlzdCA9IGpvaW50Lm1fZWRnZUIubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpvaW50Lm1fZWRnZUIucHJldiA9IG51bGw7XG4gICAgICAgICAgICBqb2ludC5tX2VkZ2VCLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgLS10aGlzLm1fam9pbnRDb3VudDtcbiAgICAgICAgICAgIC8vIElmIHRoZSBqb2ludCBwcmV2ZW50cyBjb2xsaXNpb25zLCB0aGVuIGZsYWcgYW55IGNvbnRhY3RzIGZvciBmaWx0ZXJpbmcuXG4gICAgICAgICAgICBpZiAoam9pbnQubV9jb2xsaWRlQ29ubmVjdGVkID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBib2R5Qi5nZXRDb250YWN0TGlzdCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGdlLm90aGVyID09IGJvZHlBKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGbGFnIHRoZSBjb250YWN0IGZvciBmaWx0ZXJpbmcgYXQgdGhlIG5leHQgdGltZSBzdGVwICh3aGVyZSBlaXRoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvZHkgaXMgYXdha2UpLlxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZS5jb250YWN0LmZsYWdGb3JGaWx0ZXJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlZGdlID0gZWRnZS5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVibGlzaCgncmVtb3ZlLWpvaW50Jywgam9pbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZSBhIHRpbWUgc3RlcC4gVGhpcyBwZXJmb3JtcyBjb2xsaXNpb24gZGV0ZWN0aW9uLCBpbnRlZ3JhdGlvbiwgYW5kXG4gICAgICAgICAqIGNvbnN0cmFpbnQgc29sdXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEJyb2FkLXBoYXNlLCBuYXJyb3ctcGhhc2UsIHNvbHZlIGFuZCBzb2x2ZSB0aW1lIG9mIGltcGFjdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0aW1lU3RlcCBUaW1lIHN0ZXAsIHRoaXMgc2hvdWxkIG5vdCB2YXJ5LlxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiAodGltZVN0ZXAsIHZlbG9jaXR5SXRlcmF0aW9ucywgcG9zaXRpb25JdGVyYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2goJ3ByZS1zdGVwJywgdGltZVN0ZXApO1xuICAgICAgICAgICAgaWYgKCh2ZWxvY2l0eUl0ZXJhdGlvbnMgfCAwKSAhPT0gdmVsb2NpdHlJdGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgaW4gZnV0dXJlXG4gICAgICAgICAgICAgICAgdmVsb2NpdHlJdGVyYXRpb25zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZlbG9jaXR5SXRlcmF0aW9ucyA9IHZlbG9jaXR5SXRlcmF0aW9ucyB8fCB0aGlzLm1fdmVsb2NpdHlJdGVyYXRpb25zO1xuICAgICAgICAgICAgcG9zaXRpb25JdGVyYXRpb25zID0gcG9zaXRpb25JdGVyYXRpb25zIHx8IHRoaXMubV9wb3NpdGlvbkl0ZXJhdGlvbnM7XG4gICAgICAgICAgICAvLyBJZiBuZXcgZml4dHVyZXMgd2VyZSBhZGRlZCwgd2UgbmVlZCB0byBmaW5kIHRoZSBuZXcgY29udGFjdHMuXG4gICAgICAgICAgICBpZiAodGhpcy5tX25ld0ZpeHR1cmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmROZXdDb250YWN0cygpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9uZXdGaXh0dXJlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc19zdGVwLnJlc2V0KHRpbWVTdGVwKTtcbiAgICAgICAgICAgIHRoaXMuc19zdGVwLnZlbG9jaXR5SXRlcmF0aW9ucyA9IHZlbG9jaXR5SXRlcmF0aW9ucztcbiAgICAgICAgICAgIHRoaXMuc19zdGVwLnBvc2l0aW9uSXRlcmF0aW9ucyA9IHBvc2l0aW9uSXRlcmF0aW9ucztcbiAgICAgICAgICAgIHRoaXMuc19zdGVwLndhcm1TdGFydGluZyA9IHRoaXMubV93YXJtU3RhcnRpbmc7XG4gICAgICAgICAgICB0aGlzLnNfc3RlcC5ibG9ja1NvbHZlID0gdGhpcy5tX2Jsb2NrU29sdmU7XG4gICAgICAgICAgICAvLyBVcGRhdGUgY29udGFjdHMuIFRoaXMgaXMgd2hlcmUgc29tZSBjb250YWN0cyBhcmUgZGVzdHJveWVkLlxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250YWN0cygpO1xuICAgICAgICAgICAgLy8gSW50ZWdyYXRlIHZlbG9jaXRpZXMsIHNvbHZlIHZlbG9jaXR5IGNvbnN0cmFpbnRzLCBhbmQgaW50ZWdyYXRlIHBvc2l0aW9ucy5cbiAgICAgICAgICAgIGlmICh0aGlzLm1fc3RlcENvbXBsZXRlICYmIHRpbWVTdGVwID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3NvbHZlci5zb2x2ZVdvcmxkKHRoaXMuc19zdGVwKTtcbiAgICAgICAgICAgICAgICAvLyBTeW5jaHJvbml6ZSBmaXh0dXJlcywgY2hlY2sgZm9yIG91dCBvZiByYW5nZSBib2RpZXMuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IHRoaXMubV9ib2R5TGlzdDsgYjsgYiA9IGIuZ2V0TmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgYm9keSB3YXMgbm90IGluIGFuIGlzbGFuZCB0aGVuIGl0IGRpZCBub3QgbW92ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGIubV9pc2xhbmRGbGFnID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYi5pc1N0YXRpYygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZml4dHVyZXMgKGZvciBicm9hZC1waGFzZSkuXG4gICAgICAgICAgICAgICAgICAgIGIuc3luY2hyb25pemVGaXh0dXJlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMb29rIGZvciBuZXcgY29udGFjdHMuXG4gICAgICAgICAgICAgICAgdGhpcy5maW5kTmV3Q29udGFjdHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmRsZSBUT0kgZXZlbnRzLlxuICAgICAgICAgICAgaWYgKHRoaXMubV9jb250aW51b3VzUGh5c2ljcyAmJiB0aW1lU3RlcCA+IDAuMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9zb2x2ZXIuc29sdmVXb3JsZFRPSSh0aGlzLnNfc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tX2NsZWFyRm9yY2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckZvcmNlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2xvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKCdwb3N0LXN0ZXAnLCB0aW1lU3RlcCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQ2FsbCB0aGlzIG1ldGhvZCB0byBmaW5kIG5ldyBjb250YWN0cy5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5maW5kTmV3Q29udGFjdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm1fYnJvYWRQaGFzZS51cGRhdGVQYWlycyh0aGlzLmNyZWF0ZUNvbnRhY3QpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIFJlbW92ZXMgb2xkIG5vbi1vdmVybGFwcGluZyBjb250YWN0cywgYXBwbGllcyBmaWx0ZXJzIGFuZCB1cGRhdGVzIGNvbnRhY3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLnVwZGF0ZUNvbnRhY3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGF3YWtlIGNvbnRhY3RzLlxuICAgICAgICAgICAgdmFyIGM7XG4gICAgICAgICAgICB2YXIgbmV4dF9jID0gdGhpcy5tX2NvbnRhY3RMaXN0O1xuICAgICAgICAgICAgd2hpbGUgKGMgPSBuZXh0X2MpIHtcbiAgICAgICAgICAgICAgICBuZXh0X2MgPSBjLmdldE5leHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgZml4dHVyZUEgPSBjLmdldEZpeHR1cmVBKCk7XG4gICAgICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gYy5nZXRGaXh0dXJlQigpO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleEEgPSBjLmdldENoaWxkSW5kZXhBKCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4QiA9IGMuZ2V0Q2hpbGRJbmRleEIoKTtcbiAgICAgICAgICAgICAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5nZXRCb2R5KCk7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHlCID0gZml4dHVyZUIuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgY29udGFjdCBmbGFnZ2VkIGZvciBmaWx0ZXJpbmc/XG4gICAgICAgICAgICAgICAgaWYgKGMubV9maWx0ZXJGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5Qi5zaG91bGRDb2xsaWRlKGJvZHlBKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95Q29udGFjdChjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXh0dXJlQi5zaG91bGRDb2xsaWRlKGZpeHR1cmVBKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95Q29udGFjdChjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBmaWx0ZXJpbmcgZmxhZy5cbiAgICAgICAgICAgICAgICAgICAgYy5tX2ZpbHRlckZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZUEgPSBib2R5QS5pc0F3YWtlKCkgJiYgIWJvZHlBLmlzU3RhdGljKCk7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZUIgPSBib2R5Qi5pc0F3YWtlKCkgJiYgIWJvZHlCLmlzU3RhdGljKCk7XG4gICAgICAgICAgICAgICAgLy8gQXQgbGVhc3Qgb25lIGJvZHkgbXVzdCBiZSBhd2FrZSBhbmQgaXQgbXVzdCBiZSBkeW5hbWljIG9yIGtpbmVtYXRpYy5cbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlQSA9PSBmYWxzZSAmJiBhY3RpdmVCID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcHJveHlJZEEgPSBmaXh0dXJlQS5tX3Byb3hpZXNbaW5kZXhBXS5wcm94eUlkO1xuICAgICAgICAgICAgICAgIHZhciBwcm94eUlkQiA9IGZpeHR1cmVCLm1fcHJveGllc1tpbmRleEJdLnByb3h5SWQ7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJsYXAgPSB0aGlzLm1fYnJvYWRQaGFzZS50ZXN0T3ZlcmxhcChwcm94eUlkQSwgcHJveHlJZEIpO1xuICAgICAgICAgICAgICAgIC8vIEhlcmUgd2UgZGVzdHJveSBjb250YWN0cyB0aGF0IGNlYXNlIHRvIG92ZXJsYXAgaW4gdGhlIGJyb2FkLXBoYXNlLlxuICAgICAgICAgICAgICAgIGlmIChvdmVybGFwID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveUNvbnRhY3QoYyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgY29udGFjdCBwZXJzaXN0cy5cbiAgICAgICAgICAgICAgICBjLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLmRlc3Ryb3lDb250YWN0ID0gZnVuY3Rpb24gKGNvbnRhY3QpIHtcbiAgICAgICAgICAgIENvbnRhY3QuZGVzdHJveShjb250YWN0LCB0aGlzKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSB3b3JsZC5cbiAgICAgICAgICAgIGlmIChjb250YWN0Lm1fcHJldikge1xuICAgICAgICAgICAgICAgIGNvbnRhY3QubV9wcmV2Lm1fbmV4dCA9IGNvbnRhY3QubV9uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRhY3QubV9uZXh0KSB7XG4gICAgICAgICAgICAgICAgY29udGFjdC5tX25leHQubV9wcmV2ID0gY29udGFjdC5tX3ByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGFjdCA9PSB0aGlzLm1fY29udGFjdExpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fY29udGFjdExpc3QgPSBjb250YWN0Lm1fbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC0tdGhpcy5tX2NvbnRhY3RDb3VudDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgV29ybGQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fbGlzdGVuZXJzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW25hbWVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0eXBlZGVmXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAobmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzICYmIHRoaXMuX2xpc3RlbmVyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICghbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKG5hbWUsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgJiYgdGhpcy5fbGlzdGVuZXJzW25hbWVdO1xuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGlzdGVuZXJzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2xdLmNhbGwodGhpcywgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLmJlZ2luQ29udGFjdCA9IGZ1bmN0aW9uIChjb250YWN0KSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2goJ2JlZ2luLWNvbnRhY3QnLCBjb250YWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLmVuZENvbnRhY3QgPSBmdW5jdGlvbiAoY29udGFjdCkge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKCdlbmQtY29udGFjdCcsIGNvbnRhY3QpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUucHJlU29sdmUgPSBmdW5jdGlvbiAoY29udGFjdCwgb2xkTWFuaWZvbGQpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaCgncHJlLXNvbHZlJywgY29udGFjdCwgb2xkTWFuaWZvbGQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUucG9zdFNvbHZlID0gZnVuY3Rpb24gKGNvbnRhY3QsIGltcHVsc2UpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaCgncG9zdC1zb2x2ZScsIGNvbnRhY3QsIGltcHVsc2UpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gV29ybGQ7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICB2YXIgVmVjMyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgZnVuY3Rpb24gVmVjMyh4LCB5LCB6KSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVmVjMykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMoeCwgeSwgeik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMueiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB4Lng7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0geC55O1xuICAgICAgICAgICAgICAgIHRoaXMueiA9IHguejtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgVmVjMy5wcm90b3R5cGUuX3NlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy54LFxuICAgICAgICAgICAgICAgIHk6IHRoaXMueSxcbiAgICAgICAgICAgICAgICB6OiB0aGlzLnpcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgVmVjMy5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoVmVjMy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgb2JqLnggPSBkYXRhLng7XG4gICAgICAgICAgICBvYmoueSA9IGRhdGEueTtcbiAgICAgICAgICAgIG9iai56ID0gZGF0YS56O1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBWZWMzLm5lbyA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShWZWMzLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBvYmoueCA9IHg7XG4gICAgICAgICAgICBvYmoueSA9IHk7XG4gICAgICAgICAgICBvYmoueiA9IHo7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9O1xuICAgICAgICBWZWMzLnplcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShWZWMzLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBvYmoueCA9IDA7XG4gICAgICAgICAgICBvYmoueSA9IDA7XG4gICAgICAgICAgICBvYmoueiA9IDA7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9O1xuICAgICAgICBWZWMzLmNsb25lID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMzLm5lbyh2LngsIHYueSwgdi56KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBWZWMzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERvZXMgdGhpcyB2ZWN0b3IgY29udGFpbiBmaW5pdGUgY29vcmRpbmF0ZXM/XG4gICAgICAgICAqL1xuICAgICAgICBWZWMzLmlzVmFsaWQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGgkMS5pc0Zpbml0ZShvYmoueCkgJiYgbWF0aCQxLmlzRmluaXRlKG9iai55KSAmJiBtYXRoJDEuaXNGaW5pdGUob2JqLnopO1xuICAgICAgICB9O1xuICAgICAgICBWZWMzLmFzc2VydCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIFZlYzMucHJvdG90eXBlLnNldFplcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnggPSAwLjA7XG4gICAgICAgICAgICB0aGlzLnkgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLnogPSAwLjA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHgsIHksIHopIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBWZWMzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgdGhpcy54ICs9IHcueDtcbiAgICAgICAgICAgIHRoaXMueSArPSB3Lnk7XG4gICAgICAgICAgICB0aGlzLnogKz0gdy56O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzMucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICB0aGlzLnggLT0gdy54O1xuICAgICAgICAgICAgdGhpcy55IC09IHcueTtcbiAgICAgICAgICAgIHRoaXMueiAtPSB3Lno7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMy5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHRoaXMueCAqPSBtO1xuICAgICAgICAgICAgdGhpcy55ICo9IG07XG4gICAgICAgICAgICB0aGlzLnogKj0gbTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBWZWMzLmFyZUVxdWFsID0gZnVuY3Rpb24gKHYsIHcpIHtcbiAgICAgICAgICAgIHJldHVybiB2ID09PSB3IHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHcgPT09ICdvYmplY3QnICYmIHcgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgdi54ID09PSB3LnggJiYgdi55ID09PSB3LnkgJiYgdi56ID09PSB3Lno7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtIHRoZSBkb3QgcHJvZHVjdCBvbiB0d28gdmVjdG9ycy5cbiAgICAgICAgICovXG4gICAgICAgIFZlYzMuZG90ID0gZnVuY3Rpb24gKHYsIHcpIHtcbiAgICAgICAgICAgIHJldHVybiB2LnggKiB3LnggKyB2LnkgKiB3LnkgKyB2LnogKiB3Lno7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtIHRoZSBjcm9zcyBwcm9kdWN0IG9uIHR3byB2ZWN0b3JzLiBJbiAyRCB0aGlzIHByb2R1Y2VzIGEgc2NhbGFyLlxuICAgICAgICAgKi9cbiAgICAgICAgVmVjMy5jcm9zcyA9IGZ1bmN0aW9uICh2LCB3KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModi55ICogdy56IC0gdi56ICogdy55LCB2LnogKiB3LnggLSB2LnggKiB3LnosIHYueCAqIHcueSAtIHYueSAqIHcueCk7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzMuYWRkID0gZnVuY3Rpb24gKHYsIHcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh2LnggKyB3LngsIHYueSArIHcueSwgdi56ICsgdy56KTtcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMy5zdWIgPSBmdW5jdGlvbiAodiwgdykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHYueCAtIHcueCwgdi55IC0gdy55LCB2LnogLSB3LnopO1xuICAgICAgICB9O1xuICAgICAgICBWZWMzLm11bCA9IGZ1bmN0aW9uICh2LCBtKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMobSAqIHYueCwgbSAqIHYueSwgbSAqIHYueik7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzMucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IC10aGlzLng7XG4gICAgICAgICAgICB0aGlzLnkgPSAtdGhpcy55O1xuICAgICAgICAgICAgdGhpcy56ID0gLXRoaXMuejtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBWZWMzLm5lZyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMoLXYueCwgLXYueSwgLXYueik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBWZWMzO1xuICAgIH0oKSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQSBsaW5lIHNlZ21lbnQgKGVkZ2UpIHNoYXBlLiBUaGVzZSBjYW4gYmUgY29ubmVjdGVkIGluIGNoYWlucyBvciBsb29wcyB0b1xuICAgICAqIG90aGVyIGVkZ2Ugc2hhcGVzLiBUaGUgY29ubmVjdGl2aXR5IGluZm9ybWF0aW9uIGlzIHVzZWQgdG8gZW5zdXJlIGNvcnJlY3RcbiAgICAgKiBjb250YWN0IG5vcm1hbHMuXG4gICAgICovXG4gICAgdmFyIEVkZ2VTaGFwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEVkZ2VTaGFwZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRWRnZVNoYXBlKHYxLCB2Mikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmICghKF90aGlzIGluc3RhbmNlb2YgRWRnZVNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRWRnZVNoYXBlKHYxLCB2Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5tX3R5cGUgPSBFZGdlU2hhcGUuVFlQRTtcbiAgICAgICAgICAgIF90aGlzLm1fcmFkaXVzID0gU2V0dGluZ3MucG9seWdvblJhZGl1cztcbiAgICAgICAgICAgIF90aGlzLm1fdmVydGV4MSA9IHYxID8gVmVjMi5jbG9uZSh2MSkgOiBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIF90aGlzLm1fdmVydGV4MiA9IHYyID8gVmVjMi5jbG9uZSh2MikgOiBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIF90aGlzLm1fdmVydGV4MCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgX3RoaXMubV92ZXJ0ZXgzID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICBfdGhpcy5tX2hhc1ZlcnRleDAgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLm1faGFzVmVydGV4MyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRWRnZVNoYXBlLnByb3RvdHlwZS5fc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm1fdHlwZSxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXgxOiB0aGlzLm1fdmVydGV4MSxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXgyOiB0aGlzLm1fdmVydGV4MixcbiAgICAgICAgICAgICAgICB2ZXJ0ZXgwOiB0aGlzLm1fdmVydGV4MCxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXgzOiB0aGlzLm1fdmVydGV4MyxcbiAgICAgICAgICAgICAgICBoYXNWZXJ0ZXgwOiB0aGlzLm1faGFzVmVydGV4MCxcbiAgICAgICAgICAgICAgICBoYXNWZXJ0ZXgzOiB0aGlzLm1faGFzVmVydGV4MyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRWRnZVNoYXBlLl9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBuZXcgRWRnZVNoYXBlKGRhdGEudmVydGV4MSwgZGF0YS52ZXJ0ZXgyKTtcbiAgICAgICAgICAgIGlmIChzaGFwZS5tX2hhc1ZlcnRleDApIHtcbiAgICAgICAgICAgICAgICBzaGFwZS5zZXRQcmV2VmVydGV4KGRhdGEudmVydGV4MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hhcGUubV9oYXNWZXJ0ZXgzKSB7XG4gICAgICAgICAgICAgICAgc2hhcGUuc2V0TmV4dFZlcnRleChkYXRhLnZlcnRleDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsIEBkZXByZWNhdGVkICovXG4gICAgICAgIEVkZ2VTaGFwZS5wcm90b3R5cGUuc2V0TmV4dCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0VmVydGV4KHYpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWwgbmV4dCB2ZXJ0ZXgsIHVzZWQgZm9yIHNtb290aCBjb2xsaXNpb24uXG4gICAgICAgICAqL1xuICAgICAgICBFZGdlU2hhcGUucHJvdG90eXBlLnNldE5leHRWZXJ0ZXggPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdmVydGV4My5zZXRWZWMyKHYpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9oYXNWZXJ0ZXgzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubV92ZXJ0ZXgzLnNldFplcm8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1faGFzVmVydGV4MyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25hbCBuZXh0IHZlcnRleCwgdXNlZCBmb3Igc21vb3RoIGNvbGxpc2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIEVkZ2VTaGFwZS5wcm90b3R5cGUuZ2V0TmV4dFZlcnRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdmVydGV4MztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBFZGdlU2hhcGUucHJvdG90eXBlLnNldFByZXYgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0UHJldlZlcnRleCh2KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIHByZXYgdmVydGV4LCB1c2VkIGZvciBzbW9vdGggY29sbGlzaW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgRWRnZVNoYXBlLnByb3RvdHlwZS5zZXRQcmV2VmVydGV4ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3ZlcnRleDAuc2V0VmVjMih2KTtcbiAgICAgICAgICAgICAgICB0aGlzLm1faGFzVmVydGV4MCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdmVydGV4MC5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2hhc1ZlcnRleDAgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWwgcHJldiB2ZXJ0ZXgsIHVzZWQgZm9yIHNtb290aCBjb2xsaXNpb24uXG4gICAgICAgICAqL1xuICAgICAgICBFZGdlU2hhcGUucHJvdG90eXBlLmdldFByZXZWZXJ0ZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3ZlcnRleDA7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyBhcyBhbiBpc29sYXRlZCBlZGdlLlxuICAgICAgICAgKi9cbiAgICAgICAgRWRnZVNoYXBlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICAgICAgdGhpcy5tX3ZlcnRleDEuc2V0VmVjMih2MSk7XG4gICAgICAgICAgICB0aGlzLm1fdmVydGV4Mi5zZXRWZWMyKHYyKTtcbiAgICAgICAgICAgIHRoaXMubV9oYXNWZXJ0ZXgwID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm1faGFzVmVydGV4MyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgU2hhcGVzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGltbXV0YWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogY2xvbmUgdGhlIGNvbmNyZXRlIHNoYXBlLlxuICAgICAgICAgKi9cbiAgICAgICAgRWRnZVNoYXBlLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBuZXcgRWRnZVNoYXBlKCk7XG4gICAgICAgICAgICBjbG9uZS5tX3R5cGUgPSB0aGlzLm1fdHlwZTtcbiAgICAgICAgICAgIGNsb25lLm1fcmFkaXVzID0gdGhpcy5tX3JhZGl1cztcbiAgICAgICAgICAgIGNsb25lLm1fdmVydGV4MS5zZXRWZWMyKHRoaXMubV92ZXJ0ZXgxKTtcbiAgICAgICAgICAgIGNsb25lLm1fdmVydGV4Mi5zZXRWZWMyKHRoaXMubV92ZXJ0ZXgyKTtcbiAgICAgICAgICAgIGNsb25lLm1fdmVydGV4MC5zZXRWZWMyKHRoaXMubV92ZXJ0ZXgwKTtcbiAgICAgICAgICAgIGNsb25lLm1fdmVydGV4My5zZXRWZWMyKHRoaXMubV92ZXJ0ZXgzKTtcbiAgICAgICAgICAgIGNsb25lLm1faGFzVmVydGV4MCA9IHRoaXMubV9oYXNWZXJ0ZXgwO1xuICAgICAgICAgICAgY2xvbmUubV9oYXNWZXJ0ZXgzID0gdGhpcy5tX2hhc1ZlcnRleDM7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBjaGlsZCBwcmltaXRpdmVzLlxuICAgICAgICAgKi9cbiAgICAgICAgRWRnZVNoYXBlLnByb3RvdHlwZS5nZXRDaGlsZENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0IGEgcG9pbnQgZm9yIGNvbnRhaW5tZW50IGluIHRoaXMgc2hhcGUuIFRoaXMgb25seSB3b3JrcyBmb3IgY29udmV4XG4gICAgICAgICAqIHNoYXBlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHhmIFRoZSBzaGFwZSB3b3JsZCB0cmFuc2Zvcm0uXG4gICAgICAgICAqIEBwYXJhbSBwIEEgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBFZGdlU2hhcGUucHJvdG90eXBlLnRlc3RQb2ludCA9IGZ1bmN0aW9uICh4ZiwgcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FzdCBhIHJheSBhZ2FpbnN0IGEgY2hpbGQgc2hhcGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvdXRwdXQgVGhlIHJheS1jYXN0IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgcmF5LWNhc3QgaW5wdXQgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHhmIFRoZSB0cmFuc2Zvcm0gdG8gYmUgYXBwbGllZCB0byB0aGUgc2hhcGUuXG4gICAgICAgICAqIEBwYXJhbSBjaGlsZEluZGV4IFRoZSBjaGlsZCBzaGFwZSBpbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgRWRnZVNoYXBlLnByb3RvdHlwZS5yYXlDYXN0ID0gZnVuY3Rpb24gKG91dHB1dCwgaW5wdXQsIHhmLCBjaGlsZEluZGV4KSB7XG4gICAgICAgICAgICAvLyBwID0gcDEgKyB0ICogZFxuICAgICAgICAgICAgLy8gdiA9IHYxICsgcyAqIGVcbiAgICAgICAgICAgIC8vIHAxICsgdCAqIGQgPSB2MSArIHMgKiBlXG4gICAgICAgICAgICAvLyBzICogZSAtIHQgKiBkID0gcDEgLSB2MVxuICAgICAgICAgICAgLy8gTk9UX1VTRUQoY2hpbGRJbmRleCk7XG4gICAgICAgICAgICAvLyBQdXQgdGhlIHJheSBpbnRvIHRoZSBlZGdlJ3MgZnJhbWUgb2YgcmVmZXJlbmNlLlxuICAgICAgICAgICAgdmFyIHAxID0gUm90Lm11bFRWZWMyKHhmLnEsIFZlYzIuc3ViKGlucHV0LnAxLCB4Zi5wKSk7XG4gICAgICAgICAgICB2YXIgcDIgPSBSb3QubXVsVFZlYzIoeGYucSwgVmVjMi5zdWIoaW5wdXQucDIsIHhmLnApKTtcbiAgICAgICAgICAgIHZhciBkID0gVmVjMi5zdWIocDIsIHAxKTtcbiAgICAgICAgICAgIHZhciB2MSA9IHRoaXMubV92ZXJ0ZXgxO1xuICAgICAgICAgICAgdmFyIHYyID0gdGhpcy5tX3ZlcnRleDI7XG4gICAgICAgICAgICB2YXIgZSA9IFZlYzIuc3ViKHYyLCB2MSk7XG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gVmVjMi5uZW8oZS55LCAtZS54KTtcbiAgICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIC8vIHEgPSBwMSArIHQgKiBkXG4gICAgICAgICAgICAvLyBkb3Qobm9ybWFsLCBxIC0gdjEpID0gMFxuICAgICAgICAgICAgLy8gZG90KG5vcm1hbCwgcDEgLSB2MSkgKyB0ICogZG90KG5vcm1hbCwgZCkgPSAwXG4gICAgICAgICAgICB2YXIgbnVtZXJhdG9yID0gVmVjMi5kb3Qobm9ybWFsLCBWZWMyLnN1Yih2MSwgcDEpKTtcbiAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IFZlYzIuZG90KG5vcm1hbCwgZCk7XG4gICAgICAgICAgICBpZiAoZGVub21pbmF0b3IgPT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQgPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgIGlmICh0IDwgMC4wIHx8IGlucHV0Lm1heEZyYWN0aW9uIDwgdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBxID0gVmVjMi5hZGQocDEsIFZlYzIubXVsTnVtVmVjMih0LCBkKSk7XG4gICAgICAgICAgICAvLyBxID0gdjEgKyBzICogclxuICAgICAgICAgICAgLy8gcyA9IGRvdChxIC0gdjEsIHIpIC8gZG90KHIsIHIpXG4gICAgICAgICAgICB2YXIgciA9IFZlYzIuc3ViKHYyLCB2MSk7XG4gICAgICAgICAgICB2YXIgcnIgPSBWZWMyLmRvdChyLCByKTtcbiAgICAgICAgICAgIGlmIChyciA9PSAwLjApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcyA9IFZlYzIuZG90KFZlYzIuc3ViKHEsIHYxKSwgcikgLyBycjtcbiAgICAgICAgICAgIGlmIChzIDwgMC4wIHx8IDEuMCA8IHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQuZnJhY3Rpb24gPSB0O1xuICAgICAgICAgICAgaWYgKG51bWVyYXRvciA+IDAuMCkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5ub3JtYWwgPSBSb3QubXVsVmVjMih4Zi5xLCBub3JtYWwpLm5lZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0Lm5vcm1hbCA9IFJvdC5tdWxWZWMyKHhmLnEsIG5vcm1hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgdHJhbnNmb3JtLCBjb21wdXRlIHRoZSBhc3NvY2lhdGVkIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIGFcbiAgICAgICAgICogY2hpbGQgc2hhcGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBhYWJiIFJldHVybnMgdGhlIGF4aXMgYWxpZ25lZCBib3guXG4gICAgICAgICAqIEBwYXJhbSB4ZiBUaGUgd29ybGQgdHJhbnNmb3JtIG9mIHRoZSBzaGFwZS5cbiAgICAgICAgICogQHBhcmFtIGNoaWxkSW5kZXggVGhlIGNoaWxkIHNoYXBlXG4gICAgICAgICAqL1xuICAgICAgICBFZGdlU2hhcGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKGFhYmIsIHhmLCBjaGlsZEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgdjEgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZiwgdGhpcy5tX3ZlcnRleDEpO1xuICAgICAgICAgICAgdmFyIHYyID0gVHJhbnNmb3JtLm11bFZlYzIoeGYsIHRoaXMubV92ZXJ0ZXgyKTtcbiAgICAgICAgICAgIGFhYmIuY29tYmluZVBvaW50cyh2MSwgdjIpO1xuICAgICAgICAgICAgYWFiYi5leHRlbmQodGhpcy5tX3JhZGl1cyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wdXRlIHRoZSBtYXNzIHByb3BlcnRpZXMgb2YgdGhpcyBzaGFwZSB1c2luZyBpdHMgZGltZW5zaW9ucyBhbmQgZGVuc2l0eS5cbiAgICAgICAgICogVGhlIGluZXJ0aWEgdGVuc29yIGlzIGNvbXB1dGVkIGFib3V0IHRoZSBsb2NhbCBvcmlnaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBtYXNzRGF0YSBSZXR1cm5zIHRoZSBtYXNzIGRhdGEgZm9yIHRoaXMgc2hhcGUuXG4gICAgICAgICAqIEBwYXJhbSBkZW5zaXR5IFRoZSBkZW5zaXR5IGluIGtpbG9ncmFtcyBwZXIgbWV0ZXIgc3F1YXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIEVkZ2VTaGFwZS5wcm90b3R5cGUuY29tcHV0ZU1hc3MgPSBmdW5jdGlvbiAobWFzc0RhdGEsIGRlbnNpdHkpIHtcbiAgICAgICAgICAgIG1hc3NEYXRhLm1hc3MgPSAwLjA7XG4gICAgICAgICAgICBtYXNzRGF0YS5jZW50ZXIuc2V0Q29tYmluZSgwLjUsIHRoaXMubV92ZXJ0ZXgxLCAwLjUsIHRoaXMubV92ZXJ0ZXgyKTtcbiAgICAgICAgICAgIG1hc3NEYXRhLkkgPSAwLjA7XG4gICAgICAgIH07XG4gICAgICAgIEVkZ2VTaGFwZS5wcm90b3R5cGUuY29tcHV0ZURpc3RhbmNlUHJveHkgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgICAgICAgICAgIHByb3h5Lm1fdmVydGljZXMucHVzaCh0aGlzLm1fdmVydGV4MSk7XG4gICAgICAgICAgICBwcm94eS5tX3ZlcnRpY2VzLnB1c2godGhpcy5tX3ZlcnRleDIpO1xuICAgICAgICAgICAgcHJveHkubV9jb3VudCA9IDI7XG4gICAgICAgICAgICBwcm94eS5tX3JhZGl1cyA9IHRoaXMubV9yYWRpdXM7XG4gICAgICAgIH07XG4gICAgICAgIEVkZ2VTaGFwZS5UWVBFID0gJ2VkZ2UnO1xuICAgICAgICByZXR1cm4gRWRnZVNoYXBlO1xuICAgIH0oU2hhcGUpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBIGNoYWluIHNoYXBlIGlzIGEgZnJlZSBmb3JtIHNlcXVlbmNlIG9mIGxpbmUgc2VnbWVudHMuIFRoZSBjaGFpbiBoYXNcbiAgICAgKiB0d28tc2lkZWQgY29sbGlzaW9uLCBzbyB5b3UgY2FuIHVzZSBpbnNpZGUgYW5kIG91dHNpZGUgY29sbGlzaW9uLiBUaGVyZWZvcmUsXG4gICAgICogeW91IG1heSB1c2UgYW55IHdpbmRpbmcgb3JkZXIuIENvbm5lY3Rpdml0eSBpbmZvcm1hdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZVxuICAgICAqIHNtb290aCBjb2xsaXNpb25zLlxuICAgICAqXG4gICAgICogV0FSTklORzogVGhlIGNoYWluIHdpbGwgbm90IGNvbGxpZGUgcHJvcGVybHkgaWYgdGhlcmUgYXJlIHNlbGYtaW50ZXJzZWN0aW9ucy5cbiAgICAgKi9cbiAgICB2YXIgQ2hhaW5TaGFwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKENoYWluU2hhcGUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIENoYWluU2hhcGUodmVydGljZXMsIGxvb3ApIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoIShfdGhpcyBpbnN0YW5jZW9mIENoYWluU2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFpblNoYXBlKHZlcnRpY2VzLCBsb29wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLm1fdHlwZSA9IENoYWluU2hhcGUuVFlQRTtcbiAgICAgICAgICAgIF90aGlzLm1fcmFkaXVzID0gU2V0dGluZ3MucG9seWdvblJhZGl1cztcbiAgICAgICAgICAgIF90aGlzLm1fdmVydGljZXMgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLm1fY291bnQgPSAwO1xuICAgICAgICAgICAgX3RoaXMubV9wcmV2VmVydGV4ID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLm1fbmV4dFZlcnRleCA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5tX2hhc1ByZXZWZXJ0ZXggPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLm1faGFzTmV4dFZlcnRleCA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMubV9pc0xvb3AgPSAhIWxvb3A7XG4gICAgICAgICAgICBpZiAodmVydGljZXMgJiYgdmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZUxvb3AodmVydGljZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZUNoYWluKHZlcnRpY2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBDaGFpblNoYXBlLnByb3RvdHlwZS5fc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5tX3R5cGUsXG4gICAgICAgICAgICAgICAgdmVydGljZXM6IHRoaXMubV92ZXJ0aWNlcyxcbiAgICAgICAgICAgICAgICBpc0xvb3A6IHRoaXMubV9pc0xvb3AsXG4gICAgICAgICAgICAgICAgaGFzUHJldlZlcnRleDogdGhpcy5tX2hhc1ByZXZWZXJ0ZXgsXG4gICAgICAgICAgICAgICAgaGFzTmV4dFZlcnRleDogdGhpcy5tX2hhc05leHRWZXJ0ZXgsXG4gICAgICAgICAgICAgICAgcHJldlZlcnRleDogbnVsbCxcbiAgICAgICAgICAgICAgICBuZXh0VmVydGV4OiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fcHJldlZlcnRleCkge1xuICAgICAgICAgICAgICAgIGRhdGEucHJldlZlcnRleCA9IHRoaXMubV9wcmV2VmVydGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV9uZXh0VmVydGV4KSB7XG4gICAgICAgICAgICAgICAgZGF0YS5uZXh0VmVydGV4ID0gdGhpcy5tX25leHRWZXJ0ZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBDaGFpblNoYXBlLl9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhLCBmaXh0dXJlLCByZXN0b3JlKSB7XG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChkYXRhLnZlcnRpY2VzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2gocmVzdG9yZShWZWMyLCBkYXRhLnZlcnRpY2VzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNoYXBlID0gbmV3IENoYWluU2hhcGUodmVydGljZXMsIGRhdGEuaXNMb29wKTtcbiAgICAgICAgICAgIGlmIChkYXRhLnByZXZWZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgICBzaGFwZS5zZXRQcmV2VmVydGV4KGRhdGEucHJldlZlcnRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5uZXh0VmVydGV4KSB7XG4gICAgICAgICAgICAgICAgc2hhcGUuc2V0TmV4dFZlcnRleChkYXRhLm5leHRWZXJ0ZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBjbGVhcigpIHtcbiAgICAgICAgLy8gICB0aGlzLm1fdmVydGljZXMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gICB0aGlzLm1fY291bnQgPSAwO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQ3JlYXRlIGEgbG9vcC4gVGhpcyBhdXRvbWF0aWNhbGx5IGFkanVzdHMgY29ubmVjdGl2aXR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdmVydGljZXMgYW4gYXJyYXkgb2YgdmVydGljZXMsIHRoZXNlIGFyZSBjb3BpZWRcbiAgICAgICAgICogQHBhcmFtIGNvdW50IHRoZSB2ZXJ0ZXggY291bnRcbiAgICAgICAgICovXG4gICAgICAgIENoYWluU2hhcGUucHJvdG90eXBlLl9jcmVhdGVMb29wID0gZnVuY3Rpb24gKHZlcnRpY2VzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzID0gW107XG4gICAgICAgICAgICB0aGlzLm1fY291bnQgPSB2ZXJ0aWNlcy5sZW5ndGggKyAxO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV92ZXJ0aWNlc1tpXSA9IFZlYzIuY2xvbmUodmVydGljZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzW3ZlcnRpY2VzLmxlbmd0aF0gPSBWZWMyLmNsb25lKHZlcnRpY2VzWzBdKTtcbiAgICAgICAgICAgIHRoaXMubV9wcmV2VmVydGV4ID0gdGhpcy5tX3ZlcnRpY2VzW3RoaXMubV9jb3VudCAtIDJdO1xuICAgICAgICAgICAgdGhpcy5tX25leHRWZXJ0ZXggPSB0aGlzLm1fdmVydGljZXNbMV07XG4gICAgICAgICAgICB0aGlzLm1faGFzUHJldlZlcnRleCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1faGFzTmV4dFZlcnRleCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBDcmVhdGUgYSBjaGFpbiB3aXRoIGlzb2xhdGVkIGVuZCB2ZXJ0aWNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZlcnRpY2VzIGFuIGFycmF5IG9mIHZlcnRpY2VzLCB0aGVzZSBhcmUgY29waWVkXG4gICAgICAgICAqIEBwYXJhbSBjb3VudCB0aGUgdmVydGV4IGNvdW50XG4gICAgICAgICAqL1xuICAgICAgICBDaGFpblNoYXBlLnByb3RvdHlwZS5fY3JlYXRlQ2hhaW4gPSBmdW5jdGlvbiAodmVydGljZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmVydGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY29kZSBjcmFzaGVzIGhlcmUsIGl0IG1lYW5zIHlvdXIgdmVydGljZXMgYXJlIHRvbyBjbG9zZSB0b2dldGhlci5cbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgdmVydGljZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fY291bnQgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzW2ldID0gVmVjMi5jbG9uZSh2ZXJ0aWNlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1faGFzUHJldlZlcnRleCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tX2hhc05leHRWZXJ0ZXggPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubV9wcmV2VmVydGV4ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubV9uZXh0VmVydGV4ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIENoYWluU2hhcGUucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1faXNMb29wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlTG9vcCh0aGlzLm1fdmVydGljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ2hhaW4odGhpcy5tX3ZlcnRpY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVzdGFibGlzaCBjb25uZWN0aXZpdHkgdG8gYSB2ZXJ0ZXggdGhhdCBwcmVjZWRlcyB0aGUgZmlyc3QgdmVydGV4LiBEb24ndCBjYWxsXG4gICAgICAgICAqIHRoaXMgZm9yIGxvb3BzLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhaW5TaGFwZS5wcm90b3R5cGUuc2V0UHJldlZlcnRleCA9IGZ1bmN0aW9uIChwcmV2VmVydGV4KSB7XG4gICAgICAgICAgICB0aGlzLm1fcHJldlZlcnRleCA9IHByZXZWZXJ0ZXg7XG4gICAgICAgICAgICB0aGlzLm1faGFzUHJldlZlcnRleCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIENoYWluU2hhcGUucHJvdG90eXBlLmdldFByZXZWZXJ0ZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3ByZXZWZXJ0ZXg7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFc3RhYmxpc2ggY29ubmVjdGl2aXR5IHRvIGEgdmVydGV4IHRoYXQgZm9sbG93cyB0aGUgbGFzdCB2ZXJ0ZXguIERvbid0IGNhbGxcbiAgICAgICAgICogdGhpcyBmb3IgbG9vcHMuXG4gICAgICAgICAqL1xuICAgICAgICBDaGFpblNoYXBlLnByb3RvdHlwZS5zZXROZXh0VmVydGV4ID0gZnVuY3Rpb24gKG5leHRWZXJ0ZXgpIHtcbiAgICAgICAgICAgIHRoaXMubV9uZXh0VmVydGV4ID0gbmV4dFZlcnRleDtcbiAgICAgICAgICAgIHRoaXMubV9oYXNOZXh0VmVydGV4ID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhaW5TaGFwZS5wcm90b3R5cGUuZ2V0TmV4dFZlcnRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbmV4dFZlcnRleDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBTaGFwZXMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgaW1tdXRhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBjbG9uZSB0aGUgY29uY3JldGUgc2hhcGUuXG4gICAgICAgICAqL1xuICAgICAgICBDaGFpblNoYXBlLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBuZXcgQ2hhaW5TaGFwZSgpO1xuICAgICAgICAgICAgY2xvbmUuX2NyZWF0ZUNoYWluKHRoaXMubV92ZXJ0aWNlcyk7XG4gICAgICAgICAgICBjbG9uZS5tX3R5cGUgPSB0aGlzLm1fdHlwZTtcbiAgICAgICAgICAgIGNsb25lLm1fcmFkaXVzID0gdGhpcy5tX3JhZGl1cztcbiAgICAgICAgICAgIGNsb25lLm1fcHJldlZlcnRleCA9IHRoaXMubV9wcmV2VmVydGV4O1xuICAgICAgICAgICAgY2xvbmUubV9uZXh0VmVydGV4ID0gdGhpcy5tX25leHRWZXJ0ZXg7XG4gICAgICAgICAgICBjbG9uZS5tX2hhc1ByZXZWZXJ0ZXggPSB0aGlzLm1faGFzUHJldlZlcnRleDtcbiAgICAgICAgICAgIGNsb25lLm1faGFzTmV4dFZlcnRleCA9IHRoaXMubV9oYXNOZXh0VmVydGV4O1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBudW1iZXIgb2YgY2hpbGQgcHJpbWl0aXZlcy5cbiAgICAgICAgICovXG4gICAgICAgIENoYWluU2hhcGUucHJvdG90eXBlLmdldENoaWxkQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBlZGdlIGNvdW50ID0gdmVydGV4IGNvdW50IC0gMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9jb3VudCAtIDE7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEdldCBhIGNoaWxkIGVkZ2UuXG4gICAgICAgIENoYWluU2hhcGUucHJvdG90eXBlLmdldENoaWxkRWRnZSA9IGZ1bmN0aW9uIChlZGdlLCBjaGlsZEluZGV4KSB7XG4gICAgICAgICAgICBlZGdlLm1fdHlwZSA9IEVkZ2VTaGFwZS5UWVBFO1xuICAgICAgICAgICAgZWRnZS5tX3JhZGl1cyA9IHRoaXMubV9yYWRpdXM7XG4gICAgICAgICAgICBlZGdlLm1fdmVydGV4MSA9IHRoaXMubV92ZXJ0aWNlc1tjaGlsZEluZGV4XTtcbiAgICAgICAgICAgIGVkZ2UubV92ZXJ0ZXgyID0gdGhpcy5tX3ZlcnRpY2VzW2NoaWxkSW5kZXggKyAxXTtcbiAgICAgICAgICAgIGlmIChjaGlsZEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIGVkZ2UubV92ZXJ0ZXgwID0gdGhpcy5tX3ZlcnRpY2VzW2NoaWxkSW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBlZGdlLm1faGFzVmVydGV4MCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGdlLm1fdmVydGV4MCA9IHRoaXMubV9wcmV2VmVydGV4O1xuICAgICAgICAgICAgICAgIGVkZ2UubV9oYXNWZXJ0ZXgwID0gdGhpcy5tX2hhc1ByZXZWZXJ0ZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGRJbmRleCA8IHRoaXMubV9jb3VudCAtIDIpIHtcbiAgICAgICAgICAgICAgICBlZGdlLm1fdmVydGV4MyA9IHRoaXMubV92ZXJ0aWNlc1tjaGlsZEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgZWRnZS5tX2hhc1ZlcnRleDMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWRnZS5tX3ZlcnRleDMgPSB0aGlzLm1fbmV4dFZlcnRleDtcbiAgICAgICAgICAgICAgICBlZGdlLm1faGFzVmVydGV4MyA9IHRoaXMubV9oYXNOZXh0VmVydGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBDaGFpblNoYXBlLnByb3RvdHlwZS5nZXRWZXJ0ZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMubV9jb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdmVydGljZXNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubV92ZXJ0aWNlc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQ2hhaW5TaGFwZS5wcm90b3R5cGUuaXNMb29wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9pc0xvb3A7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0IGEgcG9pbnQgZm9yIGNvbnRhaW5tZW50IGluIHRoaXMgc2hhcGUuIFRoaXMgb25seSB3b3JrcyBmb3IgY29udmV4XG4gICAgICAgICAqIHNoYXBlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBhbHdheXMgcmV0dXJuIGZhbHNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geGYgVGhlIHNoYXBlIHdvcmxkIHRyYW5zZm9ybS5cbiAgICAgICAgICogQHBhcmFtIHAgQSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIENoYWluU2hhcGUucHJvdG90eXBlLnRlc3RQb2ludCA9IGZ1bmN0aW9uICh4ZiwgcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FzdCBhIHJheSBhZ2FpbnN0IGEgY2hpbGQgc2hhcGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvdXRwdXQgVGhlIHJheS1jYXN0IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgcmF5LWNhc3QgaW5wdXQgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHhmIFRoZSB0cmFuc2Zvcm0gdG8gYmUgYXBwbGllZCB0byB0aGUgc2hhcGUuXG4gICAgICAgICAqIEBwYXJhbSBjaGlsZEluZGV4IFRoZSBjaGlsZCBzaGFwZSBpbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhaW5TaGFwZS5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uIChvdXRwdXQsIGlucHV0LCB4ZiwgY2hpbGRJbmRleCkge1xuICAgICAgICAgICAgdmFyIGVkZ2VTaGFwZSA9IG5ldyBFZGdlU2hhcGUodGhpcy5nZXRWZXJ0ZXgoY2hpbGRJbmRleCksIHRoaXMuZ2V0VmVydGV4KGNoaWxkSW5kZXggKyAxKSk7XG4gICAgICAgICAgICByZXR1cm4gZWRnZVNoYXBlLnJheUNhc3Qob3V0cHV0LCBpbnB1dCwgeGYsIDApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSB0cmFuc2Zvcm0sIGNvbXB1dGUgdGhlIGFzc29jaWF0ZWQgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgYVxuICAgICAgICAgKiBjaGlsZCBzaGFwZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGFhYmIgUmV0dXJucyB0aGUgYXhpcyBhbGlnbmVkIGJveC5cbiAgICAgICAgICogQHBhcmFtIHhmIFRoZSB3b3JsZCB0cmFuc2Zvcm0gb2YgdGhlIHNoYXBlLlxuICAgICAgICAgKiBAcGFyYW0gY2hpbGRJbmRleCBUaGUgY2hpbGQgc2hhcGVcbiAgICAgICAgICovXG4gICAgICAgIENoYWluU2hhcGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKGFhYmIsIHhmLCBjaGlsZEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgdjEgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZiwgdGhpcy5nZXRWZXJ0ZXgoY2hpbGRJbmRleCkpO1xuICAgICAgICAgICAgdmFyIHYyID0gVHJhbnNmb3JtLm11bFZlYzIoeGYsIHRoaXMuZ2V0VmVydGV4KGNoaWxkSW5kZXggKyAxKSk7XG4gICAgICAgICAgICBhYWJiLmNvbWJpbmVQb2ludHModjEsIHYyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXB1dGUgdGhlIG1hc3MgcHJvcGVydGllcyBvZiB0aGlzIHNoYXBlIHVzaW5nIGl0cyBkaW1lbnNpb25zIGFuZCBkZW5zaXR5LlxuICAgICAgICAgKiBUaGUgaW5lcnRpYSB0ZW5zb3IgaXMgY29tcHV0ZWQgYWJvdXQgdGhlIGxvY2FsIG9yaWdpbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2hhaW5zIGhhdmUgemVybyBtYXNzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbWFzc0RhdGEgUmV0dXJucyB0aGUgbWFzcyBkYXRhIGZvciB0aGlzIHNoYXBlLlxuICAgICAgICAgKiBAcGFyYW0gZGVuc2l0eSBUaGUgZGVuc2l0eSBpbiBraWxvZ3JhbXMgcGVyIG1ldGVyIHNxdWFyZWQuXG4gICAgICAgICAqL1xuICAgICAgICBDaGFpblNoYXBlLnByb3RvdHlwZS5jb21wdXRlTWFzcyA9IGZ1bmN0aW9uIChtYXNzRGF0YSwgZGVuc2l0eSkge1xuICAgICAgICAgICAgbWFzc0RhdGEubWFzcyA9IDAuMDtcbiAgICAgICAgICAgIG1hc3NEYXRhLmNlbnRlciA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgbWFzc0RhdGEuSSA9IDAuMDtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhaW5TaGFwZS5wcm90b3R5cGUuY29tcHV0ZURpc3RhbmNlUHJveHkgPSBmdW5jdGlvbiAocHJveHksIGNoaWxkSW5kZXgpIHtcbiAgICAgICAgICAgIHByb3h5Lm1fYnVmZmVyWzBdID0gdGhpcy5nZXRWZXJ0ZXgoY2hpbGRJbmRleCk7XG4gICAgICAgICAgICBwcm94eS5tX2J1ZmZlclsxXSA9IHRoaXMuZ2V0VmVydGV4KGNoaWxkSW5kZXggKyAxKTtcbiAgICAgICAgICAgIHByb3h5Lm1fdmVydGljZXMgPSBwcm94eS5tX2J1ZmZlcjtcbiAgICAgICAgICAgIHByb3h5Lm1fY291bnQgPSAyO1xuICAgICAgICAgICAgcHJveHkubV9yYWRpdXMgPSB0aGlzLm1fcmFkaXVzO1xuICAgICAgICB9O1xuICAgICAgICBDaGFpblNoYXBlLlRZUEUgPSAnY2hhaW4nO1xuICAgICAgICByZXR1cm4gQ2hhaW5TaGFwZTtcbiAgICB9KFNoYXBlKSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQSBjb252ZXggcG9seWdvbi4gSXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBpbnRlcmlvciBvZiB0aGUgcG9seWdvbiBpcyB0byB0aGVcbiAgICAgKiBsZWZ0IG9mIGVhY2ggZWRnZS4gUG9seWdvbnMgaGF2ZSBhIG1heGltdW0gbnVtYmVyIG9mIHZlcnRpY2VzIGVxdWFsIHRvXG4gICAgICogU2V0dGluZ3MubWF4UG9seWdvblZlcnRpY2VzLiBJbiBtb3N0IGNhc2VzIHlvdSBzaG91bGQgbm90IG5lZWQgbWFueSB2ZXJ0aWNlc1xuICAgICAqIGZvciBhIGNvbnZleCBwb2x5Z29uLiBleHRlbmRzIFNoYXBlXG4gICAgICovXG4gICAgdmFyIFBvbHlnb25TaGFwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFBvbHlnb25TaGFwZSwgX3N1cGVyKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBmdW5jdGlvbiBQb2x5Z29uU2hhcGUodmVydGljZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoIShfdGhpcyBpbnN0YW5jZW9mIFBvbHlnb25TaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbHlnb25TaGFwZSh2ZXJ0aWNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5tX3R5cGUgPSBQb2x5Z29uU2hhcGUuVFlQRTtcbiAgICAgICAgICAgIF90aGlzLm1fcmFkaXVzID0gU2V0dGluZ3MucG9seWdvblJhZGl1cztcbiAgICAgICAgICAgIF90aGlzLm1fY2VudHJvaWQgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIF90aGlzLm1fdmVydGljZXMgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLm1fbm9ybWFscyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMubV9jb3VudCA9IDA7XG4gICAgICAgICAgICBpZiAodmVydGljZXMgJiYgdmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldCh2ZXJ0aWNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBQb2x5Z29uU2hhcGUucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMubV90eXBlLFxuICAgICAgICAgICAgICAgIHZlcnRpY2VzOiB0aGlzLm1fdmVydGljZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFBvbHlnb25TaGFwZS5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSwgZml4dHVyZSwgcmVzdG9yZSkge1xuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gW107XG4gICAgICAgICAgICBpZiAoZGF0YS52ZXJ0aWNlcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS52ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHJlc3RvcmUoVmVjMiwgZGF0YS52ZXJ0aWNlc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzaGFwZSA9IG5ldyBQb2x5Z29uU2hhcGUodmVydGljZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9O1xuICAgICAgICBQb2x5Z29uU2hhcGUucHJvdG90eXBlLmdldFZlcnRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV92ZXJ0aWNlc1tpbmRleF07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgU2hhcGVzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGltbXV0YWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogY2xvbmUgdGhlIGNvbmNyZXRlIHNoYXBlLlxuICAgICAgICAgKi9cbiAgICAgICAgUG9seWdvblNoYXBlLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBuZXcgUG9seWdvblNoYXBlKCk7XG4gICAgICAgICAgICBjbG9uZS5tX3R5cGUgPSB0aGlzLm1fdHlwZTtcbiAgICAgICAgICAgIGNsb25lLm1fcmFkaXVzID0gdGhpcy5tX3JhZGl1cztcbiAgICAgICAgICAgIGNsb25lLm1fY291bnQgPSB0aGlzLm1fY291bnQ7XG4gICAgICAgICAgICBjbG9uZS5tX2NlbnRyb2lkLnNldFZlYzIodGhpcy5tX2NlbnRyb2lkKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjbG9uZS5tX3ZlcnRpY2VzLnB1c2godGhpcy5tX3ZlcnRpY2VzW2ldLmNsb25lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fbm9ybWFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNsb25lLm1fbm9ybWFscy5wdXNoKHRoaXMubV9ub3JtYWxzW2ldLmNsb25lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBudW1iZXIgb2YgY2hpbGQgcHJpbWl0aXZlcy5cbiAgICAgICAgICovXG4gICAgICAgIFBvbHlnb25TaGFwZS5wcm90b3R5cGUuZ2V0Q2hpbGRDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFBvbHlnb25TaGFwZS5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0KHRoaXMubV92ZXJ0aWNlcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICpcbiAgICAgICAgICogQ3JlYXRlIGEgY29udmV4IGh1bGwgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgbG9jYWwgcG9pbnRzLiBUaGUgY291bnQgbXVzdCBiZVxuICAgICAgICAgKiBpbiB0aGUgcmFuZ2UgWzMsIFNldHRpbmdzLm1heFBvbHlnb25WZXJ0aWNlc10uXG4gICAgICAgICAqXG4gICAgICAgICAqIFdhcm5pbmc6IHRoZSBwb2ludHMgbWF5IGJlIHJlLW9yZGVyZWQsIGV2ZW4gaWYgdGhleSBmb3JtIGEgY29udmV4IHBvbHlnb25cbiAgICAgICAgICogV2FybmluZzogY29sbGluZWFyIHBvaW50cyBhcmUgaGFuZGxlZCBidXQgbm90IHJlbW92ZWQuIENvbGxpbmVhciBwb2ludHMgbWF5XG4gICAgICAgICAqIGxlYWQgdG8gcG9vciBzdGFja2luZyBiZWhhdmlvci5cbiAgICAgICAgICovXG4gICAgICAgIFBvbHlnb25TaGFwZS5wcm90b3R5cGUuX3NldCA9IGZ1bmN0aW9uICh2ZXJ0aWNlcykge1xuICAgICAgICAgICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRBc0JveCgxLjAsIDEuMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG4gPSBtYXRoJDEubWluKHZlcnRpY2VzLmxlbmd0aCwgU2V0dGluZ3MubWF4UG9seWdvblZlcnRpY2VzKTtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gd2VsZGluZyBhbmQgY29weSB2ZXJ0aWNlcyBpbnRvIGxvY2FsIGJ1ZmZlci5cbiAgICAgICAgICAgIHZhciBwcyA9IFtdOyAvLyBbU2V0dGluZ3MubWF4UG9seWdvblZlcnRpY2VzXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdW5pcXVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChWZWMyLmRpc3RhbmNlU3F1YXJlZCh2LCBwc1tqXSkgPCAwLjI1ICogU2V0dGluZ3MubGluZWFyU2xvcFNxdWFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVuaXF1ZSkge1xuICAgICAgICAgICAgICAgICAgICBwcy5wdXNoKHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBwcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobiA8IDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRBc0JveCgxLjAsIDEuMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBjb252ZXggaHVsbCB1c2luZyB0aGUgR2lmdCB3cmFwcGluZyBhbGdvcml0aG1cbiAgICAgICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2lmdF93cmFwcGluZ19hbGdvcml0aG1cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHJpZ2h0IG1vc3QgcG9pbnQgb24gdGhlIGh1bGwgKGluIGNhc2Ugb2YgbXVsdGlwbGUgcG9pbnRzIGJvdHRvbSBtb3N0IGlzIHVzZWQpXG4gICAgICAgICAgICB2YXIgaTAgPSAwO1xuICAgICAgICAgICAgdmFyIHgwID0gcHNbMF0ueDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBwc1tpXS54O1xuICAgICAgICAgICAgICAgIGlmICh4ID4geDAgfHwgKHggPT09IHgwICYmIHBzW2ldLnkgPCBwc1tpMF0ueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaTAgPSBpO1xuICAgICAgICAgICAgICAgICAgICB4MCA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGh1bGwgPSBbXTsgLy8gW1NldHRpbmdzLm1heFBvbHlnb25WZXJ0aWNlc107XG4gICAgICAgICAgICB2YXIgbSA9IDA7XG4gICAgICAgICAgICB2YXIgaWggPSBpMDtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaHVsbFttXSA9IGloO1xuICAgICAgICAgICAgICAgIHZhciBpZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGllID09PSBpaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWUgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBWZWMyLnN1Yihwc1tpZV0sIHBzW2h1bGxbbV1dKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBWZWMyLnN1Yihwc1tqXSwgcHNbaHVsbFttXV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IFZlYzIuY3Jvc3NWZWMyVmVjMihyLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYyA8IDAgbWVhbnMgY291bnRlci1jbG9ja3dpc2Ugd3JhcHBpbmcsIGMgPiAwIG1lYW5zIGNsb2Nrd2lzZSB3cmFwcGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA8IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWUgPSBqO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbGxpbmVhcml0eSBjaGVja1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gMC4wICYmIHYubGVuZ3RoU3F1YXJlZCgpID4gci5sZW5ndGhTcXVhcmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGllID0gajtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK207XG4gICAgICAgICAgICAgICAgaWggPSBpZTtcbiAgICAgICAgICAgICAgICBpZiAoaWUgPT09IGkwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtIDwgMykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEFzQm94KDEuMCwgMS4wKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fY291bnQgPSBtO1xuICAgICAgICAgICAgLy8gQ29weSB2ZXJ0aWNlcy5cbiAgICAgICAgICAgIHRoaXMubV92ZXJ0aWNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdmVydGljZXNbaV0gPSBwc1todWxsW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgbm9ybWFscy4gRW5zdXJlIHRoZSBlZGdlcyBoYXZlIG5vbi16ZXJvIGxlbmd0aC5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkxID0gaTtcbiAgICAgICAgICAgICAgICB2YXIgaTIgPSBpICsgMSA8IG0gPyBpICsgMSA6IDA7XG4gICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBWZWMyLnN1Yih0aGlzLm1fdmVydGljZXNbaTJdLCB0aGlzLm1fdmVydGljZXNbaTFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbm9ybWFsc1tpXSA9IFZlYzIuY3Jvc3NWZWMyTnVtKGVkZ2UsIDEuMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX25vcm1hbHNbaV0ubm9ybWFsaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBwb2x5Z29uIGNlbnRyb2lkLlxuICAgICAgICAgICAgdGhpcy5tX2NlbnRyb2lkID0gQ29tcHV0ZUNlbnRyb2lkKHRoaXMubV92ZXJ0aWNlcywgbSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUG9seWdvblNoYXBlLnByb3RvdHlwZS5fc2V0QXNCb3ggPSBmdW5jdGlvbiAoaHgsIGh5LCBjZW50ZXIsIGFuZ2xlKSB7XG4gICAgICAgICAgICAvLyBzdGFydCB3aXRoIHJpZ2h0LWJvdHRvbSwgY291bnRlci1jbG9ja3dpc2UsIGFzIGluIEdpZnQgd3JhcHBpbmcgYWxnb3JpdGhtIGluIFBvbHlnb25TaGFwZS5fc2V0KClcbiAgICAgICAgICAgIHRoaXMubV92ZXJ0aWNlc1swXSA9IFZlYzIubmVvKGh4LCAtaHkpO1xuICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzWzFdID0gVmVjMi5uZW8oaHgsIGh5KTtcbiAgICAgICAgICAgIHRoaXMubV92ZXJ0aWNlc1syXSA9IFZlYzIubmVvKC1oeCwgaHkpO1xuICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzWzNdID0gVmVjMi5uZW8oLWh4LCAtaHkpO1xuICAgICAgICAgICAgdGhpcy5tX25vcm1hbHNbMF0gPSBWZWMyLm5lbygxLjAsIDAuMCk7XG4gICAgICAgICAgICB0aGlzLm1fbm9ybWFsc1sxXSA9IFZlYzIubmVvKDAuMCwgMS4wKTtcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWxzWzJdID0gVmVjMi5uZW8oLTEuMCwgMC4wKTtcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWxzWzNdID0gVmVjMi5uZW8oMC4wLCAtMS4wKTtcbiAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IDQ7XG4gICAgICAgICAgICBpZiAoVmVjMi5pc1ZhbGlkKGNlbnRlcikpIHtcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGFuZ2xlIHx8IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2NlbnRyb2lkLnNldFZlYzIoY2VudGVyKTtcbiAgICAgICAgICAgICAgICB2YXIgeGYgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgICAgICAgICB4Zi5wLnNldFZlYzIoY2VudGVyKTtcbiAgICAgICAgICAgICAgICB4Zi5xLnNldEFuZ2xlKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdmVydGljZXMgYW5kIG5vcm1hbHMuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fdmVydGljZXNbaV0gPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZiwgdGhpcy5tX3ZlcnRpY2VzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX25vcm1hbHNbaV0gPSBSb3QubXVsVmVjMih4Zi5xLCB0aGlzLm1fbm9ybWFsc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCBhIHBvaW50IGZvciBjb250YWlubWVudCBpbiB0aGlzIHNoYXBlLiBUaGlzIG9ubHkgd29ya3MgZm9yIGNvbnZleFxuICAgICAgICAgKiBzaGFwZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB4ZiBUaGUgc2hhcGUgd29ybGQgdHJhbnNmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gcCBBIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgUG9seWdvblNoYXBlLnByb3RvdHlwZS50ZXN0UG9pbnQgPSBmdW5jdGlvbiAoeGYsIHApIHtcbiAgICAgICAgICAgIHZhciBwTG9jYWwgPSBSb3QubXVsVFZlYzIoeGYucSwgVmVjMi5zdWIocCwgeGYucCkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBkb3QgPSBWZWMyLmRvdCh0aGlzLm1fbm9ybWFsc1tpXSwgVmVjMi5zdWIocExvY2FsLCB0aGlzLm1fdmVydGljZXNbaV0pKTtcbiAgICAgICAgICAgICAgICBpZiAoZG90ID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhc3QgYSByYXkgYWdhaW5zdCBhIGNoaWxkIHNoYXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb3V0cHV0IFRoZSByYXktY2FzdCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIHJheS1jYXN0IGlucHV0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB4ZiBUaGUgdHJhbnNmb3JtIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNoYXBlLlxuICAgICAgICAgKiBAcGFyYW0gY2hpbGRJbmRleCBUaGUgY2hpbGQgc2hhcGUgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIFBvbHlnb25TaGFwZS5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uIChvdXRwdXQsIGlucHV0LCB4ZiwgY2hpbGRJbmRleCkge1xuICAgICAgICAgICAgLy8gUHV0IHRoZSByYXkgaW50byB0aGUgcG9seWdvbidzIGZyYW1lIG9mIHJlZmVyZW5jZS5cbiAgICAgICAgICAgIHZhciBwMSA9IFJvdC5tdWxUVmVjMih4Zi5xLCBWZWMyLnN1YihpbnB1dC5wMSwgeGYucCkpO1xuICAgICAgICAgICAgdmFyIHAyID0gUm90Lm11bFRWZWMyKHhmLnEsIFZlYzIuc3ViKGlucHV0LnAyLCB4Zi5wKSk7XG4gICAgICAgICAgICB2YXIgZCA9IFZlYzIuc3ViKHAyLCBwMSk7XG4gICAgICAgICAgICB2YXIgbG93ZXIgPSAwLjA7XG4gICAgICAgICAgICB2YXIgdXBwZXIgPSBpbnB1dC5tYXhGcmFjdGlvbjtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIHAgPSBwMSArIGEgKiBkXG4gICAgICAgICAgICAgICAgLy8gZG90KG5vcm1hbCwgcCAtIHYpID0gMFxuICAgICAgICAgICAgICAgIC8vIGRvdChub3JtYWwsIHAxIC0gdikgKyBhICogZG90KG5vcm1hbCwgZCkgPSAwXG4gICAgICAgICAgICAgICAgdmFyIG51bWVyYXRvciA9IFZlYzIuZG90KHRoaXMubV9ub3JtYWxzW2ldLCBWZWMyLnN1Yih0aGlzLm1fdmVydGljZXNbaV0sIHAxKSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gVmVjMi5kb3QodGhpcy5tX25vcm1hbHNbaV0sIGQpO1xuICAgICAgICAgICAgICAgIGlmIChkZW5vbWluYXRvciA9PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bWVyYXRvciA8IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiB3ZSB3YW50IHRoaXMgcHJlZGljYXRlIHdpdGhvdXQgZGl2aXNpb246XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvd2VyIDwgbnVtZXJhdG9yIC8gZGVub21pbmF0b3IsIHdoZXJlIGRlbm9taW5hdG9yIDwgMFxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSBkZW5vbWluYXRvciA8IDAsIHdlIGhhdmUgdG8gZmxpcCB0aGUgaW5lcXVhbGl0eTpcbiAgICAgICAgICAgICAgICAgICAgLy8gbG93ZXIgPCBudW1lcmF0b3IgLyBkZW5vbWluYXRvciA8PT0+IGRlbm9taW5hdG9yICogbG93ZXIgPiBudW1lcmF0b3IuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZW5vbWluYXRvciA8IDAuMCAmJiBudW1lcmF0b3IgPCBsb3dlciAqIGRlbm9taW5hdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNyZWFzZSBsb3dlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzZWdtZW50IGVudGVycyB0aGlzIGhhbGYtc3BhY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlciA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlbm9taW5hdG9yID4gMC4wICYmIG51bWVyYXRvciA8IHVwcGVyICogZGVub21pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlY3JlYXNlIHVwcGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNlZ21lbnQgZXhpdHMgdGhpcyBoYWxmLXNwYWNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXIgPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgdXNlIG9mIGVwc2lsb24gaGVyZSBjYXVzZXMgdGhlIGFzc2VydCBvbiBsb3dlciB0byB0cmlwXG4gICAgICAgICAgICAgICAgLy8gaW4gc29tZSBjYXNlcy4gQXBwYXJlbnRseSB0aGUgdXNlIG9mIGVwc2lsb24gd2FzIHRvIG1ha2UgZWRnZVxuICAgICAgICAgICAgICAgIC8vIHNoYXBlcyB3b3JrLCBidXQgbm93IHRob3NlIGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkuXG4gICAgICAgICAgICAgICAgLy8gaWYgKHVwcGVyIDwgbG93ZXIgLSBNYXRoLkVQU0lMT04pXG4gICAgICAgICAgICAgICAgaWYgKHVwcGVyIDwgbG93ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmZyYWN0aW9uID0gbG93ZXI7XG4gICAgICAgICAgICAgICAgb3V0cHV0Lm5vcm1hbCA9IFJvdC5tdWxWZWMyKHhmLnEsIHRoaXMubV9ub3JtYWxzW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIHRyYW5zZm9ybSwgY29tcHV0ZSB0aGUgYXNzb2NpYXRlZCBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhXG4gICAgICAgICAqIGNoaWxkIHNoYXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYWFiYiBSZXR1cm5zIHRoZSBheGlzIGFsaWduZWQgYm94LlxuICAgICAgICAgKiBAcGFyYW0geGYgVGhlIHdvcmxkIHRyYW5zZm9ybSBvZiB0aGUgc2hhcGUuXG4gICAgICAgICAqIEBwYXJhbSBjaGlsZEluZGV4IFRoZSBjaGlsZCBzaGFwZVxuICAgICAgICAgKi9cbiAgICAgICAgUG9seWdvblNoYXBlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uIChhYWJiLCB4ZiwgY2hpbGRJbmRleCkge1xuICAgICAgICAgICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gVHJhbnNmb3JtLm11bFZlYzIoeGYsIHRoaXMubV92ZXJ0aWNlc1tpXSk7XG4gICAgICAgICAgICAgICAgbWluWCA9IG1hdGgkMS5taW4obWluWCwgdi54KTtcbiAgICAgICAgICAgICAgICBtYXhYID0gbWF0aCQxLm1heChtYXhYLCB2LngpO1xuICAgICAgICAgICAgICAgIG1pblkgPSBtYXRoJDEubWluKG1pblksIHYueSk7XG4gICAgICAgICAgICAgICAgbWF4WSA9IG1hdGgkMS5tYXgobWF4WSwgdi55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFhYmIubG93ZXJCb3VuZC5zZXROdW0obWluWCwgbWluWSk7XG4gICAgICAgICAgICBhYWJiLnVwcGVyQm91bmQuc2V0TnVtKG1heFgsIG1heFkpO1xuICAgICAgICAgICAgYWFiYi5leHRlbmQodGhpcy5tX3JhZGl1cyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wdXRlIHRoZSBtYXNzIHByb3BlcnRpZXMgb2YgdGhpcyBzaGFwZSB1c2luZyBpdHMgZGltZW5zaW9ucyBhbmQgZGVuc2l0eS5cbiAgICAgICAgICogVGhlIGluZXJ0aWEgdGVuc29yIGlzIGNvbXB1dGVkIGFib3V0IHRoZSBsb2NhbCBvcmlnaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBtYXNzRGF0YSBSZXR1cm5zIHRoZSBtYXNzIGRhdGEgZm9yIHRoaXMgc2hhcGUuXG4gICAgICAgICAqIEBwYXJhbSBkZW5zaXR5IFRoZSBkZW5zaXR5IGluIGtpbG9ncmFtcyBwZXIgbWV0ZXIgc3F1YXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIFBvbHlnb25TaGFwZS5wcm90b3R5cGUuY29tcHV0ZU1hc3MgPSBmdW5jdGlvbiAobWFzc0RhdGEsIGRlbnNpdHkpIHtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIHZhciBhcmVhID0gMC4wO1xuICAgICAgICAgICAgdmFyIEkgPSAwLjA7XG4gICAgICAgICAgICAvLyBzIGlzIHRoZSByZWZlcmVuY2UgcG9pbnQgZm9yIGZvcm1pbmcgdHJpYW5nbGVzLlxuICAgICAgICAgICAgLy8gSXQncyBsb2NhdGlvbiBkb2Vzbid0IGNoYW5nZSB0aGUgcmVzdWx0IChleGNlcHQgZm9yIHJvdW5kaW5nIGVycm9yKS5cbiAgICAgICAgICAgIHZhciBzID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAvLyBUaGlzIGNvZGUgd291bGQgcHV0IHRoZSByZWZlcmVuY2UgcG9pbnQgaW5zaWRlIHRoZSBwb2x5Z29uLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHMuYWRkKHRoaXMubV92ZXJ0aWNlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzLm11bCgxLjAgLyB0aGlzLm1fY291bnQpO1xuICAgICAgICAgICAgdmFyIGtfaW52MyA9IDEuMCAvIDMuMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmlhbmdsZSB2ZXJ0aWNlcy5cbiAgICAgICAgICAgICAgICB2YXIgZTEgPSBWZWMyLnN1Yih0aGlzLm1fdmVydGljZXNbaV0sIHMpO1xuICAgICAgICAgICAgICAgIHZhciBlMiA9IGkgKyAxIDwgdGhpcy5tX2NvdW50ID8gVmVjMi5zdWIodGhpcy5tX3ZlcnRpY2VzW2kgKyAxXSwgcykgOiBWZWMyLnN1Yih0aGlzLm1fdmVydGljZXNbMF0sIHMpO1xuICAgICAgICAgICAgICAgIHZhciBEID0gVmVjMi5jcm9zc1ZlYzJWZWMyKGUxLCBlMik7XG4gICAgICAgICAgICAgICAgdmFyIHRyaWFuZ2xlQXJlYSA9IDAuNSAqIEQ7XG4gICAgICAgICAgICAgICAgYXJlYSArPSB0cmlhbmdsZUFyZWE7XG4gICAgICAgICAgICAgICAgLy8gQXJlYSB3ZWlnaHRlZCBjZW50cm9pZFxuICAgICAgICAgICAgICAgIGNlbnRlci5hZGRDb21iaW5lKHRyaWFuZ2xlQXJlYSAqIGtfaW52MywgZTEsIHRyaWFuZ2xlQXJlYSAqIGtfaW52MywgZTIpO1xuICAgICAgICAgICAgICAgIHZhciBleDEgPSBlMS54O1xuICAgICAgICAgICAgICAgIHZhciBleTEgPSBlMS55O1xuICAgICAgICAgICAgICAgIHZhciBleDIgPSBlMi54O1xuICAgICAgICAgICAgICAgIHZhciBleTIgPSBlMi55O1xuICAgICAgICAgICAgICAgIHZhciBpbnR4MiA9IGV4MSAqIGV4MSArIGV4MiAqIGV4MSArIGV4MiAqIGV4MjtcbiAgICAgICAgICAgICAgICB2YXIgaW50eTIgPSBleTEgKiBleTEgKyBleTIgKiBleTEgKyBleTIgKiBleTI7XG4gICAgICAgICAgICAgICAgSSArPSAoMC4yNSAqIGtfaW52MyAqIEQpICogKGludHgyICsgaW50eTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVG90YWwgbWFzc1xuICAgICAgICAgICAgbWFzc0RhdGEubWFzcyA9IGRlbnNpdHkgKiBhcmVhO1xuICAgICAgICAgICAgY2VudGVyLm11bCgxLjAgLyBhcmVhKTtcbiAgICAgICAgICAgIG1hc3NEYXRhLmNlbnRlci5zZXRDb21iaW5lKDEsIGNlbnRlciwgMSwgcyk7XG4gICAgICAgICAgICAvLyBJbmVydGlhIHRlbnNvciByZWxhdGl2ZSB0byB0aGUgbG9jYWwgb3JpZ2luIChwb2ludCBzKS5cbiAgICAgICAgICAgIG1hc3NEYXRhLkkgPSBkZW5zaXR5ICogSTtcbiAgICAgICAgICAgIC8vIFNoaWZ0IHRvIGNlbnRlciBvZiBtYXNzIHRoZW4gdG8gb3JpZ2luYWwgYm9keSBvcmlnaW4uXG4gICAgICAgICAgICBtYXNzRGF0YS5JICs9IG1hc3NEYXRhLm1hc3MgKiAoVmVjMi5kb3QobWFzc0RhdGEuY2VudGVyLCBtYXNzRGF0YS5jZW50ZXIpIC0gVmVjMi5kb3QoY2VudGVyLCBjZW50ZXIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkYXRlIGNvbnZleGl0eS4gVGhpcyBpcyBhIHZlcnkgdGltZSBjb25zdW1pbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHZhbGlkXG4gICAgICAgICAqL1xuICAgICAgICBQb2x5Z29uU2hhcGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpMSA9IGk7XG4gICAgICAgICAgICAgICAgdmFyIGkyID0gaSA8IHRoaXMubV9jb3VudCAtIDEgPyBpMSArIDEgOiAwO1xuICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy5tX3ZlcnRpY2VzW2kxXTtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IFZlYzIuc3ViKHRoaXMubV92ZXJ0aWNlc1tpMl0sIHApO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5tX2NvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT0gaTEgfHwgaiA9PSBpMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBWZWMyLnN1Yih0aGlzLm1fdmVydGljZXNbal0sIHApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IFZlYzIuY3Jvc3NWZWMyVmVjMihlLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPCAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBQb2x5Z29uU2hhcGUucHJvdG90eXBlLmNvbXB1dGVEaXN0YW5jZVByb3h5ID0gZnVuY3Rpb24gKHByb3h5KSB7XG4gICAgICAgICAgICBwcm94eS5tX3ZlcnRpY2VzID0gdGhpcy5tX3ZlcnRpY2VzO1xuICAgICAgICAgICAgcHJveHkubV9jb3VudCA9IHRoaXMubV9jb3VudDtcbiAgICAgICAgICAgIHByb3h5Lm1fcmFkaXVzID0gdGhpcy5tX3JhZGl1cztcbiAgICAgICAgfTtcbiAgICAgICAgUG9seWdvblNoYXBlLlRZUEUgPSAncG9seWdvbic7XG4gICAgICAgIHJldHVybiBQb2x5Z29uU2hhcGU7XG4gICAgfShTaGFwZSkpO1xuICAgIGZ1bmN0aW9uIENvbXB1dGVDZW50cm9pZCh2cywgY291bnQpIHtcbiAgICAgICAgdmFyIGMgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgdmFyIGFyZWEgPSAwLjA7XG4gICAgICAgIC8vIHBSZWYgaXMgdGhlIHJlZmVyZW5jZSBwb2ludCBmb3IgZm9ybWluZyB0cmlhbmdsZXMuXG4gICAgICAgIC8vIEl0J3MgbG9jYXRpb24gZG9lc24ndCBjaGFuZ2UgdGhlIHJlc3VsdCAoZXhjZXB0IGZvciByb3VuZGluZyBlcnJvcikuXG4gICAgICAgIHZhciBwUmVmID0gVmVjMi56ZXJvKCk7XG4gICAgICAgIHZhciBpOyBcbiAgICAgICAgdmFyIGludjMgPSAxLjAgLyAzLjA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgLy8gVHJpYW5nbGUgdmVydGljZXMuXG4gICAgICAgICAgICB2YXIgcDEgPSBwUmVmO1xuICAgICAgICAgICAgdmFyIHAyID0gdnNbaV07XG4gICAgICAgICAgICB2YXIgcDMgPSBpICsgMSA8IGNvdW50ID8gdnNbaSArIDFdIDogdnNbMF07XG4gICAgICAgICAgICB2YXIgZTEgPSBWZWMyLnN1YihwMiwgcDEpO1xuICAgICAgICAgICAgdmFyIGUyID0gVmVjMi5zdWIocDMsIHAxKTtcbiAgICAgICAgICAgIHZhciBEID0gVmVjMi5jcm9zc1ZlYzJWZWMyKGUxLCBlMik7XG4gICAgICAgICAgICB2YXIgdHJpYW5nbGVBcmVhID0gMC41ICogRDtcbiAgICAgICAgICAgIGFyZWEgKz0gdHJpYW5nbGVBcmVhO1xuICAgICAgICAgICAgLy8gQXJlYSB3ZWlnaHRlZCBjZW50cm9pZFxuICAgICAgICAgICAgYy5hZGRNdWwodHJpYW5nbGVBcmVhICogaW52MywgcDEpO1xuICAgICAgICAgICAgYy5hZGRNdWwodHJpYW5nbGVBcmVhICogaW52MywgcDIpO1xuICAgICAgICAgICAgYy5hZGRNdWwodHJpYW5nbGVBcmVhICogaW52MywgcDMpO1xuICAgICAgICB9XG4gICAgICAgIGMubXVsKDEuMCAvIGFyZWEpO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQSByZWN0YW5nbGUgcG9seWdvbiB3aGljaCBleHRlbmQgUG9seWdvblNoYXBlLlxuICAgICAqL1xuICAgIHZhciBCb3hTaGFwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEJveFNoYXBlLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBCb3hTaGFwZShoeCwgaHksIGNlbnRlciwgYW5nbGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoIShfdGhpcyBpbnN0YW5jZW9mIEJveFNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQm94U2hhcGUoaHgsIGh5LCBjZW50ZXIsIGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLl9zZXRBc0JveChoeCwgaHksIGNlbnRlciwgYW5nbGUpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIEJveFNoYXBlLlRZUEUgPSAncG9seWdvbic7XG4gICAgICAgIHJldHVybiBCb3hTaGFwZTtcbiAgICB9KFBvbHlnb25TaGFwZSkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIHZhciBDaXJjbGVTaGFwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKENpcmNsZVNoYXBlLCBfc3VwZXIpO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHlwZWRlZlxuICAgICAgICBmdW5jdGlvbiBDaXJjbGVTaGFwZShhLCBiKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBDaXJjbGVTaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENpcmNsZVNoYXBlKGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlID0gQ2lyY2xlU2hhcGUuVFlQRTtcbiAgICAgICAgICAgIF90aGlzLm1fcCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgX3RoaXMubV9yYWRpdXMgPSAxO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBWZWMyLmlzVmFsaWQoYSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX3Auc2V0VmVjMihhKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1fcmFkaXVzID0gYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX3JhZGl1cyA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBDaXJjbGVTaGFwZS5wcm90b3R5cGUuX3NlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5tX3R5cGUsXG4gICAgICAgICAgICAgICAgcDogdGhpcy5tX3AsXG4gICAgICAgICAgICAgICAgcmFkaXVzOiB0aGlzLm1fcmFkaXVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBDaXJjbGVTaGFwZS5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGVTaGFwZShkYXRhLnAsIGRhdGEucmFkaXVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETzogYWxyZWFkeSBkZWZpbmVkIGluIFNoYXBlXG4gICAgICAgIENpcmNsZVNoYXBlLnByb3RvdHlwZS5nZXRSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3JhZGl1cztcbiAgICAgICAgfTtcbiAgICAgICAgQ2lyY2xlU2hhcGUucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fcDtcbiAgICAgICAgfTtcbiAgICAgICAgQ2lyY2xlU2hhcGUucHJvdG90eXBlLmdldFZlcnRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9wO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFNoYXBlcyBzaG91bGQgYmUgdHJlYXRlZCBhcyBpbW11dGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIGNsb25lIHRoZSBjb25jcmV0ZSBzaGFwZS5cbiAgICAgICAgICovXG4gICAgICAgIENpcmNsZVNoYXBlLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBuZXcgQ2lyY2xlU2hhcGUoKTtcbiAgICAgICAgICAgIGNsb25lLm1fdHlwZSA9IHRoaXMubV90eXBlO1xuICAgICAgICAgICAgY2xvbmUubV9yYWRpdXMgPSB0aGlzLm1fcmFkaXVzO1xuICAgICAgICAgICAgY2xvbmUubV9wID0gdGhpcy5tX3AuY2xvbmUoKTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGNoaWxkIHByaW1pdGl2ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBDaXJjbGVTaGFwZS5wcm90b3R5cGUuZ2V0Q2hpbGRDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCBhIHBvaW50IGZvciBjb250YWlubWVudCBpbiB0aGlzIHNoYXBlLiBUaGlzIG9ubHkgd29ya3MgZm9yIGNvbnZleFxuICAgICAgICAgKiBzaGFwZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB4ZiBUaGUgc2hhcGUgd29ybGQgdHJhbnNmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gcCBBIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2lyY2xlU2hhcGUucHJvdG90eXBlLnRlc3RQb2ludCA9IGZ1bmN0aW9uICh4ZiwgcCkge1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IFZlYzIuYWRkKHhmLnAsIFJvdC5tdWxWZWMyKHhmLnEsIHRoaXMubV9wKSk7XG4gICAgICAgICAgICB2YXIgZCA9IFZlYzIuc3ViKHAsIGNlbnRlcik7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5kb3QoZCwgZCkgPD0gdGhpcy5tX3JhZGl1cyAqIHRoaXMubV9yYWRpdXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXN0IGEgcmF5IGFnYWluc3QgYSBjaGlsZCBzaGFwZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG91dHB1dCBUaGUgcmF5LWNhc3QgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIGlucHV0IFRoZSByYXktY2FzdCBpbnB1dCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geGYgVGhlIHRyYW5zZm9ybSB0byBiZSBhcHBsaWVkIHRvIHRoZSBzaGFwZS5cbiAgICAgICAgICogQHBhcmFtIGNoaWxkSW5kZXggVGhlIGNoaWxkIHNoYXBlIGluZGV4XG4gICAgICAgICAqL1xuICAgICAgICBDaXJjbGVTaGFwZS5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uIChvdXRwdXQsIGlucHV0LCB4ZiwgY2hpbGRJbmRleCkge1xuICAgICAgICAgICAgLy8gQ29sbGlzaW9uIERldGVjdGlvbiBpbiBJbnRlcmFjdGl2ZSAzRCBFbnZpcm9ubWVudHMgYnkgR2lubyB2YW4gZGVuIEJlcmdlblxuICAgICAgICAgICAgLy8gRnJvbSBTZWN0aW9uIDMuMS4yXG4gICAgICAgICAgICAvLyB4ID0gcyArIGEgKiByXG4gICAgICAgICAgICAvLyBub3JtKHgpID0gcmFkaXVzXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBWZWMyLmFkZCh4Zi5wLCBSb3QubXVsVmVjMih4Zi5xLCB0aGlzLm1fcCkpO1xuICAgICAgICAgICAgdmFyIHMgPSBWZWMyLnN1YihpbnB1dC5wMSwgcG9zaXRpb24pO1xuICAgICAgICAgICAgdmFyIGIgPSBWZWMyLmRvdChzLCBzKSAtIHRoaXMubV9yYWRpdXMgKiB0aGlzLm1fcmFkaXVzO1xuICAgICAgICAgICAgLy8gU29sdmUgcXVhZHJhdGljIGVxdWF0aW9uLlxuICAgICAgICAgICAgdmFyIHIgPSBWZWMyLnN1YihpbnB1dC5wMiwgaW5wdXQucDEpO1xuICAgICAgICAgICAgdmFyIGMgPSBWZWMyLmRvdChzLCByKTtcbiAgICAgICAgICAgIHZhciByciA9IFZlYzIuZG90KHIsIHIpO1xuICAgICAgICAgICAgdmFyIHNpZ21hID0gYyAqIGMgLSByciAqIGI7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgbmVnYXRpdmUgZGlzY3JpbWluYW50IGFuZCBzaG9ydCBzZWdtZW50LlxuICAgICAgICAgICAgaWYgKHNpZ21hIDwgMC4wIHx8IHJyIDwgbWF0aCQxLkVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb24gb2YgdGhlIGxpbmUgd2l0aCB0aGUgY2lyY2xlLlxuICAgICAgICAgICAgdmFyIGEgPSAtKGMgKyBtYXRoJDEuc3FydChzaWdtYSkpO1xuICAgICAgICAgICAgLy8gSXMgdGhlIGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgc2VnbWVudD9cbiAgICAgICAgICAgIGlmICgwLjAgPD0gYSAmJiBhIDw9IGlucHV0Lm1heEZyYWN0aW9uICogcnIpIHtcbiAgICAgICAgICAgICAgICBhIC89IHJyO1xuICAgICAgICAgICAgICAgIG91dHB1dC5mcmFjdGlvbiA9IGE7XG4gICAgICAgICAgICAgICAgb3V0cHV0Lm5vcm1hbCA9IFZlYzIuYWRkKHMsIFZlYzIubXVsTnVtVmVjMihhLCByKSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0Lm5vcm1hbC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgdHJhbnNmb3JtLCBjb21wdXRlIHRoZSBhc3NvY2lhdGVkIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIGFcbiAgICAgICAgICogY2hpbGQgc2hhcGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBhYWJiIFJldHVybnMgdGhlIGF4aXMgYWxpZ25lZCBib3guXG4gICAgICAgICAqIEBwYXJhbSB4ZiBUaGUgd29ybGQgdHJhbnNmb3JtIG9mIHRoZSBzaGFwZS5cbiAgICAgICAgICogQHBhcmFtIGNoaWxkSW5kZXggVGhlIGNoaWxkIHNoYXBlXG4gICAgICAgICAqL1xuICAgICAgICBDaXJjbGVTaGFwZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAoYWFiYiwgeGYsIGNoaWxkSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBwID0gVmVjMi5hZGQoeGYucCwgUm90Lm11bFZlYzIoeGYucSwgdGhpcy5tX3ApKTtcbiAgICAgICAgICAgIGFhYmIubG93ZXJCb3VuZC5zZXROdW0ocC54IC0gdGhpcy5tX3JhZGl1cywgcC55IC0gdGhpcy5tX3JhZGl1cyk7XG4gICAgICAgICAgICBhYWJiLnVwcGVyQm91bmQuc2V0TnVtKHAueCArIHRoaXMubV9yYWRpdXMsIHAueSArIHRoaXMubV9yYWRpdXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHV0ZSB0aGUgbWFzcyBwcm9wZXJ0aWVzIG9mIHRoaXMgc2hhcGUgdXNpbmcgaXRzIGRpbWVuc2lvbnMgYW5kIGRlbnNpdHkuXG4gICAgICAgICAqIFRoZSBpbmVydGlhIHRlbnNvciBpcyBjb21wdXRlZCBhYm91dCB0aGUgbG9jYWwgb3JpZ2luLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbWFzc0RhdGEgUmV0dXJucyB0aGUgbWFzcyBkYXRhIGZvciB0aGlzIHNoYXBlLlxuICAgICAgICAgKiBAcGFyYW0gZGVuc2l0eSBUaGUgZGVuc2l0eSBpbiBraWxvZ3JhbXMgcGVyIG1ldGVyIHNxdWFyZWQuXG4gICAgICAgICAqL1xuICAgICAgICBDaXJjbGVTaGFwZS5wcm90b3R5cGUuY29tcHV0ZU1hc3MgPSBmdW5jdGlvbiAobWFzc0RhdGEsIGRlbnNpdHkpIHtcbiAgICAgICAgICAgIG1hc3NEYXRhLm1hc3MgPSBkZW5zaXR5ICogbWF0aCQxLlBJICogdGhpcy5tX3JhZGl1cyAqIHRoaXMubV9yYWRpdXM7XG4gICAgICAgICAgICBtYXNzRGF0YS5jZW50ZXIgPSB0aGlzLm1fcDtcbiAgICAgICAgICAgIC8vIGluZXJ0aWEgYWJvdXQgdGhlIGxvY2FsIG9yaWdpblxuICAgICAgICAgICAgbWFzc0RhdGEuSSA9IG1hc3NEYXRhLm1hc3NcbiAgICAgICAgICAgICAgICAqICgwLjUgKiB0aGlzLm1fcmFkaXVzICogdGhpcy5tX3JhZGl1cyArIFZlYzIuZG90KHRoaXMubV9wLCB0aGlzLm1fcCkpO1xuICAgICAgICB9O1xuICAgICAgICBDaXJjbGVTaGFwZS5wcm90b3R5cGUuY29tcHV0ZURpc3RhbmNlUHJveHkgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgICAgICAgICAgIHByb3h5Lm1fdmVydGljZXMucHVzaCh0aGlzLm1fcCk7XG4gICAgICAgICAgICBwcm94eS5tX2NvdW50ID0gMTtcbiAgICAgICAgICAgIHByb3h5Lm1fcmFkaXVzID0gdGhpcy5tX3JhZGl1cztcbiAgICAgICAgfTtcbiAgICAgICAgQ2lyY2xlU2hhcGUuVFlQRSA9ICdjaXJjbGUnO1xuICAgICAgICByZXR1cm4gQ2lyY2xlU2hhcGU7XG4gICAgfShTaGFwZSkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIHZhciBERUZBVUxUUyRhID0ge1xuICAgICAgICBmcmVxdWVuY3lIejogMC4wLFxuICAgICAgICBkYW1waW5nUmF0aW86IDAuMFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBkaXN0YW5jZSBqb2ludCBjb25zdHJhaW5zIHR3byBwb2ludHMgb24gdHdvIGJvZGllcyB0byByZW1haW4gYXQgYSBmaXhlZFxuICAgICAqIGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlci4gWW91IGNhbiB2aWV3IHRoaXMgYXMgYSBtYXNzbGVzcywgcmlnaWQgcm9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFuY2hvckEgQW5jaG9yIEEgaW4gZ2xvYmFsIGNvb3JkaW5hdGlvbi5cbiAgICAgKiBAcGFyYW0gYW5jaG9yQiBBbmNob3IgQiBpbiBnbG9iYWwgY29vcmRpbmF0aW9uLlxuICAgICAqL1xuICAgIHZhciBEaXN0YW5jZUpvaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRGlzdGFuY2VKb2ludCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRGlzdGFuY2VKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yQSwgYW5jaG9yQikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmICghKF90aGlzIGluc3RhbmNlb2YgRGlzdGFuY2VKb2ludCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERpc3RhbmNlSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGFuY2hvckEsIGFuY2hvckIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3JkZXIgb2YgY29uc3RydWN0b3IgYXJndW1lbnRzIGlzIGNoYW5nZWQgaW4gdjAuMlxuICAgICAgICAgICAgaWYgKGJvZHlCICYmIGFuY2hvckEgJiYgKCdtX3R5cGUnIGluIGFuY2hvckEpICYmICgneCcgaW4gYm9keUIpICYmICgneScgaW4gYm9keUIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBib2R5QjtcbiAgICAgICAgICAgICAgICBib2R5QiA9IGFuY2hvckE7XG4gICAgICAgICAgICAgICAgYW5jaG9yQSA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWYgPSBvcHRpb25zKGRlZiwgREVGQVVMVFMkYSk7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgYm9keUEsIGJvZHlCKSB8fCB0aGlzO1xuICAgICAgICAgICAgYm9keUEgPSBfdGhpcy5tX2JvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSBfdGhpcy5tX2JvZHlCO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlID0gRGlzdGFuY2VKb2ludC5UWVBFO1xuICAgICAgICAgICAgLy8gU29sdmVyIHNoYXJlZFxuICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckEgPSBWZWMyLmNsb25lKGFuY2hvckEgPyBib2R5QS5nZXRMb2NhbFBvaW50KGFuY2hvckEpIDogZGVmLmxvY2FsQW5jaG9yQSB8fCBWZWMyLnplcm8oKSk7XG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQiA9IFZlYzIuY2xvbmUoYW5jaG9yQiA/IGJvZHlCLmdldExvY2FsUG9pbnQoYW5jaG9yQikgOiBkZWYubG9jYWxBbmNob3JCIHx8IFZlYzIuemVybygpKTtcbiAgICAgICAgICAgIF90aGlzLm1fbGVuZ3RoID0gbWF0aCQxLmlzRmluaXRlKGRlZi5sZW5ndGgpID8gZGVmLmxlbmd0aCA6XG4gICAgICAgICAgICAgICAgVmVjMi5kaXN0YW5jZShib2R5QS5nZXRXb3JsZFBvaW50KF90aGlzLm1fbG9jYWxBbmNob3JBKSwgYm9keUIuZ2V0V29ybGRQb2ludChfdGhpcy5tX2xvY2FsQW5jaG9yQikpO1xuICAgICAgICAgICAgX3RoaXMubV9mcmVxdWVuY3lIeiA9IGRlZi5mcmVxdWVuY3lIejtcbiAgICAgICAgICAgIF90aGlzLm1fZGFtcGluZ1JhdGlvID0gZGVmLmRhbXBpbmdSYXRpbztcbiAgICAgICAgICAgIF90aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIF90aGlzLm1fZ2FtbWEgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX2JpYXMgPSAwLjA7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAvLyAxLUQgY29uc3RyYWluZWQgc3lzdGVtXG4gICAgICAgICAgICAvLyBtICh2MiAtIHYxKSA9IGxhbWJkYVxuICAgICAgICAgICAgLy8gdjIgKyAoYmV0YS9oKSAqIHgxICsgZ2FtbWEgKiBsYW1iZGEgPSAwLCBnYW1tYSBoYXMgdW5pdHMgb2YgaW52ZXJzZSBtYXNzLlxuICAgICAgICAgICAgLy8geDIgPSB4MSArIGggKiB2MlxuICAgICAgICAgICAgLy8gMS1EIG1hc3MtZGFtcGVyLXNwcmluZyBzeXN0ZW1cbiAgICAgICAgICAgIC8vIG0gKHYyIC0gdjEpICsgaCAqIGQgKiB2MiArIGggKiBrICpcbiAgICAgICAgICAgIC8vIEMgPSBub3JtKHAyIC0gcDEpIC0gTFxuICAgICAgICAgICAgLy8gdSA9IChwMiAtIHAxKSAvIG5vcm0ocDIgLSBwMSlcbiAgICAgICAgICAgIC8vIENkb3QgPSBkb3QodSwgdjIgKyBjcm9zcyh3MiwgcjIpIC0gdjEgLSBjcm9zcyh3MSwgcjEpKVxuICAgICAgICAgICAgLy8gSiA9IFstdSAtY3Jvc3MocjEsIHUpIHUgY3Jvc3MocjIsIHUpXVxuICAgICAgICAgICAgLy8gSyA9IEogKiBpbnZNICogSlRcbiAgICAgICAgICAgIC8vID0gaW52TWFzczEgKyBpbnZJMSAqIGNyb3NzKHIxLCB1KV4yICsgaW52TWFzczIgKyBpbnZJMiAqIGNyb3NzKHIyLCB1KV4yXG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5fc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm1fdHlwZSxcbiAgICAgICAgICAgICAgICBib2R5QTogdGhpcy5tX2JvZHlBLFxuICAgICAgICAgICAgICAgIGJvZHlCOiB0aGlzLm1fYm9keUIsXG4gICAgICAgICAgICAgICAgY29sbGlkZUNvbm5lY3RlZDogdGhpcy5tX2NvbGxpZGVDb25uZWN0ZWQsXG4gICAgICAgICAgICAgICAgZnJlcXVlbmN5SHo6IHRoaXMubV9mcmVxdWVuY3lIeixcbiAgICAgICAgICAgICAgICBkYW1waW5nUmF0aW86IHRoaXMubV9kYW1waW5nUmF0aW8sXG4gICAgICAgICAgICAgICAgbG9jYWxBbmNob3JBOiB0aGlzLm1fbG9jYWxBbmNob3JBLFxuICAgICAgICAgICAgICAgIGxvY2FsQW5jaG9yQjogdGhpcy5tX2xvY2FsQW5jaG9yQixcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMubV9sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW1wdWxzZTogdGhpcy5tX2ltcHVsc2UsXG4gICAgICAgICAgICAgICAgZ2FtbWE6IHRoaXMubV9nYW1tYSxcbiAgICAgICAgICAgICAgICBiaWFzOiB0aGlzLm1fYmlhcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGlzdGFuY2VKb2ludC5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSwgd29ybGQsIHJlc3RvcmUpIHtcbiAgICAgICAgICAgIGRhdGEgPSBfX2Fzc2lnbih7fSwgZGF0YSk7XG4gICAgICAgICAgICBkYXRhLmJvZHlBID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlBLCB3b3JsZCk7XG4gICAgICAgICAgICBkYXRhLmJvZHlCID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlCLCB3b3JsZCk7XG4gICAgICAgICAgICB2YXIgam9pbnQgPSBuZXcgRGlzdGFuY2VKb2ludChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5fc2V0QW5jaG9ycyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgICAgIGlmIChkZWYuYW5jaG9yQSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckEuc2V0VmVjMih0aGlzLm1fYm9keUEuZ2V0TG9jYWxQb2ludChkZWYuYW5jaG9yQSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVmLmxvY2FsQW5jaG9yQSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckEuc2V0VmVjMihkZWYubG9jYWxBbmNob3JBKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWYuYW5jaG9yQikge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckIuc2V0VmVjMih0aGlzLm1fYm9keUIuZ2V0TG9jYWxQb2ludChkZWYuYW5jaG9yQikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVmLmxvY2FsQW5jaG9yQikge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckIuc2V0VmVjMihkZWYubG9jYWxBbmNob3JCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWYubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sZW5ndGggPSArZGVmLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZi5sZW5ndGggPCAwKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChkZWYuYW5jaG9yQSB8fCBkZWYuYW5jaG9yQSB8fCBkZWYuYW5jaG9yQSB8fCBkZWYuYW5jaG9yQSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sZW5ndGggPSBWZWMyLmRpc3RhbmNlKHRoaXMubV9ib2R5QS5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckEpLCB0aGlzLm1fYm9keUIuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JCKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlBJ3Mgb3JpZ2luLlxuICAgICAgICAgKi9cbiAgICAgICAgRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBbmNob3JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sb2NhbEFuY2hvckE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlCJ3Mgb3JpZ2luLlxuICAgICAgICAgKi9cbiAgICAgICAgRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sb2NhbEFuY2hvckI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG5hdHVyYWwgbGVuZ3RoLiBNYW5pcHVsYXRpbmcgdGhlIGxlbmd0aCBjYW4gbGVhZCB0byBub24tcGh5c2ljYWxcbiAgICAgICAgICogYmVoYXZpb3Igd2hlbiB0aGUgZnJlcXVlbmN5IGlzIHplcm8uXG4gICAgICAgICAqL1xuICAgICAgICBEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5zZXRMZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm1fbGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBuYXR1cmFsIGxlbmd0aC5cbiAgICAgICAgICovXG4gICAgICAgIERpc3RhbmNlSm9pbnQucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgICBEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5zZXRGcmVxdWVuY3kgPSBmdW5jdGlvbiAoaHopIHtcbiAgICAgICAgICAgIHRoaXMubV9mcmVxdWVuY3lIeiA9IGh6O1xuICAgICAgICB9O1xuICAgICAgICBEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5nZXRGcmVxdWVuY3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2ZyZXF1ZW5jeUh6O1xuICAgICAgICB9O1xuICAgICAgICBEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5zZXREYW1waW5nUmF0aW8gPSBmdW5jdGlvbiAocmF0aW8pIHtcbiAgICAgICAgICAgIHRoaXMubV9kYW1waW5nUmF0aW8gPSByYXRpbztcbiAgICAgICAgfTtcbiAgICAgICAgRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuZ2V0RGFtcGluZ1JhdGlvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9kYW1waW5nUmF0aW87XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QSBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIERpc3RhbmNlSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QiBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIERpc3RhbmNlSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlYWN0aW9uIGZvcmNlIG9uIGJvZHlCIGF0IHRoZSBqb2ludCBhbmNob3IgaW4gTmV3dG9ucy5cbiAgICAgICAgICovXG4gICAgICAgIERpc3RhbmNlSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5tdWxOdW1WZWMyKHRoaXMubV9pbXB1bHNlLCB0aGlzLm1fdSkubXVsKGludl9kdCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlYWN0aW9uIHRvcnF1ZSBvbiBib2R5QiBpbiBOKm0uXG4gICAgICAgICAqL1xuICAgICAgICBEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgIH07XG4gICAgICAgIERpc3RhbmNlSm9pbnQucHJvdG90eXBlLmluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbENlbnRlckEgPSB0aGlzLm1fYm9keUEubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbENlbnRlckIgPSB0aGlzLm1fYm9keUIubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgICAgIHRoaXMubV9pbnZNYXNzQSA9IHRoaXMubV9ib2R5QS5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzc0IgPSB0aGlzLm1fYm9keUIubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX2ludklBID0gdGhpcy5tX2JvZHlBLm1faW52STtcbiAgICAgICAgICAgIHRoaXMubV9pbnZJQiA9IHRoaXMubV9ib2R5Qi5tX2ludkk7XG4gICAgICAgICAgICB2YXIgY0EgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIGNCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciBxQSA9IFJvdC5uZW8oYUEpO1xuICAgICAgICAgICAgdmFyIHFCID0gUm90Lm5lbyhhQik7XG4gICAgICAgICAgICB0aGlzLm1fckEgPSBSb3QubXVsVmVjMihxQSwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xvY2FsQ2VudGVyQSkpO1xuICAgICAgICAgICAgdGhpcy5tX3JCID0gUm90Lm11bFZlYzIocUIsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sb2NhbENlbnRlckIpKTtcbiAgICAgICAgICAgIHRoaXMubV91ID0gVmVjMi5zdWIoVmVjMi5hZGQoY0IsIHRoaXMubV9yQiksIFZlYzIuYWRkKGNBLCB0aGlzLm1fckEpKTtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBzaW5ndWxhcml0eS5cbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLm1fdS5sZW5ndGgoKTtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPiBTZXR0aW5ncy5saW5lYXJTbG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3UubXVsKDEuMCAvIGxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdS5zZXROdW0oMC4wLCAwLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNyQXUgPSBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JBLCB0aGlzLm1fdSk7XG4gICAgICAgICAgICB2YXIgY3JCdSA9IFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckIsIHRoaXMubV91KTtcbiAgICAgICAgICAgIHZhciBpbnZNYXNzID0gdGhpcy5tX2ludk1hc3NBICsgdGhpcy5tX2ludklBICogY3JBdSAqIGNyQXUgKyB0aGlzLm1faW52TWFzc0JcbiAgICAgICAgICAgICAgICArIHRoaXMubV9pbnZJQiAqIGNyQnUgKiBjckJ1O1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MgbWF0cml4LlxuICAgICAgICAgICAgdGhpcy5tX21hc3MgPSBpbnZNYXNzICE9IDAuMCA/IDEuMCAvIGludk1hc3MgOiAwLjA7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2ZyZXF1ZW5jeUh6ID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgdmFyIEMgPSBsZW5ndGggLSB0aGlzLm1fbGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIEZyZXF1ZW5jeVxuICAgICAgICAgICAgICAgIHZhciBvbWVnYSA9IDIuMCAqIG1hdGgkMS5QSSAqIHRoaXMubV9mcmVxdWVuY3lIejtcbiAgICAgICAgICAgICAgICAvLyBEYW1waW5nIGNvZWZmaWNpZW50XG4gICAgICAgICAgICAgICAgdmFyIGQgPSAyLjAgKiB0aGlzLm1fbWFzcyAqIHRoaXMubV9kYW1waW5nUmF0aW8gKiBvbWVnYTtcbiAgICAgICAgICAgICAgICAvLyBTcHJpbmcgc3RpZmZuZXNzXG4gICAgICAgICAgICAgICAgdmFyIGsgPSB0aGlzLm1fbWFzcyAqIG9tZWdhICogb21lZ2E7XG4gICAgICAgICAgICAgICAgLy8gbWFnaWMgZm9ybXVsYXNcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHN0ZXAuZHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2dhbW1hID0gaCAqIChkICsgaCAqIGspO1xuICAgICAgICAgICAgICAgIHRoaXMubV9nYW1tYSA9IHRoaXMubV9nYW1tYSAhPSAwLjAgPyAxLjAgLyB0aGlzLm1fZ2FtbWEgOiAwLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JpYXMgPSBDICogaCAqIGsgKiB0aGlzLm1fZ2FtbWE7XG4gICAgICAgICAgICAgICAgaW52TWFzcyArPSB0aGlzLm1fZ2FtbWE7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21hc3MgPSBpbnZNYXNzICE9IDAuMCA/IDEuMCAvIGludk1hc3MgOiAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fZ2FtbWEgPSAwLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JpYXMgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBTY2FsZSB0aGUgaW1wdWxzZSB0byBzdXBwb3J0IGEgdmFyaWFibGUgdGltZSBzdGVwLlxuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIubXVsTnVtVmVjMih0aGlzLm1faW1wdWxzZSwgdGhpcy5tX3UpO1xuICAgICAgICAgICAgICAgIHZBLnN1Yk11bCh0aGlzLm1faW52TWFzc0EsIFApO1xuICAgICAgICAgICAgICAgIHdBIC09IHRoaXMubV9pbnZJQSAqIFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckEsIFApO1xuICAgICAgICAgICAgICAgIHZCLmFkZE11bCh0aGlzLm1faW52TWFzc0IsIFApO1xuICAgICAgICAgICAgICAgIHdCICs9IHRoaXMubV9pbnZJQiAqIFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckIsIFApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52LnNldFZlYzIodkEpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudi5zZXRWZWMyKHZCKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LncgPSB3QjtcbiAgICAgICAgfTtcbiAgICAgICAgRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICAvLyBDZG90ID0gZG90KHUsIHYgKyBjcm9zcyh3LCByKSlcbiAgICAgICAgICAgIHZhciB2cEEgPSBWZWMyLmFkZCh2QSwgVmVjMi5jcm9zc051bVZlYzIod0EsIHRoaXMubV9yQSkpO1xuICAgICAgICAgICAgdmFyIHZwQiA9IFZlYzIuYWRkKHZCLCBWZWMyLmNyb3NzTnVtVmVjMih3QiwgdGhpcy5tX3JCKSk7XG4gICAgICAgICAgICB2YXIgQ2RvdCA9IFZlYzIuZG90KHRoaXMubV91LCB2cEIpIC0gVmVjMi5kb3QodGhpcy5tX3UsIHZwQSk7XG4gICAgICAgICAgICB2YXIgaW1wdWxzZSA9IC10aGlzLm1fbWFzc1xuICAgICAgICAgICAgICAgICogKENkb3QgKyB0aGlzLm1fYmlhcyArIHRoaXMubV9nYW1tYSAqIHRoaXMubV9pbXB1bHNlKTtcbiAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlICs9IGltcHVsc2U7XG4gICAgICAgICAgICB2YXIgUCA9IFZlYzIubXVsTnVtVmVjMihpbXB1bHNlLCB0aGlzLm1fdSk7XG4gICAgICAgICAgICB2QS5zdWJNdWwodGhpcy5tX2ludk1hc3NBLCBQKTtcbiAgICAgICAgICAgIHdBIC09IHRoaXMubV9pbnZJQSAqIFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckEsIFApO1xuICAgICAgICAgICAgdkIuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgUCk7XG4gICAgICAgICAgICB3QiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBQKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYuc2V0VmVjMih2QSk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52LnNldFZlYzIodkIpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGVycm9ycyBhcmUgd2l0aGluIHRvbGVyYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIERpc3RhbmNlSm9pbnQucHJvdG90eXBlLnNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2ZyZXF1ZW5jeUh6ID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gcG9zaXRpb24gY29ycmVjdGlvbiBmb3Igc29mdCBkaXN0YW5jZSBjb25zdHJhaW50cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIGNCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICAgICAgICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgICAgICAgICAgdmFyIHJBID0gUm90Lm11bFN1YihxQSwgdGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xvY2FsQ2VudGVyQSk7XG4gICAgICAgICAgICB2YXIgckIgPSBSb3QubXVsU3ViKHFCLCB0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKTtcbiAgICAgICAgICAgIHZhciB1ID0gVmVjMi5zdWIoVmVjMi5hZGQoY0IsIHJCKSwgVmVjMi5hZGQoY0EsIHJBKSk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIHZhciBDID0gbGVuZ3RoIC0gdGhpcy5tX2xlbmd0aDtcbiAgICAgICAgICAgIEMgPSBtYXRoJDFcbiAgICAgICAgICAgICAgICAuY2xhbXAoQywgLVNldHRpbmdzLm1heExpbmVhckNvcnJlY3Rpb24sIFNldHRpbmdzLm1heExpbmVhckNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIGltcHVsc2UgPSAtdGhpcy5tX21hc3MgKiBDO1xuICAgICAgICAgICAgdmFyIFAgPSBWZWMyLm11bE51bVZlYzIoaW1wdWxzZSwgdSk7XG4gICAgICAgICAgICBjQS5zdWJNdWwodGhpcy5tX2ludk1hc3NBLCBQKTtcbiAgICAgICAgICAgIGFBIC09IHRoaXMubV9pbnZJQSAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyQSwgUCk7XG4gICAgICAgICAgICBjQi5hZGRNdWwodGhpcy5tX2ludk1hc3NCLCBQKTtcbiAgICAgICAgICAgIGFCICs9IHRoaXMubV9pbnZJQiAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyQiwgUCk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jLnNldFZlYzIoY0EpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYSA9IGFBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYy5zZXRWZWMyKGNCKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmEgPSBhQjtcbiAgICAgICAgICAgIHJldHVybiBtYXRoJDEuYWJzKEMpIDwgU2V0dGluZ3MubGluZWFyU2xvcDtcbiAgICAgICAgfTtcbiAgICAgICAgRGlzdGFuY2VKb2ludC5UWVBFID0gJ2Rpc3RhbmNlLWpvaW50JztcbiAgICAgICAgcmV0dXJuIERpc3RhbmNlSm9pbnQ7XG4gICAgfShKb2ludCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIHZhciBERUZBVUxUUyQ5ID0ge1xuICAgICAgICBtYXhGb3JjZTogMC4wLFxuICAgICAgICBtYXhUb3JxdWU6IDAuMCxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZyaWN0aW9uIGpvaW50LiBUaGlzIGlzIHVzZWQgZm9yIHRvcC1kb3duIGZyaWN0aW9uLiBJdCBwcm92aWRlcyAyRFxuICAgICAqIHRyYW5zbGF0aW9uYWwgZnJpY3Rpb24gYW5kIGFuZ3VsYXIgZnJpY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW5jaG9yIEFuY2hvciBpbiBnbG9iYWwgY29vcmRpbmF0aW9uLlxuICAgICAqL1xuICAgIHZhciBGcmljdGlvbkpvaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRnJpY3Rpb25Kb2ludCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRnJpY3Rpb25Kb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBGcmljdGlvbkpvaW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnJpY3Rpb25Kb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBERUZBVUxUUyQ5KTtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVmLCBib2R5QSwgYm9keUIpIHx8IHRoaXM7XG4gICAgICAgICAgICBib2R5QSA9IF90aGlzLm1fYm9keUE7XG4gICAgICAgICAgICBib2R5QiA9IF90aGlzLm1fYm9keUI7XG4gICAgICAgICAgICBfdGhpcy5tX3R5cGUgPSBGcmljdGlvbkpvaW50LlRZUEU7XG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQSA9IFZlYzIuY2xvbmUoYW5jaG9yID8gYm9keUEuZ2V0TG9jYWxQb2ludChhbmNob3IpIDogZGVmLmxvY2FsQW5jaG9yQSB8fCBWZWMyLnplcm8oKSk7XG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQiA9IFZlYzIuY2xvbmUoYW5jaG9yID8gYm9keUIuZ2V0TG9jYWxQb2ludChhbmNob3IpIDogZGVmLmxvY2FsQW5jaG9yQiB8fCBWZWMyLnplcm8oKSk7XG4gICAgICAgICAgICAvLyBTb2x2ZXIgc2hhcmVkXG4gICAgICAgICAgICBfdGhpcy5tX2xpbmVhckltcHVsc2UgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIF90aGlzLm1fYW5ndWxhckltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX21heEZvcmNlID0gZGVmLm1heEZvcmNlO1xuICAgICAgICAgICAgX3RoaXMubV9tYXhUb3JxdWUgPSBkZWYubWF4VG9ycXVlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgLy8gUG9pbnQtdG8tcG9pbnQgY29uc3RyYWludFxuICAgICAgICAgICAgLy8gQ2RvdCA9IHYyIC0gdjFcbiAgICAgICAgICAgIC8vID0gdjIgKyBjcm9zcyh3MiwgcjIpIC0gdjEgLSBjcm9zcyh3MSwgcjEpXG4gICAgICAgICAgICAvLyBKID0gWy1JIC1yMV9za2V3IEkgcjJfc2tldyBdXG4gICAgICAgICAgICAvLyBJZGVudGl0eSB1c2VkOlxuICAgICAgICAgICAgLy8gdyBrICUgKHJ4IGkgKyByeSBqKSA9IHcgKiAoLXJ5IGkgKyByeCBqKVxuICAgICAgICAgICAgLy8gQW5nbGUgY29uc3RyYWludFxuICAgICAgICAgICAgLy8gQ2RvdCA9IHcyIC0gdzFcbiAgICAgICAgICAgIC8vIEogPSBbMCAwIC0xIDAgMCAxXVxuICAgICAgICAgICAgLy8gSyA9IGludkkxICsgaW52STJcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZyaWN0aW9uSm9pbnQucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMubV90eXBlLFxuICAgICAgICAgICAgICAgIGJvZHlBOiB0aGlzLm1fYm9keUEsXG4gICAgICAgICAgICAgICAgYm9keUI6IHRoaXMubV9ib2R5QixcbiAgICAgICAgICAgICAgICBjb2xsaWRlQ29ubmVjdGVkOiB0aGlzLm1fY29sbGlkZUNvbm5lY3RlZCxcbiAgICAgICAgICAgICAgICBtYXhGb3JjZTogdGhpcy5tX21heEZvcmNlLFxuICAgICAgICAgICAgICAgIG1heFRvcnF1ZTogdGhpcy5tX21heFRvcnF1ZSxcbiAgICAgICAgICAgICAgICBsb2NhbEFuY2hvckE6IHRoaXMubV9sb2NhbEFuY2hvckEsXG4gICAgICAgICAgICAgICAgbG9jYWxBbmNob3JCOiB0aGlzLm1fbG9jYWxBbmNob3JCLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGcmljdGlvbkpvaW50Ll9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhLCB3b3JsZCwgcmVzdG9yZSkge1xuICAgICAgICAgICAgZGF0YSA9IF9fYXNzaWduKHt9LCBkYXRhKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUEgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUEsIHdvcmxkKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUIgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUIsIHdvcmxkKTtcbiAgICAgICAgICAgIHZhciBqb2ludCA9IG5ldyBGcmljdGlvbkpvaW50KGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGpvaW50O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZyaWN0aW9uSm9pbnQucHJvdG90eXBlLl9zZXRBbmNob3JzID0gZnVuY3Rpb24gKGRlZikge1xuICAgICAgICAgICAgaWYgKGRlZi5hbmNob3JBKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQS5zZXRWZWMyKHRoaXMubV9ib2R5QS5nZXRMb2NhbFBvaW50KGRlZi5hbmNob3JBKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWYubG9jYWxBbmNob3JBKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQS5zZXRWZWMyKGRlZi5sb2NhbEFuY2hvckEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZi5hbmNob3JCKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQi5zZXRWZWMyKHRoaXMubV9ib2R5Qi5nZXRMb2NhbFBvaW50KGRlZi5hbmNob3JCKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWYubG9jYWxBbmNob3JCKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQi5zZXRWZWMyKGRlZi5sb2NhbEFuY2hvckIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QSdzIG9yaWdpbi5cbiAgICAgICAgICovXG4gICAgICAgIEZyaWN0aW9uSm9pbnQucHJvdG90eXBlLmdldExvY2FsQW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbG9jYWxBbmNob3JBO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QidzIG9yaWdpbi5cbiAgICAgICAgICovXG4gICAgICAgIEZyaWN0aW9uSm9pbnQucHJvdG90eXBlLmdldExvY2FsQW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbG9jYWxBbmNob3JCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBtYXhpbXVtIGZyaWN0aW9uIGZvcmNlIGluIE4uXG4gICAgICAgICAqL1xuICAgICAgICBGcmljdGlvbkpvaW50LnByb3RvdHlwZS5zZXRNYXhGb3JjZSA9IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICAgICAgdGhpcy5tX21heEZvcmNlID0gZm9yY2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG1heGltdW0gZnJpY3Rpb24gZm9yY2UgaW4gTi5cbiAgICAgICAgICovXG4gICAgICAgIEZyaWN0aW9uSm9pbnQucHJvdG90eXBlLmdldE1heEZvcmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9tYXhGb3JjZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbWF4aW11bSBmcmljdGlvbiB0b3JxdWUgaW4gTiptLlxuICAgICAgICAgKi9cbiAgICAgICAgRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuc2V0TWF4VG9ycXVlID0gZnVuY3Rpb24gKHRvcnF1ZSkge1xuICAgICAgICAgICAgdGhpcy5tX21heFRvcnF1ZSA9IHRvcnF1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbWF4aW11bSBmcmljdGlvbiB0b3JxdWUgaW4gTiptLlxuICAgICAgICAgKi9cbiAgICAgICAgRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuZ2V0TWF4VG9ycXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9tYXhUb3JxdWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QSBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIEZyaWN0aW9uSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QiBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIEZyaWN0aW9uSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlYWN0aW9uIGZvcmNlIG9uIGJvZHlCIGF0IHRoZSBqb2ludCBhbmNob3IgaW4gTmV3dG9ucy5cbiAgICAgICAgICovXG4gICAgICAgIEZyaWN0aW9uSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5tdWxOdW1WZWMyKGludl9kdCwgdGhpcy5tX2xpbmVhckltcHVsc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByZWFjdGlvbiB0b3JxdWUgb24gYm9keUIgaW4gTiptLlxuICAgICAgICAgKi9cbiAgICAgICAgRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW52X2R0ICogdGhpcy5tX2FuZ3VsYXJJbXB1bHNlO1xuICAgICAgICB9O1xuICAgICAgICBGcmljdGlvbkpvaW50LnByb3RvdHlwZS5pbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJBID0gdGhpcy5tX2JvZHlBLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJCID0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzc0EgPSB0aGlzLm1fYm9keUEubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3NCID0gdGhpcy5tX2JvZHlCLm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9pbnZJQSA9IHRoaXMubV9ib2R5QS5tX2ludkk7XG4gICAgICAgICAgICB0aGlzLm1faW52SUIgPSB0aGlzLm1fYm9keUIubV9pbnZJO1xuICAgICAgICAgICAgdmFyIGFBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHFBID0gUm90Lm5lbyhhQSk7XG4gICAgICAgICAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGVmZmVjdGl2ZSBtYXNzIG1hdHJpeC5cbiAgICAgICAgICAgIHRoaXMubV9yQSA9IFJvdC5tdWxWZWMyKHFBLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JBLCB0aGlzLm1fbG9jYWxDZW50ZXJBKSk7XG4gICAgICAgICAgICB0aGlzLm1fckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgICAgICAgICAgLy8gSiA9IFstSSAtcjFfc2tldyBJIHIyX3NrZXddXG4gICAgICAgICAgICAvLyBbIDAgLTEgMCAxXVxuICAgICAgICAgICAgLy8gcl9za2V3ID0gWy1yeTsgcnhdXG4gICAgICAgICAgICAvLyBNYXRsYWJcbiAgICAgICAgICAgIC8vIEsgPSBbIG1BK3IxeV4yKmlBK21CK3IyeV4yKmlCLCAtcjF5KmlBKnIxeC1yMnkqaUIqcjJ4LCAtcjF5KmlBLXIyeSppQl1cbiAgICAgICAgICAgIC8vIFsgLXIxeSppQSpyMXgtcjJ5KmlCKnIyeCwgbUErcjF4XjIqaUErbUIrcjJ4XjIqaUIsIHIxeCppQStyMngqaUJdXG4gICAgICAgICAgICAvLyBbIC1yMXkqaUEtcjJ5KmlCLCByMXgqaUErcjJ4KmlCLCBpQStpQl1cbiAgICAgICAgICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgICAgIHZhciBtQiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICAgICAgICAgIHZhciBpQSA9IHRoaXMubV9pbnZJQTtcbiAgICAgICAgICAgIHZhciBpQiA9IHRoaXMubV9pbnZJQjtcbiAgICAgICAgICAgIHZhciBLID0gbmV3IE1hdDIyKCk7XG4gICAgICAgICAgICBLLmV4LnggPSBtQSArIG1CICsgaUEgKiB0aGlzLm1fckEueSAqIHRoaXMubV9yQS55ICsgaUIgKiB0aGlzLm1fckIueVxuICAgICAgICAgICAgICAgICogdGhpcy5tX3JCLnk7XG4gICAgICAgICAgICBLLmV4LnkgPSAtaUEgKiB0aGlzLm1fckEueCAqIHRoaXMubV9yQS55IC0gaUIgKiB0aGlzLm1fckIueCAqIHRoaXMubV9yQi55O1xuICAgICAgICAgICAgSy5leS54ID0gSy5leC55O1xuICAgICAgICAgICAgSy5leS55ID0gbUEgKyBtQiArIGlBICogdGhpcy5tX3JBLnggKiB0aGlzLm1fckEueCArIGlCICogdGhpcy5tX3JCLnhcbiAgICAgICAgICAgICAgICAqIHRoaXMubV9yQi54O1xuICAgICAgICAgICAgdGhpcy5tX2xpbmVhck1hc3MgPSBLLmdldEludmVyc2UoKTtcbiAgICAgICAgICAgIHRoaXMubV9hbmd1bGFyTWFzcyA9IGlBICsgaUI7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2FuZ3VsYXJNYXNzID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJNYXNzID0gMS4wIC8gdGhpcy5tX2FuZ3VsYXJNYXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgaW1wdWxzZXMgdG8gc3VwcG9ydCBhIHZhcmlhYmxlIHRpbWUgc3RlcC5cbiAgICAgICAgICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5tdWwoc3RlcC5kdFJhdGlvKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYW5ndWxhckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgICAgICAgIHZhciBQID0gVmVjMi5uZW8odGhpcy5tX2xpbmVhckltcHVsc2UueCwgdGhpcy5tX2xpbmVhckltcHVsc2UueSk7XG4gICAgICAgICAgICAgICAgdkEuc3ViTXVsKG1BLCBQKTtcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIChWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JBLCBQKSArIHRoaXMubV9hbmd1bGFySW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIChWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBQKSArIHRoaXMubV9hbmd1bGFySW1wdWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudiA9IHZBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudiA9IHZCO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICBGcmljdGlvbkpvaW50LnByb3RvdHlwZS5zb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgICAgIHZhciBtQiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICAgICAgICAgIHZhciBpQSA9IHRoaXMubV9pbnZJQTtcbiAgICAgICAgICAgIHZhciBpQiA9IHRoaXMubV9pbnZJQjtcbiAgICAgICAgICAgIHZhciBoID0gc3RlcC5kdDsgLy8gZmxvYXRcbiAgICAgICAgICAgIC8vIFNvbHZlIGFuZ3VsYXIgZnJpY3Rpb25cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgQ2RvdCA9IHdCIC0gd0E7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2UgPSAtdGhpcy5tX2FuZ3VsYXJNYXNzICogQ2RvdDsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB2YXIgb2xkSW1wdWxzZSA9IHRoaXMubV9hbmd1bGFySW1wdWxzZTsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB2YXIgbWF4SW1wdWxzZSA9IGggKiB0aGlzLm1fbWF4VG9ycXVlOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgIHRoaXMubV9hbmd1bGFySW1wdWxzZSA9IG1hdGgkMS5jbGFtcCh0aGlzLm1fYW5ndWxhckltcHVsc2UgKyBpbXB1bHNlLCAtbWF4SW1wdWxzZSwgbWF4SW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9hbmd1bGFySW1wdWxzZSAtIG9sZEltcHVsc2U7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBpbXB1bHNlO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogaW1wdWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbHZlIGxpbmVhciBmcmljdGlvblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBDZG90ID0gVmVjMi5zdWIoVmVjMi5hZGQodkIsIFZlYzIuY3Jvc3NOdW1WZWMyKHdCLCB0aGlzLm1fckIpKSwgVmVjMi5hZGQodkEsIFZlYzIuY3Jvc3NOdW1WZWMyKHdBLCB0aGlzLm1fckEpKSk7IC8vIFZlYzJcbiAgICAgICAgICAgICAgICB2YXIgaW1wdWxzZSA9IFZlYzIubmVnKE1hdDIyLm11bFZlYzIodGhpcy5tX2xpbmVhck1hc3MsIENkb3QpKTsgLy8gVmVjMlxuICAgICAgICAgICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX2xpbmVhckltcHVsc2U7IC8vIFZlYzJcbiAgICAgICAgICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5hZGQoaW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgdmFyIG1heEltcHVsc2UgPSBoICogdGhpcy5tX21heEZvcmNlOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1fbGluZWFySW1wdWxzZS5sZW5ndGhTcXVhcmVkKCkgPiBtYXhJbXB1bHNlICogbWF4SW1wdWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2xpbmVhckltcHVsc2UubXVsKG1heEltcHVsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gVmVjMi5zdWIodGhpcy5tX2xpbmVhckltcHVsc2UsIG9sZEltcHVsc2UpO1xuICAgICAgICAgICAgICAgIHZBLnN1Yk11bChtQSwgaW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JBLCBpbXB1bHNlKTtcbiAgICAgICAgICAgICAgICB2Qi5hZGRNdWwobUIsIGltcHVsc2UpO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQiwgaW1wdWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52ID0gdkI7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZXJyb3JzIGFyZSB3aXRoaW4gdG9sZXJhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuc29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBGcmljdGlvbkpvaW50LlRZUEUgPSAnZnJpY3Rpb24tam9pbnQnO1xuICAgICAgICByZXR1cm4gRnJpY3Rpb25Kb2ludDtcbiAgICB9KEpvaW50KSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQSAzLWJ5LTMgbWF0cml4LiBTdG9yZWQgaW4gY29sdW1uLW1ham9yIG9yZGVyLlxuICAgICAqL1xuICAgIHZhciBNYXQzMyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTWF0MzMoYSwgYiwgYykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leCA9IFZlYzMuY2xvbmUoYSk7XG4gICAgICAgICAgICAgICAgdGhpcy5leSA9IFZlYzMuY2xvbmUoYik7XG4gICAgICAgICAgICAgICAgdGhpcy5leiA9IFZlYzMuY2xvbmUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ID0gVmVjMy56ZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5leSA9IFZlYzMuemVybygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXogPSBWZWMzLnplcm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE1hdDMzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgTWF0MzMuaXNWYWxpZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVmVjMy5pc1ZhbGlkKG9iai5leCkgJiYgVmVjMy5pc1ZhbGlkKG9iai5leSkgJiYgVmVjMy5pc1ZhbGlkKG9iai5leik7XG4gICAgICAgIH07XG4gICAgICAgIE1hdDMzLmFzc2VydCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyBtYXRyaXggdG8gYWxsIHplcm9zLlxuICAgICAgICAgKi9cbiAgICAgICAgTWF0MzMucHJvdG90eXBlLnNldFplcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmV4LnNldFplcm8oKTtcbiAgICAgICAgICAgIHRoaXMuZXkuc2V0WmVybygpO1xuICAgICAgICAgICAgdGhpcy5lei5zZXRaZXJvKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvbHZlIEEgKiB4ID0gYiwgd2hlcmUgYiBpcyBhIGNvbHVtbiB2ZWN0b3IuIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhblxuICAgICAgICAgKiBjb21wdXRpbmcgdGhlIGludmVyc2UgaW4gb25lLXNob3QgY2FzZXMuXG4gICAgICAgICAqL1xuICAgICAgICBNYXQzMy5wcm90b3R5cGUuc29sdmUzMyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgZGV0ID0gVmVjMy5kb3QodGhpcy5leCwgVmVjMy5jcm9zcyh0aGlzLmV5LCB0aGlzLmV6KSk7XG4gICAgICAgICAgICBpZiAoZGV0ICE9PSAwLjApIHtcbiAgICAgICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgciA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICByLnggPSBkZXQgKiBWZWMzLmRvdCh2LCBWZWMzLmNyb3NzKHRoaXMuZXksIHRoaXMuZXopKTtcbiAgICAgICAgICAgIHIueSA9IGRldCAqIFZlYzMuZG90KHRoaXMuZXgsIFZlYzMuY3Jvc3ModiwgdGhpcy5leikpO1xuICAgICAgICAgICAgci56ID0gZGV0ICogVmVjMy5kb3QodGhpcy5leCwgVmVjMy5jcm9zcyh0aGlzLmV5LCB2KSk7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvbHZlIEEgKiB4ID0gYiwgd2hlcmUgYiBpcyBhIGNvbHVtbiB2ZWN0b3IuIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhblxuICAgICAgICAgKiBjb21wdXRpbmcgdGhlIGludmVyc2UgaW4gb25lLXNob3QgY2FzZXMuIFNvbHZlIG9ubHkgdGhlIHVwcGVyIDItYnktMiBtYXRyaXhcbiAgICAgICAgICogZXF1YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBNYXQzMy5wcm90b3R5cGUuc29sdmUyMiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgYTExID0gdGhpcy5leC54O1xuICAgICAgICAgICAgdmFyIGExMiA9IHRoaXMuZXkueDtcbiAgICAgICAgICAgIHZhciBhMjEgPSB0aGlzLmV4Lnk7XG4gICAgICAgICAgICB2YXIgYTIyID0gdGhpcy5leS55O1xuICAgICAgICAgICAgdmFyIGRldCA9IGExMSAqIGEyMiAtIGExMiAqIGEyMTtcbiAgICAgICAgICAgIGlmIChkZXQgIT09IDAuMCkge1xuICAgICAgICAgICAgICAgIGRldCA9IDEuMCAvIGRldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICByLnggPSBkZXQgKiAoYTIyICogdi54IC0gYTEyICogdi55KTtcbiAgICAgICAgICAgIHIueSA9IGRldCAqIChhMTEgKiB2LnkgLSBhMjEgKiB2LngpO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGludmVyc2Ugb2YgdGhpcyBtYXRyaXggYXMgYSAyLWJ5LTIuIFJldHVybnMgdGhlIHplcm8gbWF0cml4IGlmXG4gICAgICAgICAqIHNpbmd1bGFyLlxuICAgICAgICAgKi9cbiAgICAgICAgTWF0MzMucHJvdG90eXBlLmdldEludmVyc2UyMiA9IGZ1bmN0aW9uIChNKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuZXgueDtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5leS54O1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmV4Lnk7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuZXkueTtcbiAgICAgICAgICAgIHZhciBkZXQgPSBhICogZCAtIGIgKiBjO1xuICAgICAgICAgICAgaWYgKGRldCAhPT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgZGV0ID0gMS4wIC8gZGV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTS5leC54ID0gZGV0ICogZDtcbiAgICAgICAgICAgIE0uZXkueCA9IC1kZXQgKiBiO1xuICAgICAgICAgICAgTS5leC56ID0gMC4wO1xuICAgICAgICAgICAgTS5leC55ID0gLWRldCAqIGM7XG4gICAgICAgICAgICBNLmV5LnkgPSBkZXQgKiBhO1xuICAgICAgICAgICAgTS5leS56ID0gMC4wO1xuICAgICAgICAgICAgTS5lei54ID0gMC4wO1xuICAgICAgICAgICAgTS5lei55ID0gMC4wO1xuICAgICAgICAgICAgTS5lei56ID0gMC4wO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBzeW1tZXRyaWMgaW52ZXJzZSBvZiB0aGlzIG1hdHJpeCBhcyBhIDMtYnktMy4gUmV0dXJucyB0aGUgemVybyBtYXRyaXhcbiAgICAgICAgICogaWYgc2luZ3VsYXIuXG4gICAgICAgICAqL1xuICAgICAgICBNYXQzMy5wcm90b3R5cGUuZ2V0U3ltSW52ZXJzZTMzID0gZnVuY3Rpb24gKE0pIHtcbiAgICAgICAgICAgIHZhciBkZXQgPSBWZWMzLmRvdCh0aGlzLmV4LCBWZWMzLmNyb3NzKHRoaXMuZXksIHRoaXMuZXopKTtcbiAgICAgICAgICAgIGlmIChkZXQgIT09IDAuMCkge1xuICAgICAgICAgICAgICAgIGRldCA9IDEuMCAvIGRldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhMTEgPSB0aGlzLmV4Lng7XG4gICAgICAgICAgICB2YXIgYTEyID0gdGhpcy5leS54O1xuICAgICAgICAgICAgdmFyIGExMyA9IHRoaXMuZXoueDtcbiAgICAgICAgICAgIHZhciBhMjIgPSB0aGlzLmV5Lnk7XG4gICAgICAgICAgICB2YXIgYTIzID0gdGhpcy5lei55O1xuICAgICAgICAgICAgdmFyIGEzMyA9IHRoaXMuZXouejtcbiAgICAgICAgICAgIE0uZXgueCA9IGRldCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMjMpO1xuICAgICAgICAgICAgTS5leC55ID0gZGV0ICogKGExMyAqIGEyMyAtIGExMiAqIGEzMyk7XG4gICAgICAgICAgICBNLmV4LnogPSBkZXQgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKTtcbiAgICAgICAgICAgIE0uZXkueCA9IE0uZXgueTtcbiAgICAgICAgICAgIE0uZXkueSA9IGRldCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMTMpO1xuICAgICAgICAgICAgTS5leS56ID0gZGV0ICogKGExMyAqIGExMiAtIGExMSAqIGEyMyk7XG4gICAgICAgICAgICBNLmV6LnggPSBNLmV4Lno7XG4gICAgICAgICAgICBNLmV6LnkgPSBNLmV5Lno7XG4gICAgICAgICAgICBNLmV6LnogPSBkZXQgKiAoYTExICogYTIyIC0gYTEyICogYTEyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgTWF0MzMubXVsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChiICYmICd6JyBpbiBiICYmICd5JyBpbiBiICYmICd4JyBpbiBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBhLmV4LnggKiBiLnggKyBhLmV5LnggKiBiLnkgKyBhLmV6LnggKiBiLno7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBhLmV4LnkgKiBiLnggKyBhLmV5LnkgKiBiLnkgKyBhLmV6LnkgKiBiLno7XG4gICAgICAgICAgICAgICAgdmFyIHogPSBhLmV4LnogKiBiLnggKyBhLmV5LnogKiBiLnkgKyBhLmV6LnogKiBiLno7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHgsIHksIHopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiAmJiAneScgaW4gYiAmJiAneCcgaW4gYikge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gYS5leC54ICogYi54ICsgYS5leS54ICogYi55O1xuICAgICAgICAgICAgICAgIHZhciB5ID0gYS5leC55ICogYi54ICsgYS5leS55ICogYi55O1xuICAgICAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyh4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTWF0MzMubXVsVmVjMyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGEuZXgueCAqIGIueCArIGEuZXkueCAqIGIueSArIGEuZXoueCAqIGIuejtcbiAgICAgICAgICAgIHZhciB5ID0gYS5leC55ICogYi54ICsgYS5leS55ICogYi55ICsgYS5lei55ICogYi56O1xuICAgICAgICAgICAgdmFyIHogPSBhLmV4LnogKiBiLnggKyBhLmV5LnogKiBiLnkgKyBhLmV6LnogKiBiLno7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMoeCwgeSwgeik7XG4gICAgICAgIH07XG4gICAgICAgIE1hdDMzLm11bFZlYzIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgdmFyIHggPSBhLmV4LnggKiBiLnggKyBhLmV5LnggKiBiLnk7XG4gICAgICAgICAgICB2YXIgeSA9IGEuZXgueSAqIGIueCArIGEuZXkueSAqIGIueTtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyh4LCB5KTtcbiAgICAgICAgfTtcbiAgICAgICAgTWF0MzMuYWRkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0MzMoVmVjMy5hZGQoYS5leCwgYi5leCksIFZlYzMuYWRkKGEuZXksIGIuZXkpLCBWZWMzLmFkZChhLmV6LCBiLmV6KSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBNYXQzMztcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIHZhciBpbmFjdGl2ZUxpbWl0JDIgPSAwO1xuICAgIHZhciBhdExvd2VyTGltaXQkMSA9IDE7XG4gICAgdmFyIGF0VXBwZXJMaW1pdCQyID0gMjtcbiAgICB2YXIgZXF1YWxMaW1pdHMkMSA9IDM7XG4gICAgdmFyIERFRkFVTFRTJDggPSB7XG4gICAgICAgIGxvd2VyQW5nbGU6IDAuMCxcbiAgICAgICAgdXBwZXJBbmdsZTogMC4wLFxuICAgICAgICBtYXhNb3RvclRvcnF1ZTogMC4wLFxuICAgICAgICBtb3RvclNwZWVkOiAwLjAsXG4gICAgICAgIGVuYWJsZUxpbWl0OiBmYWxzZSxcbiAgICAgICAgZW5hYmxlTW90b3I6IGZhbHNlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHJldm9sdXRlIGpvaW50IGNvbnN0cmFpbnMgdHdvIGJvZGllcyB0byBzaGFyZSBhIGNvbW1vbiBwb2ludCB3aGlsZSB0aGV5IGFyZVxuICAgICAqIGZyZWUgdG8gcm90YXRlIGFib3V0IHRoZSBwb2ludC4gVGhlIHJlbGF0aXZlIHJvdGF0aW9uIGFib3V0IHRoZSBzaGFyZWQgcG9pbnRcbiAgICAgKiBpcyB0aGUgam9pbnQgYW5nbGUuIFlvdSBjYW4gbGltaXQgdGhlIHJlbGF0aXZlIHJvdGF0aW9uIHdpdGggYSBqb2ludCBsaW1pdFxuICAgICAqIHRoYXQgc3BlY2lmaWVzIGEgbG93ZXIgYW5kIHVwcGVyIGFuZ2xlLiBZb3UgY2FuIHVzZSBhIG1vdG9yIHRvIGRyaXZlIHRoZVxuICAgICAqIHJlbGF0aXZlIHJvdGF0aW9uIGFib3V0IHRoZSBzaGFyZWQgcG9pbnQuIEEgbWF4aW11bSBtb3RvciB0b3JxdWUgaXMgcHJvdmlkZWRcbiAgICAgKiBzbyB0aGF0IGluZmluaXRlIGZvcmNlcyBhcmUgbm90IGdlbmVyYXRlZC5cbiAgICAgKi9cbiAgICB2YXIgUmV2b2x1dGVKb2ludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFJldm9sdXRlSm9pbnQsIF9zdXBlcik7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZnVuY3Rpb24gUmV2b2x1dGVKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBSZXZvbHV0ZUpvaW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmV2b2x1dGVKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBERUZBVUxUUyQ4KTtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVmLCBib2R5QSwgYm9keUIpIHx8IHRoaXM7XG4gICAgICAgICAgICAvLyBlZmZlY3RpdmUgbWFzcyBmb3IgcG9pbnQtdG8tcG9pbnQgY29uc3RyYWludC5cbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gX3RoaXMubV9tYXNzID0gbmV3IE1hdDMzKCk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIF90aGlzLm1fbGltaXRTdGF0ZSA9IGluYWN0aXZlTGltaXQkMjsgLy8gVE9ETyBlbnVtXG4gICAgICAgICAgICBib2R5QSA9IF90aGlzLm1fYm9keUE7XG4gICAgICAgICAgICBib2R5QiA9IF90aGlzLm1fYm9keUI7XG4gICAgICAgICAgICBfdGhpcy5tX3R5cGUgPSBSZXZvbHV0ZUpvaW50LlRZUEU7XG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQSA9IFZlYzIuY2xvbmUoYW5jaG9yID8gYm9keUEuZ2V0TG9jYWxQb2ludChhbmNob3IpIDogZGVmLmxvY2FsQW5jaG9yQSB8fCBWZWMyLnplcm8oKSk7XG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQiA9IFZlYzIuY2xvbmUoYW5jaG9yID8gYm9keUIuZ2V0TG9jYWxQb2ludChhbmNob3IpIDogZGVmLmxvY2FsQW5jaG9yQiB8fCBWZWMyLnplcm8oKSk7XG4gICAgICAgICAgICBfdGhpcy5tX3JlZmVyZW5jZUFuZ2xlID0gbWF0aCQxLmlzRmluaXRlKGRlZi5yZWZlcmVuY2VBbmdsZSkgPyBkZWYucmVmZXJlbmNlQW5nbGUgOiBib2R5Qi5nZXRBbmdsZSgpIC0gYm9keUEuZ2V0QW5nbGUoKTtcbiAgICAgICAgICAgIF90aGlzLm1faW1wdWxzZSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICBfdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIF90aGlzLm1fbG93ZXJBbmdsZSA9IGRlZi5sb3dlckFuZ2xlO1xuICAgICAgICAgICAgX3RoaXMubV91cHBlckFuZ2xlID0gZGVmLnVwcGVyQW5nbGU7XG4gICAgICAgICAgICBfdGhpcy5tX21heE1vdG9yVG9ycXVlID0gZGVmLm1heE1vdG9yVG9ycXVlO1xuICAgICAgICAgICAgX3RoaXMubV9tb3RvclNwZWVkID0gZGVmLm1vdG9yU3BlZWQ7XG4gICAgICAgICAgICBfdGhpcy5tX2VuYWJsZUxpbWl0ID0gZGVmLmVuYWJsZUxpbWl0O1xuICAgICAgICAgICAgX3RoaXMubV9lbmFibGVNb3RvciA9IGRlZi5lbmFibGVNb3RvcjtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIC8vIFBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnRcbiAgICAgICAgICAgIC8vIEMgPSBwMiAtIHAxXG4gICAgICAgICAgICAvLyBDZG90ID0gdjIgLSB2MVxuICAgICAgICAgICAgLy8gPSB2MiArIGNyb3NzKHcyLCByMikgLSB2MSAtIGNyb3NzKHcxLCByMSlcbiAgICAgICAgICAgIC8vIEogPSBbLUkgLXIxX3NrZXcgSSByMl9za2V3IF1cbiAgICAgICAgICAgIC8vIElkZW50aXR5IHVzZWQ6XG4gICAgICAgICAgICAvLyB3IGsgJSAocnggaSArIHJ5IGopID0gdyAqICgtcnkgaSArIHJ4IGopXG4gICAgICAgICAgICAvLyBNb3RvciBjb25zdHJhaW50XG4gICAgICAgICAgICAvLyBDZG90ID0gdzIgLSB3MVxuICAgICAgICAgICAgLy8gSiA9IFswIDAgLTEgMCAwIDFdXG4gICAgICAgICAgICAvLyBLID0gaW52STEgKyBpbnZJMlxuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuX3NlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5tX3R5cGUsXG4gICAgICAgICAgICAgICAgYm9keUE6IHRoaXMubV9ib2R5QSxcbiAgICAgICAgICAgICAgICBib2R5QjogdGhpcy5tX2JvZHlCLFxuICAgICAgICAgICAgICAgIGNvbGxpZGVDb25uZWN0ZWQ6IHRoaXMubV9jb2xsaWRlQ29ubmVjdGVkLFxuICAgICAgICAgICAgICAgIGxvd2VyQW5nbGU6IHRoaXMubV9sb3dlckFuZ2xlLFxuICAgICAgICAgICAgICAgIHVwcGVyQW5nbGU6IHRoaXMubV91cHBlckFuZ2xlLFxuICAgICAgICAgICAgICAgIG1heE1vdG9yVG9ycXVlOiB0aGlzLm1fbWF4TW90b3JUb3JxdWUsXG4gICAgICAgICAgICAgICAgbW90b3JTcGVlZDogdGhpcy5tX21vdG9yU3BlZWQsXG4gICAgICAgICAgICAgICAgZW5hYmxlTGltaXQ6IHRoaXMubV9lbmFibGVMaW1pdCxcbiAgICAgICAgICAgICAgICBlbmFibGVNb3RvcjogdGhpcy5tX2VuYWJsZU1vdG9yLFxuICAgICAgICAgICAgICAgIGxvY2FsQW5jaG9yQTogdGhpcy5tX2xvY2FsQW5jaG9yQSxcbiAgICAgICAgICAgICAgICBsb2NhbEFuY2hvckI6IHRoaXMubV9sb2NhbEFuY2hvckIsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlQW5nbGU6IHRoaXMubV9yZWZlcmVuY2VBbmdsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUmV2b2x1dGVKb2ludC5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSwgd29ybGQsIHJlc3RvcmUpIHtcbiAgICAgICAgICAgIGRhdGEgPSBfX2Fzc2lnbih7fSwgZGF0YSk7XG4gICAgICAgICAgICBkYXRhLmJvZHlBID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlBLCB3b3JsZCk7XG4gICAgICAgICAgICBkYXRhLmJvZHlCID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlCLCB3b3JsZCk7XG4gICAgICAgICAgICB2YXIgam9pbnQgPSBuZXcgUmV2b2x1dGVKb2ludChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5fc2V0QW5jaG9ycyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgICAgIGlmIChkZWYuYW5jaG9yQSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckEuc2V0VmVjMih0aGlzLm1fYm9keUEuZ2V0TG9jYWxQb2ludChkZWYuYW5jaG9yQSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVmLmxvY2FsQW5jaG9yQSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckEuc2V0VmVjMihkZWYubG9jYWxBbmNob3JBKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWYuYW5jaG9yQikge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckIuc2V0VmVjMih0aGlzLm1fYm9keUIuZ2V0TG9jYWxQb2ludChkZWYuYW5jaG9yQikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVmLmxvY2FsQW5jaG9yQikge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckIuc2V0VmVjMihkZWYubG9jYWxBbmNob3JCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUEncyBvcmlnaW4uXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUIncyBvcmlnaW4uXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVmZXJlbmNlIGFuZ2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0UmVmZXJlbmNlQW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3JlZmVyZW5jZUFuZ2xlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IGpvaW50IGFuZ2xlIGluIHJhZGlhbnMuXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5nZXRKb2ludEFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgICAgICAgcmV0dXJuIGJCLm1fc3dlZXAuYSAtIGJBLm1fc3dlZXAuYSAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY3VycmVudCBqb2ludCBhbmdsZSBzcGVlZCBpbiByYWRpYW5zIHBlciBzZWNvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5nZXRKb2ludFNwZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgICAgICAgcmV0dXJuIGJCLm1fYW5ndWxhclZlbG9jaXR5IC0gYkEubV9hbmd1bGFyVmVsb2NpdHk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgam9pbnQgbW90b3IgZW5hYmxlZD9cbiAgICAgICAgICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLmlzTW90b3JFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9lbmFibGVNb3RvcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZS9kaXNhYmxlIHRoZSBqb2ludCBtb3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLmVuYWJsZU1vdG9yID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9lbmFibGVNb3RvciA9IGZsYWc7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgbW90b3IgdG9ycXVlIGdpdmVuIHRoZSBpbnZlcnNlIHRpbWUgc3RlcC4gVW5pdCBpcyBOKm0uXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5nZXRNb3RvclRvcnF1ZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBtb3RvciBzcGVlZCBpbiByYWRpYW5zIHBlciBzZWNvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5zZXRNb3RvclNwZWVkID0gZnVuY3Rpb24gKHNwZWVkKSB7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm1fbW90b3JTcGVlZCA9IHNwZWVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtb3RvciBzcGVlZCBpbiByYWRpYW5zIHBlciBzZWNvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5nZXRNb3RvclNwZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9tb3RvclNwZWVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBtYXhpbXVtIG1vdG9yIHRvcnF1ZSwgdXN1YWxseSBpbiBOLW0uXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5zZXRNYXhNb3RvclRvcnF1ZSA9IGZ1bmN0aW9uICh0b3JxdWUpIHtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9tYXhNb3RvclRvcnF1ZSA9IHRvcnF1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0TWF4TW90b3JUb3JxdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX21heE1vdG9yVG9ycXVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIGpvaW50IGxpbWl0IGVuYWJsZWQ/XG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5pc0xpbWl0RW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fZW5hYmxlTGltaXQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGUvZGlzYWJsZSB0aGUgam9pbnQgbGltaXQuXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5lbmFibGVMaW1pdCA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICBpZiAoZmxhZyAhPSB0aGlzLm1fZW5hYmxlTGltaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9lbmFibGVMaW1pdCA9IGZsYWc7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbG93ZXIgam9pbnQgbGltaXQgaW4gcmFkaWFucy5cbiAgICAgICAgICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLmdldExvd2VyTGltaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvd2VyQW5nbGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHVwcGVyIGpvaW50IGxpbWl0IGluIHJhZGlhbnMuXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5nZXRVcHBlckxpbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV91cHBlckFuZ2xlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBqb2ludCBsaW1pdHMgaW4gcmFkaWFucy5cbiAgICAgICAgICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLnNldExpbWl0cyA9IGZ1bmN0aW9uIChsb3dlciwgdXBwZXIpIHtcbiAgICAgICAgICAgIGlmIChsb3dlciAhPSB0aGlzLm1fbG93ZXJBbmdsZSB8fCB1cHBlciAhPSB0aGlzLm1fdXBwZXJBbmdsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG93ZXJBbmdsZSA9IGxvd2VyO1xuICAgICAgICAgICAgICAgIHRoaXMubV91cHBlckFuZ2xlID0gdXBwZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QSBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QiBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlYWN0aW9uIGZvcmNlIGdpdmVuIHRoZSBpbnZlcnNlIHRpbWUgc3RlcC4gVW5pdCBpcyBOLlxuICAgICAgICAgKi9cbiAgICAgICAgUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyh0aGlzLm1faW1wdWxzZS54LCB0aGlzLm1faW1wdWxzZS55KS5tdWwoaW52X2R0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gdG9ycXVlIGR1ZSB0byB0aGUgam9pbnQgbGltaXQgZ2l2ZW4gdGhlIGludmVyc2UgdGltZSBzdGVwLlxuICAgICAgICAgKiBVbml0IGlzIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9pbXB1bHNlLno7XG4gICAgICAgIH07XG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLmluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbENlbnRlckEgPSB0aGlzLm1fYm9keUEubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbENlbnRlckIgPSB0aGlzLm1fYm9keUIubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgICAgIHRoaXMubV9pbnZNYXNzQSA9IHRoaXMubV9ib2R5QS5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzc0IgPSB0aGlzLm1fYm9keUIubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX2ludklBID0gdGhpcy5tX2JvZHlBLm1faW52STtcbiAgICAgICAgICAgIHRoaXMubV9pbnZJQiA9IHRoaXMubV9ib2R5Qi5tX2ludkk7XG4gICAgICAgICAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICAgICAgICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgICAgICAgICAgdGhpcy5tX3JBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTtcbiAgICAgICAgICAgIHRoaXMubV9yQiA9IFJvdC5tdWxWZWMyKHFCLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKSk7XG4gICAgICAgICAgICAvLyBKID0gWy1JIC1yMV9za2V3IEkgcjJfc2tld11cbiAgICAgICAgICAgIC8vIFsgMCAtMSAwIDFdXG4gICAgICAgICAgICAvLyByX3NrZXcgPSBbLXJ5OyByeF1cbiAgICAgICAgICAgIC8vIE1hdGxhYlxuICAgICAgICAgICAgLy8gSyA9IFsgbUErcjF5XjIqaUErbUIrcjJ5XjIqaUIsIC1yMXkqaUEqcjF4LXIyeSppQipyMngsIC1yMXkqaUEtcjJ5KmlCXVxuICAgICAgICAgICAgLy8gWyAtcjF5KmlBKnIxeC1yMnkqaUIqcjJ4LCBtQStyMXheMippQSttQityMnheMippQiwgcjF4KmlBK3IyeCppQl1cbiAgICAgICAgICAgIC8vIFsgLXIxeSppQS1yMnkqaUIsIHIxeCppQStyMngqaUIsIGlBK2lCXVxuICAgICAgICAgICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBO1xuICAgICAgICAgICAgdmFyIG1CID0gdGhpcy5tX2ludk1hc3NCOyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIGlBID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgICAgdmFyIGlCID0gdGhpcy5tX2ludklCOyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIGZpeGVkUm90YXRpb24gPSAoaUEgKyBpQiA9PT0gMC4wKTsgLy8gYm9vbFxuICAgICAgICAgICAgdGhpcy5tX21hc3MuZXgueCA9IG1BICsgbUIgKyB0aGlzLm1fckEueSAqIHRoaXMubV9yQS55ICogaUEgKyB0aGlzLm1fckIueVxuICAgICAgICAgICAgICAgICogdGhpcy5tX3JCLnkgKiBpQjtcbiAgICAgICAgICAgIHRoaXMubV9tYXNzLmV5LnggPSAtdGhpcy5tX3JBLnkgKiB0aGlzLm1fckEueCAqIGlBIC0gdGhpcy5tX3JCLnlcbiAgICAgICAgICAgICAgICAqIHRoaXMubV9yQi54ICogaUI7XG4gICAgICAgICAgICB0aGlzLm1fbWFzcy5lei54ID0gLXRoaXMubV9yQS55ICogaUEgLSB0aGlzLm1fckIueSAqIGlCO1xuICAgICAgICAgICAgdGhpcy5tX21hc3MuZXgueSA9IHRoaXMubV9tYXNzLmV5Lng7XG4gICAgICAgICAgICB0aGlzLm1fbWFzcy5leS55ID0gbUEgKyBtQiArIHRoaXMubV9yQS54ICogdGhpcy5tX3JBLnggKiBpQSArIHRoaXMubV9yQi54XG4gICAgICAgICAgICAgICAgKiB0aGlzLm1fckIueCAqIGlCO1xuICAgICAgICAgICAgdGhpcy5tX21hc3MuZXoueSA9IHRoaXMubV9yQS54ICogaUEgKyB0aGlzLm1fckIueCAqIGlCO1xuICAgICAgICAgICAgdGhpcy5tX21hc3MuZXgueiA9IHRoaXMubV9tYXNzLmV6Lng7XG4gICAgICAgICAgICB0aGlzLm1fbWFzcy5leS56ID0gdGhpcy5tX21hc3MuZXoueTtcbiAgICAgICAgICAgIHRoaXMubV9tYXNzLmV6LnogPSBpQSArIGlCO1xuICAgICAgICAgICAgdGhpcy5tX21vdG9yTWFzcyA9IGlBICsgaUI7XG4gICAgICAgICAgICBpZiAodGhpcy5tX21vdG9yTWFzcyA+IDAuMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9tb3Rvck1hc3MgPSAxLjAgLyB0aGlzLm1fbW90b3JNYXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV9lbmFibGVNb3RvciA9PSBmYWxzZSB8fCBmaXhlZFJvdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1fZW5hYmxlTGltaXQgJiYgZml4ZWRSb3RhdGlvbiA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHZhciBqb2ludEFuZ2xlID0gYUIgLSBhQSAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZTsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICBpZiAobWF0aCQxLmFicyh0aGlzLm1fdXBwZXJBbmdsZSAtIHRoaXMubV9sb3dlckFuZ2xlKSA8IDIuMCAqIFNldHRpbmdzLmFuZ3VsYXJTbG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gZXF1YWxMaW1pdHMkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoam9pbnRBbmdsZSA8PSB0aGlzLm1fbG93ZXJBbmdsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgIT0gYXRMb3dlckxpbWl0JDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBhdExvd2VyTGltaXQkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoam9pbnRBbmdsZSA+PSB0aGlzLm1fdXBwZXJBbmdsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgIT0gYXRVcHBlckxpbWl0JDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBhdFVwcGVyTGltaXQkMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gaW5hY3RpdmVMaW1pdCQyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gaW5hY3RpdmVMaW1pdCQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgaW1wdWxzZXMgdG8gc3VwcG9ydCBhIHZhcmlhYmxlIHRpbWUgc3RlcC5cbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS5tdWwoc3RlcC5kdFJhdGlvKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIubmVvKHRoaXMubV9pbXB1bHNlLngsIHRoaXMubV9pbXB1bHNlLnkpO1xuICAgICAgICAgICAgICAgIHZBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiAoVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQSwgUCkgKyB0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2Uueik7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIChWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBQKSArIHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS56KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnNldFplcm8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudiA9IHZBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudiA9IHZCO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5zb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgICAgIHZhciBtQiA9IHRoaXMubV9pbnZNYXNzQjsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciBpQSA9IHRoaXMubV9pbnZJQTtcbiAgICAgICAgICAgIHZhciBpQiA9IHRoaXMubV9pbnZJQjsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciBmaXhlZFJvdGF0aW9uID0gKGlBICsgaUIgPT09IDAuMCk7IC8vIGJvb2xcbiAgICAgICAgICAgIC8vIFNvbHZlIG1vdG9yIGNvbnN0cmFpbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5tX2VuYWJsZU1vdG9yICYmIHRoaXMubV9saW1pdFN0YXRlICE9IGVxdWFsTGltaXRzJDFcbiAgICAgICAgICAgICAgICAmJiBmaXhlZFJvdGF0aW9uID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIENkb3QgPSB3QiAtIHdBIC0gdGhpcy5tX21vdG9yU3BlZWQ7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2UgPSAtdGhpcy5tX21vdG9yTWFzcyAqIENkb3Q7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgdmFyIG9sZEltcHVsc2UgPSB0aGlzLm1fbW90b3JJbXB1bHNlOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgIHZhciBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIHRoaXMubV9tYXhNb3RvclRvcnF1ZTsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gbWF0aCQxLmNsYW1wKHRoaXMubV9tb3RvckltcHVsc2UgKyBpbXB1bHNlLCAtbWF4SW1wdWxzZSwgbWF4SW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9tb3RvckltcHVsc2UgLSBvbGRJbXB1bHNlO1xuICAgICAgICAgICAgICAgIHdBIC09IGlBICogaW1wdWxzZTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIGltcHVsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb2x2ZSBsaW1pdCBjb25zdHJhaW50LlxuICAgICAgICAgICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCAmJiB0aGlzLm1fbGltaXRTdGF0ZSAhPSBpbmFjdGl2ZUxpbWl0JDJcbiAgICAgICAgICAgICAgICAmJiBmaXhlZFJvdGF0aW9uID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIENkb3QxID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAgICAgQ2RvdDEuYWRkQ29tYmluZSgxLCB2QiwgMSwgVmVjMi5jcm9zc051bVZlYzIod0IsIHRoaXMubV9yQikpO1xuICAgICAgICAgICAgICAgIENkb3QxLnN1YkNvbWJpbmUoMSwgdkEsIDEsIFZlYzIuY3Jvc3NOdW1WZWMyKHdBLCB0aGlzLm1fckEpKTtcbiAgICAgICAgICAgICAgICB2YXIgQ2RvdDIgPSB3QiAtIHdBOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgIHZhciBDZG90ID0gbmV3IFZlYzMoQ2RvdDEueCwgQ2RvdDEueSwgQ2RvdDIpO1xuICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlID0gVmVjMy5uZWcodGhpcy5tX21hc3Muc29sdmUzMyhDZG90KSk7IC8vIFZlYzNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gZXF1YWxMaW1pdHMkMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS5hZGQoaW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGF0TG93ZXJMaW1pdCQxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdJbXB1bHNlID0gdGhpcy5tX2ltcHVsc2UueiArIGltcHVsc2UuejsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0ltcHVsc2UgPCAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaHMgPSBWZWMyLmNvbWJpbmUoLTEsIENkb3QxLCB0aGlzLm1faW1wdWxzZS56LCBWZWMyLm5lbyh0aGlzLm1fbWFzcy5lei54LCB0aGlzLm1fbWFzcy5lei55KSk7IC8vIFZlYzJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWR1Y2VkID0gdGhpcy5tX21hc3Muc29sdmUyMihyaHMpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLnggPSByZWR1Y2VkLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLnkgPSByZWR1Y2VkLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLnogPSAtdGhpcy5tX2ltcHVsc2UuejtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggKz0gcmVkdWNlZC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSArPSByZWR1Y2VkLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UuYWRkKGltcHVsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGF0VXBwZXJMaW1pdCQyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdJbXB1bHNlID0gdGhpcy5tX2ltcHVsc2UueiArIGltcHVsc2UuejsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0ltcHVsc2UgPiAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaHMgPSBWZWMyLmNvbWJpbmUoLTEsIENkb3QxLCB0aGlzLm1faW1wdWxzZS56LCBWZWMyLm5lbyh0aGlzLm1fbWFzcy5lei54LCB0aGlzLm1fbWFzcy5lei55KSk7IC8vIFZlYzJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWR1Y2VkID0gdGhpcy5tX21hc3Muc29sdmUyMihyaHMpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLnggPSByZWR1Y2VkLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLnkgPSByZWR1Y2VkLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLnogPSAtdGhpcy5tX2ltcHVsc2UuejtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggKz0gcmVkdWNlZC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSArPSByZWR1Y2VkLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UuYWRkKGltcHVsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBQID0gVmVjMi5uZW8oaW1wdWxzZS54LCBpbXB1bHNlLnkpO1xuICAgICAgICAgICAgICAgIHZBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiAoVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQSwgUCkgKyBpbXB1bHNlLnopO1xuICAgICAgICAgICAgICAgIHZCLmFkZE11bChtQiwgUCk7XG4gICAgICAgICAgICAgICAgd0IgKz0gaUIgKiAoVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQiwgUCkgKyBpbXB1bHNlLnopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU29sdmUgcG9pbnQtdG8tcG9pbnQgY29uc3RyYWludFxuICAgICAgICAgICAgICAgIHZhciBDZG90ID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAgICAgQ2RvdC5hZGRDb21iaW5lKDEsIHZCLCAxLCBWZWMyLmNyb3NzTnVtVmVjMih3QiwgdGhpcy5tX3JCKSk7XG4gICAgICAgICAgICAgICAgQ2RvdC5zdWJDb21iaW5lKDEsIHZBLCAxLCBWZWMyLmNyb3NzTnVtVmVjMih3QSwgdGhpcy5tX3JBKSk7XG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2UgPSB0aGlzLm1fbWFzcy5zb2x2ZTIyKFZlYzIubmVnKENkb3QpKTsgLy8gVmVjMlxuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggKz0gaW1wdWxzZS54O1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgKz0gaW1wdWxzZS55O1xuICAgICAgICAgICAgICAgIHZBLnN1Yk11bChtQSwgaW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JBLCBpbXB1bHNlKTtcbiAgICAgICAgICAgICAgICB2Qi5hZGRNdWwobUIsIGltcHVsc2UpO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQiwgaW1wdWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52ID0gdkI7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZXJyb3JzIGFyZSB3aXRoaW4gdG9sZXJhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuc29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciBjQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIGNCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICAgICAgICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgICAgICAgICAgdmFyIGFuZ3VsYXJFcnJvciA9IDAuMDsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkVycm9yID0gMC4wOyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIGZpeGVkUm90YXRpb24gPSAodGhpcy5tX2ludklBICsgdGhpcy5tX2ludklCID09IDAuMCk7IC8vIGJvb2xcbiAgICAgICAgICAgIC8vIFNvbHZlIGFuZ3VsYXIgbGltaXQgY29uc3RyYWludC5cbiAgICAgICAgICAgIGlmICh0aGlzLm1fZW5hYmxlTGltaXQgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gaW5hY3RpdmVMaW1pdCQyXG4gICAgICAgICAgICAgICAgJiYgZml4ZWRSb3RhdGlvbiA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IGFCIC0gYUEgLSB0aGlzLm1fcmVmZXJlbmNlQW5nbGU7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgdmFyIGxpbWl0SW1wdWxzZSA9IDAuMDsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gZXF1YWxMaW1pdHMkMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGFuZ3VsYXIgY29ycmVjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIEMgPSBtYXRoJDEuY2xhbXAoYW5nbGUgLSB0aGlzLm1fbG93ZXJBbmdsZSwgLVNldHRpbmdzLm1heEFuZ3VsYXJDb3JyZWN0aW9uLCBTZXR0aW5ncy5tYXhBbmd1bGFyQ29ycmVjdGlvbik7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0SW1wdWxzZSA9IC10aGlzLm1fbW90b3JNYXNzICogQztcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhckVycm9yID0gbWF0aCQxLmFicyhDKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYXRMb3dlckxpbWl0JDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEMgPSBhbmdsZSAtIHRoaXMubV9sb3dlckFuZ2xlOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSAtQztcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBsYXJnZSBhbmd1bGFyIGNvcnJlY3Rpb25zIGFuZCBhbGxvdyBzb21lIHNsb3AuXG4gICAgICAgICAgICAgICAgICAgIEMgPSBtYXRoJDEuY2xhbXAoQyArIFNldHRpbmdzLmFuZ3VsYXJTbG9wLCAtU2V0dGluZ3MubWF4QW5ndWxhckNvcnJlY3Rpb24sIDAuMCk7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0SW1wdWxzZSA9IC10aGlzLm1fbW90b3JNYXNzICogQztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYXRVcHBlckxpbWl0JDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEMgPSBhbmdsZSAtIHRoaXMubV91cHBlckFuZ2xlOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSBDO1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGFuZ3VsYXIgY29ycmVjdGlvbnMgYW5kIGFsbG93IHNvbWUgc2xvcC5cbiAgICAgICAgICAgICAgICAgICAgQyA9IG1hdGgkMS5jbGFtcChDIC0gU2V0dGluZ3MuYW5ndWxhclNsb3AsIDAuMCwgU2V0dGluZ3MubWF4QW5ndWxhckNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBsaW1pdEltcHVsc2UgPSAtdGhpcy5tX21vdG9yTWFzcyAqIEM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFBIC09IHRoaXMubV9pbnZJQSAqIGxpbWl0SW1wdWxzZTtcbiAgICAgICAgICAgICAgICBhQiArPSB0aGlzLm1faW52SUIgKiBsaW1pdEltcHVsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb2x2ZSBwb2ludC10by1wb2ludCBjb25zdHJhaW50LlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHFBLnNldEFuZ2xlKGFBKTtcbiAgICAgICAgICAgICAgICBxQi5zZXRBbmdsZShhQik7XG4gICAgICAgICAgICAgICAgdmFyIHJBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTsgLy8gVmVjMlxuICAgICAgICAgICAgICAgIHZhciByQiA9IFJvdC5tdWxWZWMyKHFCLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKSk7IC8vIFZlYzJcbiAgICAgICAgICAgICAgICB2YXIgQyA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgICAgIEMuYWRkQ29tYmluZSgxLCBjQiwgMSwgckIpO1xuICAgICAgICAgICAgICAgIEMuc3ViQ29tYmluZSgxLCBjQSwgMSwgckEpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uRXJyb3IgPSBDLmxlbmd0aCgpO1xuICAgICAgICAgICAgICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgICAgICAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0I7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgdmFyIGlBID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgICAgICAgIHZhciBpQiA9IHRoaXMubV9pbnZJQjsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB2YXIgSyA9IG5ldyBNYXQyMigpO1xuICAgICAgICAgICAgICAgIEsuZXgueCA9IG1BICsgbUIgKyBpQSAqIHJBLnkgKiByQS55ICsgaUIgKiByQi55ICogckIueTtcbiAgICAgICAgICAgICAgICBLLmV4LnkgPSAtaUEgKiByQS54ICogckEueSAtIGlCICogckIueCAqIHJCLnk7XG4gICAgICAgICAgICAgICAgSy5leS54ID0gSy5leC55O1xuICAgICAgICAgICAgICAgIEsuZXkueSA9IG1BICsgbUIgKyBpQSAqIHJBLnggKiByQS54ICsgaUIgKiByQi54ICogckIueDtcbiAgICAgICAgICAgICAgICB2YXIgaW1wdWxzZSA9IFZlYzIubmVnKEsuc29sdmUoQykpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgY0Euc3ViTXVsKG1BLCBpbXB1bHNlKTtcbiAgICAgICAgICAgICAgICBhQSAtPSBpQSAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyQSwgaW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgY0IuYWRkTXVsKG1CLCBpbXB1bHNlKTtcbiAgICAgICAgICAgICAgICBhQiArPSBpQiAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyQiwgaW1wdWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jLnNldFZlYzIoY0EpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYSA9IGFBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYy5zZXRWZWMyKGNCKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmEgPSBhQjtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbkVycm9yIDw9IFNldHRpbmdzLmxpbmVhclNsb3BcbiAgICAgICAgICAgICAgICAmJiBhbmd1bGFyRXJyb3IgPD0gU2V0dGluZ3MuYW5ndWxhclNsb3A7XG4gICAgICAgIH07XG4gICAgICAgIFJldm9sdXRlSm9pbnQuVFlQRSA9ICdyZXZvbHV0ZS1qb2ludCc7XG4gICAgICAgIHJldHVybiBSZXZvbHV0ZUpvaW50O1xuICAgIH0oSm9pbnQpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICB2YXIgaW5hY3RpdmVMaW1pdCQxID0gMDtcbiAgICB2YXIgYXRMb3dlckxpbWl0ID0gMTtcbiAgICB2YXIgYXRVcHBlckxpbWl0JDEgPSAyO1xuICAgIHZhciBlcXVhbExpbWl0cyA9IDM7XG4gICAgdmFyIERFRkFVTFRTJDcgPSB7XG4gICAgICAgIGVuYWJsZUxpbWl0OiBmYWxzZSxcbiAgICAgICAgbG93ZXJUcmFuc2xhdGlvbjogMC4wLFxuICAgICAgICB1cHBlclRyYW5zbGF0aW9uOiAwLjAsXG4gICAgICAgIGVuYWJsZU1vdG9yOiBmYWxzZSxcbiAgICAgICAgbWF4TW90b3JGb3JjZTogMC4wLFxuICAgICAgICBtb3RvclNwZWVkOiAwLjBcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgcHJpc21hdGljIGpvaW50LiBUaGlzIGpvaW50IHByb3ZpZGVzIG9uZSBkZWdyZWUgb2YgZnJlZWRvbTogdHJhbnNsYXRpb25cbiAgICAgKiBhbG9uZyBhbiBheGlzIGZpeGVkIGluIGJvZHlBLiBSZWxhdGl2ZSByb3RhdGlvbiBpcyBwcmV2ZW50ZWQuIFlvdSBjYW4gdXNlIGFcbiAgICAgKiBqb2ludCBsaW1pdCB0byByZXN0cmljdCB0aGUgcmFuZ2Ugb2YgbW90aW9uIGFuZCBhIGpvaW50IG1vdG9yIHRvIGRyaXZlIHRoZVxuICAgICAqIG1vdGlvbiBvciB0byBtb2RlbCBqb2ludCBmcmljdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgUHJpc21hdGljSm9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhQcmlzbWF0aWNKb2ludCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gUHJpc21hdGljSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGFuY2hvciwgYXhpcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmICghKF90aGlzIGluc3RhbmNlb2YgUHJpc21hdGljSm9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmlzbWF0aWNKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yLCBheGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBERUZBVUxUUyQ3KTtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVmLCBib2R5QSwgYm9keUIpIHx8IHRoaXM7XG4gICAgICAgICAgICBib2R5QSA9IF90aGlzLm1fYm9keUE7XG4gICAgICAgICAgICBib2R5QiA9IF90aGlzLm1fYm9keUI7XG4gICAgICAgICAgICBfdGhpcy5tX3R5cGUgPSBQcmlzbWF0aWNKb2ludC5UWVBFO1xuICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckEgPSBWZWMyLmNsb25lKGFuY2hvciA/IGJvZHlBLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckEgfHwgVmVjMi56ZXJvKCkpO1xuICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckIgPSBWZWMyLmNsb25lKGFuY2hvciA/IGJvZHlCLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckIgfHwgVmVjMi56ZXJvKCkpO1xuICAgICAgICAgICAgX3RoaXMubV9sb2NhbFhBeGlzQSA9IFZlYzIuY2xvbmUoYXhpcyA/IGJvZHlBLmdldExvY2FsVmVjdG9yKGF4aXMpIDogZGVmLmxvY2FsQXhpc0EgfHwgVmVjMi5uZW8oMS4wLCAwLjApKTtcbiAgICAgICAgICAgIF90aGlzLm1fbG9jYWxYQXhpc0Eubm9ybWFsaXplKCk7XG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsWUF4aXNBID0gVmVjMi5jcm9zc051bVZlYzIoMS4wLCBfdGhpcy5tX2xvY2FsWEF4aXNBKTtcbiAgICAgICAgICAgIF90aGlzLm1fcmVmZXJlbmNlQW5nbGUgPSBtYXRoJDEuaXNGaW5pdGUoZGVmLnJlZmVyZW5jZUFuZ2xlKSA/IGRlZi5yZWZlcmVuY2VBbmdsZSA6IGJvZHlCLmdldEFuZ2xlKCkgLSBib2R5QS5nZXRBbmdsZSgpO1xuICAgICAgICAgICAgX3RoaXMubV9pbXB1bHNlID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIF90aGlzLm1fbW90b3JNYXNzID0gMC4wO1xuICAgICAgICAgICAgX3RoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24gPSBkZWYubG93ZXJUcmFuc2xhdGlvbjtcbiAgICAgICAgICAgIF90aGlzLm1fdXBwZXJUcmFuc2xhdGlvbiA9IGRlZi51cHBlclRyYW5zbGF0aW9uO1xuICAgICAgICAgICAgX3RoaXMubV9tYXhNb3RvckZvcmNlID0gZGVmLm1heE1vdG9yRm9yY2U7XG4gICAgICAgICAgICBfdGhpcy5tX21vdG9yU3BlZWQgPSBkZWYubW90b3JTcGVlZDtcbiAgICAgICAgICAgIF90aGlzLm1fZW5hYmxlTGltaXQgPSBkZWYuZW5hYmxlTGltaXQ7XG4gICAgICAgICAgICBfdGhpcy5tX2VuYWJsZU1vdG9yID0gZGVmLmVuYWJsZU1vdG9yO1xuICAgICAgICAgICAgX3RoaXMubV9saW1pdFN0YXRlID0gaW5hY3RpdmVMaW1pdCQxO1xuICAgICAgICAgICAgX3RoaXMubV9heGlzID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICBfdGhpcy5tX3BlcnAgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIF90aGlzLm1fSyA9IG5ldyBNYXQzMygpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgLy8gTGluZWFyIGNvbnN0cmFpbnQgKHBvaW50LXRvLWxpbmUpXG4gICAgICAgICAgICAvLyBkID0gcDIgLSBwMSA9IHgyICsgcjIgLSB4MSAtIHIxXG4gICAgICAgICAgICAvLyBDID0gZG90KHBlcnAsIGQpXG4gICAgICAgICAgICAvLyBDZG90ID0gZG90KGQsIGNyb3NzKHcxLCBwZXJwKSkgKyBkb3QocGVycCwgdjIgKyBjcm9zcyh3MiwgcjIpIC0gdjEgLVxuICAgICAgICAgICAgLy8gY3Jvc3ModzEsIHIxKSlcbiAgICAgICAgICAgIC8vID0gLWRvdChwZXJwLCB2MSkgLSBkb3QoY3Jvc3MoZCArIHIxLCBwZXJwKSwgdzEpICsgZG90KHBlcnAsIHYyKSArXG4gICAgICAgICAgICAvLyBkb3QoY3Jvc3MocjIsIHBlcnApLCB2MilcbiAgICAgICAgICAgIC8vIEogPSBbLXBlcnAsIC1jcm9zcyhkICsgcjEsIHBlcnApLCBwZXJwLCBjcm9zcyhyMixwZXJwKV1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBbmd1bGFyIGNvbnN0cmFpbnRcbiAgICAgICAgICAgIC8vIEMgPSBhMiAtIGExICsgYV9pbml0aWFsXG4gICAgICAgICAgICAvLyBDZG90ID0gdzIgLSB3MVxuICAgICAgICAgICAgLy8gSiA9IFswIDAgLTEgMCAwIDFdXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSyA9IEogKiBpbnZNICogSlRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBKID0gWy1hIC1zMSBhIHMyXVxuICAgICAgICAgICAgLy8gWzAgLTEgMCAxXVxuICAgICAgICAgICAgLy8gYSA9IHBlcnBcbiAgICAgICAgICAgIC8vIHMxID0gY3Jvc3MoZCArIHIxLCBhKSA9IGNyb3NzKHAyIC0geDEsIGEpXG4gICAgICAgICAgICAvLyBzMiA9IGNyb3NzKHIyLCBhKSA9IGNyb3NzKHAyIC0geDIsIGEpXG4gICAgICAgICAgICAvLyBNb3Rvci9MaW1pdCBsaW5lYXIgY29uc3RyYWludFxuICAgICAgICAgICAgLy8gQyA9IGRvdChheDEsIGQpXG4gICAgICAgICAgICAvLyBDZG90ID0gPSAtZG90KGF4MSwgdjEpIC0gZG90KGNyb3NzKGQgKyByMSwgYXgxKSwgdzEpICsgZG90KGF4MSwgdjIpICtcbiAgICAgICAgICAgIC8vIGRvdChjcm9zcyhyMiwgYXgxKSwgdjIpXG4gICAgICAgICAgICAvLyBKID0gWy1heDEgLWNyb3NzKGQrcjEsYXgxKSBheDEgY3Jvc3MocjIsYXgxKV1cbiAgICAgICAgICAgIC8vIEJsb2NrIFNvbHZlclxuICAgICAgICAgICAgLy8gV2UgZGV2ZWxvcCBhIGJsb2NrIHNvbHZlciB0aGF0IGluY2x1ZGVzIHRoZSBqb2ludCBsaW1pdC4gVGhpcyBtYWtlcyB0aGVcbiAgICAgICAgICAgIC8vIGxpbWl0IHN0aWZmIChpbmVsYXN0aWMpIGV2ZW5cbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIG1hc3MgaGFzIHBvb3IgZGlzdHJpYnV0aW9uIChsZWFkaW5nIHRvIGxhcmdlIHRvcnF1ZXMgYWJvdXQgdGhlXG4gICAgICAgICAgICAvLyBqb2ludCBhbmNob3IgcG9pbnRzKS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgSmFjb2JpYW4gaGFzIDMgcm93czpcbiAgICAgICAgICAgIC8vIEogPSBbLXVUIC1zMSB1VCBzMl0gLy8gbGluZWFyXG4gICAgICAgICAgICAvLyBbMCAtMSAwIDFdIC8vIGFuZ3VsYXJcbiAgICAgICAgICAgIC8vIFstdlQgLWExIHZUIGEyXSAvLyBsaW1pdFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHUgPSBwZXJwXG4gICAgICAgICAgICAvLyB2ID0gYXhpc1xuICAgICAgICAgICAgLy8gczEgPSBjcm9zcyhkICsgcjEsIHUpLCBzMiA9IGNyb3NzKHIyLCB1KVxuICAgICAgICAgICAgLy8gYTEgPSBjcm9zcyhkICsgcjEsIHYpLCBhMiA9IGNyb3NzKHIyLCB2KVxuICAgICAgICAgICAgLy8gTSAqICh2MiAtIHYxKSA9IEpUICogZGZcbiAgICAgICAgICAgIC8vIEogKiB2MiA9IGJpYXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB2MiA9IHYxICsgaW52TSAqIEpUICogZGZcbiAgICAgICAgICAgIC8vIEogKiAodjEgKyBpbnZNICogSlQgKiBkZikgPSBiaWFzXG4gICAgICAgICAgICAvLyBLICogZGYgPSBiaWFzIC0gSiAqIHYxID0gLUNkb3RcbiAgICAgICAgICAgIC8vIEsgPSBKICogaW52TSAqIEpUXG4gICAgICAgICAgICAvLyBDZG90ID0gSiAqIHYxIC0gYmlhc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE5vdyBzb2x2ZSBmb3IgZjIuXG4gICAgICAgICAgICAvLyBkZiA9IGYyIC0gZjFcbiAgICAgICAgICAgIC8vIEsgKiAoZjIgLSBmMSkgPSAtQ2RvdFxuICAgICAgICAgICAgLy8gZjIgPSBpbnZLICogKC1DZG90KSArIGYxXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQ2xhbXAgYWNjdW11bGF0ZWQgbGltaXQgaW1wdWxzZS5cbiAgICAgICAgICAgIC8vIGxvd2VyOiBmMigzKSA9IG1heChmMigzKSwgMClcbiAgICAgICAgICAgIC8vIHVwcGVyOiBmMigzKSA9IG1pbihmMigzKSwgMClcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBTb2x2ZSBmb3IgY29ycmVjdCBmMigxOjIpXG4gICAgICAgICAgICAvLyBLKDE6MiwgMToyKSAqIGYyKDE6MikgPSAtQ2RvdCgxOjIpIC0gSygxOjIsMykgKiBmMigzKSArIEsoMToyLDE6MykgKiBmMVxuICAgICAgICAgICAgLy8gPSAtQ2RvdCgxOjIpIC0gSygxOjIsMykgKiBmMigzKSArIEsoMToyLDE6MikgKiBmMSgxOjIpICsgSygxOjIsMykgKiBmMSgzKVxuICAgICAgICAgICAgLy8gSygxOjIsIDE6MikgKiBmMigxOjIpID0gLUNkb3QoMToyKSAtIEsoMToyLDMpICogKGYyKDMpIC0gZjEoMykpICtcbiAgICAgICAgICAgIC8vIEsoMToyLDE6MikgKiBmMSgxOjIpXG4gICAgICAgICAgICAvLyBmMigxOjIpID0gaW52SygxOjIsMToyKSAqICgtQ2RvdCgxOjIpIC0gSygxOjIsMykgKiAoZjIoMykgLSBmMSgzKSkpICtcbiAgICAgICAgICAgIC8vIGYxKDE6MilcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBOb3cgY29tcHV0ZSBpbXB1bHNlIHRvIGJlIGFwcGxpZWQ6XG4gICAgICAgICAgICAvLyBkZiA9IGYyIC0gZjFcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5fc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm1fdHlwZSxcbiAgICAgICAgICAgICAgICBib2R5QTogdGhpcy5tX2JvZHlBLFxuICAgICAgICAgICAgICAgIGJvZHlCOiB0aGlzLm1fYm9keUIsXG4gICAgICAgICAgICAgICAgY29sbGlkZUNvbm5lY3RlZDogdGhpcy5tX2NvbGxpZGVDb25uZWN0ZWQsXG4gICAgICAgICAgICAgICAgbG93ZXJUcmFuc2xhdGlvbjogdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24sXG4gICAgICAgICAgICAgICAgdXBwZXJUcmFuc2xhdGlvbjogdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24sXG4gICAgICAgICAgICAgICAgbWF4TW90b3JGb3JjZTogdGhpcy5tX21heE1vdG9yRm9yY2UsXG4gICAgICAgICAgICAgICAgbW90b3JTcGVlZDogdGhpcy5tX21vdG9yU3BlZWQsXG4gICAgICAgICAgICAgICAgZW5hYmxlTGltaXQ6IHRoaXMubV9lbmFibGVMaW1pdCxcbiAgICAgICAgICAgICAgICBlbmFibGVNb3RvcjogdGhpcy5tX2VuYWJsZU1vdG9yLFxuICAgICAgICAgICAgICAgIGxvY2FsQW5jaG9yQTogdGhpcy5tX2xvY2FsQW5jaG9yQSxcbiAgICAgICAgICAgICAgICBsb2NhbEFuY2hvckI6IHRoaXMubV9sb2NhbEFuY2hvckIsXG4gICAgICAgICAgICAgICAgbG9jYWxBeGlzQTogdGhpcy5tX2xvY2FsWEF4aXNBLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUFuZ2xlOiB0aGlzLm1fcmVmZXJlbmNlQW5nbGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50Ll9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhLCB3b3JsZCwgcmVzdG9yZSkge1xuICAgICAgICAgICAgZGF0YSA9IF9fYXNzaWduKHt9LCBkYXRhKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUEgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUEsIHdvcmxkKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUIgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUIsIHdvcmxkKTtcbiAgICAgICAgICAgIGRhdGEubG9jYWxBeGlzQSA9IFZlYzIuY2xvbmUoZGF0YS5sb2NhbEF4aXNBKTtcbiAgICAgICAgICAgIHZhciBqb2ludCA9IG5ldyBQcmlzbWF0aWNKb2ludChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuX3NldEFuY2hvcnMgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICAgICAgICBpZiAoZGVmLmFuY2hvckEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JBLnNldFZlYzIodGhpcy5tX2JvZHlBLmdldExvY2FsUG9pbnQoZGVmLmFuY2hvckEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZi5sb2NhbEFuY2hvckEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JBLnNldFZlYzIoZGVmLmxvY2FsQW5jaG9yQSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmLmFuY2hvckIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JCLnNldFZlYzIodGhpcy5tX2JvZHlCLmdldExvY2FsUG9pbnQoZGVmLmFuY2hvckIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZi5sb2NhbEFuY2hvckIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JCLnNldFZlYzIoZGVmLmxvY2FsQW5jaG9yQik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmLmxvY2FsQXhpc0EpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG9jYWxYQXhpc0Euc2V0VmVjMihkZWYubG9jYWxBeGlzQSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsWUF4aXNBLnNldFZlYzIoVmVjMi5jcm9zc051bVZlYzIoMS4wLCBkZWYubG9jYWxBeGlzQSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QSdzIG9yaWdpbi5cbiAgICAgICAgICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUIncyBvcmlnaW4uXG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sb2NhbEFuY2hvckI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9jYWwgam9pbnQgYXhpcyByZWxhdGl2ZSB0byBib2R5QS5cbiAgICAgICAgICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRMb2NhbEF4aXNBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sb2NhbFhBeGlzQTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVmZXJlbmNlIGFuZ2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmdldFJlZmVyZW5jZUFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY3VycmVudCBqb2ludCB0cmFuc2xhdGlvbiwgdXN1YWxseSBpbiBtZXRlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZ2V0Sm9pbnRUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwQSA9IHRoaXMubV9ib2R5QS5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckEpO1xuICAgICAgICAgICAgdmFyIHBCID0gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICAgICAgICAgICB2YXIgZCA9IFZlYzIuc3ViKHBCLCBwQSk7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IHRoaXMubV9ib2R5QS5nZXRXb3JsZFZlY3Rvcih0aGlzLm1fbG9jYWxYQXhpc0EpO1xuICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gVmVjMi5kb3QoZCwgYXhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRpb247XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgam9pbnQgdHJhbnNsYXRpb24gc3BlZWQsIHVzdWFsbHkgaW4gbWV0ZXJzIHBlciBzZWNvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZ2V0Sm9pbnRTcGVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgICAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgICAgICAgIHZhciByQSA9IFJvdC5tdWxWZWMyKGJBLm1feGYucSwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQSwgYkEubV9zd2VlcC5sb2NhbENlbnRlcikpOyAvLyBWZWMyXG4gICAgICAgICAgICB2YXIgckIgPSBSb3QubXVsVmVjMihiQi5tX3hmLnEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckIsIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIpKTsgLy8gVmVjMlxuICAgICAgICAgICAgdmFyIHAxID0gVmVjMi5hZGQoYkEubV9zd2VlcC5jLCByQSk7IC8vIFZlYzJcbiAgICAgICAgICAgIHZhciBwMiA9IFZlYzIuYWRkKGJCLm1fc3dlZXAuYywgckIpOyAvLyBWZWMyXG4gICAgICAgICAgICB2YXIgZCA9IFZlYzIuc3ViKHAyLCBwMSk7IC8vIFZlYzJcbiAgICAgICAgICAgIHZhciBheGlzID0gUm90Lm11bFZlYzIoYkEubV94Zi5xLCB0aGlzLm1fbG9jYWxYQXhpc0EpOyAvLyBWZWMyXG4gICAgICAgICAgICB2YXIgdkEgPSBiQS5tX2xpbmVhclZlbG9jaXR5OyAvLyBWZWMyXG4gICAgICAgICAgICB2YXIgdkIgPSBiQi5tX2xpbmVhclZlbG9jaXR5OyAvLyBWZWMyXG4gICAgICAgICAgICB2YXIgd0EgPSBiQS5tX2FuZ3VsYXJWZWxvY2l0eTsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciB3QiA9IGJCLm1fYW5ndWxhclZlbG9jaXR5OyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIHNwZWVkID0gVmVjMi5kb3QoZCwgVmVjMi5jcm9zc051bVZlYzIod0EsIGF4aXMpKVxuICAgICAgICAgICAgICAgICsgVmVjMi5kb3QoYXhpcywgVmVjMi5zdWIoVmVjMi5hZGRDcm9zc051bVZlYzIodkIsIHdCLCByQiksIFZlYzIuYWRkQ3Jvc3NOdW1WZWMyKHZBLCB3QSwgckEpKSk7IC8vIGZsb2F0XG4gICAgICAgICAgICByZXR1cm4gc3BlZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgam9pbnQgbGltaXQgZW5hYmxlZD9cbiAgICAgICAgICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5pc0xpbWl0RW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fZW5hYmxlTGltaXQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGUvZGlzYWJsZSB0aGUgam9pbnQgbGltaXQuXG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZW5hYmxlTGltaXQgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICAgICAgaWYgKGZsYWcgIT0gdGhpcy5tX2VuYWJsZUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JvZHlBLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fZW5hYmxlTGltaXQgPSBmbGFnO1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxvd2VyIGpvaW50IGxpbWl0LCB1c3VhbGx5IGluIG1ldGVycy5cbiAgICAgICAgICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRMb3dlckxpbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB1cHBlciBqb2ludCBsaW1pdCwgdXN1YWxseSBpbiBtZXRlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZ2V0VXBwZXJMaW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgam9pbnQgbGltaXRzLCB1c3VhbGx5IGluIG1ldGVycy5cbiAgICAgICAgICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5zZXRMaW1pdHMgPSBmdW5jdGlvbiAobG93ZXIsIHVwcGVyKSB7XG4gICAgICAgICAgICBpZiAobG93ZXIgIT0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24gfHwgdXBwZXIgIT0gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uID0gbG93ZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gPSB1cHBlcjtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIGpvaW50IG1vdG9yIGVuYWJsZWQ/XG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuaXNNb3RvckVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2VuYWJsZU1vdG9yO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlL2Rpc2FibGUgdGhlIGpvaW50IG1vdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmVuYWJsZU1vdG9yID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9lbmFibGVNb3RvciA9IGZsYWc7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG1vdG9yIHNwZWVkLCB1c3VhbGx5IGluIG1ldGVycyBwZXIgc2Vjb25kLlxuICAgICAgICAgKi9cbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLnNldE1vdG9yU3BlZWQgPSBmdW5jdGlvbiAoc3BlZWQpIHtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9tb3RvclNwZWVkID0gc3BlZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG1heGltdW0gbW90b3IgZm9yY2UsIHVzdWFsbHkgaW4gTi5cbiAgICAgICAgICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5zZXRNYXhNb3RvckZvcmNlID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm1fbWF4TW90b3JGb3JjZSA9IGZvcmNlO1xuICAgICAgICB9O1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZ2V0TWF4TW90b3JGb3JjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbWF4TW90b3JGb3JjZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbW90b3Igc3BlZWQsIHVzdWFsbHkgaW4gbWV0ZXJzIHBlciBzZWNvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZ2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbW90b3JTcGVlZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY3VycmVudCBtb3RvciBmb3JjZSBnaXZlbiB0aGUgaW52ZXJzZSB0aW1lIHN0ZXAsIHVzdWFsbHkgaW4gTi5cbiAgICAgICAgICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRNb3RvckZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9tb3RvckltcHVsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QSBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRBbmNob3JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QS5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUIgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUIuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JCKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gZm9yY2Ugb24gYm9keUIgYXQgdGhlIGpvaW50IGFuY2hvciBpbiBOZXd0b25zLlxuICAgICAgICAgKi9cbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5jb21iaW5lKHRoaXMubV9pbXB1bHNlLngsIHRoaXMubV9wZXJwLCB0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueiwgdGhpcy5tX2F4aXMpLm11bChpbnZfZHQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByZWFjdGlvbiB0b3JxdWUgb24gYm9keUIgaW4gTiptLlxuICAgICAgICAgKi9cbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9pbXB1bHNlLnk7XG4gICAgICAgIH07XG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5pbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJBID0gdGhpcy5tX2JvZHlBLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJCID0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzc0EgPSB0aGlzLm1fYm9keUEubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3NCID0gdGhpcy5tX2JvZHlCLm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9pbnZJQSA9IHRoaXMubV9ib2R5QS5tX2ludkk7XG4gICAgICAgICAgICB0aGlzLm1faW52SUIgPSB0aGlzLm1fYm9keUIubV9pbnZJO1xuICAgICAgICAgICAgdmFyIGNBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICAgICAgICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3Nlcy5cbiAgICAgICAgICAgIHZhciByQSA9IFJvdC5tdWxWZWMyKHFBLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JBLCB0aGlzLm1fbG9jYWxDZW50ZXJBKSk7XG4gICAgICAgICAgICB2YXIgckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgICAgICAgICAgdmFyIGQgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIGQuYWRkQ29tYmluZSgxLCBjQiwgMSwgckIpO1xuICAgICAgICAgICAgZC5zdWJDb21iaW5lKDEsIGNBLCAxLCByQSk7XG4gICAgICAgICAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0E7XG4gICAgICAgICAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0I7XG4gICAgICAgICAgICB2YXIgaUEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICAgICB2YXIgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgICAgICAgICAvLyBDb21wdXRlIG1vdG9yIEphY29iaWFuIGFuZCBlZmZlY3RpdmUgbWFzcy5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYXhpcyA9IFJvdC5tdWxWZWMyKHFBLCB0aGlzLm1fbG9jYWxYQXhpc0EpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9hMSA9IFZlYzIuY3Jvc3NWZWMyVmVjMihWZWMyLmFkZChkLCByQSksIHRoaXMubV9heGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYTIgPSBWZWMyLmNyb3NzVmVjMlZlYzIockIsIHRoaXMubV9heGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbW90b3JNYXNzID0gbUEgKyBtQiArIGlBICogdGhpcy5tX2ExICogdGhpcy5tX2ExICsgaUIgKiB0aGlzLm1fYTJcbiAgICAgICAgICAgICAgICAgICAgKiB0aGlzLm1fYTI7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubV9tb3Rvck1hc3MgPiAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX21vdG9yTWFzcyA9IDEuMCAvIHRoaXMubV9tb3Rvck1hc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJpc21hdGljIGNvbnN0cmFpbnQuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3BlcnAgPSBSb3QubXVsVmVjMihxQSwgdGhpcy5tX2xvY2FsWUF4aXNBKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fczEgPSBWZWMyLmNyb3NzVmVjMlZlYzIoVmVjMi5hZGQoZCwgckEpLCB0aGlzLm1fcGVycCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3MyID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHJCLCB0aGlzLm1fcGVycCk7XG4gICAgICAgICAgICAgICAgVmVjMi5jcm9zc1ZlYzJWZWMyKHJBLCB0aGlzLm1fcGVycCk7XG4gICAgICAgICAgICAgICAgdmFyIGsxMSA9IG1BICsgbUIgKyBpQSAqIHRoaXMubV9zMSAqIHRoaXMubV9zMSArIGlCICogdGhpcy5tX3MyICogdGhpcy5tX3MyO1xuICAgICAgICAgICAgICAgIHZhciBrMTIgPSBpQSAqIHRoaXMubV9zMSArIGlCICogdGhpcy5tX3MyO1xuICAgICAgICAgICAgICAgIHZhciBrMTMgPSBpQSAqIHRoaXMubV9zMSAqIHRoaXMubV9hMSArIGlCICogdGhpcy5tX3MyICogdGhpcy5tX2EyO1xuICAgICAgICAgICAgICAgIHZhciBrMjIgPSBpQSArIGlCO1xuICAgICAgICAgICAgICAgIGlmIChrMjIgPT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBib2RpZXMgd2l0aCBmaXhlZCByb3RhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgazIyID0gMS4wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgazIzID0gaUEgKiB0aGlzLm1fYTEgKyBpQiAqIHRoaXMubV9hMjtcbiAgICAgICAgICAgICAgICB2YXIgazMzID0gbUEgKyBtQiArIGlBICogdGhpcy5tX2ExICogdGhpcy5tX2ExICsgaUIgKiB0aGlzLm1fYTIgKiB0aGlzLm1fYTI7XG4gICAgICAgICAgICAgICAgdGhpcy5tX0suZXguc2V0KGsxMSwgazEyLCBrMTMpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9LLmV5LnNldChrMTIsIGsyMiwgazIzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fSy5lei5zZXQoazEzLCBrMjMsIGszMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb21wdXRlIG1vdG9yIGFuZCBsaW1pdCB0ZXJtcy5cbiAgICAgICAgICAgIGlmICh0aGlzLm1fZW5hYmxlTGltaXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgam9pbnRUcmFuc2xhdGlvbiA9IFZlYzIuZG90KHRoaXMubV9heGlzLCBkKTsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICBpZiAobWF0aCQxLmFicyh0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbiAtIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uKSA8IDIuMCAqIFNldHRpbmdzLmxpbmVhclNsb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBlcXVhbExpbWl0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoam9pbnRUcmFuc2xhdGlvbiA8PSB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgIT0gYXRMb3dlckxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGF0TG93ZXJMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoam9pbnRUcmFuc2xhdGlvbiA+PSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgIT0gYXRVcHBlckxpbWl0JDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYXRVcHBlckxpbWl0JDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGluYWN0aXZlTGltaXQkMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGluYWN0aXZlTGltaXQkMTtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV9lbmFibGVNb3RvciA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBBY2NvdW50IGZvciB2YXJpYWJsZSB0aW1lIHN0ZXAuXG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UubXVsKHN0ZXAuZHRSYXRpbyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgICAgICAgICAgdmFyIFAgPSBWZWMyLmNvbWJpbmUodGhpcy5tX2ltcHVsc2UueCwgdGhpcy5tX3BlcnAsIHRoaXMubV9tb3RvckltcHVsc2VcbiAgICAgICAgICAgICAgICAgICAgKyB0aGlzLm1faW1wdWxzZS56LCB0aGlzLm1fYXhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIExBID0gdGhpcy5tX2ltcHVsc2UueCAqIHRoaXMubV9zMSArIHRoaXMubV9pbXB1bHNlLnlcbiAgICAgICAgICAgICAgICAgICAgKyAodGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnopICogdGhpcy5tX2ExO1xuICAgICAgICAgICAgICAgIHZhciBMQiA9IHRoaXMubV9pbXB1bHNlLnggKiB0aGlzLm1fczIgKyB0aGlzLm1faW1wdWxzZS55XG4gICAgICAgICAgICAgICAgICAgICsgKHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS56KSAqIHRoaXMubV9hMjtcbiAgICAgICAgICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICAgICAgICAgIHdBIC09IGlBICogTEE7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIExCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2Uuc2V0WmVybygpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52LnNldFZlYzIodkEpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudi5zZXRWZWMyKHZCKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LncgPSB3QjtcbiAgICAgICAgfTtcbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLnNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBO1xuICAgICAgICAgICAgdmFyIG1CID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgICAgdmFyIGlBID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgICAgdmFyIGlCID0gdGhpcy5tX2ludklCO1xuICAgICAgICAgICAgLy8gU29sdmUgbGluZWFyIG1vdG9yIGNvbnN0cmFpbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5tX2VuYWJsZU1vdG9yICYmIHRoaXMubV9saW1pdFN0YXRlICE9IGVxdWFsTGltaXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIENkb3QgPSBWZWMyLmRvdCh0aGlzLm1fYXhpcywgVmVjMi5zdWIodkIsIHZBKSkgKyB0aGlzLm1fYTIgKiB3QlxuICAgICAgICAgICAgICAgICAgICAtIHRoaXMubV9hMSAqIHdBO1xuICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlID0gdGhpcy5tX21vdG9yTWFzcyAqICh0aGlzLm1fbW90b3JTcGVlZCAtIENkb3QpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX21vdG9ySW1wdWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiB0aGlzLm1fbWF4TW90b3JGb3JjZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gbWF0aCQxLmNsYW1wKHRoaXMubV9tb3RvckltcHVsc2UgKyBpbXB1bHNlLCAtbWF4SW1wdWxzZSwgbWF4SW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9tb3RvckltcHVsc2UgLSBvbGRJbXB1bHNlO1xuICAgICAgICAgICAgICAgIHZhciBQID0gVmVjMi5tdWxOdW1WZWMyKGltcHVsc2UsIHRoaXMubV9heGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgTEEgPSBpbXB1bHNlICogdGhpcy5tX2ExO1xuICAgICAgICAgICAgICAgIHZhciBMQiA9IGltcHVsc2UgKiB0aGlzLm1fYTI7XG4gICAgICAgICAgICAgICAgdkEuc3ViTXVsKG1BLCBQKTtcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIExBO1xuICAgICAgICAgICAgICAgIHZCLmFkZE11bChtQiwgUCk7XG4gICAgICAgICAgICAgICAgd0IgKz0gaUIgKiBMQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBDZG90MSA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgQ2RvdDEueCArPSBWZWMyLmRvdCh0aGlzLm1fcGVycCwgdkIpICsgdGhpcy5tX3MyICogd0I7XG4gICAgICAgICAgICBDZG90MS54IC09IFZlYzIuZG90KHRoaXMubV9wZXJwLCB2QSkgKyB0aGlzLm1fczEgKiB3QTtcbiAgICAgICAgICAgIENkb3QxLnkgPSB3QiAtIHdBO1xuICAgICAgICAgICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCAmJiB0aGlzLm1fbGltaXRTdGF0ZSAhPSBpbmFjdGl2ZUxpbWl0JDEpIHtcbiAgICAgICAgICAgICAgICAvLyBTb2x2ZSBwcmlzbWF0aWMgYW5kIGxpbWl0IGNvbnN0cmFpbnQgaW4gYmxvY2sgZm9ybS5cbiAgICAgICAgICAgICAgICB2YXIgQ2RvdDIgPSAwO1xuICAgICAgICAgICAgICAgIENkb3QyICs9IFZlYzIuZG90KHRoaXMubV9heGlzLCB2QikgKyB0aGlzLm1fYTIgKiB3QjtcbiAgICAgICAgICAgICAgICBDZG90MiAtPSBWZWMyLmRvdCh0aGlzLm1fYXhpcywgdkEpICsgdGhpcy5tX2ExICogd0E7XG4gICAgICAgICAgICAgICAgdmFyIENkb3QgPSBuZXcgVmVjMyhDZG90MS54LCBDZG90MS55LCBDZG90Mik7XG4gICAgICAgICAgICAgICAgdmFyIGYxID0gVmVjMy5jbG9uZSh0aGlzLm1faW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgdmFyIGRmID0gdGhpcy5tX0suc29sdmUzMyhWZWMzLm5lZyhDZG90KSk7IC8vIFZlYzNcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS5hZGQoZGYpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1fbGltaXRTdGF0ZSA9PSBhdExvd2VyTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IG1hdGgkMS5tYXgodGhpcy5tX2ltcHVsc2UueiwgMC4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYXRVcHBlckxpbWl0JDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IG1hdGgkMS5taW4odGhpcy5tX2ltcHVsc2UueiwgMC4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZjIoMToyKSA9IGludksoMToyLDE6MikgKiAoLUNkb3QoMToyKSAtIEsoMToyLDMpICogKGYyKDMpIC0gZjEoMykpKSArXG4gICAgICAgICAgICAgICAgLy8gZjEoMToyKVxuICAgICAgICAgICAgICAgIHZhciBiID0gVmVjMi5jb21iaW5lKC0xLCBDZG90MSwgLSh0aGlzLm1faW1wdWxzZS56IC0gZjEueiksIFZlYzIubmVvKHRoaXMubV9LLmV6LngsIHRoaXMubV9LLmV6LnkpKTsgLy8gVmVjMlxuICAgICAgICAgICAgICAgIHZhciBmMnIgPSBWZWMyLmFkZCh0aGlzLm1fSy5zb2x2ZTIyKGIpLCBWZWMyLm5lbyhmMS54LCBmMS55KSk7IC8vIFZlYzJcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS54ID0gZjJyLng7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSA9IGYyci55O1xuICAgICAgICAgICAgICAgIGRmID0gVmVjMy5zdWIodGhpcy5tX2ltcHVsc2UsIGYxKTtcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIuY29tYmluZShkZi54LCB0aGlzLm1fcGVycCwgZGYueiwgdGhpcy5tX2F4aXMpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgdmFyIExBID0gZGYueCAqIHRoaXMubV9zMSArIGRmLnkgKyBkZi56ICogdGhpcy5tX2ExOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgIHZhciBMQiA9IGRmLnggKiB0aGlzLm1fczIgKyBkZi55ICsgZGYueiAqIHRoaXMubV9hMjsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICAgICAgICAgIHdBIC09IGlBICogTEE7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIExCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTGltaXQgaXMgaW5hY3RpdmUsIGp1c3Qgc29sdmUgdGhlIHByaXNtYXRpYyBjb25zdHJhaW50IGluIGJsb2NrIGZvcm0uXG4gICAgICAgICAgICAgICAgdmFyIGRmID0gdGhpcy5tX0suc29sdmUyMihWZWMyLm5lZyhDZG90MSkpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueCArPSBkZi54O1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgKz0gZGYueTtcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIubXVsTnVtVmVjMihkZi54LCB0aGlzLm1fcGVycCk7IC8vIFZlYzJcbiAgICAgICAgICAgICAgICB2YXIgTEEgPSBkZi54ICogdGhpcy5tX3MxICsgZGYueTsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB2YXIgTEIgPSBkZi54ICogdGhpcy5tX3MyICsgZGYueTsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICAgICAgICAgIHdBIC09IGlBICogTEE7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIExCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudiA9IHZBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudiA9IHZCO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGVycm9ycyBhcmUgd2l0aGluIHRvbGVyYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIGNBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgY0IgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciBxQSA9IFJvdC5uZW8oYUEpO1xuICAgICAgICAgICAgdmFyIHFCID0gUm90Lm5lbyhhQik7XG4gICAgICAgICAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0E7XG4gICAgICAgICAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0I7XG4gICAgICAgICAgICB2YXIgaUEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICAgICB2YXIgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgICAgICAgICAvLyBDb21wdXRlIGZyZXNoIEphY29iaWFuc1xuICAgICAgICAgICAgdmFyIHJBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTsgLy8gVmVjMlxuICAgICAgICAgICAgdmFyIHJCID0gUm90Lm11bFZlYzIocUIsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sb2NhbENlbnRlckIpKTsgLy8gVmVjMlxuICAgICAgICAgICAgdmFyIGQgPSBWZWMyLnN1YihWZWMyLmFkZChjQiwgckIpLCBWZWMyLmFkZChjQSwgckEpKTsgLy8gVmVjMlxuICAgICAgICAgICAgdmFyIGF4aXMgPSBSb3QubXVsVmVjMihxQSwgdGhpcy5tX2xvY2FsWEF4aXNBKTsgLy8gVmVjMlxuICAgICAgICAgICAgdmFyIGExID0gVmVjMi5jcm9zc1ZlYzJWZWMyKFZlYzIuYWRkKGQsIHJBKSwgYXhpcyk7IC8vIGZsb2F0XG4gICAgICAgICAgICB2YXIgYTIgPSBWZWMyLmNyb3NzVmVjMlZlYzIockIsIGF4aXMpOyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIHBlcnAgPSBSb3QubXVsVmVjMihxQSwgdGhpcy5tX2xvY2FsWUF4aXNBKTsgLy8gVmVjMlxuICAgICAgICAgICAgdmFyIHMxID0gVmVjMi5jcm9zc1ZlYzJWZWMyKFZlYzIuYWRkKGQsIHJBKSwgcGVycCk7IC8vIGZsb2F0XG4gICAgICAgICAgICB2YXIgczIgPSBWZWMyLmNyb3NzVmVjMlZlYzIockIsIHBlcnApOyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIGltcHVsc2UgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIEMxID0gVmVjMi56ZXJvKCk7IC8vIFZlYzJcbiAgICAgICAgICAgIEMxLnggPSBWZWMyLmRvdChwZXJwLCBkKTtcbiAgICAgICAgICAgIEMxLnkgPSBhQiAtIGFBIC0gdGhpcy5tX3JlZmVyZW5jZUFuZ2xlO1xuICAgICAgICAgICAgdmFyIGxpbmVhckVycm9yID0gbWF0aCQxLmFicyhDMS54KTsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciBhbmd1bGFyRXJyb3IgPSBtYXRoJDEuYWJzKEMxLnkpOyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIGxpbmVhclNsb3AgPSBTZXR0aW5ncy5saW5lYXJTbG9wO1xuICAgICAgICAgICAgdmFyIG1heExpbmVhckNvcnJlY3Rpb24gPSBTZXR0aW5ncy5tYXhMaW5lYXJDb3JyZWN0aW9uO1xuICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IGZhbHNlOyAvLyBib29sXG4gICAgICAgICAgICB2YXIgQzIgPSAwLjA7IC8vIGZsb2F0XG4gICAgICAgICAgICBpZiAodGhpcy5tX2VuYWJsZUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gVmVjMi5kb3QoYXhpcywgZCk7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgaWYgKG1hdGgkMS5hYnModGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gLSB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbikgPCAyLjAgKiBsaW5lYXJTbG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgYW5ndWxhciBjb3JyZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBDMiA9IG1hdGgkMS5jbGFtcCh0cmFuc2xhdGlvbiwgLW1heExpbmVhckNvcnJlY3Rpb24sIG1heExpbmVhckNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBsaW5lYXJFcnJvciA9IG1hdGgkMS5tYXgobGluZWFyRXJyb3IsIG1hdGgkMS5hYnModHJhbnNsYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNsYXRpb24gPD0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBsYXJnZSBsaW5lYXIgY29ycmVjdGlvbnMgYW5kIGFsbG93IHNvbWUgc2xvcC5cbiAgICAgICAgICAgICAgICAgICAgQzIgPSBtYXRoJDEuY2xhbXAodHJhbnNsYXRpb24gLSB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbiArIGxpbmVhclNsb3AsIC1tYXhMaW5lYXJDb3JyZWN0aW9uLCAwLjApO1xuICAgICAgICAgICAgICAgICAgICBsaW5lYXJFcnJvciA9IG1hdGgkMVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1heChsaW5lYXJFcnJvciwgdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24gLSB0cmFuc2xhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRyYW5zbGF0aW9uID49IHRoaXMubV91cHBlclRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgbGluZWFyIGNvcnJlY3Rpb25zIGFuZCBhbGxvdyBzb21lIHNsb3AuXG4gICAgICAgICAgICAgICAgICAgIEMyID0gbWF0aCQxLmNsYW1wKHRyYW5zbGF0aW9uIC0gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gLSBsaW5lYXJTbG9wLCAwLjAsIG1heExpbmVhckNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBsaW5lYXJFcnJvciA9IG1hdGgkMVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1heChsaW5lYXJFcnJvciwgdHJhbnNsYXRpb24gLSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHZhciBrMTEgPSBtQSArIG1CICsgaUEgKiBzMSAqIHMxICsgaUIgKiBzMiAqIHMyOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgIHZhciBrMTIgPSBpQSAqIHMxICsgaUIgKiBzMjsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB2YXIgazEzID0gaUEgKiBzMSAqIGExICsgaUIgKiBzMiAqIGEyOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgIHZhciBrMjIgPSBpQSArIGlCOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgIGlmIChrMjIgPT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBmaXhlZCByb3RhdGlvblxuICAgICAgICAgICAgICAgICAgICBrMjIgPSAxLjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBrMjMgPSBpQSAqIGExICsgaUIgKiBhMjsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB2YXIgazMzID0gbUEgKyBtQiArIGlBICogYTEgKiBhMSArIGlCICogYTIgKiBhMjsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB2YXIgSyA9IG5ldyBNYXQzMygpO1xuICAgICAgICAgICAgICAgIEsuZXguc2V0KGsxMSwgazEyLCBrMTMpO1xuICAgICAgICAgICAgICAgIEsuZXkuc2V0KGsxMiwgazIyLCBrMjMpO1xuICAgICAgICAgICAgICAgIEsuZXouc2V0KGsxMywgazIzLCBrMzMpO1xuICAgICAgICAgICAgICAgIHZhciBDID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICBDLnggPSBDMS54O1xuICAgICAgICAgICAgICAgIEMueSA9IEMxLnk7XG4gICAgICAgICAgICAgICAgQy56ID0gQzI7XG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IEsuc29sdmUzMyhWZWMzLm5lZyhDKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgazExID0gbUEgKyBtQiArIGlBICogczEgKiBzMSArIGlCICogczIgKiBzMjsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB2YXIgazEyID0gaUEgKiBzMSArIGlCICogczI7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgdmFyIGsyMiA9IGlBICsgaUI7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgaWYgKGsyMiA9PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgazIyID0gMS4wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgSyA9IG5ldyBNYXQyMigpO1xuICAgICAgICAgICAgICAgIEsuZXguc2V0TnVtKGsxMSwgazEyKTtcbiAgICAgICAgICAgICAgICBLLmV5LnNldE51bShrMTIsIGsyMik7XG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2UxID0gSy5zb2x2ZShWZWMyLm5lZyhDMSkpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgaW1wdWxzZS54ID0gaW1wdWxzZTEueDtcbiAgICAgICAgICAgICAgICBpbXB1bHNlLnkgPSBpbXB1bHNlMS55O1xuICAgICAgICAgICAgICAgIGltcHVsc2UueiA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBQID0gVmVjMi5jb21iaW5lKGltcHVsc2UueCwgcGVycCwgaW1wdWxzZS56LCBheGlzKTsgLy8gVmVjMlxuICAgICAgICAgICAgdmFyIExBID0gaW1wdWxzZS54ICogczEgKyBpbXB1bHNlLnkgKyBpbXB1bHNlLnogKiBhMTsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciBMQiA9IGltcHVsc2UueCAqIHMyICsgaW1wdWxzZS55ICsgaW1wdWxzZS56ICogYTI7IC8vIGZsb2F0XG4gICAgICAgICAgICBjQS5zdWJNdWwobUEsIFApO1xuICAgICAgICAgICAgYUEgLT0gaUEgKiBMQTtcbiAgICAgICAgICAgIGNCLmFkZE11bChtQiwgUCk7XG4gICAgICAgICAgICBhQiArPSBpQiAqIExCO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYyA9IGNBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYSA9IGFBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYyA9IGNCO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYSA9IGFCO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVhckVycm9yIDw9IFNldHRpbmdzLmxpbmVhclNsb3BcbiAgICAgICAgICAgICAgICAmJiBhbmd1bGFyRXJyb3IgPD0gU2V0dGluZ3MuYW5ndWxhclNsb3A7XG4gICAgICAgIH07XG4gICAgICAgIFByaXNtYXRpY0pvaW50LlRZUEUgPSAncHJpc21hdGljLWpvaW50JztcbiAgICAgICAgcmV0dXJuIFByaXNtYXRpY0pvaW50O1xuICAgIH0oSm9pbnQpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICB2YXIgREVGQVVMVFMkNiA9IHtcbiAgICAgICAgcmF0aW86IDEuMFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBnZWFyIGpvaW50IGlzIHVzZWQgdG8gY29ubmVjdCB0d28gam9pbnRzIHRvZ2V0aGVyLiBFaXRoZXIgam9pbnQgY2FuIGJlIGFcbiAgICAgKiByZXZvbHV0ZSBvciBwcmlzbWF0aWMgam9pbnQuIFlvdSBzcGVjaWZ5IGEgZ2VhciByYXRpbyB0byBiaW5kIHRoZSBtb3Rpb25zXG4gICAgICogdG9nZXRoZXI6IGNvb3JkaW5hdGUxICsgcmF0aW8gKiBjb29yZGluYXRlMiA9IGNvbnN0YW50XG4gICAgICpcbiAgICAgKiBUaGUgcmF0aW8gY2FuIGJlIG5lZ2F0aXZlIG9yIHBvc2l0aXZlLiBJZiBvbmUgam9pbnQgaXMgYSByZXZvbHV0ZSBqb2ludCBhbmRcbiAgICAgKiB0aGUgb3RoZXIgam9pbnQgaXMgYSBwcmlzbWF0aWMgam9pbnQsIHRoZW4gdGhlIHJhdGlvIHdpbGwgaGF2ZSB1bml0cyBvZlxuICAgICAqIGxlbmd0aCBvciB1bml0cyBvZiAxL2xlbmd0aC4gV2FybmluZzogWW91IGhhdmUgdG8gbWFudWFsbHkgZGVzdHJveSB0aGUgZ2VhclxuICAgICAqIGpvaW50IGlmIGpvaW50MSBvciBqb2ludDIgaXMgZGVzdHJveWVkLlxuICAgICAqXG4gICAgICogVGhpcyBkZWZpbml0aW9uIHJlcXVpcmVzIHR3byBleGlzdGluZyByZXZvbHV0ZSBvciBwcmlzbWF0aWMgam9pbnRzIChhbnlcbiAgICAgKiBjb21iaW5hdGlvbiB3aWxsIHdvcmspLlxuICAgICAqL1xuICAgIHZhciBHZWFySm9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhHZWFySm9pbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEdlYXJKb2ludChkZWYsIGJvZHlBLCBib2R5Qiwgam9pbnQxLCBqb2ludDIsIHJhdGlvKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBHZWFySm9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHZWFySm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGpvaW50MSwgam9pbnQyLCByYXRpbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWYgPSBvcHRpb25zKGRlZiwgREVGQVVMVFMkNik7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgYm9keUEsIGJvZHlCKSB8fCB0aGlzO1xuICAgICAgICAgICAgYm9keUEgPSBfdGhpcy5tX2JvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSBfdGhpcy5tX2JvZHlCO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlID0gR2VhckpvaW50LlRZUEU7XG4gICAgICAgICAgICBfdGhpcy5tX2pvaW50MSA9IGpvaW50MSA/IGpvaW50MSA6IGRlZi5qb2ludDE7XG4gICAgICAgICAgICBfdGhpcy5tX2pvaW50MiA9IGpvaW50MiA/IGpvaW50MiA6IGRlZi5qb2ludDI7XG4gICAgICAgICAgICBfdGhpcy5tX3JhdGlvID0gbWF0aCQxLmlzRmluaXRlKHJhdGlvKSA/IHJhdGlvIDogZGVmLnJhdGlvO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlMSA9IF90aGlzLm1fam9pbnQxLmdldFR5cGUoKTtcbiAgICAgICAgICAgIF90aGlzLm1fdHlwZTIgPSBfdGhpcy5tX2pvaW50Mi5nZXRUeXBlKCk7XG4gICAgICAgICAgICAvLyBqb2ludDEgY29ubmVjdHMgYm9keSBBIHRvIGJvZHkgQ1xuICAgICAgICAgICAgLy8gam9pbnQyIGNvbm5lY3RzIGJvZHkgQiB0byBib2R5IERcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlQTtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlQjtcbiAgICAgICAgICAgIC8vIFRPRE9fRVJJTiB0aGVyZSBtaWdodCBiZSBzb21lIHByb2JsZW0gd2l0aCB0aGUgam9pbnQgZWRnZXMgaW4gSm9pbnQuXG4gICAgICAgICAgICBfdGhpcy5tX2JvZHlDID0gX3RoaXMubV9qb2ludDEuZ2V0Qm9keUEoKTtcbiAgICAgICAgICAgIF90aGlzLm1fYm9keUEgPSBfdGhpcy5tX2pvaW50MS5nZXRCb2R5QigpO1xuICAgICAgICAgICAgLy8gR2V0IGdlb21ldHJ5IG9mIGpvaW50MVxuICAgICAgICAgICAgdmFyIHhmQSA9IF90aGlzLm1fYm9keUEubV94ZjtcbiAgICAgICAgICAgIHZhciBhQSA9IF90aGlzLm1fYm9keUEubV9zd2VlcC5hO1xuICAgICAgICAgICAgdmFyIHhmQyA9IF90aGlzLm1fYm9keUMubV94ZjtcbiAgICAgICAgICAgIHZhciBhQyA9IF90aGlzLm1fYm9keUMubV9zd2VlcC5hO1xuICAgICAgICAgICAgaWYgKF90aGlzLm1fdHlwZTEgPT09IFJldm9sdXRlSm9pbnQuVFlQRSkge1xuICAgICAgICAgICAgICAgIHZhciByZXZvbHV0ZSA9IF90aGlzLm1fam9pbnQxO1xuICAgICAgICAgICAgICAgIF90aGlzLm1fbG9jYWxBbmNob3JDID0gcmV2b2x1dGUubV9sb2NhbEFuY2hvckE7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckEgPSByZXZvbHV0ZS5tX2xvY2FsQW5jaG9yQjtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX3JlZmVyZW5jZUFuZ2xlQSA9IHJldm9sdXRlLm1fcmVmZXJlbmNlQW5nbGU7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9sb2NhbEF4aXNDID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZUEgPSBhQSAtIGFDIC0gX3RoaXMubV9yZWZlcmVuY2VBbmdsZUE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJpc21hdGljID0gX3RoaXMubV9qb2ludDE7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckMgPSBwcmlzbWF0aWMubV9sb2NhbEFuY2hvckE7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckEgPSBwcmlzbWF0aWMubV9sb2NhbEFuY2hvckI7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9yZWZlcmVuY2VBbmdsZUEgPSBwcmlzbWF0aWMubV9yZWZlcmVuY2VBbmdsZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX2xvY2FsQXhpc0MgPSBwcmlzbWF0aWMubV9sb2NhbFhBeGlzQTtcbiAgICAgICAgICAgICAgICB2YXIgcEMgPSBfdGhpcy5tX2xvY2FsQW5jaG9yQztcbiAgICAgICAgICAgICAgICB2YXIgcEEgPSBSb3QubXVsVFZlYzIoeGZDLnEsIFZlYzIuYWRkKFJvdC5tdWxWZWMyKHhmQS5xLCBfdGhpcy5tX2xvY2FsQW5jaG9yQSksIFZlYzIuc3ViKHhmQS5wLCB4ZkMucCkpKTtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlQSA9IFZlYzIuZG90KHBBLCBfdGhpcy5tX2xvY2FsQXhpc0MpIC0gVmVjMi5kb3QocEMsIF90aGlzLm1fbG9jYWxBeGlzQyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5tX2JvZHlEID0gX3RoaXMubV9qb2ludDIuZ2V0Qm9keUEoKTtcbiAgICAgICAgICAgIF90aGlzLm1fYm9keUIgPSBfdGhpcy5tX2pvaW50Mi5nZXRCb2R5QigpO1xuICAgICAgICAgICAgLy8gR2V0IGdlb21ldHJ5IG9mIGpvaW50MlxuICAgICAgICAgICAgdmFyIHhmQiA9IF90aGlzLm1fYm9keUIubV94ZjtcbiAgICAgICAgICAgIHZhciBhQiA9IF90aGlzLm1fYm9keUIubV9zd2VlcC5hO1xuICAgICAgICAgICAgdmFyIHhmRCA9IF90aGlzLm1fYm9keUQubV94ZjtcbiAgICAgICAgICAgIHZhciBhRCA9IF90aGlzLm1fYm9keUQubV9zd2VlcC5hO1xuICAgICAgICAgICAgaWYgKF90aGlzLm1fdHlwZTIgPT09IFJldm9sdXRlSm9pbnQuVFlQRSkge1xuICAgICAgICAgICAgICAgIHZhciByZXZvbHV0ZSA9IF90aGlzLm1fam9pbnQyO1xuICAgICAgICAgICAgICAgIF90aGlzLm1fbG9jYWxBbmNob3JEID0gcmV2b2x1dGUubV9sb2NhbEFuY2hvckE7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckIgPSByZXZvbHV0ZS5tX2xvY2FsQW5jaG9yQjtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX3JlZmVyZW5jZUFuZ2xlQiA9IHJldm9sdXRlLm1fcmVmZXJlbmNlQW5nbGU7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9sb2NhbEF4aXNEID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZUIgPSBhQiAtIGFEIC0gX3RoaXMubV9yZWZlcmVuY2VBbmdsZUI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJpc21hdGljID0gX3RoaXMubV9qb2ludDI7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckQgPSBwcmlzbWF0aWMubV9sb2NhbEFuY2hvckE7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckIgPSBwcmlzbWF0aWMubV9sb2NhbEFuY2hvckI7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9yZWZlcmVuY2VBbmdsZUIgPSBwcmlzbWF0aWMubV9yZWZlcmVuY2VBbmdsZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX2xvY2FsQXhpc0QgPSBwcmlzbWF0aWMubV9sb2NhbFhBeGlzQTtcbiAgICAgICAgICAgICAgICB2YXIgcEQgPSBfdGhpcy5tX2xvY2FsQW5jaG9yRDtcbiAgICAgICAgICAgICAgICB2YXIgcEIgPSBSb3QubXVsVFZlYzIoeGZELnEsIFZlYzIuYWRkKFJvdC5tdWxWZWMyKHhmQi5xLCBfdGhpcy5tX2xvY2FsQW5jaG9yQiksIFZlYzIuc3ViKHhmQi5wLCB4ZkQucCkpKTtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlQiA9IFZlYzIuZG90KHBCLCBfdGhpcy5tX2xvY2FsQXhpc0QpIC0gVmVjMi5kb3QocEQsIF90aGlzLm1fbG9jYWxBeGlzRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5tX2NvbnN0YW50ID0gY29vcmRpbmF0ZUEgKyBfdGhpcy5tX3JhdGlvICogY29vcmRpbmF0ZUI7XG4gICAgICAgICAgICBfdGhpcy5tX2ltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAvLyBHZWFyIEpvaW50OlxuICAgICAgICAgICAgLy8gQzAgPSAoY29vcmRpbmF0ZTEgKyByYXRpbyAqIGNvb3JkaW5hdGUyKV9pbml0aWFsXG4gICAgICAgICAgICAvLyBDID0gKGNvb3JkaW5hdGUxICsgcmF0aW8gKiBjb29yZGluYXRlMikgLSBDMCA9IDBcbiAgICAgICAgICAgIC8vIEogPSBbSjEgcmF0aW8gKiBKMl1cbiAgICAgICAgICAgIC8vIEsgPSBKICogaW52TSAqIEpUXG4gICAgICAgICAgICAvLyA9IEoxICogaW52TTEgKiBKMVQgKyByYXRpbyAqIHJhdGlvICogSjIgKiBpbnZNMiAqIEoyVFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFJldm9sdXRlOlxuICAgICAgICAgICAgLy8gY29vcmRpbmF0ZSA9IHJvdGF0aW9uXG4gICAgICAgICAgICAvLyBDZG90ID0gYW5ndWxhclZlbG9jaXR5XG4gICAgICAgICAgICAvLyBKID0gWzAgMCAxXVxuICAgICAgICAgICAgLy8gSyA9IEogKiBpbnZNICogSlQgPSBpbnZJXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gUHJpc21hdGljOlxuICAgICAgICAgICAgLy8gY29vcmRpbmF0ZSA9IGRvdChwIC0gcGcsIHVnKVxuICAgICAgICAgICAgLy8gQ2RvdCA9IGRvdCh2ICsgY3Jvc3ModywgciksIHVnKVxuICAgICAgICAgICAgLy8gSiA9IFt1ZyBjcm9zcyhyLCB1ZyldXG4gICAgICAgICAgICAvLyBLID0gSiAqIGludk0gKiBKVCA9IGludk1hc3MgKyBpbnZJICogY3Jvc3MociwgdWcpXjJcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEdlYXJKb2ludC5wcm90b3R5cGUuX3NlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5tX3R5cGUsXG4gICAgICAgICAgICAgICAgYm9keUE6IHRoaXMubV9ib2R5QSxcbiAgICAgICAgICAgICAgICBib2R5QjogdGhpcy5tX2JvZHlCLFxuICAgICAgICAgICAgICAgIGNvbGxpZGVDb25uZWN0ZWQ6IHRoaXMubV9jb2xsaWRlQ29ubmVjdGVkLFxuICAgICAgICAgICAgICAgIGpvaW50MTogdGhpcy5tX2pvaW50MSxcbiAgICAgICAgICAgICAgICBqb2ludDI6IHRoaXMubV9qb2ludDIsXG4gICAgICAgICAgICAgICAgcmF0aW86IHRoaXMubV9yYXRpbyxcbiAgICAgICAgICAgICAgICAvLyBfY29uc3RhbnQ6IHRoaXMubV9jb25zdGFudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgR2VhckpvaW50Ll9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhLCB3b3JsZCwgcmVzdG9yZSkge1xuICAgICAgICAgICAgZGF0YSA9IF9fYXNzaWduKHt9LCBkYXRhKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUEgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUEsIHdvcmxkKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUIgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUIsIHdvcmxkKTtcbiAgICAgICAgICAgIGRhdGEuam9pbnQxID0gcmVzdG9yZShKb2ludCwgZGF0YS5qb2ludDEsIHdvcmxkKTtcbiAgICAgICAgICAgIGRhdGEuam9pbnQyID0gcmVzdG9yZShKb2ludCwgZGF0YS5qb2ludDIsIHdvcmxkKTtcbiAgICAgICAgICAgIHZhciBqb2ludCA9IG5ldyBHZWFySm9pbnQoZGF0YSk7XG4gICAgICAgICAgICAvLyBpZiAoZGF0YS5fY29uc3RhbnQpIGpvaW50Lm1fY29uc3RhbnQgPSBkYXRhLl9jb25zdGFudDtcbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZmlyc3Qgam9pbnQuXG4gICAgICAgICAqL1xuICAgICAgICBHZWFySm9pbnQucHJvdG90eXBlLmdldEpvaW50MSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fam9pbnQxO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBzZWNvbmQgam9pbnQuXG4gICAgICAgICAqL1xuICAgICAgICBHZWFySm9pbnQucHJvdG90eXBlLmdldEpvaW50MiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fam9pbnQyO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBnZWFyIHJhdGlvLlxuICAgICAgICAgKi9cbiAgICAgICAgR2VhckpvaW50LnByb3RvdHlwZS5zZXRSYXRpbyA9IGZ1bmN0aW9uIChyYXRpbykge1xuICAgICAgICAgICAgdGhpcy5tX3JhdGlvID0gcmF0aW87XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGdlYXIgcmF0aW8uXG4gICAgICAgICAqL1xuICAgICAgICBHZWFySm9pbnQucHJvdG90eXBlLmdldFJhdGlvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9yYXRpbztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHlBIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgR2VhckpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QS5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUIgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBHZWFySm9pbnQucHJvdG90eXBlLmdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlYWN0aW9uIGZvcmNlIG9uIGJvZHlCIGF0IHRoZSBqb2ludCBhbmNob3IgaW4gTmV3dG9ucy5cbiAgICAgICAgICovXG4gICAgICAgIEdlYXJKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm11bE51bVZlYzIodGhpcy5tX2ltcHVsc2UsIHRoaXMubV9KdkFDKS5tdWwoaW52X2R0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gdG9ycXVlIG9uIGJvZHlCIGluIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIEdlYXJKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICAgICAgICB2YXIgTCA9IHRoaXMubV9pbXB1bHNlICogdGhpcy5tX0p3QTsgLy8gZmxvYXRcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiBMO1xuICAgICAgICB9O1xuICAgICAgICBHZWFySm9pbnQucHJvdG90eXBlLmluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMubV9sY0EgPSB0aGlzLm1fYm9keUEubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgICAgIHRoaXMubV9sY0IgPSB0aGlzLm1fYm9keUIubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgICAgIHRoaXMubV9sY0MgPSB0aGlzLm1fYm9keUMubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgICAgIHRoaXMubV9sY0QgPSB0aGlzLm1fYm9keUQubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgICAgIHRoaXMubV9tQSA9IHRoaXMubV9ib2R5QS5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLm1fbUIgPSB0aGlzLm1fYm9keUIubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX21DID0gdGhpcy5tX2JvZHlDLm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9tRCA9IHRoaXMubV9ib2R5RC5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLm1faUEgPSB0aGlzLm1fYm9keUEubV9pbnZJO1xuICAgICAgICAgICAgdGhpcy5tX2lCID0gdGhpcy5tX2JvZHlCLm1faW52STtcbiAgICAgICAgICAgIHRoaXMubV9pQyA9IHRoaXMubV9ib2R5Qy5tX2ludkk7XG4gICAgICAgICAgICB0aGlzLm1faUQgPSB0aGlzLm1fYm9keUQubV9pbnZJO1xuICAgICAgICAgICAgdmFyIGFBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIGFDID0gdGhpcy5tX2JvZHlDLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QyA9IHRoaXMubV9ib2R5Qy5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0MgPSB0aGlzLm1fYm9keUMuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIGFEID0gdGhpcy5tX2JvZHlELmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2RCA9IHRoaXMubV9ib2R5RC5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0QgPSB0aGlzLm1fYm9keUQuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHFBID0gUm90Lm5lbyhhQSk7XG4gICAgICAgICAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICAgICAgICAgIHZhciBxQyA9IFJvdC5uZW8oYUMpO1xuICAgICAgICAgICAgdmFyIHFEID0gUm90Lm5lbyhhRCk7XG4gICAgICAgICAgICB0aGlzLm1fbWFzcyA9IDAuMDtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fdHlwZTEgPT0gUmV2b2x1dGVKb2ludC5UWVBFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX0p2QUMgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fSndBID0gMS4wO1xuICAgICAgICAgICAgICAgIHRoaXMubV9Kd0MgPSAxLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21hc3MgKz0gdGhpcy5tX2lBICsgdGhpcy5tX2lDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHUgPSBSb3QubXVsVmVjMihxQywgdGhpcy5tX2xvY2FsQXhpc0MpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgdmFyIHJDID0gUm90Lm11bFN1YihxQywgdGhpcy5tX2xvY2FsQW5jaG9yQywgdGhpcy5tX2xjQyk7IC8vIFZlYzJcbiAgICAgICAgICAgICAgICB2YXIgckEgPSBSb3QubXVsU3ViKHFBLCB0aGlzLm1fbG9jYWxBbmNob3JBLCB0aGlzLm1fbGNBKTsgLy8gVmVjMlxuICAgICAgICAgICAgICAgIHRoaXMubV9KdkFDID0gdTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fSndDID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHJDLCB1KTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fSndBID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHJBLCB1KTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbWFzcyArPSB0aGlzLm1fbUMgKyB0aGlzLm1fbUEgKyB0aGlzLm1faUMgKiB0aGlzLm1fSndDICogdGhpcy5tX0p3QyArIHRoaXMubV9pQSAqIHRoaXMubV9Kd0EgKiB0aGlzLm1fSndBO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV90eXBlMiA9PSBSZXZvbHV0ZUpvaW50LlRZUEUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fSnZCRCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9Kd0IgPSB0aGlzLm1fcmF0aW87XG4gICAgICAgICAgICAgICAgdGhpcy5tX0p3RCA9IHRoaXMubV9yYXRpbztcbiAgICAgICAgICAgICAgICB0aGlzLm1fbWFzcyArPSB0aGlzLm1fcmF0aW8gKiB0aGlzLm1fcmF0aW8gKiAodGhpcy5tX2lCICsgdGhpcy5tX2lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB1ID0gUm90Lm11bFZlYzIocUQsIHRoaXMubV9sb2NhbEF4aXNEKTsgLy8gVmVjMlxuICAgICAgICAgICAgICAgIHZhciByRCA9IFJvdC5tdWxTdWIocUQsIHRoaXMubV9sb2NhbEFuY2hvckQsIHRoaXMubV9sY0QpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgdmFyIHJCID0gUm90Lm11bFN1YihxQiwgdGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xjQik7IC8vIFZlYzJcbiAgICAgICAgICAgICAgICB0aGlzLm1fSnZCRCA9IFZlYzIubXVsTnVtVmVjMih0aGlzLm1fcmF0aW8sIHUpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9Kd0QgPSB0aGlzLm1fcmF0aW8gKiBWZWMyLmNyb3NzVmVjMlZlYzIockQsIHUpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9Kd0IgPSB0aGlzLm1fcmF0aW8gKiBWZWMyLmNyb3NzVmVjMlZlYzIockIsIHUpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9tYXNzICs9IHRoaXMubV9yYXRpbyAqIHRoaXMubV9yYXRpbyAqICh0aGlzLm1fbUQgKyB0aGlzLm1fbUIpICsgdGhpcy5tX2lEICogdGhpcy5tX0p3RCAqIHRoaXMubV9Kd0QgKyB0aGlzLm1faUIgKiB0aGlzLm1fSndCICogdGhpcy5tX0p3QjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgZWZmZWN0aXZlIG1hc3MuXG4gICAgICAgICAgICB0aGlzLm1fbWFzcyA9IHRoaXMubV9tYXNzID4gMC4wID8gMS4wIC8gdGhpcy5tX21hc3MgOiAwLjA7XG4gICAgICAgICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgICAgICAgICB2QS5hZGRNdWwodGhpcy5tX21BICogdGhpcy5tX2ltcHVsc2UsIHRoaXMubV9KdkFDKTtcbiAgICAgICAgICAgICAgICB3QSArPSB0aGlzLm1faUEgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9Kd0E7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKHRoaXMubV9tQiAqIHRoaXMubV9pbXB1bHNlLCB0aGlzLm1fSnZCRCk7XG4gICAgICAgICAgICAgICAgd0IgKz0gdGhpcy5tX2lCICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSndCO1xuICAgICAgICAgICAgICAgIHZDLnN1Yk11bCh0aGlzLm1fbUMgKiB0aGlzLm1faW1wdWxzZSwgdGhpcy5tX0p2QUMpO1xuICAgICAgICAgICAgICAgIHdDIC09IHRoaXMubV9pQyAqIHRoaXMubV9pbXB1bHNlICogdGhpcy5tX0p3QztcbiAgICAgICAgICAgICAgICB2RC5zdWJNdWwodGhpcy5tX21EICogdGhpcy5tX2ltcHVsc2UsIHRoaXMubV9KdkJEKTtcbiAgICAgICAgICAgICAgICB3RCAtPSB0aGlzLm1faUQgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9Kd0Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYuc2V0VmVjMih2QSk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52LnNldFZlYzIodkIpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlDLmNfdmVsb2NpdHkudi5zZXRWZWMyKHZDKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qy5jX3ZlbG9jaXR5LncgPSB3QztcbiAgICAgICAgICAgIHRoaXMubV9ib2R5RC5jX3ZlbG9jaXR5LnYuc2V0VmVjMih2RCk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUQuY192ZWxvY2l0eS53ID0gd0Q7XG4gICAgICAgIH07XG4gICAgICAgIEdlYXJKb2ludC5wcm90b3R5cGUuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgdkMgPSB0aGlzLm1fYm9keUMuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdDID0gdGhpcy5tX2JvZHlDLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciB2RCA9IHRoaXMubV9ib2R5RC5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0QgPSB0aGlzLm1fYm9keUQuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIENkb3QgPSBWZWMyLmRvdCh0aGlzLm1fSnZBQywgdkEpIC0gVmVjMi5kb3QodGhpcy5tX0p2QUMsIHZDKVxuICAgICAgICAgICAgICAgICsgVmVjMi5kb3QodGhpcy5tX0p2QkQsIHZCKSAtIFZlYzIuZG90KHRoaXMubV9KdkJELCB2RCk7IC8vIGZsb2F0XG4gICAgICAgICAgICBDZG90ICs9ICh0aGlzLm1fSndBICogd0EgLSB0aGlzLm1fSndDICogd0MpXG4gICAgICAgICAgICAgICAgKyAodGhpcy5tX0p3QiAqIHdCIC0gdGhpcy5tX0p3RCAqIHdEKTtcbiAgICAgICAgICAgIHZhciBpbXB1bHNlID0gLXRoaXMubV9tYXNzICogQ2RvdDsgLy8gZmxvYXRcbiAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlICs9IGltcHVsc2U7XG4gICAgICAgICAgICB2QS5hZGRNdWwodGhpcy5tX21BICogaW1wdWxzZSwgdGhpcy5tX0p2QUMpO1xuICAgICAgICAgICAgd0EgKz0gdGhpcy5tX2lBICogaW1wdWxzZSAqIHRoaXMubV9Kd0E7XG4gICAgICAgICAgICB2Qi5hZGRNdWwodGhpcy5tX21CICogaW1wdWxzZSwgdGhpcy5tX0p2QkQpO1xuICAgICAgICAgICAgd0IgKz0gdGhpcy5tX2lCICogaW1wdWxzZSAqIHRoaXMubV9Kd0I7XG4gICAgICAgICAgICB2Qy5zdWJNdWwodGhpcy5tX21DICogaW1wdWxzZSwgdGhpcy5tX0p2QUMpO1xuICAgICAgICAgICAgd0MgLT0gdGhpcy5tX2lDICogaW1wdWxzZSAqIHRoaXMubV9Kd0M7XG4gICAgICAgICAgICB2RC5zdWJNdWwodGhpcy5tX21EICogaW1wdWxzZSwgdGhpcy5tX0p2QkQpO1xuICAgICAgICAgICAgd0QgLT0gdGhpcy5tX2lEICogaW1wdWxzZSAqIHRoaXMubV9Kd0Q7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52LnNldFZlYzIodkEpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudi5zZXRWZWMyKHZCKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LncgPSB3QjtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qy5jX3ZlbG9jaXR5LnYuc2V0VmVjMih2Qyk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUMuY192ZWxvY2l0eS53ID0gd0M7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUQuY192ZWxvY2l0eS52LnNldFZlYzIodkQpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlELmNfdmVsb2NpdHkudyA9IHdEO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGVycm9ycyBhcmUgd2l0aGluIHRvbGVyYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIEdlYXJKb2ludC5wcm90b3R5cGUuc29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciBjQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIGNCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgY0MgPSB0aGlzLm1fYm9keUMuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFDID0gdGhpcy5tX2JvZHlDLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciBjRCA9IHRoaXMubV9ib2R5RC5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUQgPSB0aGlzLm1fYm9keUQuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHFBID0gUm90Lm5lbyhhQSk7XG4gICAgICAgICAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICAgICAgICAgIHZhciBxQyA9IFJvdC5uZW8oYUMpO1xuICAgICAgICAgICAgdmFyIHFEID0gUm90Lm5lbyhhRCk7XG4gICAgICAgICAgICB2YXIgbGluZWFyRXJyb3IgPSAwLjA7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZUE7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZUI7XG4gICAgICAgICAgICB2YXIgSnZBQztcbiAgICAgICAgICAgIHZhciBKdkJEO1xuICAgICAgICAgICAgdmFyIEp3QTtcbiAgICAgICAgICAgIHZhciBKd0I7XG4gICAgICAgICAgICB2YXIgSndDO1xuICAgICAgICAgICAgdmFyIEp3RDtcbiAgICAgICAgICAgIHZhciBtYXNzID0gMC4wO1xuICAgICAgICAgICAgaWYgKHRoaXMubV90eXBlMSA9PSBSZXZvbHV0ZUpvaW50LlRZUEUpIHtcbiAgICAgICAgICAgICAgICBKdkFDID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAgICAgSndBID0gMS4wO1xuICAgICAgICAgICAgICAgIEp3QyA9IDEuMDtcbiAgICAgICAgICAgICAgICBtYXNzICs9IHRoaXMubV9pQSArIHRoaXMubV9pQztcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlQSA9IGFBIC0gYUMgLSB0aGlzLm1fcmVmZXJlbmNlQW5nbGVBO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHUgPSBSb3QubXVsVmVjMihxQywgdGhpcy5tX2xvY2FsQXhpc0MpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgdmFyIHJDID0gUm90Lm11bFN1YihxQywgdGhpcy5tX2xvY2FsQW5jaG9yQywgdGhpcy5tX2xjQyk7IC8vIFZlYzJcbiAgICAgICAgICAgICAgICB2YXIgckEgPSBSb3QubXVsU3ViKHFBLCB0aGlzLm1fbG9jYWxBbmNob3JBLCB0aGlzLm1fbGNBKTsgLy8gVmVjMlxuICAgICAgICAgICAgICAgIEp2QUMgPSB1O1xuICAgICAgICAgICAgICAgIEp3QyA9IFZlYzIuY3Jvc3NWZWMyVmVjMihyQywgdSk7XG4gICAgICAgICAgICAgICAgSndBID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHJBLCB1KTtcbiAgICAgICAgICAgICAgICBtYXNzICs9IHRoaXMubV9tQyArIHRoaXMubV9tQSArIHRoaXMubV9pQyAqIEp3QyAqIEp3QyArIHRoaXMubV9pQSAqIEp3QSAqIEp3QTtcbiAgICAgICAgICAgICAgICB2YXIgcEMgPSBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JDLCB0aGlzLm1fbGNDKTsgLy8gVmVjMlxuICAgICAgICAgICAgICAgIHZhciBwQSA9IFJvdC5tdWxUVmVjMihxQywgVmVjMi5hZGQockEsIFZlYzIuc3ViKGNBLCBjQykpKTsgLy8gVmVjMlxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVBID0gVmVjMi5kb3QoVmVjMi5zdWIocEEsIHBDKSwgdGhpcy5tX2xvY2FsQXhpc0MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV90eXBlMiA9PSBSZXZvbHV0ZUpvaW50LlRZUEUpIHtcbiAgICAgICAgICAgICAgICBKdkJEID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAgICAgSndCID0gdGhpcy5tX3JhdGlvO1xuICAgICAgICAgICAgICAgIEp3RCA9IHRoaXMubV9yYXRpbztcbiAgICAgICAgICAgICAgICBtYXNzICs9IHRoaXMubV9yYXRpbyAqIHRoaXMubV9yYXRpbyAqICh0aGlzLm1faUIgKyB0aGlzLm1faUQpO1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVCID0gYUIgLSBhRCAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZUI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdSA9IFJvdC5tdWxWZWMyKHFELCB0aGlzLm1fbG9jYWxBeGlzRCk7XG4gICAgICAgICAgICAgICAgdmFyIHJEID0gUm90Lm11bFN1YihxRCwgdGhpcy5tX2xvY2FsQW5jaG9yRCwgdGhpcy5tX2xjRCk7XG4gICAgICAgICAgICAgICAgdmFyIHJCID0gUm90Lm11bFN1YihxQiwgdGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xjQik7XG4gICAgICAgICAgICAgICAgSnZCRCA9IFZlYzIubXVsTnVtVmVjMih0aGlzLm1fcmF0aW8sIHUpO1xuICAgICAgICAgICAgICAgIEp3RCA9IHRoaXMubV9yYXRpbyAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyRCwgdSk7XG4gICAgICAgICAgICAgICAgSndCID0gdGhpcy5tX3JhdGlvICogVmVjMi5jcm9zc1ZlYzJWZWMyKHJCLCB1KTtcbiAgICAgICAgICAgICAgICBtYXNzICs9IHRoaXMubV9yYXRpbyAqIHRoaXMubV9yYXRpbyAqICh0aGlzLm1fbUQgKyB0aGlzLm1fbUIpICsgdGhpcy5tX2lEXG4gICAgICAgICAgICAgICAgICAgICogSndEICogSndEICsgdGhpcy5tX2lCICogSndCICogSndCO1xuICAgICAgICAgICAgICAgIHZhciBwRCA9IFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckQsIHRoaXMubV9sY0QpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgdmFyIHBCID0gUm90Lm11bFRWZWMyKHFELCBWZWMyLmFkZChyQiwgVmVjMi5zdWIoY0IsIGNEKSkpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZUIgPSBWZWMyLmRvdChwQiwgdGhpcy5tX2xvY2FsQXhpc0QpXG4gICAgICAgICAgICAgICAgICAgIC0gVmVjMi5kb3QocEQsIHRoaXMubV9sb2NhbEF4aXNEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBDID0gKGNvb3JkaW5hdGVBICsgdGhpcy5tX3JhdGlvICogY29vcmRpbmF0ZUIpIC0gdGhpcy5tX2NvbnN0YW50OyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIGltcHVsc2UgPSAwLjA7IC8vIGZsb2F0XG4gICAgICAgICAgICBpZiAobWFzcyA+IDAuMCkge1xuICAgICAgICAgICAgICAgIGltcHVsc2UgPSAtQyAvIG1hc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjQS5hZGRNdWwodGhpcy5tX21BICogaW1wdWxzZSwgSnZBQyk7XG4gICAgICAgICAgICBhQSArPSB0aGlzLm1faUEgKiBpbXB1bHNlICogSndBO1xuICAgICAgICAgICAgY0IuYWRkTXVsKHRoaXMubV9tQiAqIGltcHVsc2UsIEp2QkQpO1xuICAgICAgICAgICAgYUIgKz0gdGhpcy5tX2lCICogaW1wdWxzZSAqIEp3QjtcbiAgICAgICAgICAgIGNDLnN1Yk11bCh0aGlzLm1fbUMgKiBpbXB1bHNlLCBKdkFDKTtcbiAgICAgICAgICAgIGFDIC09IHRoaXMubV9pQyAqIGltcHVsc2UgKiBKd0M7XG4gICAgICAgICAgICBjRC5zdWJNdWwodGhpcy5tX21EICogaW1wdWxzZSwgSnZCRCk7XG4gICAgICAgICAgICBhRCAtPSB0aGlzLm1faUQgKiBpbXB1bHNlICogSndEO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYy5zZXRWZWMyKGNBKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmEgPSBhQTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmMuc2V0VmVjMihjQik7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hID0gYUI7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUMuY19wb3NpdGlvbi5jLnNldFZlYzIoY0MpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlDLmNfcG9zaXRpb24uYSA9IGFDO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlELmNfcG9zaXRpb24uYy5zZXRWZWMyKGNEKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5RC5jX3Bvc2l0aW9uLmEgPSBhRDtcbiAgICAgICAgICAgIC8vIFRPRE9fRVJJTiBub3QgaW1wbGVtZW50ZWRcbiAgICAgICAgICAgIHJldHVybiBsaW5lYXJFcnJvciA8IFNldHRpbmdzLmxpbmVhclNsb3A7XG4gICAgICAgIH07XG4gICAgICAgIEdlYXJKb2ludC5UWVBFID0gJ2dlYXItam9pbnQnO1xuICAgICAgICByZXR1cm4gR2VhckpvaW50O1xuICAgIH0oSm9pbnQpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICB2YXIgREVGQVVMVFMkNSA9IHtcbiAgICAgICAgbWF4Rm9yY2U6IDEuMCxcbiAgICAgICAgbWF4VG9ycXVlOiAxLjAsXG4gICAgICAgIGNvcnJlY3Rpb25GYWN0b3I6IDAuM1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtb3RvciBqb2ludCBpcyB1c2VkIHRvIGNvbnRyb2wgdGhlIHJlbGF0aXZlIG1vdGlvbiBiZXR3ZWVuIHR3byBib2RpZXMuIEFcbiAgICAgKiB0eXBpY2FsIHVzYWdlIGlzIHRvIGNvbnRyb2wgdGhlIG1vdmVtZW50IG9mIGEgZHluYW1pYyBib2R5IHdpdGggcmVzcGVjdCB0b1xuICAgICAqIHRoZSBncm91bmQuXG4gICAgICovXG4gICAgdmFyIE1vdG9ySm9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhNb3RvckpvaW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBNb3RvckpvaW50KGRlZiwgYm9keUEsIGJvZHlCKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBNb3RvckpvaW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW90b3JKb2ludChkZWYsIGJvZHlBLCBib2R5Qik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWYgPSBvcHRpb25zKGRlZiwgREVGQVVMVFMkNSk7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgYm9keUEsIGJvZHlCKSB8fCB0aGlzO1xuICAgICAgICAgICAgYm9keUEgPSBfdGhpcy5tX2JvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSBfdGhpcy5tX2JvZHlCO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlID0gTW90b3JKb2ludC5UWVBFO1xuICAgICAgICAgICAgX3RoaXMubV9saW5lYXJPZmZzZXQgPSBtYXRoJDEuaXNGaW5pdGUoZGVmLmxpbmVhck9mZnNldCkgPyBkZWYubGluZWFyT2Zmc2V0IDogYm9keUEuZ2V0TG9jYWxQb2ludChib2R5Qi5nZXRQb3NpdGlvbigpKTtcbiAgICAgICAgICAgIF90aGlzLm1fYW5ndWxhck9mZnNldCA9IG1hdGgkMS5pc0Zpbml0ZShkZWYuYW5ndWxhck9mZnNldCkgPyBkZWYuYW5ndWxhck9mZnNldCA6IGJvZHlCLmdldEFuZ2xlKCkgLSBib2R5QS5nZXRBbmdsZSgpO1xuICAgICAgICAgICAgX3RoaXMubV9saW5lYXJJbXB1bHNlID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICBfdGhpcy5tX2FuZ3VsYXJJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgX3RoaXMubV9tYXhGb3JjZSA9IGRlZi5tYXhGb3JjZTtcbiAgICAgICAgICAgIF90aGlzLm1fbWF4VG9ycXVlID0gZGVmLm1heFRvcnF1ZTtcbiAgICAgICAgICAgIF90aGlzLm1fY29ycmVjdGlvbkZhY3RvciA9IGRlZi5jb3JyZWN0aW9uRmFjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgLy8gUG9pbnQtdG8tcG9pbnQgY29uc3RyYWludFxuICAgICAgICAgICAgLy8gQ2RvdCA9IHYyIC0gdjFcbiAgICAgICAgICAgIC8vID0gdjIgKyBjcm9zcyh3MiwgcjIpIC0gdjEgLSBjcm9zcyh3MSwgcjEpXG4gICAgICAgICAgICAvLyBKID0gWy1JIC1yMV9za2V3IEkgcjJfc2tldyBdXG4gICAgICAgICAgICAvLyBJZGVudGl0eSB1c2VkOlxuICAgICAgICAgICAgLy8gdyBrICUgKHJ4IGkgKyByeSBqKSA9IHcgKiAoLXJ5IGkgKyByeCBqKVxuICAgICAgICAgICAgLy8gQW5nbGUgY29uc3RyYWludFxuICAgICAgICAgICAgLy8gQ2RvdCA9IHcyIC0gdzFcbiAgICAgICAgICAgIC8vIEogPSBbMCAwIC0xIDAgMCAxXVxuICAgICAgICAgICAgLy8gSyA9IGludkkxICsgaW52STJcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE1vdG9ySm9pbnQucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMubV90eXBlLFxuICAgICAgICAgICAgICAgIGJvZHlBOiB0aGlzLm1fYm9keUEsXG4gICAgICAgICAgICAgICAgYm9keUI6IHRoaXMubV9ib2R5QixcbiAgICAgICAgICAgICAgICBjb2xsaWRlQ29ubmVjdGVkOiB0aGlzLm1fY29sbGlkZUNvbm5lY3RlZCxcbiAgICAgICAgICAgICAgICBtYXhGb3JjZTogdGhpcy5tX21heEZvcmNlLFxuICAgICAgICAgICAgICAgIG1heFRvcnF1ZTogdGhpcy5tX21heFRvcnF1ZSxcbiAgICAgICAgICAgICAgICBjb3JyZWN0aW9uRmFjdG9yOiB0aGlzLm1fY29ycmVjdGlvbkZhY3RvcixcbiAgICAgICAgICAgICAgICBsaW5lYXJPZmZzZXQ6IHRoaXMubV9saW5lYXJPZmZzZXQsXG4gICAgICAgICAgICAgICAgYW5ndWxhck9mZnNldDogdGhpcy5tX2FuZ3VsYXJPZmZzZXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE1vdG9ySm9pbnQuX2Rlc2VyaWFsaXplID0gZnVuY3Rpb24gKGRhdGEsIHdvcmxkLCByZXN0b3JlKSB7XG4gICAgICAgICAgICBkYXRhID0gX19hc3NpZ24oe30sIGRhdGEpO1xuICAgICAgICAgICAgZGF0YS5ib2R5QSA9IHJlc3RvcmUoQm9keSwgZGF0YS5ib2R5QSwgd29ybGQpO1xuICAgICAgICAgICAgZGF0YS5ib2R5QiA9IHJlc3RvcmUoQm9keSwgZGF0YS5ib2R5Qiwgd29ybGQpO1xuICAgICAgICAgICAgdmFyIGpvaW50ID0gbmV3IE1vdG9ySm9pbnQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gam9pbnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTW90b3JKb2ludC5wcm90b3R5cGUuX3NldEFuY2hvcnMgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG1heGltdW0gZnJpY3Rpb24gZm9yY2UgaW4gTi5cbiAgICAgICAgICovXG4gICAgICAgIE1vdG9ySm9pbnQucHJvdG90eXBlLnNldE1heEZvcmNlID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgICAgICAgICB0aGlzLm1fbWF4Rm9yY2UgPSBmb3JjZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbWF4aW11bSBmcmljdGlvbiBmb3JjZSBpbiBOLlxuICAgICAgICAgKi9cbiAgICAgICAgTW90b3JKb2ludC5wcm90b3R5cGUuZ2V0TWF4Rm9yY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX21heEZvcmNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBtYXhpbXVtIGZyaWN0aW9uIHRvcnF1ZSBpbiBOKm0uXG4gICAgICAgICAqL1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5zZXRNYXhUb3JxdWUgPSBmdW5jdGlvbiAodG9ycXVlKSB7XG4gICAgICAgICAgICB0aGlzLm1fbWF4VG9ycXVlID0gdG9ycXVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtYXhpbXVtIGZyaWN0aW9uIHRvcnF1ZSBpbiBOKm0uXG4gICAgICAgICAqL1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5nZXRNYXhUb3JxdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX21heFRvcnF1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgcG9zaXRpb24gY29ycmVjdGlvbiBmYWN0b3IgaW4gdGhlIHJhbmdlIFswLDFdLlxuICAgICAgICAgKi9cbiAgICAgICAgTW90b3JKb2ludC5wcm90b3R5cGUuc2V0Q29ycmVjdGlvbkZhY3RvciA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMubV9jb3JyZWN0aW9uRmFjdG9yID0gZmFjdG9yO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBwb3NpdGlvbiBjb3JyZWN0aW9uIGZhY3RvciBpbiB0aGUgcmFuZ2UgWzAsMV0uXG4gICAgICAgICAqL1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5nZXRDb3JyZWN0aW9uRmFjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9jb3JyZWN0aW9uRmFjdG9yO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0L2dldCB0aGUgdGFyZ2V0IGxpbmVhciBvZmZzZXQsIGluIGZyYW1lIEEsIGluIG1ldGVycy5cbiAgICAgICAgICovXG4gICAgICAgIE1vdG9ySm9pbnQucHJvdG90eXBlLnNldExpbmVhck9mZnNldCA9IGZ1bmN0aW9uIChsaW5lYXJPZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChsaW5lYXJPZmZzZXQueCAhPSB0aGlzLm1fbGluZWFyT2Zmc2V0LnhcbiAgICAgICAgICAgICAgICB8fCBsaW5lYXJPZmZzZXQueSAhPSB0aGlzLm1fbGluZWFyT2Zmc2V0LnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9saW5lYXJPZmZzZXQgPSBsaW5lYXJPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE1vdG9ySm9pbnQucHJvdG90eXBlLmdldExpbmVhck9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbGluZWFyT2Zmc2V0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0L2dldCB0aGUgdGFyZ2V0IGFuZ3VsYXIgb2Zmc2V0LCBpbiByYWRpYW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgTW90b3JKb2ludC5wcm90b3R5cGUuc2V0QW5ndWxhck9mZnNldCA9IGZ1bmN0aW9uIChhbmd1bGFyT2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAoYW5ndWxhck9mZnNldCAhPSB0aGlzLm1fYW5ndWxhck9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJPZmZzZXQgPSBhbmd1bGFyT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5nZXRBbmd1bGFyT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9hbmd1bGFyT2Zmc2V0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUEgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QS5nZXRQb3NpdGlvbigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUIgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5nZXRQb3NpdGlvbigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByZWFjdGlvbiBmb3JjZSBvbiBib2R5QiBhdCB0aGUgam9pbnQgYW5jaG9yIGluIE5ld3RvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubXVsTnVtVmVjMihpbnZfZHQsIHRoaXMubV9saW5lYXJJbXB1bHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gdG9ycXVlIG9uIGJvZHlCIGluIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIE1vdG9ySm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9hbmd1bGFySW1wdWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgTW90b3JKb2ludC5wcm90b3R5cGUuaW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQSA9IHRoaXMubV9ib2R5QS5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQiA9IHRoaXMubV9ib2R5Qi5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3NBID0gdGhpcy5tX2JvZHlBLm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9pbnZNYXNzQiA9IHRoaXMubV9ib2R5Qi5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLm1faW52SUEgPSB0aGlzLm1fYm9keUEubV9pbnZJO1xuICAgICAgICAgICAgdGhpcy5tX2ludklCID0gdGhpcy5tX2JvZHlCLm1faW52STtcbiAgICAgICAgICAgIHZhciBjQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgY0IgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHFBID0gUm90Lm5lbyhhQSk7XG4gICAgICAgICAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGVmZmVjdGl2ZSBtYXNzIG1hdHJpeC5cbiAgICAgICAgICAgIHRoaXMubV9yQSA9IFJvdC5tdWxWZWMyKHFBLCBWZWMyLm5lZyh0aGlzLm1fbG9jYWxDZW50ZXJBKSk7XG4gICAgICAgICAgICB0aGlzLm1fckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5uZWcodGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgICAgICAgICAgLy8gSiA9IFstSSAtcjFfc2tldyBJIHIyX3NrZXddXG4gICAgICAgICAgICAvLyBbIDAgLTEgMCAxXVxuICAgICAgICAgICAgLy8gcl9za2V3ID0gWy1yeTsgcnhdXG4gICAgICAgICAgICAvLyBNYXRsYWJcbiAgICAgICAgICAgIC8vIEsgPSBbIG1BK3IxeV4yKmlBK21CK3IyeV4yKmlCLCAtcjF5KmlBKnIxeC1yMnkqaUIqcjJ4LCAtcjF5KmlBLXIyeSppQl1cbiAgICAgICAgICAgIC8vIFsgLXIxeSppQSpyMXgtcjJ5KmlCKnIyeCwgbUErcjF4XjIqaUErbUIrcjJ4XjIqaUIsIHIxeCppQStyMngqaUJdXG4gICAgICAgICAgICAvLyBbIC1yMXkqaUEtcjJ5KmlCLCByMXgqaUErcjJ4KmlCLCBpQStpQl1cbiAgICAgICAgICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgICAgIHZhciBtQiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICAgICAgICAgIHZhciBpQSA9IHRoaXMubV9pbnZJQTtcbiAgICAgICAgICAgIHZhciBpQiA9IHRoaXMubV9pbnZJQjtcbiAgICAgICAgICAgIHZhciBLID0gbmV3IE1hdDIyKCk7XG4gICAgICAgICAgICBLLmV4LnggPSBtQSArIG1CICsgaUEgKiB0aGlzLm1fckEueSAqIHRoaXMubV9yQS55ICsgaUIgKiB0aGlzLm1fckIueSAqIHRoaXMubV9yQi55O1xuICAgICAgICAgICAgSy5leC55ID0gLWlBICogdGhpcy5tX3JBLnggKiB0aGlzLm1fckEueSAtIGlCICogdGhpcy5tX3JCLnggKiB0aGlzLm1fckIueTtcbiAgICAgICAgICAgIEsuZXkueCA9IEsuZXgueTtcbiAgICAgICAgICAgIEsuZXkueSA9IG1BICsgbUIgKyBpQSAqIHRoaXMubV9yQS54ICogdGhpcy5tX3JBLnggKyBpQiAqIHRoaXMubV9yQi54ICogdGhpcy5tX3JCLng7XG4gICAgICAgICAgICB0aGlzLm1fbGluZWFyTWFzcyA9IEsuZ2V0SW52ZXJzZSgpO1xuICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJNYXNzID0gaUEgKyBpQjtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fYW5ndWxhck1hc3MgPiAwLjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYW5ndWxhck1hc3MgPSAxLjAgLyB0aGlzLm1fYW5ndWxhck1hc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fbGluZWFyRXJyb3IgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIHRoaXMubV9saW5lYXJFcnJvci5hZGRDb21iaW5lKDEsIGNCLCAxLCB0aGlzLm1fckIpO1xuICAgICAgICAgICAgdGhpcy5tX2xpbmVhckVycm9yLnN1YkNvbWJpbmUoMSwgY0EsIDEsIHRoaXMubV9yQSk7XG4gICAgICAgICAgICB0aGlzLm1fbGluZWFyRXJyb3Iuc3ViKFJvdC5tdWxWZWMyKHFBLCB0aGlzLm1fbGluZWFyT2Zmc2V0KSk7XG4gICAgICAgICAgICB0aGlzLm1fYW5ndWxhckVycm9yID0gYUIgLSBhQSAtIHRoaXMubV9hbmd1bGFyT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgaW1wdWxzZXMgdG8gc3VwcG9ydCBhIHZhcmlhYmxlIHRpbWUgc3RlcC5cbiAgICAgICAgICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5tdWwoc3RlcC5kdFJhdGlvKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYW5ndWxhckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgICAgICAgIHZhciBQID0gVmVjMi5uZW8odGhpcy5tX2xpbmVhckltcHVsc2UueCwgdGhpcy5tX2xpbmVhckltcHVsc2UueSk7XG4gICAgICAgICAgICAgICAgdkEuc3ViTXVsKG1BLCBQKTtcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIChWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JBLCBQKSArIHRoaXMubV9hbmd1bGFySW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIChWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBQKSArIHRoaXMubV9hbmd1bGFySW1wdWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudiA9IHZBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudiA9IHZCO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5zb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgICAgIHZhciBtQiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICAgICAgICAgIHZhciBpQSA9IHRoaXMubV9pbnZJQTtcbiAgICAgICAgICAgIHZhciBpQiA9IHRoaXMubV9pbnZJQjtcbiAgICAgICAgICAgIHZhciBoID0gc3RlcC5kdDtcbiAgICAgICAgICAgIHZhciBpbnZfaCA9IHN0ZXAuaW52X2R0O1xuICAgICAgICAgICAgLy8gU29sdmUgYW5ndWxhciBmcmljdGlvblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBDZG90ID0gd0IgLSB3QSArIGludl9oICogdGhpcy5tX2NvcnJlY3Rpb25GYWN0b3IgKiB0aGlzLm1fYW5ndWxhckVycm9yO1xuICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlID0gLXRoaXMubV9hbmd1bGFyTWFzcyAqIENkb3Q7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEltcHVsc2UgPSB0aGlzLm1fYW5ndWxhckltcHVsc2U7XG4gICAgICAgICAgICAgICAgdmFyIG1heEltcHVsc2UgPSBoICogdGhpcy5tX21heFRvcnF1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYW5ndWxhckltcHVsc2UgPSBtYXRoJDEuY2xhbXAodGhpcy5tX2FuZ3VsYXJJbXB1bHNlICsgaW1wdWxzZSwgLW1heEltcHVsc2UsIG1heEltcHVsc2UpO1xuICAgICAgICAgICAgICAgIGltcHVsc2UgPSB0aGlzLm1fYW5ndWxhckltcHVsc2UgLSBvbGRJbXB1bHNlO1xuICAgICAgICAgICAgICAgIHdBIC09IGlBICogaW1wdWxzZTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIGltcHVsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb2x2ZSBsaW5lYXIgZnJpY3Rpb25cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgQ2RvdCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgICAgIENkb3QuYWRkQ29tYmluZSgxLCB2QiwgMSwgVmVjMi5jcm9zc051bVZlYzIod0IsIHRoaXMubV9yQikpO1xuICAgICAgICAgICAgICAgIENkb3Quc3ViQ29tYmluZSgxLCB2QSwgMSwgVmVjMi5jcm9zc051bVZlYzIod0EsIHRoaXMubV9yQSkpO1xuICAgICAgICAgICAgICAgIENkb3QuYWRkTXVsKGludl9oICogdGhpcy5tX2NvcnJlY3Rpb25GYWN0b3IsIHRoaXMubV9saW5lYXJFcnJvcik7XG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2UgPSBWZWMyLm5lZyhNYXQyMi5tdWxWZWMyKHRoaXMubV9saW5lYXJNYXNzLCBDZG90KSk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEltcHVsc2UgPSBWZWMyLmNsb25lKHRoaXMubV9saW5lYXJJbXB1bHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5hZGQoaW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgdmFyIG1heEltcHVsc2UgPSBoICogdGhpcy5tX21heEZvcmNlO1xuICAgICAgICAgICAgICAgIHRoaXMubV9saW5lYXJJbXB1bHNlLmNsYW1wKG1heEltcHVsc2UpO1xuICAgICAgICAgICAgICAgIGltcHVsc2UgPSBWZWMyLnN1Yih0aGlzLm1fbGluZWFySW1wdWxzZSwgb2xkSW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgdkEuc3ViTXVsKG1BLCBpbXB1bHNlKTtcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckEsIGltcHVsc2UpO1xuICAgICAgICAgICAgICAgIHZCLmFkZE11bChtQiwgaW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgd0IgKz0gaUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBpbXB1bHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYgPSB2QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYgPSB2QjtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LncgPSB3QjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBwb3NpdGlvbiBlcnJvcnMgYXJlIHdpdGhpbiB0b2xlcmFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIE1vdG9ySm9pbnQuVFlQRSA9ICdtb3Rvci1qb2ludCc7XG4gICAgICAgIHJldHVybiBNb3RvckpvaW50O1xuICAgIH0oSm9pbnQpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICB2YXIgREVGQVVMVFMkNCA9IHtcbiAgICAgICAgbWF4Rm9yY2U6IDAuMCxcbiAgICAgICAgZnJlcXVlbmN5SHo6IDUuMCxcbiAgICAgICAgZGFtcGluZ1JhdGlvOiAwLjdcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbW91c2Ugam9pbnQgaXMgdXNlZCB0byBtYWtlIGEgcG9pbnQgb24gYSBib2R5IHRyYWNrIGEgc3BlY2lmaWVkIHdvcmxkXG4gICAgICogcG9pbnQuIFRoaXMgYSBzb2Z0IGNvbnN0cmFpbnQgd2l0aCBhIG1heGltdW0gZm9yY2UuIFRoaXMgYWxsb3dzIHRoZVxuICAgICAqIGNvbnN0cmFpbnQgdG8gc3RyZXRjaCBhbmQgd2l0aG91dCBhcHBseWluZyBodWdlIGZvcmNlcy5cbiAgICAgKlxuICAgICAqIE5PVEU6IHRoaXMgam9pbnQgaXMgbm90IGRvY3VtZW50ZWQgaW4gdGhlIG1hbnVhbCBiZWNhdXNlIGl0IHdhcyBkZXZlbG9wZWQgdG9cbiAgICAgKiBiZSB1c2VkIGluIHRoZSB0ZXN0YmVkLiBJZiB5b3Ugd2FudCB0byBsZWFybiBob3cgdG8gdXNlIHRoZSBtb3VzZSBqb2ludCwgbG9va1xuICAgICAqIGF0IHRoZSB0ZXN0YmVkLlxuICAgICAqL1xuICAgIHZhciBNb3VzZUpvaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoTW91c2VKb2ludCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTW91c2VKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgdGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBNb3VzZUpvaW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW91c2VKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBERUZBVUxUUyQ0KTtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVmLCBib2R5QSwgYm9keUIpIHx8IHRoaXM7XG4gICAgICAgICAgICBib2R5QSA9IF90aGlzLm1fYm9keUE7XG4gICAgICAgICAgICBib2R5QiA9IF90aGlzLm1fYm9keUI7XG4gICAgICAgICAgICBfdGhpcy5tX3R5cGUgPSBNb3VzZUpvaW50LlRZUEU7XG4gICAgICAgICAgICBfdGhpcy5tX3RhcmdldEEgPSB0YXJnZXQgPyBWZWMyLmNsb25lKHRhcmdldCkgOiBkZWYudGFyZ2V0IHx8IFZlYzIuemVybygpO1xuICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckIgPSBUcmFuc2Zvcm0ubXVsVFZlYzIoYm9keUIuZ2V0VHJhbnNmb3JtKCksIF90aGlzLm1fdGFyZ2V0QSk7XG4gICAgICAgICAgICBfdGhpcy5tX21heEZvcmNlID0gZGVmLm1heEZvcmNlO1xuICAgICAgICAgICAgX3RoaXMubV9pbXB1bHNlID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICBfdGhpcy5tX2ZyZXF1ZW5jeUh6ID0gZGVmLmZyZXF1ZW5jeUh6O1xuICAgICAgICAgICAgX3RoaXMubV9kYW1waW5nUmF0aW8gPSBkZWYuZGFtcGluZ1JhdGlvO1xuICAgICAgICAgICAgX3RoaXMubV9iZXRhID0gMC4wO1xuICAgICAgICAgICAgX3RoaXMubV9nYW1tYSA9IDAuMDtcbiAgICAgICAgICAgIC8vIFNvbHZlciB0ZW1wXG4gICAgICAgICAgICBfdGhpcy5tX3JCID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsQ2VudGVyQiA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgX3RoaXMubV9pbnZNYXNzQiA9IDAuMDtcbiAgICAgICAgICAgIF90aGlzLm1faW52SUIgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX21hc3MgPSBuZXcgTWF0MjIoKTtcbiAgICAgICAgICAgIF90aGlzLm1fQyA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgLy8gcCA9IGF0dGFjaGVkIHBvaW50LCBtID0gbW91c2UgcG9pbnRcbiAgICAgICAgICAgIC8vIEMgPSBwIC0gbVxuICAgICAgICAgICAgLy8gQ2RvdCA9IHZcbiAgICAgICAgICAgIC8vID0gdiArIGNyb3NzKHcsIHIpXG4gICAgICAgICAgICAvLyBKID0gW0kgcl9za2V3XVxuICAgICAgICAgICAgLy8gSWRlbnRpdHkgdXNlZDpcbiAgICAgICAgICAgIC8vIHcgayAlIChyeCBpICsgcnkgaikgPSB3ICogKC1yeSBpICsgcnggailcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE1vdXNlSm9pbnQucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMubV90eXBlLFxuICAgICAgICAgICAgICAgIGJvZHlBOiB0aGlzLm1fYm9keUEsXG4gICAgICAgICAgICAgICAgYm9keUI6IHRoaXMubV9ib2R5QixcbiAgICAgICAgICAgICAgICBjb2xsaWRlQ29ubmVjdGVkOiB0aGlzLm1fY29sbGlkZUNvbm5lY3RlZCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMubV90YXJnZXRBLFxuICAgICAgICAgICAgICAgIG1heEZvcmNlOiB0aGlzLm1fbWF4Rm9yY2UsXG4gICAgICAgICAgICAgICAgZnJlcXVlbmN5SHo6IHRoaXMubV9mcmVxdWVuY3lIeixcbiAgICAgICAgICAgICAgICBkYW1waW5nUmF0aW86IHRoaXMubV9kYW1waW5nUmF0aW8sXG4gICAgICAgICAgICAgICAgX2xvY2FsQW5jaG9yQjogdGhpcy5tX2xvY2FsQW5jaG9yQixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTW91c2VKb2ludC5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSwgd29ybGQsIHJlc3RvcmUpIHtcbiAgICAgICAgICAgIGRhdGEgPSBfX2Fzc2lnbih7fSwgZGF0YSk7XG4gICAgICAgICAgICBkYXRhLmJvZHlBID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlBLCB3b3JsZCk7XG4gICAgICAgICAgICBkYXRhLmJvZHlCID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlCLCB3b3JsZCk7XG4gICAgICAgICAgICBkYXRhLnRhcmdldCA9IFZlYzIuY2xvbmUoZGF0YS50YXJnZXQpO1xuICAgICAgICAgICAgdmFyIGpvaW50ID0gbmV3IE1vdXNlSm9pbnQoZGF0YSk7XG4gICAgICAgICAgICBpZiAoZGF0YS5fbG9jYWxBbmNob3JCKSB7XG4gICAgICAgICAgICAgICAgam9pbnQubV9sb2NhbEFuY2hvckIgPSBkYXRhLl9sb2NhbEFuY2hvckI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gam9pbnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgdGhpcyB0byB1cGRhdGUgdGhlIHRhcmdldCBwb2ludC5cbiAgICAgICAgICovXG4gICAgICAgIE1vdXNlSm9pbnQucHJvdG90eXBlLnNldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fYm9keUIuaXNBd2FrZSgpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX3RhcmdldEEgPSBWZWMyLmNsb25lKHRhcmdldCk7XG4gICAgICAgIH07XG4gICAgICAgIE1vdXNlSm9pbnQucHJvdG90eXBlLmdldFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdGFyZ2V0QTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbWF4aW11bSBmb3JjZSBpbiBOZXd0b25zLlxuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VKb2ludC5wcm90b3R5cGUuc2V0TWF4Rm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgICAgIHRoaXMubV9tYXhGb3JjZSA9IGZvcmNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtYXhpbXVtIGZvcmNlIGluIE5ld3RvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBNb3VzZUpvaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbWF4Rm9yY2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGZyZXF1ZW5jeSBpbiBIZXJ0ei5cbiAgICAgICAgICovXG4gICAgICAgIE1vdXNlSm9pbnQucHJvdG90eXBlLnNldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uIChoeikge1xuICAgICAgICAgICAgdGhpcy5tX2ZyZXF1ZW5jeUh6ID0gaHo7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGZyZXF1ZW5jeSBpbiBIZXJ0ei5cbiAgICAgICAgICovXG4gICAgICAgIE1vdXNlSm9pbnQucHJvdG90eXBlLmdldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGRhbXBpbmcgcmF0aW8gKGRpbWVuc2lvbmxlc3MpLlxuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VKb2ludC5wcm90b3R5cGUuc2V0RGFtcGluZ1JhdGlvID0gZnVuY3Rpb24gKHJhdGlvKSB7XG4gICAgICAgICAgICB0aGlzLm1fZGFtcGluZ1JhdGlvID0gcmF0aW87XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGRhbXBpbmcgcmF0aW8gKGRpbWVuc2lvbmxlc3MpLlxuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VKb2ludC5wcm90b3R5cGUuZ2V0RGFtcGluZ1JhdGlvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9kYW1waW5nUmF0aW87XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QSBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIE1vdXNlSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5jbG9uZSh0aGlzLm1fdGFyZ2V0QSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QiBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIE1vdXNlSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlYWN0aW9uIGZvcmNlIG9uIGJvZHlCIGF0IHRoZSBqb2ludCBhbmNob3IgaW4gTmV3dG9ucy5cbiAgICAgICAgICovXG4gICAgICAgIE1vdXNlSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5tdWxOdW1WZWMyKGludl9kdCwgdGhpcy5tX2ltcHVsc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByZWFjdGlvbiB0b3JxdWUgb24gYm9keUIgaW4gTiptLlxuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW52X2R0ICogMC4wO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hpZnQgdGhlIG9yaWdpbiBmb3IgYW55IHBvaW50cyBzdG9yZWQgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBNb3VzZUpvaW50LnByb3RvdHlwZS5zaGlmdE9yaWdpbiA9IGZ1bmN0aW9uIChuZXdPcmlnaW4pIHtcbiAgICAgICAgICAgIHRoaXMubV90YXJnZXRBLnN1YihuZXdPcmlnaW4pO1xuICAgICAgICB9O1xuICAgICAgICBNb3VzZUpvaW50LnByb3RvdHlwZS5pbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJCID0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzc0IgPSB0aGlzLm1fYm9keUIubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX2ludklCID0gdGhpcy5tX2JvZHlCLm1faW52STtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHZlbG9jaXR5ID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHk7XG4gICAgICAgICAgICB2YXIgY0IgPSBwb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFCID0gcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QiA9IHZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB2ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHFCID0gUm90Lm5lbyhhQik7XG4gICAgICAgICAgICB2YXIgbWFzcyA9IHRoaXMubV9ib2R5Qi5nZXRNYXNzKCk7XG4gICAgICAgICAgICAvLyBGcmVxdWVuY3lcbiAgICAgICAgICAgIHZhciBvbWVnYSA9IDIuMCAqIG1hdGgkMS5QSSAqIHRoaXMubV9mcmVxdWVuY3lIejtcbiAgICAgICAgICAgIC8vIERhbXBpbmcgY29lZmZpY2llbnRcbiAgICAgICAgICAgIHZhciBkID0gMi4wICogbWFzcyAqIHRoaXMubV9kYW1waW5nUmF0aW8gKiBvbWVnYTtcbiAgICAgICAgICAgIC8vIFNwcmluZyBzdGlmZm5lc3NcbiAgICAgICAgICAgIHZhciBrID0gbWFzcyAqIChvbWVnYSAqIG9tZWdhKTtcbiAgICAgICAgICAgIC8vIG1hZ2ljIGZvcm11bGFzXG4gICAgICAgICAgICAvLyBnYW1tYSBoYXMgdW5pdHMgb2YgaW52ZXJzZSBtYXNzLlxuICAgICAgICAgICAgLy8gYmV0YSBoYXMgdW5pdHMgb2YgaW52ZXJzZSB0aW1lLlxuICAgICAgICAgICAgdmFyIGggPSBzdGVwLmR0O1xuICAgICAgICAgICAgdGhpcy5tX2dhbW1hID0gaCAqIChkICsgaCAqIGspO1xuICAgICAgICAgICAgaWYgKHRoaXMubV9nYW1tYSAhPSAwLjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fZ2FtbWEgPSAxLjAgLyB0aGlzLm1fZ2FtbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYmV0YSA9IGggKiBrICogdGhpcy5tX2dhbW1hO1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MgbWF0cml4LlxuICAgICAgICAgICAgdGhpcy5tX3JCID0gUm90Lm11bFZlYzIocUIsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sb2NhbENlbnRlckIpKTtcbiAgICAgICAgICAgIC8vIEsgPSBbKDEvbTEgKyAxL20yKSAqIGV5ZSgyKSAtIHNrZXcocjEpICogaW52STEgKiBza2V3KHIxKSAtIHNrZXcocjIpICpcbiAgICAgICAgICAgIC8vIGludkkyICogc2tldyhyMildXG4gICAgICAgICAgICAvLyA9IFsxL20xKzEvbTIgMCBdICsgaW52STEgKiBbcjEueSpyMS55IC1yMS54KnIxLnldICsgaW52STIgKiBbcjEueSpyMS55XG4gICAgICAgICAgICAvLyAtcjEueCpyMS55XVxuICAgICAgICAgICAgLy8gWyAwIDEvbTErMS9tMl0gWy1yMS54KnIxLnkgcjEueCpyMS54XSBbLXIxLngqcjEueSByMS54KnIxLnhdXG4gICAgICAgICAgICB2YXIgSyA9IG5ldyBNYXQyMigpO1xuICAgICAgICAgICAgSy5leC54ID0gdGhpcy5tX2ludk1hc3NCICsgdGhpcy5tX2ludklCICogdGhpcy5tX3JCLnkgKiB0aGlzLm1fckIueVxuICAgICAgICAgICAgICAgICsgdGhpcy5tX2dhbW1hO1xuICAgICAgICAgICAgSy5leC55ID0gLXRoaXMubV9pbnZJQiAqIHRoaXMubV9yQi54ICogdGhpcy5tX3JCLnk7XG4gICAgICAgICAgICBLLmV5LnggPSBLLmV4Lnk7XG4gICAgICAgICAgICBLLmV5LnkgPSB0aGlzLm1faW52TWFzc0IgKyB0aGlzLm1faW52SUIgKiB0aGlzLm1fckIueCAqIHRoaXMubV9yQi54XG4gICAgICAgICAgICAgICAgKyB0aGlzLm1fZ2FtbWE7XG4gICAgICAgICAgICB0aGlzLm1fbWFzcyA9IEsuZ2V0SW52ZXJzZSgpO1xuICAgICAgICAgICAgdGhpcy5tX0Muc2V0VmVjMihjQik7XG4gICAgICAgICAgICB0aGlzLm1fQy5hZGRDb21iaW5lKDEsIHRoaXMubV9yQiwgLTEsIHRoaXMubV90YXJnZXRBKTtcbiAgICAgICAgICAgIHRoaXMubV9DLm11bCh0aGlzLm1fYmV0YSk7XG4gICAgICAgICAgICAvLyBDaGVhdCB3aXRoIHNvbWUgZGFtcGluZ1xuICAgICAgICAgICAgd0IgKj0gMC45ODtcbiAgICAgICAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLm11bChzdGVwLmR0UmF0aW8pO1xuICAgICAgICAgICAgICAgIHZCLmFkZE11bCh0aGlzLm1faW52TWFzc0IsIHRoaXMubV9pbXB1bHNlKTtcbiAgICAgICAgICAgICAgICB3QiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCB0aGlzLm1faW1wdWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS5zZXRaZXJvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ZWxvY2l0eS52LnNldFZlYzIodkIpO1xuICAgICAgICAgICAgdmVsb2NpdHkudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICBNb3VzZUpvaW50LnByb3RvdHlwZS5zb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIHZlbG9jaXR5ID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHk7XG4gICAgICAgICAgICB2YXIgdkIgPSBWZWMyLmNsb25lKHZlbG9jaXR5LnYpO1xuICAgICAgICAgICAgdmFyIHdCID0gdmVsb2NpdHkudztcbiAgICAgICAgICAgIC8vIENkb3QgPSB2ICsgY3Jvc3ModywgcilcbiAgICAgICAgICAgIHZhciBDZG90ID0gVmVjMi5jcm9zc051bVZlYzIod0IsIHRoaXMubV9yQik7XG4gICAgICAgICAgICBDZG90LmFkZCh2Qik7XG4gICAgICAgICAgICBDZG90LmFkZENvbWJpbmUoMSwgdGhpcy5tX0MsIHRoaXMubV9nYW1tYSwgdGhpcy5tX2ltcHVsc2UpO1xuICAgICAgICAgICAgQ2RvdC5uZWcoKTtcbiAgICAgICAgICAgIHZhciBpbXB1bHNlID0gTWF0MjIubXVsVmVjMih0aGlzLm1fbWFzcywgQ2RvdCk7XG4gICAgICAgICAgICB2YXIgb2xkSW1wdWxzZSA9IFZlYzIuY2xvbmUodGhpcy5tX2ltcHVsc2UpO1xuICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UuYWRkKGltcHVsc2UpO1xuICAgICAgICAgICAgdmFyIG1heEltcHVsc2UgPSBzdGVwLmR0ICogdGhpcy5tX21heEZvcmNlO1xuICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UuY2xhbXAobWF4SW1wdWxzZSk7XG4gICAgICAgICAgICBpbXB1bHNlID0gVmVjMi5zdWIodGhpcy5tX2ltcHVsc2UsIG9sZEltcHVsc2UpO1xuICAgICAgICAgICAgdkIuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgaW1wdWxzZSk7XG4gICAgICAgICAgICB3QiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBpbXB1bHNlKTtcbiAgICAgICAgICAgIHZlbG9jaXR5LnYuc2V0VmVjMih2Qik7XG4gICAgICAgICAgICB2ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZXJyb3JzIGFyZSB3aXRoaW4gdG9sZXJhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VKb2ludC5wcm90b3R5cGUuc29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBNb3VzZUpvaW50LlRZUEUgPSAnbW91c2Utam9pbnQnO1xuICAgICAgICByZXR1cm4gTW91c2VKb2ludDtcbiAgICB9KEpvaW50KSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgdmFyIERFRkFVTFRTJDMgPSB7XG4gICAgICAgIGNvbGxpZGVDb25uZWN0ZWQ6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBwdWxsZXkgam9pbnQgaXMgY29ubmVjdGVkIHRvIHR3byBib2RpZXMgYW5kIHR3byBmaXhlZCBncm91bmQgcG9pbnRzLiBUaGVcbiAgICAgKiBwdWxsZXkgc3VwcG9ydHMgYSByYXRpbyBzdWNoIHRoYXQ6IGxlbmd0aDEgKyByYXRpbyAqIGxlbmd0aDIgPD0gY29uc3RhbnRcbiAgICAgKlxuICAgICAqIFllcywgdGhlIGZvcmNlIHRyYW5zbWl0dGVkIGlzIHNjYWxlZCBieSB0aGUgcmF0aW8uXG4gICAgICpcbiAgICAgKiBXYXJuaW5nOiB0aGUgcHVsbGV5IGpvaW50IGNhbiBnZXQgYSBiaXQgc3F1aXJyZWxseSBieSBpdHNlbGYuIFRoZXkgb2Z0ZW4gd29ya1xuICAgICAqIGJldHRlciB3aGVuIGNvbWJpbmVkIHdpdGggcHJpc21hdGljIGpvaW50cy4gWW91IHNob3VsZCBhbHNvIGNvdmVyIHRoZSB0aGVcbiAgICAgKiBhbmNob3IgcG9pbnRzIHdpdGggc3RhdGljIHNoYXBlcyB0byBwcmV2ZW50IG9uZSBzaWRlIGZyb20gZ29pbmcgdG8gemVyb1xuICAgICAqIGxlbmd0aC5cbiAgICAgKi9cbiAgICB2YXIgUHVsbGV5Sm9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhQdWxsZXlKb2ludCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gUHVsbGV5Sm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGdyb3VuZEEsIGdyb3VuZEIsIGFuY2hvckEsIGFuY2hvckIsIHJhdGlvKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBQdWxsZXlKb2ludCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFB1bGxleUpvaW50KGRlZiwgYm9keUEsIGJvZHlCLCBncm91bmRBLCBncm91bmRCLCBhbmNob3JBLCBhbmNob3JCLCByYXRpbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWYgPSBvcHRpb25zKGRlZiwgREVGQVVMVFMkMyk7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgYm9keUEsIGJvZHlCKSB8fCB0aGlzO1xuICAgICAgICAgICAgYm9keUEgPSBfdGhpcy5tX2JvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSBfdGhpcy5tX2JvZHlCO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlID0gUHVsbGV5Sm9pbnQuVFlQRTtcbiAgICAgICAgICAgIF90aGlzLm1fZ3JvdW5kQW5jaG9yQSA9IGdyb3VuZEEgPyBncm91bmRBIDogZGVmLmdyb3VuZEFuY2hvckEgfHwgVmVjMi5uZW8oLTEuMCwgMS4wKTtcbiAgICAgICAgICAgIF90aGlzLm1fZ3JvdW5kQW5jaG9yQiA9IGdyb3VuZEIgPyBncm91bmRCIDogZGVmLmdyb3VuZEFuY2hvckIgfHwgVmVjMi5uZW8oMS4wLCAxLjApO1xuICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckEgPSBhbmNob3JBID8gYm9keUEuZ2V0TG9jYWxQb2ludChhbmNob3JBKSA6IGRlZi5sb2NhbEFuY2hvckEgfHwgVmVjMi5uZW8oLTEuMCwgMC4wKTtcbiAgICAgICAgICAgIF90aGlzLm1fbG9jYWxBbmNob3JCID0gYW5jaG9yQiA/IGJvZHlCLmdldExvY2FsUG9pbnQoYW5jaG9yQikgOiBkZWYubG9jYWxBbmNob3JCIHx8IFZlYzIubmVvKDEuMCwgMC4wKTtcbiAgICAgICAgICAgIF90aGlzLm1fbGVuZ3RoQSA9IG1hdGgkMS5pc0Zpbml0ZShkZWYubGVuZ3RoQSkgPyBkZWYubGVuZ3RoQSA6IFZlYzIuZGlzdGFuY2UoYW5jaG9yQSwgZ3JvdW5kQSk7XG4gICAgICAgICAgICBfdGhpcy5tX2xlbmd0aEIgPSBtYXRoJDEuaXNGaW5pdGUoZGVmLmxlbmd0aEIpID8gZGVmLmxlbmd0aEIgOiBWZWMyLmRpc3RhbmNlKGFuY2hvckIsIGdyb3VuZEIpO1xuICAgICAgICAgICAgX3RoaXMubV9yYXRpbyA9IG1hdGgkMS5pc0Zpbml0ZShyYXRpbykgPyByYXRpbyA6IGRlZi5yYXRpbztcbiAgICAgICAgICAgIF90aGlzLm1fY29uc3RhbnQgPSBfdGhpcy5tX2xlbmd0aEEgKyBfdGhpcy5tX3JhdGlvICogX3RoaXMubV9sZW5ndGhCO1xuICAgICAgICAgICAgX3RoaXMubV9pbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgLy8gUHVsbGV5OlxuICAgICAgICAgICAgLy8gbGVuZ3RoMSA9IG5vcm0ocDEgLSBzMSlcbiAgICAgICAgICAgIC8vIGxlbmd0aDIgPSBub3JtKHAyIC0gczIpXG4gICAgICAgICAgICAvLyBDMCA9IChsZW5ndGgxICsgcmF0aW8gKiBsZW5ndGgyKV9pbml0aWFsXG4gICAgICAgICAgICAvLyBDID0gQzAgLSAobGVuZ3RoMSArIHJhdGlvICogbGVuZ3RoMilcbiAgICAgICAgICAgIC8vIHUxID0gKHAxIC0gczEpIC8gbm9ybShwMSAtIHMxKVxuICAgICAgICAgICAgLy8gdTIgPSAocDIgLSBzMikgLyBub3JtKHAyIC0gczIpXG4gICAgICAgICAgICAvLyBDZG90ID0gLWRvdCh1MSwgdjEgKyBjcm9zcyh3MSwgcjEpKSAtIHJhdGlvICogZG90KHUyLCB2MiArIGNyb3NzKHcyLCByMikpXG4gICAgICAgICAgICAvLyBKID0gLVt1MSBjcm9zcyhyMSwgdTEpIHJhdGlvICogdTIgcmF0aW8gKiBjcm9zcyhyMiwgdTIpXVxuICAgICAgICAgICAgLy8gSyA9IEogKiBpbnZNICogSlRcbiAgICAgICAgICAgIC8vID0gaW52TWFzczEgKyBpbnZJMSAqIGNyb3NzKHIxLCB1MSleMiArIHJhdGlvXjIgKiAoaW52TWFzczIgKyBpbnZJMiAqXG4gICAgICAgICAgICAvLyBjcm9zcyhyMiwgdTIpXjIpXG4gICAgICAgIH1cbiAgICAgICAgUHVsbGV5Sm9pbnQucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMubV90eXBlLFxuICAgICAgICAgICAgICAgIGJvZHlBOiB0aGlzLm1fYm9keUEsXG4gICAgICAgICAgICAgICAgYm9keUI6IHRoaXMubV9ib2R5QixcbiAgICAgICAgICAgICAgICBjb2xsaWRlQ29ubmVjdGVkOiB0aGlzLm1fY29sbGlkZUNvbm5lY3RlZCxcbiAgICAgICAgICAgICAgICBncm91bmRBbmNob3JBOiB0aGlzLm1fZ3JvdW5kQW5jaG9yQSxcbiAgICAgICAgICAgICAgICBncm91bmRBbmNob3JCOiB0aGlzLm1fZ3JvdW5kQW5jaG9yQixcbiAgICAgICAgICAgICAgICBsb2NhbEFuY2hvckE6IHRoaXMubV9sb2NhbEFuY2hvckEsXG4gICAgICAgICAgICAgICAgbG9jYWxBbmNob3JCOiB0aGlzLm1fbG9jYWxBbmNob3JCLFxuICAgICAgICAgICAgICAgIGxlbmd0aEE6IHRoaXMubV9sZW5ndGhBLFxuICAgICAgICAgICAgICAgIGxlbmd0aEI6IHRoaXMubV9sZW5ndGhCLFxuICAgICAgICAgICAgICAgIHJhdGlvOiB0aGlzLm1fcmF0aW8sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFB1bGxleUpvaW50Ll9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhLCB3b3JsZCwgcmVzdG9yZSkge1xuICAgICAgICAgICAgZGF0YSA9IF9fYXNzaWduKHt9LCBkYXRhKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUEgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUEsIHdvcmxkKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUIgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUIsIHdvcmxkKTtcbiAgICAgICAgICAgIHZhciBqb2ludCA9IG5ldyBQdWxsZXlKb2ludChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZmlyc3QgZ3JvdW5kIGFuY2hvci5cbiAgICAgICAgICovXG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRHcm91bmRBbmNob3JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ncm91bmRBbmNob3JBO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBzZWNvbmQgZ3JvdW5kIGFuY2hvci5cbiAgICAgICAgICovXG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRHcm91bmRBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ncm91bmRBbmNob3JCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgc2VnbWVudCBhdHRhY2hlZCB0byBib2R5QS5cbiAgICAgICAgICovXG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRMZW5ndGhBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sZW5ndGhBO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgc2VnbWVudCBhdHRhY2hlZCB0byBib2R5Qi5cbiAgICAgICAgICovXG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRMZW5ndGhCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sZW5ndGhCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBwdWxsZXkgcmF0aW8uXG4gICAgICAgICAqL1xuICAgICAgICBQdWxsZXlKb2ludC5wcm90b3R5cGUuZ2V0UmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3JhdGlvO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgc2VnbWVudCBhdHRhY2hlZCB0byBib2R5QS5cbiAgICAgICAgICovXG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRDdXJyZW50TGVuZ3RoQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5tX2JvZHlBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMubV9ncm91bmRBbmNob3JBO1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIuZGlzdGFuY2UocCwgcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoZSBzZWdtZW50IGF0dGFjaGVkIHRvIGJvZHlCLlxuICAgICAgICAgKi9cbiAgICAgICAgUHVsbGV5Sm9pbnQucHJvdG90eXBlLmdldEN1cnJlbnRMZW5ndGhCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLm1fYm9keUIuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JCKTtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5tX2dyb3VuZEFuY2hvckI7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5kaXN0YW5jZShwLCBzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNoaWZ0IHRoZSBvcmlnaW4gZm9yIGFueSBwb2ludHMgc3RvcmVkIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmV3T3JpZ2luXG4gICAgICAgICAqL1xuICAgICAgICBQdWxsZXlKb2ludC5wcm90b3R5cGUuc2hpZnRPcmlnaW4gPSBmdW5jdGlvbiAobmV3T3JpZ2luKSB7XG4gICAgICAgICAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yQS5zdWIobmV3T3JpZ2luKTtcbiAgICAgICAgICAgIHRoaXMubV9ncm91bmRBbmNob3JCLnN1YihuZXdPcmlnaW4pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUEgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBQdWxsZXlKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JBKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHlCIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgUHVsbGV5Sm9pbnQucHJvdG90eXBlLmdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlYWN0aW9uIGZvcmNlIG9uIGJvZHlCIGF0IHRoZSBqb2ludCBhbmNob3IgaW4gTmV3dG9ucy5cbiAgICAgICAgICovXG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubXVsTnVtVmVjMih0aGlzLm1faW1wdWxzZSwgdGhpcy5tX3VCKS5tdWwoaW52X2R0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gdG9ycXVlIG9uIGJvZHlCIGluIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgIH07XG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5pbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJBID0gdGhpcy5tX2JvZHlBLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJCID0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzc0EgPSB0aGlzLm1fYm9keUEubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3NCID0gdGhpcy5tX2JvZHlCLm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9pbnZJQSA9IHRoaXMubV9ib2R5QS5tX2ludkk7XG4gICAgICAgICAgICB0aGlzLm1faW52SUIgPSB0aGlzLm1fYm9keUIubV9pbnZJO1xuICAgICAgICAgICAgdmFyIGNBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICAgICAgICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgICAgICAgICAgdGhpcy5tX3JBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTtcbiAgICAgICAgICAgIHRoaXMubV9yQiA9IFJvdC5tdWxWZWMyKHFCLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKSk7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHB1bGxleSBheGVzLlxuICAgICAgICAgICAgdGhpcy5tX3VBID0gVmVjMi5zdWIoVmVjMi5hZGQoY0EsIHRoaXMubV9yQSksIHRoaXMubV9ncm91bmRBbmNob3JBKTtcbiAgICAgICAgICAgIHRoaXMubV91QiA9IFZlYzIuc3ViKFZlYzIuYWRkKGNCLCB0aGlzLm1fckIpLCB0aGlzLm1fZ3JvdW5kQW5jaG9yQik7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoQSA9IHRoaXMubV91QS5sZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGhCID0gdGhpcy5tX3VCLmxlbmd0aCgpO1xuICAgICAgICAgICAgaWYgKGxlbmd0aEEgPiAxMC4wICogU2V0dGluZ3MubGluZWFyU2xvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV91QS5tdWwoMS4wIC8gbGVuZ3RoQSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdUEuc2V0WmVybygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aEIgPiAxMC4wICogU2V0dGluZ3MubGluZWFyU2xvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV91Qi5tdWwoMS4wIC8gbGVuZ3RoQik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdUIuc2V0WmVybygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBlZmZlY3RpdmUgbWFzcy5cbiAgICAgICAgICAgIHZhciBydUEgPSBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JBLCB0aGlzLm1fdUEpOyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIHJ1QiA9IFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckIsIHRoaXMubV91Qik7IC8vIGZsb2F0XG4gICAgICAgICAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0EgKyB0aGlzLm1faW52SUEgKiBydUEgKiBydUE7IC8vIGZsb2F0XG4gICAgICAgICAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0IgKyB0aGlzLm1faW52SUIgKiBydUIgKiBydUI7IC8vIGZsb2F0XG4gICAgICAgICAgICB0aGlzLm1fbWFzcyA9IG1BICsgdGhpcy5tX3JhdGlvICogdGhpcy5tX3JhdGlvICogbUI7XG4gICAgICAgICAgICBpZiAodGhpcy5tX21hc3MgPiAwLjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbWFzcyA9IDEuMCAvIHRoaXMubV9tYXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgaW1wdWxzZXMgdG8gc3VwcG9ydCB2YXJpYWJsZSB0aW1lIHN0ZXBzLlxuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgICAgICAgICAvLyBXYXJtIHN0YXJ0aW5nLlxuICAgICAgICAgICAgICAgIHZhciBQQSA9IFZlYzIubXVsTnVtVmVjMigtdGhpcy5tX2ltcHVsc2UsIHRoaXMubV91QSk7XG4gICAgICAgICAgICAgICAgdmFyIFBCID0gVmVjMi5tdWxOdW1WZWMyKC10aGlzLm1fcmF0aW8gKiB0aGlzLm1faW1wdWxzZSwgdGhpcy5tX3VCKTtcbiAgICAgICAgICAgICAgICB2QS5hZGRNdWwodGhpcy5tX2ludk1hc3NBLCBQQSk7XG4gICAgICAgICAgICAgICAgd0EgKz0gdGhpcy5tX2ludklBICogVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQSwgUEEpO1xuICAgICAgICAgICAgICAgIHZCLmFkZE11bCh0aGlzLm1faW52TWFzc0IsIFBCKTtcbiAgICAgICAgICAgICAgICB3QiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBQQik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYgPSB2QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYgPSB2QjtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LncgPSB3QjtcbiAgICAgICAgfTtcbiAgICAgICAgUHVsbGV5Sm9pbnQucHJvdG90eXBlLnNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHZwQSA9IFZlYzIuYWRkKHZBLCBWZWMyLmNyb3NzTnVtVmVjMih3QSwgdGhpcy5tX3JBKSk7XG4gICAgICAgICAgICB2YXIgdnBCID0gVmVjMi5hZGQodkIsIFZlYzIuY3Jvc3NOdW1WZWMyKHdCLCB0aGlzLm1fckIpKTtcbiAgICAgICAgICAgIHZhciBDZG90ID0gLVZlYzIuZG90KHRoaXMubV91QSwgdnBBKSAtIHRoaXMubV9yYXRpb1xuICAgICAgICAgICAgICAgICogVmVjMi5kb3QodGhpcy5tX3VCLCB2cEIpOyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIGltcHVsc2UgPSAtdGhpcy5tX21hc3MgKiBDZG90OyAvLyBmbG9hdFxuICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UgKz0gaW1wdWxzZTtcbiAgICAgICAgICAgIHZhciBQQSA9IFZlYzIubXVsTnVtVmVjMigtaW1wdWxzZSwgdGhpcy5tX3VBKTsgLy8gVmVjMlxuICAgICAgICAgICAgdmFyIFBCID0gVmVjMi5tdWxOdW1WZWMyKC10aGlzLm1fcmF0aW8gKiBpbXB1bHNlLCB0aGlzLm1fdUIpOyAvLyBWZWMyXG4gICAgICAgICAgICB2QS5hZGRNdWwodGhpcy5tX2ludk1hc3NBLCBQQSk7XG4gICAgICAgICAgICB3QSArPSB0aGlzLm1faW52SUEgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JBLCBQQSk7XG4gICAgICAgICAgICB2Qi5hZGRNdWwodGhpcy5tX2ludk1hc3NCLCBQQik7XG4gICAgICAgICAgICB3QiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBQQik7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52ID0gdkI7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZXJyb3JzIGFyZSB3aXRoaW4gdG9sZXJhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgUHVsbGV5Sm9pbnQucHJvdG90eXBlLnNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB2YXIgY0EgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHFBID0gUm90Lm5lbyhhQSk7XG4gICAgICAgICAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICAgICAgICAgIHZhciByQSA9IFJvdC5tdWxWZWMyKHFBLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JBLCB0aGlzLm1fbG9jYWxDZW50ZXJBKSk7XG4gICAgICAgICAgICB2YXIgckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBwdWxsZXkgYXhlcy5cbiAgICAgICAgICAgIHZhciB1QSA9IFZlYzIuc3ViKFZlYzIuYWRkKGNBLCB0aGlzLm1fckEpLCB0aGlzLm1fZ3JvdW5kQW5jaG9yQSk7XG4gICAgICAgICAgICB2YXIgdUIgPSBWZWMyLnN1YihWZWMyLmFkZChjQiwgdGhpcy5tX3JCKSwgdGhpcy5tX2dyb3VuZEFuY2hvckIpO1xuICAgICAgICAgICAgdmFyIGxlbmd0aEEgPSB1QS5sZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGhCID0gdUIubGVuZ3RoKCk7XG4gICAgICAgICAgICBpZiAobGVuZ3RoQSA+IDEwLjAgKiBTZXR0aW5ncy5saW5lYXJTbG9wKSB7XG4gICAgICAgICAgICAgICAgdUEubXVsKDEuMCAvIGxlbmd0aEEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdUEuc2V0WmVybygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aEIgPiAxMC4wICogU2V0dGluZ3MubGluZWFyU2xvcCkge1xuICAgICAgICAgICAgICAgIHVCLm11bCgxLjAgLyBsZW5ndGhCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVCLnNldFplcm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgZWZmZWN0aXZlIG1hc3MuXG4gICAgICAgICAgICB2YXIgcnVBID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHJBLCB1QSk7XG4gICAgICAgICAgICB2YXIgcnVCID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHJCLCB1Qik7XG4gICAgICAgICAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0EgKyB0aGlzLm1faW52SUEgKiBydUEgKiBydUE7IC8vIGZsb2F0XG4gICAgICAgICAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0IgKyB0aGlzLm1faW52SUIgKiBydUIgKiBydUI7IC8vIGZsb2F0XG4gICAgICAgICAgICB2YXIgbWFzcyA9IG1BICsgdGhpcy5tX3JhdGlvICogdGhpcy5tX3JhdGlvICogbUI7IC8vIGZsb2F0XG4gICAgICAgICAgICBpZiAobWFzcyA+IDAuMCkge1xuICAgICAgICAgICAgICAgIG1hc3MgPSAxLjAgLyBtYXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIEMgPSB0aGlzLm1fY29uc3RhbnQgLSBsZW5ndGhBIC0gdGhpcy5tX3JhdGlvICogbGVuZ3RoQjsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciBsaW5lYXJFcnJvciA9IG1hdGgkMS5hYnMoQyk7IC8vIGZsb2F0XG4gICAgICAgICAgICB2YXIgaW1wdWxzZSA9IC1tYXNzICogQzsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciBQQSA9IFZlYzIubXVsTnVtVmVjMigtaW1wdWxzZSwgdUEpOyAvLyBWZWMyXG4gICAgICAgICAgICB2YXIgUEIgPSBWZWMyLm11bE51bVZlYzIoLXRoaXMubV9yYXRpbyAqIGltcHVsc2UsIHVCKTsgLy8gVmVjMlxuICAgICAgICAgICAgY0EuYWRkTXVsKHRoaXMubV9pbnZNYXNzQSwgUEEpO1xuICAgICAgICAgICAgYUEgKz0gdGhpcy5tX2ludklBICogVmVjMi5jcm9zc1ZlYzJWZWMyKHJBLCBQQSk7XG4gICAgICAgICAgICBjQi5hZGRNdWwodGhpcy5tX2ludk1hc3NCLCBQQik7XG4gICAgICAgICAgICBhQiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIockIsIFBCKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmMgPSBjQTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmEgPSBhQTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmMgPSBjQjtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmEgPSBhQjtcbiAgICAgICAgICAgIHJldHVybiBsaW5lYXJFcnJvciA8IFNldHRpbmdzLmxpbmVhclNsb3A7XG4gICAgICAgIH07XG4gICAgICAgIFB1bGxleUpvaW50LlRZUEUgPSAncHVsbGV5LWpvaW50JztcbiAgICAgICAgcmV0dXJuIFB1bGxleUpvaW50O1xuICAgIH0oSm9pbnQpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICB2YXIgaW5hY3RpdmVMaW1pdCA9IDA7XG4gICAgdmFyIGF0VXBwZXJMaW1pdCA9IDI7XG4gICAgdmFyIERFRkFVTFRTJDIgPSB7XG4gICAgICAgIG1heExlbmd0aDogMC4wLFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSByb3BlIGpvaW50IGVuZm9yY2VzIGEgbWF4aW11bSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMgb24gdHdvIGJvZGllcy4gSXRcbiAgICAgKiBoYXMgbm8gb3RoZXIgZWZmZWN0LlxuICAgICAqXG4gICAgICogV2FybmluZzogaWYgeW91IGF0dGVtcHQgdG8gY2hhbmdlIHRoZSBtYXhpbXVtIGxlbmd0aCBkdXJpbmcgdGhlIHNpbXVsYXRpb25cbiAgICAgKiB5b3Ugd2lsbCBnZXQgc29tZSBub24tcGh5c2ljYWwgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBBIG1vZGVsIHRoYXQgd291bGQgYWxsb3cgeW91IHRvIGR5bmFtaWNhbGx5IG1vZGlmeSB0aGUgbGVuZ3RoIHdvdWxkIGhhdmUgc29tZVxuICAgICAqIHNwb25naW5lc3MsIHNvIEkgY2hvc2Ugbm90IHRvIGltcGxlbWVudCBpdCB0aGF0IHdheS4gU2VlIHtAbGluayBEaXN0YW5jZUpvaW50fSBpZiB5b3VcbiAgICAgKiB3YW50IHRvIGR5bmFtaWNhbGx5IGNvbnRyb2wgbGVuZ3RoLlxuICAgICAqL1xuICAgIHZhciBSb3BlSm9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhSb3BlSm9pbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFJvcGVKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBSb3BlSm9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSb3BlSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGFuY2hvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWYgPSBvcHRpb25zKGRlZiwgREVGQVVMVFMkMik7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgYm9keUEsIGJvZHlCKSB8fCB0aGlzO1xuICAgICAgICAgICAgYm9keUEgPSBfdGhpcy5tX2JvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSBfdGhpcy5tX2JvZHlCO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlID0gUm9wZUpvaW50LlRZUEU7XG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQSA9IGFuY2hvciA/IGJvZHlBLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckEgfHwgVmVjMi5uZW8oLTEuMCwgMC4wKTtcbiAgICAgICAgICAgIF90aGlzLm1fbG9jYWxBbmNob3JCID0gYW5jaG9yID8gYm9keUIuZ2V0TG9jYWxQb2ludChhbmNob3IpIDogZGVmLmxvY2FsQW5jaG9yQiB8fCBWZWMyLm5lbygxLjAsIDAuMCk7XG4gICAgICAgICAgICBfdGhpcy5tX21heExlbmd0aCA9IGRlZi5tYXhMZW5ndGg7XG4gICAgICAgICAgICBfdGhpcy5tX21hc3MgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX2ltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX2xlbmd0aCA9IDAuMDtcbiAgICAgICAgICAgIF90aGlzLm1fc3RhdGUgPSBpbmFjdGl2ZUxpbWl0O1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgLy8gTGltaXQ6XG4gICAgICAgICAgICAvLyBDID0gbm9ybShwQiAtIHBBKSAtIExcbiAgICAgICAgICAgIC8vIHUgPSAocEIgLSBwQSkgLyBub3JtKHBCIC0gcEEpXG4gICAgICAgICAgICAvLyBDZG90ID0gZG90KHUsIHZCICsgY3Jvc3Mod0IsIHJCKSAtIHZBIC0gY3Jvc3Mod0EsIHJBKSlcbiAgICAgICAgICAgIC8vIEogPSBbLXUgLWNyb3NzKHJBLCB1KSB1IGNyb3NzKHJCLCB1KV1cbiAgICAgICAgICAgIC8vIEsgPSBKICogaW52TSAqIEpUXG4gICAgICAgICAgICAvLyA9IGludk1hc3NBICsgaW52SUEgKiBjcm9zcyhyQSwgdSleMiArIGludk1hc3NCICsgaW52SUIgKiBjcm9zcyhyQiwgdSleMlxuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUm9wZUpvaW50LnByb3RvdHlwZS5fc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm1fdHlwZSxcbiAgICAgICAgICAgICAgICBib2R5QTogdGhpcy5tX2JvZHlBLFxuICAgICAgICAgICAgICAgIGJvZHlCOiB0aGlzLm1fYm9keUIsXG4gICAgICAgICAgICAgICAgY29sbGlkZUNvbm5lY3RlZDogdGhpcy5tX2NvbGxpZGVDb25uZWN0ZWQsXG4gICAgICAgICAgICAgICAgbG9jYWxBbmNob3JBOiB0aGlzLm1fbG9jYWxBbmNob3JBLFxuICAgICAgICAgICAgICAgIGxvY2FsQW5jaG9yQjogdGhpcy5tX2xvY2FsQW5jaG9yQixcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGg6IHRoaXMubV9tYXhMZW5ndGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFJvcGVKb2ludC5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSwgd29ybGQsIHJlc3RvcmUpIHtcbiAgICAgICAgICAgIGRhdGEgPSBfX2Fzc2lnbih7fSwgZGF0YSk7XG4gICAgICAgICAgICBkYXRhLmJvZHlBID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlBLCB3b3JsZCk7XG4gICAgICAgICAgICBkYXRhLmJvZHlCID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlCLCB3b3JsZCk7XG4gICAgICAgICAgICB2YXIgam9pbnQgPSBuZXcgUm9wZUpvaW50KGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGpvaW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QSdzIG9yaWdpbi5cbiAgICAgICAgICovXG4gICAgICAgIFJvcGVKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBbmNob3JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sb2NhbEFuY2hvckE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlCJ3Mgb3JpZ2luLlxuICAgICAgICAgKi9cbiAgICAgICAgUm9wZUpvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHJvcGUuXG4gICAgICAgICAqL1xuICAgICAgICBSb3BlSm9pbnQucHJvdG90eXBlLnNldE1heExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubV9tYXhMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSByb3BlLlxuICAgICAgICAgKi9cbiAgICAgICAgUm9wZUpvaW50LnByb3RvdHlwZS5nZXRNYXhMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX21heExlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgUm9wZUpvaW50LnByb3RvdHlwZS5nZXRMaW1pdFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETyBMaW1pdFN0YXRlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3N0YXRlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUEgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBSb3BlSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QiBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIFJvcGVKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUIuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JCKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gZm9yY2Ugb24gYm9keUIgYXQgdGhlIGpvaW50IGFuY2hvciBpbiBOZXd0b25zLlxuICAgICAgICAgKi9cbiAgICAgICAgUm9wZUpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubXVsTnVtVmVjMih0aGlzLm1faW1wdWxzZSwgdGhpcy5tX3UpLm11bChpbnZfZHQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByZWFjdGlvbiB0b3JxdWUgb24gYm9keUIgaW4gTiptLlxuICAgICAgICAgKi9cbiAgICAgICAgUm9wZUpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgIH07XG4gICAgICAgIFJvcGVKb2ludC5wcm90b3R5cGUuaW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQSA9IHRoaXMubV9ib2R5QS5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQiA9IHRoaXMubV9ib2R5Qi5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3NBID0gdGhpcy5tX2JvZHlBLm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9pbnZNYXNzQiA9IHRoaXMubV9ib2R5Qi5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLm1faW52SUEgPSB0aGlzLm1fYm9keUEubV9pbnZJO1xuICAgICAgICAgICAgdGhpcy5tX2ludklCID0gdGhpcy5tX2JvZHlCLm1faW52STtcbiAgICAgICAgICAgIHZhciBjQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgY0IgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHFBID0gUm90Lm5lbyhhQSk7XG4gICAgICAgICAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICAgICAgICAgIHRoaXMubV9yQSA9IFJvdC5tdWxTdWIocUEsIHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpO1xuICAgICAgICAgICAgdGhpcy5tX3JCID0gUm90Lm11bFN1YihxQiwgdGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQik7XG4gICAgICAgICAgICB0aGlzLm1fdSA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgdGhpcy5tX3UuYWRkQ29tYmluZSgxLCBjQiwgMSwgdGhpcy5tX3JCKTtcbiAgICAgICAgICAgIHRoaXMubV91LnN1YkNvbWJpbmUoMSwgY0EsIDEsIHRoaXMubV9yQSk7IC8vIFZlYzJcbiAgICAgICAgICAgIHRoaXMubV9sZW5ndGggPSB0aGlzLm1fdS5sZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBDID0gdGhpcy5tX2xlbmd0aCAtIHRoaXMubV9tYXhMZW5ndGg7IC8vIGZsb2F0XG4gICAgICAgICAgICBpZiAoQyA+IDAuMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9zdGF0ZSA9IGF0VXBwZXJMaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubV9zdGF0ZSA9IGluYWN0aXZlTGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tX2xlbmd0aCA+IFNldHRpbmdzLmxpbmVhclNsb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdS5tdWwoMS4wIC8gdGhpcy5tX2xlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdS5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21hc3MgPSAwLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBlZmZlY3RpdmUgbWFzcy5cbiAgICAgICAgICAgIHZhciBjckEgPSBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JBLCB0aGlzLm1fdSk7IC8vIGZsb2F0XG4gICAgICAgICAgICB2YXIgY3JCID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQiwgdGhpcy5tX3UpOyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIGludk1hc3MgPSB0aGlzLm1faW52TWFzc0EgKyB0aGlzLm1faW52SUEgKiBjckEgKiBjckEgKyB0aGlzLm1faW52TWFzc0JcbiAgICAgICAgICAgICAgICArIHRoaXMubV9pbnZJQiAqIGNyQiAqIGNyQjsgLy8gZmxvYXRcbiAgICAgICAgICAgIHRoaXMubV9tYXNzID0gaW52TWFzcyAhPSAwLjAgPyAxLjAgLyBpbnZNYXNzIDogMC4wO1xuICAgICAgICAgICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgdGhlIGltcHVsc2UgdG8gc3VwcG9ydCBhIHZhcmlhYmxlIHRpbWUgc3RlcC5cbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgICAgICAgICAgdmFyIFAgPSBWZWMyLm11bE51bVZlYzIodGhpcy5tX2ltcHVsc2UsIHRoaXMubV91KTtcbiAgICAgICAgICAgICAgICB2QS5zdWJNdWwodGhpcy5tX2ludk1hc3NBLCBQKTtcbiAgICAgICAgICAgICAgICB3QSAtPSB0aGlzLm1faW52SUEgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JBLCBQKTtcbiAgICAgICAgICAgICAgICB2Qi5hZGRNdWwodGhpcy5tX2ludk1hc3NCLCBQKTtcbiAgICAgICAgICAgICAgICB3QiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBQKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudi5zZXRWZWMyKHZBKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYuc2V0VmVjMih2Qik7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIFJvcGVKb2ludC5wcm90b3R5cGUuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICAvLyBDZG90ID0gZG90KHUsIHYgKyBjcm9zcyh3LCByKSlcbiAgICAgICAgICAgIHZhciB2cEEgPSBWZWMyLmFkZENyb3NzTnVtVmVjMih2QSwgd0EsIHRoaXMubV9yQSk7IC8vIFZlYzJcbiAgICAgICAgICAgIHZhciB2cEIgPSBWZWMyLmFkZENyb3NzTnVtVmVjMih2Qiwgd0IsIHRoaXMubV9yQik7IC8vIFZlYzJcbiAgICAgICAgICAgIHZhciBDID0gdGhpcy5tX2xlbmd0aCAtIHRoaXMubV9tYXhMZW5ndGg7IC8vIGZsb2F0XG4gICAgICAgICAgICB2YXIgQ2RvdCA9IFZlYzIuZG90KHRoaXMubV91LCBWZWMyLnN1Yih2cEIsIHZwQSkpOyAvLyBmbG9hdFxuICAgICAgICAgICAgLy8gUHJlZGljdGl2ZSBjb25zdHJhaW50LlxuICAgICAgICAgICAgaWYgKEMgPCAwLjApIHtcbiAgICAgICAgICAgICAgICBDZG90ICs9IHN0ZXAuaW52X2R0ICogQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbXB1bHNlID0gLXRoaXMubV9tYXNzICogQ2RvdDsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX2ltcHVsc2U7IC8vIGZsb2F0XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZSA9IG1hdGgkMS5taW4oMC4wLCB0aGlzLm1faW1wdWxzZSArIGltcHVsc2UpO1xuICAgICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9pbXB1bHNlIC0gb2xkSW1wdWxzZTtcbiAgICAgICAgICAgIHZhciBQID0gVmVjMi5tdWxOdW1WZWMyKGltcHVsc2UsIHRoaXMubV91KTsgLy8gVmVjMlxuICAgICAgICAgICAgdkEuc3ViTXVsKHRoaXMubV9pbnZNYXNzQSwgUCk7XG4gICAgICAgICAgICB3QSAtPSB0aGlzLm1faW52SUEgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JBLCBQKTtcbiAgICAgICAgICAgIHZCLmFkZE11bCh0aGlzLm1faW52TWFzc0IsIFApO1xuICAgICAgICAgICAgd0IgKz0gdGhpcy5tX2ludklCICogVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQiwgUCk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52ID0gdkI7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZXJyb3JzIGFyZSB3aXRoaW4gdG9sZXJhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgUm9wZUpvaW50LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIGNBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYzsgLy8gVmVjMlxuICAgICAgICAgICAgdmFyIGFBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYTsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7IC8vIFZlYzJcbiAgICAgICAgICAgIHZhciBhQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmE7IC8vIGZsb2F0XG4gICAgICAgICAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICAgICAgICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgICAgICAgICAgdmFyIHJBID0gUm90Lm11bFN1YihxQSwgdGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xvY2FsQ2VudGVyQSk7XG4gICAgICAgICAgICB2YXIgckIgPSBSb3QubXVsU3ViKHFCLCB0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKTtcbiAgICAgICAgICAgIHZhciB1ID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICB1LmFkZENvbWJpbmUoMSwgY0IsIDEsIHJCKTtcbiAgICAgICAgICAgIHUuc3ViQ29tYmluZSgxLCBjQSwgMSwgckEpOyAvLyBWZWMyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdS5ub3JtYWxpemUoKTsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciBDID0gbGVuZ3RoIC0gdGhpcy5tX21heExlbmd0aDsgLy8gZmxvYXRcbiAgICAgICAgICAgIEMgPSBtYXRoJDEuY2xhbXAoQywgMC4wLCBTZXR0aW5ncy5tYXhMaW5lYXJDb3JyZWN0aW9uKTtcbiAgICAgICAgICAgIHZhciBpbXB1bHNlID0gLXRoaXMubV9tYXNzICogQzsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciBQID0gVmVjMi5tdWxOdW1WZWMyKGltcHVsc2UsIHUpOyAvLyBWZWMyXG4gICAgICAgICAgICBjQS5zdWJNdWwodGhpcy5tX2ludk1hc3NBLCBQKTtcbiAgICAgICAgICAgIGFBIC09IHRoaXMubV9pbnZJQSAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyQSwgUCk7XG4gICAgICAgICAgICBjQi5hZGRNdWwodGhpcy5tX2ludk1hc3NCLCBQKTtcbiAgICAgICAgICAgIGFCICs9IHRoaXMubV9pbnZJQiAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyQiwgUCk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jLnNldFZlYzIoY0EpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYSA9IGFBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYy5zZXRWZWMyKGNCKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmEgPSBhQjtcbiAgICAgICAgICAgIHJldHVybiBsZW5ndGggLSB0aGlzLm1fbWF4TGVuZ3RoIDwgU2V0dGluZ3MubGluZWFyU2xvcDtcbiAgICAgICAgfTtcbiAgICAgICAgUm9wZUpvaW50LlRZUEUgPSAncm9wZS1qb2ludCc7XG4gICAgICAgIHJldHVybiBSb3BlSm9pbnQ7XG4gICAgfShKb2ludCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIHZhciBERUZBVUxUUyQxID0ge1xuICAgICAgICBmcmVxdWVuY3lIejogMC4wLFxuICAgICAgICBkYW1waW5nUmF0aW86IDAuMCxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgd2VsZCBqb2ludCBlc3NlbnRpYWxseSBnbHVlcyB0d28gYm9kaWVzIHRvZ2V0aGVyLiBBIHdlbGQgam9pbnQgbWF5IGRpc3RvcnRcbiAgICAgKiBzb21ld2hhdCBiZWNhdXNlIHRoZSBpc2xhbmQgY29uc3RyYWludCBzb2x2ZXIgaXMgYXBwcm94aW1hdGUuXG4gICAgICovXG4gICAgdmFyIFdlbGRKb2ludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFdlbGRKb2ludCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gV2VsZEpvaW50KGRlZiwgYm9keUEsIGJvZHlCLCBhbmNob3IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoIShfdGhpcyBpbnN0YW5jZW9mIFdlbGRKb2ludCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdlbGRKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBERUZBVUxUUyQxKTtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVmLCBib2R5QSwgYm9keUIpIHx8IHRoaXM7XG4gICAgICAgICAgICBib2R5QSA9IF90aGlzLm1fYm9keUE7XG4gICAgICAgICAgICBib2R5QiA9IF90aGlzLm1fYm9keUI7XG4gICAgICAgICAgICBfdGhpcy5tX3R5cGUgPSBXZWxkSm9pbnQuVFlQRTtcbiAgICAgICAgICAgIF90aGlzLm1fbG9jYWxBbmNob3JBID0gVmVjMi5jbG9uZShhbmNob3IgPyBib2R5QS5nZXRMb2NhbFBvaW50KGFuY2hvcikgOiBkZWYubG9jYWxBbmNob3JBIHx8IFZlYzIuemVybygpKTtcbiAgICAgICAgICAgIF90aGlzLm1fbG9jYWxBbmNob3JCID0gVmVjMi5jbG9uZShhbmNob3IgPyBib2R5Qi5nZXRMb2NhbFBvaW50KGFuY2hvcikgOiBkZWYubG9jYWxBbmNob3JCIHx8IFZlYzIuemVybygpKTtcbiAgICAgICAgICAgIF90aGlzLm1fcmVmZXJlbmNlQW5nbGUgPSBtYXRoJDEuaXNGaW5pdGUoZGVmLnJlZmVyZW5jZUFuZ2xlKSA/IGRlZi5yZWZlcmVuY2VBbmdsZSA6IGJvZHlCLmdldEFuZ2xlKCkgLSBib2R5QS5nZXRBbmdsZSgpO1xuICAgICAgICAgICAgX3RoaXMubV9mcmVxdWVuY3lIeiA9IGRlZi5mcmVxdWVuY3lIejtcbiAgICAgICAgICAgIF90aGlzLm1fZGFtcGluZ1JhdGlvID0gZGVmLmRhbXBpbmdSYXRpbztcbiAgICAgICAgICAgIF90aGlzLm1faW1wdWxzZSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICBfdGhpcy5tX2JpYXMgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX2dhbW1hID0gMC4wO1xuICAgICAgICAgICAgLy8gU29sdmVyIHRlbXBcbiAgICAgICAgICAgIF90aGlzLm1fckE7IC8vIFZlYzJcbiAgICAgICAgICAgIF90aGlzLm1fckI7IC8vIFZlYzJcbiAgICAgICAgICAgIF90aGlzLm1fbG9jYWxDZW50ZXJBOyAvLyBWZWMyXG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsQ2VudGVyQjsgLy8gVmVjMlxuICAgICAgICAgICAgX3RoaXMubV9pbnZNYXNzQTsgLy8gZmxvYXRcbiAgICAgICAgICAgIF90aGlzLm1faW52TWFzc0I7IC8vIGZsb2F0XG4gICAgICAgICAgICBfdGhpcy5tX2ludklBOyAvLyBmbG9hdFxuICAgICAgICAgICAgX3RoaXMubV9pbnZJQjsgLy8gZmxvYXRcbiAgICAgICAgICAgIF90aGlzLm1fbWFzcyA9IG5ldyBNYXQzMygpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgLy8gUG9pbnQtdG8tcG9pbnQgY29uc3RyYWludFxuICAgICAgICAgICAgLy8gQyA9IHAyIC0gcDFcbiAgICAgICAgICAgIC8vIENkb3QgPSB2MiAtIHYxXG4gICAgICAgICAgICAvLyAvID0gdjIgKyBjcm9zcyh3MiwgcjIpIC0gdjEgLSBjcm9zcyh3MSwgcjEpXG4gICAgICAgICAgICAvLyBKID0gWy1JIC1yMV9za2V3IEkgcjJfc2tldyBdXG4gICAgICAgICAgICAvLyBJZGVudGl0eSB1c2VkOlxuICAgICAgICAgICAgLy8gdyBrICUgKHJ4IGkgKyByeSBqKSA9IHcgKiAoLXJ5IGkgKyByeCBqKVxuICAgICAgICAgICAgLy8gQW5nbGUgY29uc3RyYWludFxuICAgICAgICAgICAgLy8gQyA9IGFuZ2xlMiAtIGFuZ2xlMSAtIHJlZmVyZW5jZUFuZ2xlXG4gICAgICAgICAgICAvLyBDZG90ID0gdzIgLSB3MVxuICAgICAgICAgICAgLy8gSiA9IFswIDAgLTEgMCAwIDFdXG4gICAgICAgICAgICAvLyBLID0gaW52STEgKyBpbnZJMlxuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgV2VsZEpvaW50LnByb3RvdHlwZS5fc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm1fdHlwZSxcbiAgICAgICAgICAgICAgICBib2R5QTogdGhpcy5tX2JvZHlBLFxuICAgICAgICAgICAgICAgIGJvZHlCOiB0aGlzLm1fYm9keUIsXG4gICAgICAgICAgICAgICAgY29sbGlkZUNvbm5lY3RlZDogdGhpcy5tX2NvbGxpZGVDb25uZWN0ZWQsXG4gICAgICAgICAgICAgICAgZnJlcXVlbmN5SHo6IHRoaXMubV9mcmVxdWVuY3lIeixcbiAgICAgICAgICAgICAgICBkYW1waW5nUmF0aW86IHRoaXMubV9kYW1waW5nUmF0aW8sXG4gICAgICAgICAgICAgICAgbG9jYWxBbmNob3JBOiB0aGlzLm1fbG9jYWxBbmNob3JBLFxuICAgICAgICAgICAgICAgIGxvY2FsQW5jaG9yQjogdGhpcy5tX2xvY2FsQW5jaG9yQixcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VBbmdsZTogdGhpcy5tX3JlZmVyZW5jZUFuZ2xlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBXZWxkSm9pbnQuX2Rlc2VyaWFsaXplID0gZnVuY3Rpb24gKGRhdGEsIHdvcmxkLCByZXN0b3JlKSB7XG4gICAgICAgICAgICBkYXRhID0gX19hc3NpZ24oe30sIGRhdGEpO1xuICAgICAgICAgICAgZGF0YS5ib2R5QSA9IHJlc3RvcmUoQm9keSwgZGF0YS5ib2R5QSwgd29ybGQpO1xuICAgICAgICAgICAgZGF0YS5ib2R5QiA9IHJlc3RvcmUoQm9keSwgZGF0YS5ib2R5Qiwgd29ybGQpO1xuICAgICAgICAgICAgdmFyIGpvaW50ID0gbmV3IFdlbGRKb2ludChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBXZWxkSm9pbnQucHJvdG90eXBlLl9zZXRBbmNob3JzID0gZnVuY3Rpb24gKGRlZikge1xuICAgICAgICAgICAgaWYgKGRlZi5hbmNob3JBKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQS5zZXRWZWMyKHRoaXMubV9ib2R5QS5nZXRMb2NhbFBvaW50KGRlZi5hbmNob3JBKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWYubG9jYWxBbmNob3JBKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQS5zZXRWZWMyKGRlZi5sb2NhbEFuY2hvckEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZi5hbmNob3JCKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQi5zZXRWZWMyKHRoaXMubV9ib2R5Qi5nZXRMb2NhbFBvaW50KGRlZi5hbmNob3JCKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWYubG9jYWxBbmNob3JCKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQi5zZXRWZWMyKGRlZi5sb2NhbEFuY2hvckIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QSdzIG9yaWdpbi5cbiAgICAgICAgICovXG4gICAgICAgIFdlbGRKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBbmNob3JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sb2NhbEFuY2hvckE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlCJ3Mgb3JpZ2luLlxuICAgICAgICAgKi9cbiAgICAgICAgV2VsZEpvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVmZXJlbmNlIGFuZ2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgV2VsZEpvaW50LnByb3RvdHlwZS5nZXRSZWZlcmVuY2VBbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fcmVmZXJlbmNlQW5nbGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgZnJlcXVlbmN5IGluIEh6LlxuICAgICAgICAgKi9cbiAgICAgICAgV2VsZEpvaW50LnByb3RvdHlwZS5zZXRGcmVxdWVuY3kgPSBmdW5jdGlvbiAoaHopIHtcbiAgICAgICAgICAgIHRoaXMubV9mcmVxdWVuY3lIeiA9IGh6O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGZyZXF1ZW5jeSBpbiBIei5cbiAgICAgICAgICovXG4gICAgICAgIFdlbGRKb2ludC5wcm90b3R5cGUuZ2V0RnJlcXVlbmN5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9mcmVxdWVuY3lIejtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBkYW1waW5nIHJhdGlvLlxuICAgICAgICAgKi9cbiAgICAgICAgV2VsZEpvaW50LnByb3RvdHlwZS5zZXREYW1waW5nUmF0aW8gPSBmdW5jdGlvbiAocmF0aW8pIHtcbiAgICAgICAgICAgIHRoaXMubV9kYW1waW5nUmF0aW8gPSByYXRpbztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBkYW1waW5nIHJhdGlvLlxuICAgICAgICAgKi9cbiAgICAgICAgV2VsZEpvaW50LnByb3RvdHlwZS5nZXREYW1waW5nUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2RhbXBpbmdSYXRpbztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHlBIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgV2VsZEpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QS5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUIgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBXZWxkSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlYWN0aW9uIGZvcmNlIG9uIGJvZHlCIGF0IHRoZSBqb2ludCBhbmNob3IgaW4gTmV3dG9ucy5cbiAgICAgICAgICovXG4gICAgICAgIFdlbGRKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyh0aGlzLm1faW1wdWxzZS54LCB0aGlzLm1faW1wdWxzZS55KS5tdWwoaW52X2R0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gdG9ycXVlIG9uIGJvZHlCIGluIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIFdlbGRKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW52X2R0ICogdGhpcy5tX2ltcHVsc2UuejtcbiAgICAgICAgfTtcbiAgICAgICAgV2VsZEpvaW50LnByb3RvdHlwZS5pbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJBID0gdGhpcy5tX2JvZHlBLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJCID0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzc0EgPSB0aGlzLm1fYm9keUEubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3NCID0gdGhpcy5tX2JvZHlCLm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9pbnZJQSA9IHRoaXMubV9ib2R5QS5tX2ludkk7XG4gICAgICAgICAgICB0aGlzLm1faW52SUIgPSB0aGlzLm1fYm9keUIubV9pbnZJO1xuICAgICAgICAgICAgdmFyIGFBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHFBID0gUm90Lm5lbyhhQSk7XG4gICAgICAgICAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICAgICAgICAgIHRoaXMubV9yQSA9IFJvdC5tdWxWZWMyKHFBLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JBLCB0aGlzLm1fbG9jYWxDZW50ZXJBKSk7XG4gICAgICAgICAgICB0aGlzLm1fckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgICAgICAgICAgLy8gSiA9IFstSSAtcjFfc2tldyBJIHIyX3NrZXddXG4gICAgICAgICAgICAvLyBbIDAgLTEgMCAxXVxuICAgICAgICAgICAgLy8gcl9za2V3ID0gWy1yeTsgcnhdXG4gICAgICAgICAgICAvLyBNYXRsYWJcbiAgICAgICAgICAgIC8vIEsgPSBbIG1BK3IxeV4yKmlBK21CK3IyeV4yKmlCLCAtcjF5KmlBKnIxeC1yMnkqaUIqcjJ4LCAtcjF5KmlBLXIyeSppQl1cbiAgICAgICAgICAgIC8vIFsgLXIxeSppQSpyMXgtcjJ5KmlCKnIyeCwgbUErcjF4XjIqaUErbUIrcjJ4XjIqaUIsIHIxeCppQStyMngqaUJdXG4gICAgICAgICAgICAvLyBbIC1yMXkqaUEtcjJ5KmlCLCByMXgqaUErcjJ4KmlCLCBpQStpQl1cbiAgICAgICAgICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgICAgIHZhciBtQiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICAgICAgICAgIHZhciBpQSA9IHRoaXMubV9pbnZJQTtcbiAgICAgICAgICAgIHZhciBpQiA9IHRoaXMubV9pbnZJQjtcbiAgICAgICAgICAgIHZhciBLID0gbmV3IE1hdDMzKCk7XG4gICAgICAgICAgICBLLmV4LnggPSBtQSArIG1CICsgdGhpcy5tX3JBLnkgKiB0aGlzLm1fckEueSAqIGlBICsgdGhpcy5tX3JCLnkgKiB0aGlzLm1fckIueVxuICAgICAgICAgICAgICAgICogaUI7XG4gICAgICAgICAgICBLLmV5LnggPSAtdGhpcy5tX3JBLnkgKiB0aGlzLm1fckEueCAqIGlBIC0gdGhpcy5tX3JCLnkgKiB0aGlzLm1fckIueCAqIGlCO1xuICAgICAgICAgICAgSy5lei54ID0gLXRoaXMubV9yQS55ICogaUEgLSB0aGlzLm1fckIueSAqIGlCO1xuICAgICAgICAgICAgSy5leC55ID0gSy5leS54O1xuICAgICAgICAgICAgSy5leS55ID0gbUEgKyBtQiArIHRoaXMubV9yQS54ICogdGhpcy5tX3JBLnggKiBpQSArIHRoaXMubV9yQi54ICogdGhpcy5tX3JCLnhcbiAgICAgICAgICAgICAgICAqIGlCO1xuICAgICAgICAgICAgSy5lei55ID0gdGhpcy5tX3JBLnggKiBpQSArIHRoaXMubV9yQi54ICogaUI7XG4gICAgICAgICAgICBLLmV4LnogPSBLLmV6Lng7XG4gICAgICAgICAgICBLLmV5LnogPSBLLmV6Lnk7XG4gICAgICAgICAgICBLLmV6LnogPSBpQSArIGlCO1xuICAgICAgICAgICAgaWYgKHRoaXMubV9mcmVxdWVuY3lIeiA+IDAuMCkge1xuICAgICAgICAgICAgICAgIEsuZ2V0SW52ZXJzZTIyKHRoaXMubV9tYXNzKTtcbiAgICAgICAgICAgICAgICB2YXIgaW52TSA9IGlBICsgaUI7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBpbnZNID4gMC4wID8gMS4wIC8gaW52TSA6IDAuMDsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB2YXIgQyA9IGFCIC0gYUEgLSB0aGlzLm1fcmVmZXJlbmNlQW5nbGU7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgLy8gRnJlcXVlbmN5XG4gICAgICAgICAgICAgICAgdmFyIG9tZWdhID0gMi4wICogbWF0aCQxLlBJICogdGhpcy5tX2ZyZXF1ZW5jeUh6OyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgIC8vIERhbXBpbmcgY29lZmZpY2llbnRcbiAgICAgICAgICAgICAgICB2YXIgZCA9IDIuMCAqIG0gKiB0aGlzLm1fZGFtcGluZ1JhdGlvICogb21lZ2E7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgLy8gU3ByaW5nIHN0aWZmbmVzc1xuICAgICAgICAgICAgICAgIHZhciBrID0gbSAqIG9tZWdhICogb21lZ2E7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgLy8gbWFnaWMgZm9ybXVsYXNcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHN0ZXAuZHQ7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgdGhpcy5tX2dhbW1hID0gaCAqIChkICsgaCAqIGspO1xuICAgICAgICAgICAgICAgIHRoaXMubV9nYW1tYSA9IHRoaXMubV9nYW1tYSAhPSAwLjAgPyAxLjAgLyB0aGlzLm1fZ2FtbWEgOiAwLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JpYXMgPSBDICogaCAqIGsgKiB0aGlzLm1fZ2FtbWE7XG4gICAgICAgICAgICAgICAgaW52TSArPSB0aGlzLm1fZ2FtbWE7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21hc3MuZXoueiA9IGludk0gIT0gMC4wID8gMS4wIC8gaW52TSA6IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEsuZXoueiA9PSAwLjApIHtcbiAgICAgICAgICAgICAgICBLLmdldEludmVyc2UyMih0aGlzLm1fbWFzcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2dhbW1hID0gMC4wO1xuICAgICAgICAgICAgICAgIHRoaXMubV9iaWFzID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgSy5nZXRTeW1JbnZlcnNlMzModGhpcy5tX21hc3MpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9nYW1tYSA9IDAuMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYmlhcyA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgICAgICAgIC8vIFNjYWxlIGltcHVsc2VzIHRvIHN1cHBvcnQgYSB2YXJpYWJsZSB0aW1lIHN0ZXAuXG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UubXVsKHN0ZXAuZHRSYXRpbyk7XG4gICAgICAgICAgICAgICAgdmFyIFAgPSBWZWMyLm5lbyh0aGlzLm1faW1wdWxzZS54LCB0aGlzLm1faW1wdWxzZS55KTtcbiAgICAgICAgICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICAgICAgICAgIHdBIC09IGlBICogKFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckEsIFApICsgdGhpcy5tX2ltcHVsc2Uueik7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIChWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBQKSArIHRoaXMubV9pbXB1bHNlLnopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2Uuc2V0WmVybygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudiA9IHZBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudiA9IHZCO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICBXZWxkSm9pbnQucHJvdG90eXBlLnNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBO1xuICAgICAgICAgICAgdmFyIG1CID0gdGhpcy5tX2ludk1hc3NCOyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIGlBID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgICAgdmFyIGlCID0gdGhpcy5tX2ludklCOyAvLyBmbG9hdFxuICAgICAgICAgICAgaWYgKHRoaXMubV9mcmVxdWVuY3lIeiA+IDAuMCkge1xuICAgICAgICAgICAgICAgIHZhciBDZG90MiA9IHdCIC0gd0E7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2UyID0gLXRoaXMubV9tYXNzLmV6LnpcbiAgICAgICAgICAgICAgICAgICAgKiAoQ2RvdDIgKyB0aGlzLm1fYmlhcyArIHRoaXMubV9nYW1tYSAqIHRoaXMubV9pbXB1bHNlLnopOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogKz0gaW1wdWxzZTI7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBpbXB1bHNlMjtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIGltcHVsc2UyO1xuICAgICAgICAgICAgICAgIHZhciBDZG90MSA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgICAgIENkb3QxLmFkZENvbWJpbmUoMSwgdkIsIDEsIFZlYzIuY3Jvc3NOdW1WZWMyKHdCLCB0aGlzLm1fckIpKTtcbiAgICAgICAgICAgICAgICBDZG90MS5zdWJDb21iaW5lKDEsIHZBLCAxLCBWZWMyLmNyb3NzTnVtVmVjMih3QSwgdGhpcy5tX3JBKSk7IC8vIFZlYzJcbiAgICAgICAgICAgICAgICB2YXIgaW1wdWxzZTEgPSBWZWMyLm5lZyhNYXQzMy5tdWxWZWMyKHRoaXMubV9tYXNzLCBDZG90MSkpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueCArPSBpbXB1bHNlMS54O1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgKz0gaW1wdWxzZTEueTtcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIuY2xvbmUoaW1wdWxzZTEpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgdkEuc3ViTXVsKG1BLCBQKTtcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckEsIFApO1xuICAgICAgICAgICAgICAgIHZCLmFkZE11bChtQiwgUCk7XG4gICAgICAgICAgICAgICAgd0IgKz0gaUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBQKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBDZG90MSA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgICAgIENkb3QxLmFkZENvbWJpbmUoMSwgdkIsIDEsIFZlYzIuY3Jvc3NOdW1WZWMyKHdCLCB0aGlzLm1fckIpKTtcbiAgICAgICAgICAgICAgICBDZG90MS5zdWJDb21iaW5lKDEsIHZBLCAxLCBWZWMyLmNyb3NzTnVtVmVjMih3QSwgdGhpcy5tX3JBKSk7IC8vIFZlYzJcbiAgICAgICAgICAgICAgICB2YXIgQ2RvdDIgPSB3QiAtIHdBOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgIHZhciBDZG90ID0gbmV3IFZlYzMoQ2RvdDEueCwgQ2RvdDEueSwgQ2RvdDIpOyAvLyBWZWMzXG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2UgPSBWZWMzLm5lZyhNYXQzMy5tdWxWZWMzKHRoaXMubV9tYXNzLCBDZG90KSk7IC8vIFZlYzNcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS5hZGQoaW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgdmFyIFAgPSBWZWMyLm5lbyhpbXB1bHNlLngsIGltcHVsc2UueSk7XG4gICAgICAgICAgICAgICAgdkEuc3ViTXVsKG1BLCBQKTtcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIChWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JBLCBQKSArIGltcHVsc2Uueik7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIChWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBQKSArIGltcHVsc2Uueik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52ID0gdkI7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZXJyb3JzIGFyZSB3aXRoaW4gdG9sZXJhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgV2VsZEpvaW50LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIGNBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgY0IgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciBxQSA9IFJvdC5uZW8oYUEpO1xuICAgICAgICAgICAgdmFyIHFCID0gUm90Lm5lbyhhQik7XG4gICAgICAgICAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0E7XG4gICAgICAgICAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0I7XG4gICAgICAgICAgICB2YXIgaUEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICAgICB2YXIgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgICAgICAgICB2YXIgckEgPSBSb3QubXVsVmVjMihxQSwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xvY2FsQ2VudGVyQSkpO1xuICAgICAgICAgICAgdmFyIHJCID0gUm90Lm11bFZlYzIocUIsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sb2NhbENlbnRlckIpKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkVycm9yO1xuICAgICAgICAgICAgdmFyIGFuZ3VsYXJFcnJvcjtcbiAgICAgICAgICAgIHZhciBLID0gbmV3IE1hdDMzKCk7XG4gICAgICAgICAgICBLLmV4LnggPSBtQSArIG1CICsgckEueSAqIHJBLnkgKiBpQSArIHJCLnkgKiByQi55ICogaUI7XG4gICAgICAgICAgICBLLmV5LnggPSAtckEueSAqIHJBLnggKiBpQSAtIHJCLnkgKiByQi54ICogaUI7XG4gICAgICAgICAgICBLLmV6LnggPSAtckEueSAqIGlBIC0gckIueSAqIGlCO1xuICAgICAgICAgICAgSy5leC55ID0gSy5leS54O1xuICAgICAgICAgICAgSy5leS55ID0gbUEgKyBtQiArIHJBLnggKiByQS54ICogaUEgKyByQi54ICogckIueCAqIGlCO1xuICAgICAgICAgICAgSy5lei55ID0gckEueCAqIGlBICsgckIueCAqIGlCO1xuICAgICAgICAgICAgSy5leC56ID0gSy5lei54O1xuICAgICAgICAgICAgSy5leS56ID0gSy5lei55O1xuICAgICAgICAgICAgSy5lei56ID0gaUEgKyBpQjtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fZnJlcXVlbmN5SHogPiAwLjApIHtcbiAgICAgICAgICAgICAgICB2YXIgQzEgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgICAgICBDMS5hZGRDb21iaW5lKDEsIGNCLCAxLCByQik7XG4gICAgICAgICAgICAgICAgQzEuc3ViQ29tYmluZSgxLCBjQSwgMSwgckEpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25FcnJvciA9IEMxLmxlbmd0aCgpO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXJFcnJvciA9IDAuMDtcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIubmVnKEsuc29sdmUyMihDMSkpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgY0Euc3ViTXVsKG1BLCBQKTtcbiAgICAgICAgICAgICAgICBhQSAtPSBpQSAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyQSwgUCk7XG4gICAgICAgICAgICAgICAgY0IuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICBhQiArPSBpQiAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyQiwgUCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgQzEgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgICAgICBDMS5hZGRDb21iaW5lKDEsIGNCLCAxLCByQik7XG4gICAgICAgICAgICAgICAgQzEuc3ViQ29tYmluZSgxLCBjQSwgMSwgckEpO1xuICAgICAgICAgICAgICAgIHZhciBDMiA9IGFCIC0gYUEgLSB0aGlzLm1fcmVmZXJlbmNlQW5nbGU7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgcG9zaXRpb25FcnJvciA9IEMxLmxlbmd0aCgpO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXJFcnJvciA9IG1hdGgkMS5hYnMoQzIpO1xuICAgICAgICAgICAgICAgIHZhciBDID0gbmV3IFZlYzMoQzEueCwgQzEueSwgQzIpO1xuICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICBpZiAoSy5lei56ID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIGltcHVsc2UgPSBWZWMzLm5lZyhLLnNvbHZlMzMoQykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltcHVsc2UyID0gVmVjMi5uZWcoSy5zb2x2ZTIyKEMxKSk7XG4gICAgICAgICAgICAgICAgICAgIGltcHVsc2Uuc2V0KGltcHVsc2UyLngsIGltcHVsc2UyLnksIDAuMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBQID0gVmVjMi5uZW8oaW1wdWxzZS54LCBpbXB1bHNlLnkpO1xuICAgICAgICAgICAgICAgIGNBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgICAgICAgICAgYUEgLT0gaUEgKiAoVmVjMi5jcm9zc1ZlYzJWZWMyKHJBLCBQKSArIGltcHVsc2Uueik7XG4gICAgICAgICAgICAgICAgY0IuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICBhQiArPSBpQiAqIChWZWMyLmNyb3NzVmVjMlZlYzIockIsIFApICsgaW1wdWxzZS56KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmMgPSBjQTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmEgPSBhQTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmMgPSBjQjtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmEgPSBhQjtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbkVycm9yIDw9IFNldHRpbmdzLmxpbmVhclNsb3AgJiYgYW5ndWxhckVycm9yIDw9IFNldHRpbmdzLmFuZ3VsYXJTbG9wO1xuICAgICAgICB9O1xuICAgICAgICBXZWxkSm9pbnQuVFlQRSA9ICd3ZWxkLWpvaW50JztcbiAgICAgICAgcmV0dXJuIFdlbGRKb2ludDtcbiAgICB9KEpvaW50KSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgdmFyIERFRkFVTFRTID0ge1xuICAgICAgICBlbmFibGVNb3RvcjogZmFsc2UsXG4gICAgICAgIG1heE1vdG9yVG9ycXVlOiAwLjAsXG4gICAgICAgIG1vdG9yU3BlZWQ6IDAuMCxcbiAgICAgICAgZnJlcXVlbmN5SHo6IDIuMCxcbiAgICAgICAgZGFtcGluZ1JhdGlvOiAwLjcsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHdoZWVsIGpvaW50LiBUaGlzIGpvaW50IHByb3ZpZGVzIHR3byBkZWdyZWVzIG9mIGZyZWVkb206IHRyYW5zbGF0aW9uIGFsb25nXG4gICAgICogYW4gYXhpcyBmaXhlZCBpbiBib2R5QSBhbmQgcm90YXRpb24gaW4gdGhlIHBsYW5lLiBJbiBvdGhlciB3b3JkcywgaXQgaXMgYVxuICAgICAqIHBvaW50IHRvIGxpbmUgY29uc3RyYWludCB3aXRoIGEgcm90YXRpb25hbCBtb3RvciBhbmQgYSBsaW5lYXIgc3ByaW5nL2RhbXBlci5cbiAgICAgKiBUaGlzIGpvaW50IGlzIGRlc2lnbmVkIGZvciB2ZWhpY2xlIHN1c3BlbnNpb25zLlxuICAgICAqL1xuICAgIHZhciBXaGVlbEpvaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoV2hlZWxKb2ludCwgX3N1cGVyKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBmdW5jdGlvbiBXaGVlbEpvaW50KGRlZiwgYm9keUEsIGJvZHlCLCBhbmNob3IsIGF4aXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoIShfdGhpcyBpbnN0YW5jZW9mIFdoZWVsSm9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXaGVlbEpvaW50KGRlZiwgYm9keUEsIGJvZHlCLCBhbmNob3IsIGF4aXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmID0gb3B0aW9ucyhkZWYsIERFRkFVTFRTKTtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVmLCBib2R5QSwgYm9keUIpIHx8IHRoaXM7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIF90aGlzLm1fYXggPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gX3RoaXMubV9heSA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgYm9keUEgPSBfdGhpcy5tX2JvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSBfdGhpcy5tX2JvZHlCO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlID0gV2hlZWxKb2ludC5UWVBFO1xuICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckEgPSBWZWMyLmNsb25lKGFuY2hvciA/IGJvZHlBLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckEgfHwgVmVjMi56ZXJvKCkpO1xuICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckIgPSBWZWMyLmNsb25lKGFuY2hvciA/IGJvZHlCLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckIgfHwgVmVjMi56ZXJvKCkpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBsb2NhbEF4aXNcbiAgICAgICAgICAgIF90aGlzLm1fbG9jYWxYQXhpc0EgPSBWZWMyLmNsb25lKGF4aXMgPyBib2R5QS5nZXRMb2NhbFZlY3RvcihheGlzKSA6IGRlZi5sb2NhbEF4aXNBIHx8IGRlZi5sb2NhbEF4aXMgfHwgVmVjMi5uZW8oMS4wLCAwLjApKTtcbiAgICAgICAgICAgIF90aGlzLm1fbG9jYWxZQXhpc0EgPSBWZWMyLmNyb3NzTnVtVmVjMigxLjAsIF90aGlzLm1fbG9jYWxYQXhpc0EpO1xuICAgICAgICAgICAgX3RoaXMubV9tYXNzID0gMC4wO1xuICAgICAgICAgICAgX3RoaXMubV9pbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgX3RoaXMubV9tb3Rvck1hc3MgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIF90aGlzLm1fc3ByaW5nTWFzcyA9IDAuMDtcbiAgICAgICAgICAgIF90aGlzLm1fc3ByaW5nSW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIF90aGlzLm1fbWF4TW90b3JUb3JxdWUgPSBkZWYubWF4TW90b3JUb3JxdWU7XG4gICAgICAgICAgICBfdGhpcy5tX21vdG9yU3BlZWQgPSBkZWYubW90b3JTcGVlZDtcbiAgICAgICAgICAgIF90aGlzLm1fZW5hYmxlTW90b3IgPSBkZWYuZW5hYmxlTW90b3I7XG4gICAgICAgICAgICBfdGhpcy5tX2ZyZXF1ZW5jeUh6ID0gZGVmLmZyZXF1ZW5jeUh6O1xuICAgICAgICAgICAgX3RoaXMubV9kYW1waW5nUmF0aW8gPSBkZWYuZGFtcGluZ1JhdGlvO1xuICAgICAgICAgICAgX3RoaXMubV9iaWFzID0gMC4wO1xuICAgICAgICAgICAgX3RoaXMubV9nYW1tYSA9IDAuMDtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIC8vIExpbmVhciBjb25zdHJhaW50IChwb2ludC10by1saW5lKVxuICAgICAgICAgICAgLy8gZCA9IHBCIC0gcEEgPSB4QiArIHJCIC0geEEgLSByQVxuICAgICAgICAgICAgLy8gQyA9IGRvdChheSwgZClcbiAgICAgICAgICAgIC8vIENkb3QgPSBkb3QoZCwgY3Jvc3Mod0EsIGF5KSkgKyBkb3QoYXksIHZCICsgY3Jvc3Mod0IsIHJCKSAtIHZBIC0gY3Jvc3Mod0EsXG4gICAgICAgICAgICAvLyByQSkpXG4gICAgICAgICAgICAvLyA9IC1kb3QoYXksIHZBKSAtIGRvdChjcm9zcyhkICsgckEsIGF5KSwgd0EpICsgZG90KGF5LCB2QikgKyBkb3QoY3Jvc3MockIsXG4gICAgICAgICAgICAvLyBheSksIHZCKVxuICAgICAgICAgICAgLy8gSiA9IFstYXksIC1jcm9zcyhkICsgckEsIGF5KSwgYXksIGNyb3NzKHJCLCBheSldXG4gICAgICAgICAgICAvLyBTcHJpbmcgbGluZWFyIGNvbnN0cmFpbnRcbiAgICAgICAgICAgIC8vIEMgPSBkb3QoYXgsIGQpXG4gICAgICAgICAgICAvLyBDZG90ID0gPSAtZG90KGF4LCB2QSkgLSBkb3QoY3Jvc3MoZCArIHJBLCBheCksIHdBKSArIGRvdChheCwgdkIpICtcbiAgICAgICAgICAgIC8vIGRvdChjcm9zcyhyQiwgYXgpLCB2QilcbiAgICAgICAgICAgIC8vIEogPSBbLWF4IC1jcm9zcyhkK3JBLCBheCkgYXggY3Jvc3MockIsIGF4KV1cbiAgICAgICAgICAgIC8vIE1vdG9yIHJvdGF0aW9uYWwgY29uc3RyYWludFxuICAgICAgICAgICAgLy8gQ2RvdCA9IHdCIC0gd0FcbiAgICAgICAgICAgIC8vIEogPSBbMCAwIC0xIDAgMCAxXVxuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgV2hlZWxKb2ludC5wcm90b3R5cGUuX3NlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5tX3R5cGUsXG4gICAgICAgICAgICAgICAgYm9keUE6IHRoaXMubV9ib2R5QSxcbiAgICAgICAgICAgICAgICBib2R5QjogdGhpcy5tX2JvZHlCLFxuICAgICAgICAgICAgICAgIGNvbGxpZGVDb25uZWN0ZWQ6IHRoaXMubV9jb2xsaWRlQ29ubmVjdGVkLFxuICAgICAgICAgICAgICAgIGVuYWJsZU1vdG9yOiB0aGlzLm1fZW5hYmxlTW90b3IsXG4gICAgICAgICAgICAgICAgbWF4TW90b3JUb3JxdWU6IHRoaXMubV9tYXhNb3RvclRvcnF1ZSxcbiAgICAgICAgICAgICAgICBtb3RvclNwZWVkOiB0aGlzLm1fbW90b3JTcGVlZCxcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3lIejogdGhpcy5tX2ZyZXF1ZW5jeUh6LFxuICAgICAgICAgICAgICAgIGRhbXBpbmdSYXRpbzogdGhpcy5tX2RhbXBpbmdSYXRpbyxcbiAgICAgICAgICAgICAgICBsb2NhbEFuY2hvckE6IHRoaXMubV9sb2NhbEFuY2hvckEsXG4gICAgICAgICAgICAgICAgbG9jYWxBbmNob3JCOiB0aGlzLm1fbG9jYWxBbmNob3JCLFxuICAgICAgICAgICAgICAgIGxvY2FsQXhpc0E6IHRoaXMubV9sb2NhbFhBeGlzQSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgV2hlZWxKb2ludC5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSwgd29ybGQsIHJlc3RvcmUpIHtcbiAgICAgICAgICAgIGRhdGEgPSBfX2Fzc2lnbih7fSwgZGF0YSk7XG4gICAgICAgICAgICBkYXRhLmJvZHlBID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlBLCB3b3JsZCk7XG4gICAgICAgICAgICBkYXRhLmJvZHlCID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlCLCB3b3JsZCk7XG4gICAgICAgICAgICB2YXIgam9pbnQgPSBuZXcgV2hlZWxKb2ludChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5fc2V0QW5jaG9ycyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgICAgIGlmIChkZWYuYW5jaG9yQSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckEuc2V0VmVjMih0aGlzLm1fYm9keUEuZ2V0TG9jYWxQb2ludChkZWYuYW5jaG9yQSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVmLmxvY2FsQW5jaG9yQSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckEuc2V0VmVjMihkZWYubG9jYWxBbmNob3JBKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWYuYW5jaG9yQikge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckIuc2V0VmVjMih0aGlzLm1fYm9keUIuZ2V0TG9jYWxQb2ludChkZWYuYW5jaG9yQikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVmLmxvY2FsQW5jaG9yQikge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckIuc2V0VmVjMihkZWYubG9jYWxBbmNob3JCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWYubG9jYWxBeGlzQSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbFhBeGlzQS5zZXRWZWMyKGRlZi5sb2NhbEF4aXNBKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG9jYWxZQXhpc0Euc2V0VmVjMihWZWMyLmNyb3NzTnVtVmVjMigxLjAsIGRlZi5sb2NhbEF4aXNBKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlBJ3Mgb3JpZ2luLlxuICAgICAgICAgKi9cbiAgICAgICAgV2hlZWxKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBbmNob3JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sb2NhbEFuY2hvckE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlCJ3Mgb3JpZ2luLlxuICAgICAgICAgKi9cbiAgICAgICAgV2hlZWxKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sb2NhbEFuY2hvckI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9jYWwgam9pbnQgYXhpcyByZWxhdGl2ZSB0byBib2R5QS5cbiAgICAgICAgICovXG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLmdldExvY2FsQXhpc0EgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvY2FsWEF4aXNBO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IGpvaW50IHRyYW5zbGF0aW9uLCB1c3VhbGx5IGluIG1ldGVycy5cbiAgICAgICAgICovXG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLmdldEpvaW50VHJhbnNsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICAgICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICAgICAgICB2YXIgcEEgPSBiQS5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckEpOyAvLyBWZWMyXG4gICAgICAgICAgICB2YXIgcEIgPSBiQi5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckIpOyAvLyBWZWMyXG4gICAgICAgICAgICB2YXIgZCA9IFZlYzIuc3ViKHBCLCBwQSk7IC8vIFZlYzJcbiAgICAgICAgICAgIHZhciBheGlzID0gYkEuZ2V0V29ybGRWZWN0b3IodGhpcy5tX2xvY2FsWEF4aXNBKTsgLy8gVmVjMlxuICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gVmVjMi5kb3QoZCwgYXhpcyk7IC8vIGZsb2F0XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRpb247XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgam9pbnQgdHJhbnNsYXRpb24gc3BlZWQsIHVzdWFsbHkgaW4gbWV0ZXJzIHBlciBzZWNvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5nZXRKb2ludFNwZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgICAgcmV0dXJuIHdCIC0gd0E7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgam9pbnQgbW90b3IgZW5hYmxlZD9cbiAgICAgICAgICovXG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLmlzTW90b3JFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9lbmFibGVNb3RvcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZS9kaXNhYmxlIHRoZSBqb2ludCBtb3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLmVuYWJsZU1vdG9yID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9lbmFibGVNb3RvciA9IGZsYWc7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG1vdG9yIHNwZWVkLCB1c3VhbGx5IGluIHJhZGlhbnMgcGVyIHNlY29uZC5cbiAgICAgICAgICovXG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLnNldE1vdG9yU3BlZWQgPSBmdW5jdGlvbiAoc3BlZWQpIHtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9tb3RvclNwZWVkID0gc3BlZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG1vdG9yIHNwZWVkLCB1c3VhbGx5IGluIHJhZGlhbnMgcGVyIHNlY29uZC5cbiAgICAgICAgICovXG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLmdldE1vdG9yU3BlZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX21vdG9yU3BlZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQvR2V0IHRoZSBtYXhpbXVtIG1vdG9yIGZvcmNlLCB1c3VhbGx5IGluIE4tbS5cbiAgICAgICAgICovXG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLnNldE1heE1vdG9yVG9ycXVlID0gZnVuY3Rpb24gKHRvcnF1ZSkge1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5tX21heE1vdG9yVG9ycXVlID0gdG9ycXVlO1xuICAgICAgICB9O1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5nZXRNYXhNb3RvclRvcnF1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbWF4TW90b3JUb3JxdWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgbW90b3IgdG9ycXVlIGdpdmVuIHRoZSBpbnZlcnNlIHRpbWUgc3RlcCwgdXN1YWxseSBpbiBOLW0uXG4gICAgICAgICAqL1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5nZXRNb3RvclRvcnF1ZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0L0dldCB0aGUgc3ByaW5nIGZyZXF1ZW5jeSBpbiBoZXJ0ei4gU2V0dGluZyB0aGUgZnJlcXVlbmN5IHRvIHplcm8gZGlzYWJsZXNcbiAgICAgICAgICogdGhlIHNwcmluZy5cbiAgICAgICAgICovXG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLnNldFNwcmluZ0ZyZXF1ZW5jeUh6ID0gZnVuY3Rpb24gKGh6KSB7XG4gICAgICAgICAgICB0aGlzLm1fZnJlcXVlbmN5SHogPSBoejtcbiAgICAgICAgfTtcbiAgICAgICAgV2hlZWxKb2ludC5wcm90b3R5cGUuZ2V0U3ByaW5nRnJlcXVlbmN5SHogPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2ZyZXF1ZW5jeUh6O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0L0dldCB0aGUgc3ByaW5nIGRhbXBpbmcgcmF0aW9cbiAgICAgICAgICovXG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLnNldFNwcmluZ0RhbXBpbmdSYXRpbyA9IGZ1bmN0aW9uIChyYXRpbykge1xuICAgICAgICAgICAgdGhpcy5tX2RhbXBpbmdSYXRpbyA9IHJhdGlvO1xuICAgICAgICB9O1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5nZXRTcHJpbmdEYW1waW5nUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2RhbXBpbmdSYXRpbztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHlBIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgV2hlZWxKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JBKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHlCIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgV2hlZWxKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUIuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JCKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gZm9yY2Ugb24gYm9keUIgYXQgdGhlIGpvaW50IGFuY2hvciBpbiBOZXd0b25zLlxuICAgICAgICAgKi9cbiAgICAgICAgV2hlZWxKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLmNvbWJpbmUodGhpcy5tX2ltcHVsc2UsIHRoaXMubV9heSwgdGhpcy5tX3NwcmluZ0ltcHVsc2UsIHRoaXMubV9heCkubXVsKGludl9kdCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlYWN0aW9uIHRvcnF1ZSBvbiBib2R5QiBpbiBOKm0uXG4gICAgICAgICAqL1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgICAgICB9O1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5pbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJBID0gdGhpcy5tX2JvZHlBLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJCID0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzc0EgPSB0aGlzLm1fYm9keUEubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3NCID0gdGhpcy5tX2JvZHlCLm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9pbnZJQSA9IHRoaXMubV9ib2R5QS5tX2ludkk7XG4gICAgICAgICAgICB0aGlzLm1faW52SUIgPSB0aGlzLm1fYm9keUIubV9pbnZJO1xuICAgICAgICAgICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBO1xuICAgICAgICAgICAgdmFyIG1CID0gdGhpcy5tX2ludk1hc3NCOyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIGlBID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgICAgdmFyIGlCID0gdGhpcy5tX2ludklCOyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIGNBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICAgICAgICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3Nlcy5cbiAgICAgICAgICAgIHZhciByQSA9IFJvdC5tdWxWZWMyKHFBLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JBLCB0aGlzLm1fbG9jYWxDZW50ZXJBKSk7XG4gICAgICAgICAgICB2YXIgckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgICAgICAgICAgdmFyIGQgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIGQuYWRkQ29tYmluZSgxLCBjQiwgMSwgckIpO1xuICAgICAgICAgICAgZC5zdWJDb21iaW5lKDEsIGNBLCAxLCByQSk7IC8vIFZlYzJcbiAgICAgICAgICAgIC8vIFBvaW50IHRvIGxpbmUgY29uc3RyYWludFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMubV9heSA9IFJvdC5tdWxWZWMyKHFBLCB0aGlzLm1fbG9jYWxZQXhpc0EpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9zQXkgPSBWZWMyLmNyb3NzVmVjMlZlYzIoVmVjMi5hZGQoZCwgckEpLCB0aGlzLm1fYXkpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9zQnkgPSBWZWMyLmNyb3NzVmVjMlZlYzIockIsIHRoaXMubV9heSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21hc3MgPSBtQSArIG1CICsgaUEgKiB0aGlzLm1fc0F5ICogdGhpcy5tX3NBeSArIGlCICogdGhpcy5tX3NCeVxuICAgICAgICAgICAgICAgICAgICAqIHRoaXMubV9zQnk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubV9tYXNzID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9tYXNzID0gMS4wIC8gdGhpcy5tX21hc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3ByaW5nIGNvbnN0cmFpbnRcbiAgICAgICAgICAgIHRoaXMubV9zcHJpbmdNYXNzID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5tX2JpYXMgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLm1fZ2FtbWEgPSAwLjA7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2ZyZXF1ZW5jeUh6ID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2F4ID0gUm90Lm11bFZlYzIocUEsIHRoaXMubV9sb2NhbFhBeGlzQSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3NBeCA9IFZlYzIuY3Jvc3NWZWMyVmVjMihWZWMyLmFkZChkLCByQSksIHRoaXMubV9heCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3NCeCA9IFZlYzIuY3Jvc3NWZWMyVmVjMihyQiwgdGhpcy5tX2F4KTtcbiAgICAgICAgICAgICAgICB2YXIgaW52TWFzcyA9IG1BICsgbUIgKyBpQSAqIHRoaXMubV9zQXggKiB0aGlzLm1fc0F4ICsgaUIgKiB0aGlzLm1fc0J4XG4gICAgICAgICAgICAgICAgICAgICogdGhpcy5tX3NCeDsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICBpZiAoaW52TWFzcyA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fc3ByaW5nTWFzcyA9IDEuMCAvIGludk1hc3M7XG4gICAgICAgICAgICAgICAgICAgIHZhciBDID0gVmVjMi5kb3QoZCwgdGhpcy5tX2F4KTsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gRnJlcXVlbmN5XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbWVnYSA9IDIuMCAqIG1hdGgkMS5QSSAqIHRoaXMubV9mcmVxdWVuY3lIejsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gRGFtcGluZyBjb2VmZmljaWVudFxuICAgICAgICAgICAgICAgICAgICB2YXIgZGFtcCA9IDIuMCAqIHRoaXMubV9zcHJpbmdNYXNzICogdGhpcy5tX2RhbXBpbmdSYXRpbyAqIG9tZWdhOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgICAgICAvLyBTcHJpbmcgc3RpZmZuZXNzXG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gdGhpcy5tX3NwcmluZ01hc3MgKiBvbWVnYSAqIG9tZWdhOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgICAgICAvLyBtYWdpYyBmb3JtdWxhc1xuICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IHN0ZXAuZHQ7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9nYW1tYSA9IGggKiAoZGFtcCArIGggKiBrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubV9nYW1tYSA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2dhbW1hID0gMS4wIC8gdGhpcy5tX2dhbW1hO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9iaWFzID0gQyAqIGggKiBrICogdGhpcy5tX2dhbW1hO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fc3ByaW5nTWFzcyA9IGludk1hc3MgKyB0aGlzLm1fZ2FtbWE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1fc3ByaW5nTWFzcyA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3NwcmluZ01hc3MgPSAxLjAgLyB0aGlzLm1fc3ByaW5nTWFzcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubV9zcHJpbmdJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUm90YXRpb25hbCBtb3RvclxuICAgICAgICAgICAgaWYgKHRoaXMubV9lbmFibGVNb3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMubV9tb3Rvck1hc3MgPSBpQSArIGlCO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1fbW90b3JNYXNzID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9tb3Rvck1hc3MgPSAxLjAgLyB0aGlzLm1fbW90b3JNYXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubV9tb3Rvck1hc3MgPSAwLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgICAgICAgIC8vIEFjY291bnQgZm9yIHZhcmlhYmxlIHRpbWUgc3RlcC5cbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgICAgICAgICAgdGhpcy5tX3NwcmluZ0ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgICAgICAgIHZhciBQID0gVmVjMi5jb21iaW5lKHRoaXMubV9pbXB1bHNlLCB0aGlzLm1fYXksIHRoaXMubV9zcHJpbmdJbXB1bHNlLCB0aGlzLm1fYXgpO1xuICAgICAgICAgICAgICAgIHZhciBMQSA9IHRoaXMubV9pbXB1bHNlICogdGhpcy5tX3NBeSArIHRoaXMubV9zcHJpbmdJbXB1bHNlICogdGhpcy5tX3NBeCArIHRoaXMubV9tb3RvckltcHVsc2U7XG4gICAgICAgICAgICAgICAgdmFyIExCID0gdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fc0J5ICsgdGhpcy5tX3NwcmluZ0ltcHVsc2UgKiB0aGlzLm1fc0J4ICsgdGhpcy5tX21vdG9ySW1wdWxzZTtcbiAgICAgICAgICAgICAgICB2QS5zdWJNdWwodGhpcy5tX2ludk1hc3NBLCBQKTtcbiAgICAgICAgICAgICAgICB3QSAtPSB0aGlzLm1faW52SUEgKiBMQTtcbiAgICAgICAgICAgICAgICB2Qi5hZGRNdWwodGhpcy5tX2ludk1hc3NCLCBQKTtcbiAgICAgICAgICAgICAgICB3QiArPSB0aGlzLm1faW52SUIgKiBMQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgICAgIHRoaXMubV9zcHJpbmdJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52LnNldFZlYzIodkEpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudi5zZXRWZWMyKHZCKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LncgPSB3QjtcbiAgICAgICAgfTtcbiAgICAgICAgV2hlZWxKb2ludC5wcm90b3R5cGUuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgICAgIHZhciBtQiA9IHRoaXMubV9pbnZNYXNzQjsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciBpQSA9IHRoaXMubV9pbnZJQTtcbiAgICAgICAgICAgIHZhciBpQiA9IHRoaXMubV9pbnZJQjsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICAvLyBTb2x2ZSBzcHJpbmcgY29uc3RyYWludFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBDZG90ID0gVmVjMi5kb3QodGhpcy5tX2F4LCB2QikgLSBWZWMyLmRvdCh0aGlzLm1fYXgsIHZBKSArIHRoaXMubV9zQnhcbiAgICAgICAgICAgICAgICAgICAgKiB3QiAtIHRoaXMubV9zQXggKiB3QTsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB2YXIgaW1wdWxzZSA9IC10aGlzLm1fc3ByaW5nTWFzc1xuICAgICAgICAgICAgICAgICAgICAqIChDZG90ICsgdGhpcy5tX2JpYXMgKyB0aGlzLm1fZ2FtbWEgKiB0aGlzLm1fc3ByaW5nSW1wdWxzZSk7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgdGhpcy5tX3NwcmluZ0ltcHVsc2UgKz0gaW1wdWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIubXVsTnVtVmVjMihpbXB1bHNlLCB0aGlzLm1fYXgpOyAvLyBWZWMyXG4gICAgICAgICAgICAgICAgdmFyIExBID0gaW1wdWxzZSAqIHRoaXMubV9zQXg7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgdmFyIExCID0gaW1wdWxzZSAqIHRoaXMubV9zQng7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgdkEuc3ViTXVsKG1BLCBQKTtcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIExBO1xuICAgICAgICAgICAgICAgIHZCLmFkZE11bChtQiwgUCk7XG4gICAgICAgICAgICAgICAgd0IgKz0gaUIgKiBMQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbHZlIHJvdGF0aW9uYWwgbW90b3IgY29uc3RyYWludFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBDZG90ID0gd0IgLSB3QSAtIHRoaXMubV9tb3RvclNwZWVkOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlID0gLXRoaXMubV9tb3Rvck1hc3MgKiBDZG90OyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX21vdG9ySW1wdWxzZTsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB2YXIgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiB0aGlzLm1fbWF4TW90b3JUb3JxdWU7IC8vIGZsb2F0XG4gICAgICAgICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IG1hdGgkMS5jbGFtcCh0aGlzLm1fbW90b3JJbXB1bHNlICsgaW1wdWxzZSwgLW1heEltcHVsc2UsIG1heEltcHVsc2UpO1xuICAgICAgICAgICAgICAgIGltcHVsc2UgPSB0aGlzLm1fbW90b3JJbXB1bHNlIC0gb2xkSW1wdWxzZTtcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIGltcHVsc2U7XG4gICAgICAgICAgICAgICAgd0IgKz0gaUIgKiBpbXB1bHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29sdmUgcG9pbnQgdG8gbGluZSBjb25zdHJhaW50XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIENkb3QgPSBWZWMyLmRvdCh0aGlzLm1fYXksIHZCKSAtIFZlYzIuZG90KHRoaXMubV9heSwgdkEpICsgdGhpcy5tX3NCeVxuICAgICAgICAgICAgICAgICAgICAqIHdCIC0gdGhpcy5tX3NBeSAqIHdBOyAvLyBmbG9hdFxuICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlID0gLXRoaXMubV9tYXNzICogQ2RvdDsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZSArPSBpbXB1bHNlO1xuICAgICAgICAgICAgICAgIHZhciBQID0gVmVjMi5tdWxOdW1WZWMyKGltcHVsc2UsIHRoaXMubV9heSk7IC8vIFZlYzJcbiAgICAgICAgICAgICAgICB2YXIgTEEgPSBpbXB1bHNlICogdGhpcy5tX3NBeTsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB2YXIgTEIgPSBpbXB1bHNlICogdGhpcy5tX3NCeTsgLy8gZmxvYXRcbiAgICAgICAgICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICAgICAgICAgIHdBIC09IGlBICogTEE7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIExCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudi5zZXRWZWMyKHZBKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYuc2V0VmVjMih2Qik7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZXJyb3JzIGFyZSB3aXRoaW4gdG9sZXJhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgV2hlZWxKb2ludC5wcm90b3R5cGUuc29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciBjQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIGNCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICAgICAgICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgICAgICAgICAgdmFyIHJBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTtcbiAgICAgICAgICAgIHZhciByQiA9IFJvdC5tdWxWZWMyKHFCLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKSk7XG4gICAgICAgICAgICB2YXIgZCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgZC5hZGRDb21iaW5lKDEsIGNCLCAxLCByQik7XG4gICAgICAgICAgICBkLnN1YkNvbWJpbmUoMSwgY0EsIDEsIHJBKTtcbiAgICAgICAgICAgIHZhciBheSA9IFJvdC5tdWxWZWMyKHFBLCB0aGlzLm1fbG9jYWxZQXhpc0EpO1xuICAgICAgICAgICAgdmFyIHNBeSA9IFZlYzIuY3Jvc3NWZWMyVmVjMihWZWMyLmFkZChkLCByQSksIGF5KTsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciBzQnkgPSBWZWMyLmNyb3NzVmVjMlZlYzIockIsIGF5KTsgLy8gZmxvYXRcbiAgICAgICAgICAgIHZhciBDID0gVmVjMi5kb3QoZCwgYXkpOyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIGsgPSB0aGlzLm1faW52TWFzc0EgKyB0aGlzLm1faW52TWFzc0IgKyB0aGlzLm1faW52SUEgKiB0aGlzLm1fc0F5XG4gICAgICAgICAgICAgICAgKiB0aGlzLm1fc0F5ICsgdGhpcy5tX2ludklCICogdGhpcy5tX3NCeSAqIHRoaXMubV9zQnk7IC8vIGZsb2F0XG4gICAgICAgICAgICB2YXIgaW1wdWxzZTsgLy8gZmxvYXRcbiAgICAgICAgICAgIGlmIChrICE9IDAuMCkge1xuICAgICAgICAgICAgICAgIGltcHVsc2UgPSAtQyAvIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIFAgPSBWZWMyLm11bE51bVZlYzIoaW1wdWxzZSwgYXkpOyAvLyBWZWMyXG4gICAgICAgICAgICB2YXIgTEEgPSBpbXB1bHNlICogc0F5OyAvLyBmbG9hdFxuICAgICAgICAgICAgdmFyIExCID0gaW1wdWxzZSAqIHNCeTsgLy8gZmxvYXRcbiAgICAgICAgICAgIGNBLnN1Yk11bCh0aGlzLm1faW52TWFzc0EsIFApO1xuICAgICAgICAgICAgYUEgLT0gdGhpcy5tX2ludklBICogTEE7XG4gICAgICAgICAgICBjQi5hZGRNdWwodGhpcy5tX2ludk1hc3NCLCBQKTtcbiAgICAgICAgICAgIGFCICs9IHRoaXMubV9pbnZJQiAqIExCO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYy5zZXRWZWMyKGNBKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmEgPSBhQTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmMuc2V0VmVjMihjQik7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hID0gYUI7XG4gICAgICAgICAgICByZXR1cm4gbWF0aCQxLmFicyhDKSA8PSBTZXR0aW5ncy5saW5lYXJTbG9wO1xuICAgICAgICB9O1xuICAgICAgICBXaGVlbEpvaW50LlRZUEUgPSAnd2hlZWwtam9pbnQnO1xuICAgICAgICByZXR1cm4gV2hlZWxKb2ludDtcbiAgICB9KEpvaW50KSk7XG5cbiAgICB2YXIgU0lEID0gMDtcbiAgICBmdW5jdGlvbiBTZXJpYWxpemVyKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgdmFyIHJvb3RDbGFzcyA9IG9wdHMucm9vdENsYXNzIHx8IFdvcmxkO1xuICAgICAgICB2YXIgcHJlU2VyaWFsaXplID0gb3B0cy5wcmVTZXJpYWxpemUgfHwgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqOyB9O1xuICAgICAgICB2YXIgcG9zdFNlcmlhbGl6ZSA9IG9wdHMucG9zdFNlcmlhbGl6ZSB8fCBmdW5jdGlvbiAoZGF0YSwgb2JqKSB7IHJldHVybiBkYXRhOyB9O1xuICAgICAgICB2YXIgcHJlRGVzZXJpYWxpemUgPSBvcHRzLnByZURlc2VyaWFsaXplIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhOyB9O1xuICAgICAgICB2YXIgcG9zdERlc2VyaWFsaXplID0gb3B0cy5wb3N0RGVzZXJpYWxpemUgfHwgZnVuY3Rpb24gKG9iaiwgZGF0YSkgeyByZXR1cm4gb2JqOyB9O1xuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIHJlZiBvYmplY3RzIGR1cmluZyBzZXJpYWxpemVcbiAgICAgICAgdmFyIHJlZlR5cGVzID0ge1xuICAgICAgICAgICAgV29ybGQ6IFdvcmxkLFxuICAgICAgICAgICAgQm9keTogQm9keSxcbiAgICAgICAgICAgIEpvaW50OiBKb2ludCxcbiAgICAgICAgICAgIEZpeHR1cmU6IEZpeHR1cmUsXG4gICAgICAgICAgICBTaGFwZTogU2hhcGUsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCBieSByZXN0b3JlIHRvIGRlc2VyaWFsaXplIG9iamVjdHMgYW5kIHJlZnNcbiAgICAgICAgdmFyIHJlc3RvcmVUeXBlcyA9IF9fYXNzaWduKHsgVmVjMjogVmVjMixcbiAgICAgICAgICAgIFZlYzM6IFZlYzMgfSwgcmVmVHlwZXMpO1xuICAgICAgICB2YXIgQ0xBU1NfQllfVFlQRV9QUk9QID0gKF9hID0ge30sXG4gICAgICAgICAgICBfYVtCb2R5LlNUQVRJQ10gPSBCb2R5LFxuICAgICAgICAgICAgX2FbQm9keS5EWU5BTUlDXSA9IEJvZHksXG4gICAgICAgICAgICBfYVtCb2R5LktJTkVNQVRJQ10gPSBCb2R5LFxuICAgICAgICAgICAgX2FbQ2hhaW5TaGFwZS5UWVBFXSA9IENoYWluU2hhcGUsXG4gICAgICAgICAgICBfYVtCb3hTaGFwZS5UWVBFXSA9IEJveFNoYXBlLFxuICAgICAgICAgICAgX2FbRWRnZVNoYXBlLlRZUEVdID0gRWRnZVNoYXBlLFxuICAgICAgICAgICAgX2FbUG9seWdvblNoYXBlLlRZUEVdID0gUG9seWdvblNoYXBlLFxuICAgICAgICAgICAgX2FbQ2lyY2xlU2hhcGUuVFlQRV0gPSBDaXJjbGVTaGFwZSxcbiAgICAgICAgICAgIF9hW0Rpc3RhbmNlSm9pbnQuVFlQRV0gPSBEaXN0YW5jZUpvaW50LFxuICAgICAgICAgICAgX2FbRnJpY3Rpb25Kb2ludC5UWVBFXSA9IEZyaWN0aW9uSm9pbnQsXG4gICAgICAgICAgICBfYVtHZWFySm9pbnQuVFlQRV0gPSBHZWFySm9pbnQsXG4gICAgICAgICAgICBfYVtNb3RvckpvaW50LlRZUEVdID0gTW90b3JKb2ludCxcbiAgICAgICAgICAgIF9hW01vdXNlSm9pbnQuVFlQRV0gPSBNb3VzZUpvaW50LFxuICAgICAgICAgICAgX2FbUHJpc21hdGljSm9pbnQuVFlQRV0gPSBQcmlzbWF0aWNKb2ludCxcbiAgICAgICAgICAgIF9hW1B1bGxleUpvaW50LlRZUEVdID0gUHVsbGV5Sm9pbnQsXG4gICAgICAgICAgICBfYVtSZXZvbHV0ZUpvaW50LlRZUEVdID0gUmV2b2x1dGVKb2ludCxcbiAgICAgICAgICAgIF9hW1JvcGVKb2ludC5UWVBFXSA9IFJvcGVKb2ludCxcbiAgICAgICAgICAgIF9hW1dlbGRKb2ludC5UWVBFXSA9IFdlbGRKb2ludCxcbiAgICAgICAgICAgIF9hW1doZWVsSm9pbnQuVFlQRV0gPSBXaGVlbEpvaW50LFxuICAgICAgICAgICAgX2EpO1xuICAgICAgICB0aGlzLnRvSnNvbiA9IGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgICAgICB2YXIganNvbiA9IFtdO1xuICAgICAgICAgICAgdmFyIHF1ZXVlID0gW3Jvb3RdO1xuICAgICAgICAgICAgdmFyIHJlZk1hcCA9IHt9O1xuICAgICAgICAgICAgZnVuY3Rpb24gc3RvcmVSZWYodmFsdWUsIHR5cGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuX19zaWQgPSB2YWx1ZS5fX3NpZCB8fCArK1NJRDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZk1hcFt2YWx1ZS5fX3NpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGpzb24ubGVuZ3RoICsgcXVldWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmVHlwZTogdHlwZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVmTWFwW3ZhbHVlLl9fc2lkXSA9IHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZk1hcFt2YWx1ZS5fX3NpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gcHJlU2VyaWFsaXplKG9iaik7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBvYmouX3NlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBwb3N0U2VyaWFsaXplKGRhdGEsIG9iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB0b0pzb24odmFsdWUsIHRvcCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS5fc2VyaWFsaXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZm9yLWluXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0eXBlTmFtZSBpbiByZWZUeXBlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIHJlZlR5cGVzW3R5cGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmVSZWYodmFsdWUsIHR5cGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZXJpYWxpemUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSA9IDA7IGtleSA8IHZhbHVlLmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlW2tleV0gPSB0b0pzb24odmFsdWVba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZm9yLWluXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVtrZXldID0gdG9Kc29uKHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyID0gdG9Kc29uKG9iaiwgb2JqKTtcbiAgICAgICAgICAgICAgICBqc29uLnB1c2goc3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZyb21Kc29uID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgICAgIHZhciByZWZNYXAgPSB7fTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmREZXNlcmlsaXplcihkYXRhLCBjbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNscyB8fCAhY2xzLl9kZXNlcmlhbGl6ZSkge1xuICAgICAgICAgICAgICAgICAgICBjbHMgPSBDTEFTU19CWV9UWVBFX1BST1BbZGF0YS50eXBlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNscyAmJiBjbHMuX2Rlc2VyaWFsaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZXNlcmlhbGl6ZSBhIGRhdGEgb2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBkZXNlcmlhbGl6ZShjbHMsIGRhdGEsIGN0eCkge1xuICAgICAgICAgICAgICAgIHZhciBkZXNlcmlhbGl6ZXIgPSBmaW5kRGVzZXJpbGl6ZXIoZGF0YSwgY2xzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlc2VyaWFsaXplcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEgPSBwcmVEZXNlcmlhbGl6ZShkYXRhKTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gZGVzZXJpYWxpemVyKGRhdGEsIGN0eCwgcmVzdG9yZVJlZik7XG4gICAgICAgICAgICAgICAgb2JqID0gcG9zdERlc2VyaWFsaXplKG9iaiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVzdG9yZSBhIHJlZiBvYmplY3Qgb3IgZGVzZXJpYWxpemUgYSBkYXRhIG9iamVjdC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGlzIGlzIHBhc3NlZCBhcyBjYWxsYmFjayB0byBjbGFzcyBkZXNlcmlhbGl6ZXJzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiByZXN0b3JlUmVmKGNscywgcmVmLCBjdHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZi5yZWZJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xzICYmIGNscy5fZGVzZXJpYWxpemUgJiYgZGVzZXJpYWxpemUoY2xzLCByZWYsIGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNscyA9IHJlc3RvcmVUeXBlc1tyZWYucmVmVHlwZV0gfHwgY2xzO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHJlZi5yZWZJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZk1hcFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBqc29uW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IGRlc2VyaWFsaXplKGNscywgZGF0YSwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgcmVmTWFwW2luZGV4XSA9IG9iajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZk1hcFtpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHJvb3RDbGFzcy5fZGVzZXJpYWxpemUoanNvblswXSwgbnVsbCwgcmVzdG9yZVJlZik7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHNlcmlhbGl6ZXIgPSBuZXcgU2VyaWFsaXplcigpO1xuICAgIFNlcmlhbGl6ZXIudG9Kc29uID0gc2VyaWFsaXplci50b0pzb247XG4gICAgU2VyaWFsaXplci5mcm9tSnNvbiA9IHNlcmlhbGl6ZXIuZnJvbUpzb247XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgQ29udGFjdC5hZGRUeXBlKENpcmNsZVNoYXBlLlRZUEUsIENpcmNsZVNoYXBlLlRZUEUsIENpcmNsZUNpcmNsZUNvbnRhY3QpO1xuICAgIGZ1bmN0aW9uIENpcmNsZUNpcmNsZUNvbnRhY3QobWFuaWZvbGQsIHhmQSwgZml4dHVyZUEsIGluZGV4QSwgeGZCLCBmaXh0dXJlQiwgaW5kZXhCKSB7XG4gICAgICAgIENvbGxpZGVDaXJjbGVzKG1hbmlmb2xkLCBmaXh0dXJlQS5nZXRTaGFwZSgpLCB4ZkEsIGZpeHR1cmVCLmdldFNoYXBlKCksIHhmQik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENvbGxpZGVDaXJjbGVzKG1hbmlmb2xkLCBjaXJjbGVBLCB4ZkEsIGNpcmNsZUIsIHhmQikge1xuICAgICAgICBtYW5pZm9sZC5wb2ludENvdW50ID0gMDtcbiAgICAgICAgdmFyIHBBID0gVHJhbnNmb3JtLm11bFZlYzIoeGZBLCBjaXJjbGVBLm1fcCk7XG4gICAgICAgIHZhciBwQiA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQiwgY2lyY2xlQi5tX3ApO1xuICAgICAgICB2YXIgZGlzdFNxciA9IFZlYzIuZGlzdGFuY2VTcXVhcmVkKHBCLCBwQSk7XG4gICAgICAgIHZhciByQSA9IGNpcmNsZUEubV9yYWRpdXM7XG4gICAgICAgIHZhciByQiA9IGNpcmNsZUIubV9yYWRpdXM7XG4gICAgICAgIHZhciByYWRpdXMgPSByQSArIHJCO1xuICAgICAgICBpZiAoZGlzdFNxciA+IHJhZGl1cyAqIHJhZGl1cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1hbmlmb2xkLnR5cGUgPSBNYW5pZm9sZFR5cGUuZV9jaXJjbGVzO1xuICAgICAgICBtYW5pZm9sZC5sb2NhbFBvaW50LnNldFZlYzIoY2lyY2xlQS5tX3ApO1xuICAgICAgICBtYW5pZm9sZC5sb2NhbE5vcm1hbC5zZXRaZXJvKCk7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50Q291bnQgPSAxO1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0ubG9jYWxQb2ludC5zZXRWZWMyKGNpcmNsZUIubV9wKTtcbiAgICAgICAgLy8gbWFuaWZvbGQucG9pbnRzWzBdLmlkLmtleSA9IDA7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi5pbmRleEEgPSAwO1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YudHlwZUEgPSBDb250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXg7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi5pbmRleEIgPSAwO1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YudHlwZUIgPSBDb250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXg7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIENvbnRhY3QuYWRkVHlwZShFZGdlU2hhcGUuVFlQRSwgQ2lyY2xlU2hhcGUuVFlQRSwgRWRnZUNpcmNsZUNvbnRhY3QpO1xuICAgIENvbnRhY3QuYWRkVHlwZShDaGFpblNoYXBlLlRZUEUsIENpcmNsZVNoYXBlLlRZUEUsIENoYWluQ2lyY2xlQ29udGFjdCk7XG4gICAgZnVuY3Rpb24gRWRnZUNpcmNsZUNvbnRhY3QobWFuaWZvbGQsIHhmQSwgZml4dHVyZUEsIGluZGV4QSwgeGZCLCBmaXh0dXJlQiwgaW5kZXhCKSB7XG4gICAgICAgIHZhciBzaGFwZUEgPSBmaXh0dXJlQS5nZXRTaGFwZSgpO1xuICAgICAgICB2YXIgc2hhcGVCID0gZml4dHVyZUIuZ2V0U2hhcGUoKTtcbiAgICAgICAgQ29sbGlkZUVkZ2VDaXJjbGUobWFuaWZvbGQsIHNoYXBlQSwgeGZBLCBzaGFwZUIsIHhmQik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENoYWluQ2lyY2xlQ29udGFjdChtYW5pZm9sZCwgeGZBLCBmaXh0dXJlQSwgaW5kZXhBLCB4ZkIsIGZpeHR1cmVCLCBpbmRleEIpIHtcbiAgICAgICAgdmFyIGNoYWluID0gZml4dHVyZUEuZ2V0U2hhcGUoKTtcbiAgICAgICAgdmFyIGVkZ2UgPSBuZXcgRWRnZVNoYXBlKCk7XG4gICAgICAgIGNoYWluLmdldENoaWxkRWRnZShlZGdlLCBpbmRleEEpO1xuICAgICAgICB2YXIgc2hhcGVBID0gZWRnZTtcbiAgICAgICAgdmFyIHNoYXBlQiA9IGZpeHR1cmVCLmdldFNoYXBlKCk7XG4gICAgICAgIENvbGxpZGVFZGdlQ2lyY2xlKG1hbmlmb2xkLCBzaGFwZUEsIHhmQSwgc2hhcGVCLCB4ZkIpO1xuICAgIH1cbiAgICAvLyBDb21wdXRlIGNvbnRhY3QgcG9pbnRzIGZvciBlZGdlIHZlcnN1cyBjaXJjbGUuXG4gICAgLy8gVGhpcyBhY2NvdW50cyBmb3IgZWRnZSBjb25uZWN0aXZpdHkuXG4gICAgZnVuY3Rpb24gQ29sbGlkZUVkZ2VDaXJjbGUobWFuaWZvbGQsIGVkZ2VBLCB4ZkEsIGNpcmNsZUIsIHhmQikge1xuICAgICAgICBtYW5pZm9sZC5wb2ludENvdW50ID0gMDtcbiAgICAgICAgLy8gQ29tcHV0ZSBjaXJjbGUgaW4gZnJhbWUgb2YgZWRnZVxuICAgICAgICB2YXIgUSA9IFRyYW5zZm9ybS5tdWxUVmVjMih4ZkEsIFRyYW5zZm9ybS5tdWxWZWMyKHhmQiwgY2lyY2xlQi5tX3ApKTtcbiAgICAgICAgdmFyIEEgPSBlZGdlQS5tX3ZlcnRleDE7XG4gICAgICAgIHZhciBCID0gZWRnZUEubV92ZXJ0ZXgyO1xuICAgICAgICB2YXIgZSA9IFZlYzIuc3ViKEIsIEEpO1xuICAgICAgICAvLyBCYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xuICAgICAgICB2YXIgdSA9IFZlYzIuZG90KGUsIFZlYzIuc3ViKEIsIFEpKTtcbiAgICAgICAgdmFyIHYgPSBWZWMyLmRvdChlLCBWZWMyLnN1YihRLCBBKSk7XG4gICAgICAgIHZhciByYWRpdXMgPSBlZGdlQS5tX3JhZGl1cyArIGNpcmNsZUIubV9yYWRpdXM7XG4gICAgICAgIC8vIFJlZ2lvbiBBXG4gICAgICAgIGlmICh2IDw9IDAuMCkge1xuICAgICAgICAgICAgdmFyIFBfMSA9IFZlYzIuY2xvbmUoQSk7XG4gICAgICAgICAgICB2YXIgZF8xID0gVmVjMi5zdWIoUSwgUF8xKTtcbiAgICAgICAgICAgIHZhciBkZF8xID0gVmVjMi5kb3QoZF8xLCBkXzEpO1xuICAgICAgICAgICAgaWYgKGRkXzEgPiByYWRpdXMgKiByYWRpdXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJcyB0aGVyZSBhbiBlZGdlIGNvbm5lY3RlZCB0byBBP1xuICAgICAgICAgICAgaWYgKGVkZ2VBLm1faGFzVmVydGV4MCkge1xuICAgICAgICAgICAgICAgIHZhciBBMSA9IGVkZ2VBLm1fdmVydGV4MDtcbiAgICAgICAgICAgICAgICB2YXIgQjEgPSBBO1xuICAgICAgICAgICAgICAgIHZhciBlMSA9IFZlYzIuc3ViKEIxLCBBMSk7XG4gICAgICAgICAgICAgICAgdmFyIHUxID0gVmVjMi5kb3QoZTEsIFZlYzIuc3ViKEIxLCBRKSk7XG4gICAgICAgICAgICAgICAgLy8gSXMgdGhlIGNpcmNsZSBpbiBSZWdpb24gQUIgb2YgdGhlIHByZXZpb3VzIGVkZ2U/XG4gICAgICAgICAgICAgICAgaWYgKHUxID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYW5pZm9sZC50eXBlID0gTWFuaWZvbGRUeXBlLmVfY2lyY2xlcztcbiAgICAgICAgICAgIG1hbmlmb2xkLmxvY2FsTm9ybWFsLnNldFplcm8oKTtcbiAgICAgICAgICAgIG1hbmlmb2xkLmxvY2FsUG9pbnQuc2V0VmVjMihQXzEpO1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDE7XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0ubG9jYWxQb2ludC5zZXRWZWMyKGNpcmNsZUIubV9wKTtcbiAgICAgICAgICAgIC8vIG1hbmlmb2xkLnBvaW50c1swXS5pZC5rZXkgPSAwO1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLmluZGV4QSA9IDA7XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YudHlwZUEgPSBDb250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXg7XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YuaW5kZXhCID0gMDtcbiAgICAgICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi50eXBlQiA9IENvbnRhY3RGZWF0dXJlVHlwZS5lX3ZlcnRleDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWdpb24gQlxuICAgICAgICBpZiAodSA8PSAwLjApIHtcbiAgICAgICAgICAgIHZhciBQXzIgPSBWZWMyLmNsb25lKEIpO1xuICAgICAgICAgICAgdmFyIGRfMiA9IFZlYzIuc3ViKFEsIFBfMik7XG4gICAgICAgICAgICB2YXIgZGRfMiA9IFZlYzIuZG90KGRfMiwgZF8yKTtcbiAgICAgICAgICAgIGlmIChkZF8yID4gcmFkaXVzICogcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSXMgdGhlcmUgYW4gZWRnZSBjb25uZWN0ZWQgdG8gQj9cbiAgICAgICAgICAgIGlmIChlZGdlQS5tX2hhc1ZlcnRleDMpIHtcbiAgICAgICAgICAgICAgICB2YXIgQjIgPSBlZGdlQS5tX3ZlcnRleDM7XG4gICAgICAgICAgICAgICAgdmFyIEEyID0gQjtcbiAgICAgICAgICAgICAgICB2YXIgZTIgPSBWZWMyLnN1YihCMiwgQTIpO1xuICAgICAgICAgICAgICAgIHZhciB2MiA9IFZlYzIuZG90KGUyLCBWZWMyLnN1YihRLCBBMikpO1xuICAgICAgICAgICAgICAgIC8vIElzIHRoZSBjaXJjbGUgaW4gUmVnaW9uIEFCIG9mIHRoZSBuZXh0IGVkZ2U/XG4gICAgICAgICAgICAgICAgaWYgKHYyID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYW5pZm9sZC50eXBlID0gTWFuaWZvbGRUeXBlLmVfY2lyY2xlcztcbiAgICAgICAgICAgIG1hbmlmb2xkLmxvY2FsTm9ybWFsLnNldFplcm8oKTtcbiAgICAgICAgICAgIG1hbmlmb2xkLmxvY2FsUG9pbnQuc2V0VmVjMihQXzIpO1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDE7XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0ubG9jYWxQb2ludC5zZXRWZWMyKGNpcmNsZUIubV9wKTtcbiAgICAgICAgICAgIC8vIG1hbmlmb2xkLnBvaW50c1swXS5pZC5rZXkgPSAwO1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLmluZGV4QSA9IDE7XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YudHlwZUEgPSBDb250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXg7XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YuaW5kZXhCID0gMDtcbiAgICAgICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi50eXBlQiA9IENvbnRhY3RGZWF0dXJlVHlwZS5lX3ZlcnRleDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWdpb24gQUJcbiAgICAgICAgdmFyIGRlbiA9IFZlYzIuZG90KGUsIGUpO1xuICAgICAgICB2YXIgUCA9IFZlYzIuY29tYmluZSh1IC8gZGVuLCBBLCB2IC8gZGVuLCBCKTtcbiAgICAgICAgdmFyIGQgPSBWZWMyLnN1YihRLCBQKTtcbiAgICAgICAgdmFyIGRkID0gVmVjMi5kb3QoZCwgZCk7XG4gICAgICAgIGlmIChkZCA+IHJhZGl1cyAqIHJhZGl1cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuID0gVmVjMi5uZW8oLWUueSwgZS54KTtcbiAgICAgICAgaWYgKFZlYzIuZG90KG4sIFZlYzIuc3ViKFEsIEEpKSA8IDAuMCkge1xuICAgICAgICAgICAgbi5zZXROdW0oLW4ueCwgLW4ueSk7XG4gICAgICAgIH1cbiAgICAgICAgbi5ub3JtYWxpemUoKTtcbiAgICAgICAgbWFuaWZvbGQudHlwZSA9IE1hbmlmb2xkVHlwZS5lX2ZhY2VBO1xuICAgICAgICBtYW5pZm9sZC5sb2NhbE5vcm1hbCA9IG47XG4gICAgICAgIG1hbmlmb2xkLmxvY2FsUG9pbnQuc2V0VmVjMihBKTtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDE7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5sb2NhbFBvaW50LnNldFZlYzIoY2lyY2xlQi5tX3ApO1xuICAgICAgICAvLyBtYW5pZm9sZC5wb2ludHNbMF0uaWQua2V5ID0gMDtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLmluZGV4QSA9IDA7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi50eXBlQSA9IENvbnRhY3RGZWF0dXJlVHlwZS5lX2ZhY2U7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi5pbmRleEIgPSAwO1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YudHlwZUIgPSBDb250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXg7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIENvbnRhY3QuYWRkVHlwZShQb2x5Z29uU2hhcGUuVFlQRSwgUG9seWdvblNoYXBlLlRZUEUsIFBvbHlnb25Db250YWN0KTtcbiAgICBmdW5jdGlvbiBQb2x5Z29uQ29udGFjdChtYW5pZm9sZCwgeGZBLCBmaXh0dXJlQSwgaW5kZXhBLCB4ZkIsIGZpeHR1cmVCLCBpbmRleEIpIHtcbiAgICAgICAgQ29sbGlkZVBvbHlnb25zKG1hbmlmb2xkLCBmaXh0dXJlQS5nZXRTaGFwZSgpLCB4ZkEsIGZpeHR1cmVCLmdldFNoYXBlKCksIHhmQik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIG1heCBzZXBhcmF0aW9uIGJldHdlZW4gcG9seTEgYW5kIHBvbHkyIHVzaW5nIGVkZ2Ugbm9ybWFscyBmcm9tXG4gICAgICogcG9seTEuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZE1heFNlcGFyYXRpb24ocG9seTEsIHhmMSwgcG9seTIsIHhmMiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBjb3VudDEgPSBwb2x5MS5tX2NvdW50O1xuICAgICAgICB2YXIgY291bnQyID0gcG9seTIubV9jb3VudDtcbiAgICAgICAgdmFyIG4xcyA9IHBvbHkxLm1fbm9ybWFscztcbiAgICAgICAgdmFyIHYxcyA9IHBvbHkxLm1fdmVydGljZXM7XG4gICAgICAgIHZhciB2MnMgPSBwb2x5Mi5tX3ZlcnRpY2VzO1xuICAgICAgICB2YXIgeGYgPSBUcmFuc2Zvcm0ubXVsVFhmKHhmMiwgeGYxKTtcbiAgICAgICAgdmFyIGJlc3RJbmRleCA9IDA7XG4gICAgICAgIHZhciBtYXhTZXBhcmF0aW9uID0gLUluZmluaXR5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50MTsgKytpKSB7XG4gICAgICAgICAgICAvLyBHZXQgcG9seTEgbm9ybWFsIGluIGZyYW1lMi5cbiAgICAgICAgICAgIHZhciBuID0gUm90Lm11bFZlYzIoeGYucSwgbjFzW2ldKTtcbiAgICAgICAgICAgIHZhciB2MSA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmLCB2MXNbaV0pO1xuICAgICAgICAgICAgLy8gRmluZCBkZWVwZXN0IHBvaW50IGZvciBub3JtYWwgaS5cbiAgICAgICAgICAgIHZhciBzaSA9IEluZmluaXR5O1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDI7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciBzaWogPSBWZWMyLmRvdChuLCB2MnNbal0pIC0gVmVjMi5kb3QobiwgdjEpO1xuICAgICAgICAgICAgICAgIGlmIChzaWogPCBzaSkge1xuICAgICAgICAgICAgICAgICAgICBzaSA9IHNpajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2kgPiBtYXhTZXBhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgbWF4U2VwYXJhdGlvbiA9IHNpO1xuICAgICAgICAgICAgICAgIGJlc3RJbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXNlZCB0byBrZWVwIGxhc3QgRmluZE1heFNlcGFyYXRpb24gY2FsbCB2YWx1ZXNcbiAgICAgICAgb3V0cHV0Lm1heFNlcGFyYXRpb24gPSBtYXhTZXBhcmF0aW9uO1xuICAgICAgICBvdXRwdXQuYmVzdEluZGV4ID0gYmVzdEluZGV4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kSW5jaWRlbnRFZGdlKGMsIHBvbHkxLCB4ZjEsIGVkZ2UxLCBwb2x5MiwgeGYyKSB7XG4gICAgICAgIHZhciBub3JtYWxzMSA9IHBvbHkxLm1fbm9ybWFscztcbiAgICAgICAgdmFyIGNvdW50MiA9IHBvbHkyLm1fY291bnQ7XG4gICAgICAgIHZhciB2ZXJ0aWNlczIgPSBwb2x5Mi5tX3ZlcnRpY2VzO1xuICAgICAgICB2YXIgbm9ybWFsczIgPSBwb2x5Mi5tX25vcm1hbHM7XG4gICAgICAgIC8vIEdldCB0aGUgbm9ybWFsIG9mIHRoZSByZWZlcmVuY2UgZWRnZSBpbiBwb2x5MidzIGZyYW1lLlxuICAgICAgICB2YXIgbm9ybWFsMSA9IFJvdC5tdWxUVmVjMih4ZjIucSwgUm90Lm11bFZlYzIoeGYxLnEsIG5vcm1hbHMxW2VkZ2UxXSkpO1xuICAgICAgICAvLyBGaW5kIHRoZSBpbmNpZGVudCBlZGdlIG9uIHBvbHkyLlxuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgbWluRG90ID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQyOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBkb3QgPSBWZWMyLmRvdChub3JtYWwxLCBub3JtYWxzMltpXSk7XG4gICAgICAgICAgICBpZiAoZG90IDwgbWluRG90KSB7XG4gICAgICAgICAgICAgICAgbWluRG90ID0gZG90O1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB0aGUgY2xpcCB2ZXJ0aWNlcyBmb3IgdGhlIGluY2lkZW50IGVkZ2UuXG4gICAgICAgIHZhciBpMSA9IGluZGV4O1xuICAgICAgICB2YXIgaTIgPSBpMSArIDEgPCBjb3VudDIgPyBpMSArIDEgOiAwO1xuICAgICAgICBjWzBdLnYgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZjIsIHZlcnRpY2VzMltpMV0pO1xuICAgICAgICBjWzBdLmlkLmNmLmluZGV4QSA9IGVkZ2UxO1xuICAgICAgICBjWzBdLmlkLmNmLmluZGV4QiA9IGkxO1xuICAgICAgICBjWzBdLmlkLmNmLnR5cGVBID0gQ29udGFjdEZlYXR1cmVUeXBlLmVfZmFjZTtcbiAgICAgICAgY1swXS5pZC5jZi50eXBlQiA9IENvbnRhY3RGZWF0dXJlVHlwZS5lX3ZlcnRleDtcbiAgICAgICAgY1sxXS52ID0gVHJhbnNmb3JtLm11bFZlYzIoeGYyLCB2ZXJ0aWNlczJbaTJdKTtcbiAgICAgICAgY1sxXS5pZC5jZi5pbmRleEEgPSBlZGdlMTtcbiAgICAgICAgY1sxXS5pZC5jZi5pbmRleEIgPSBpMjtcbiAgICAgICAgY1sxXS5pZC5jZi50eXBlQSA9IENvbnRhY3RGZWF0dXJlVHlwZS5lX2ZhY2U7XG4gICAgICAgIGNbMV0uaWQuY2YudHlwZUIgPSBDb250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXg7XG4gICAgfVxuICAgIHZhciBtYXhTZXBhcmF0aW9uID0ge1xuICAgICAgICBtYXhTZXBhcmF0aW9uOiAwLFxuICAgICAgICBiZXN0SW5kZXg6IDAsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZpbmQgZWRnZSBub3JtYWwgb2YgbWF4IHNlcGFyYXRpb24gb24gQSAtIHJldHVybiBpZiBzZXBhcmF0aW5nIGF4aXMgaXMgZm91bmQ8YnI+XG4gICAgICogRmluZCBlZGdlIG5vcm1hbCBvZiBtYXggc2VwYXJhdGlvbiBvbiBCIC0gcmV0dXJuIGlmIHNlcGFyYXRpb24gYXhpcyBpcyBmb3VuZDxicj5cbiAgICAgKiBDaG9vc2UgcmVmZXJlbmNlIGVkZ2UgYXMgbWluKG1pbkEsIG1pbkIpPGJyPlxuICAgICAqIEZpbmQgaW5jaWRlbnQgZWRnZTxicj5cbiAgICAgKiBDbGlwXG4gICAgICpcbiAgICAgKiBUaGUgbm9ybWFsIHBvaW50cyBmcm9tIDEgdG8gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbGxpZGVQb2x5Z29ucyhtYW5pZm9sZCwgcG9seUEsIHhmQSwgcG9seUIsIHhmQikge1xuICAgICAgICBtYW5pZm9sZC5wb2ludENvdW50ID0gMDtcbiAgICAgICAgdmFyIHRvdGFsUmFkaXVzID0gcG9seUEubV9yYWRpdXMgKyBwb2x5Qi5tX3JhZGl1cztcbiAgICAgICAgZmluZE1heFNlcGFyYXRpb24ocG9seUEsIHhmQSwgcG9seUIsIHhmQiwgbWF4U2VwYXJhdGlvbik7XG4gICAgICAgIHZhciBlZGdlQSA9IG1heFNlcGFyYXRpb24uYmVzdEluZGV4O1xuICAgICAgICB2YXIgc2VwYXJhdGlvbkEgPSBtYXhTZXBhcmF0aW9uLm1heFNlcGFyYXRpb247XG4gICAgICAgIGlmIChzZXBhcmF0aW9uQSA+IHRvdGFsUmFkaXVzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmaW5kTWF4U2VwYXJhdGlvbihwb2x5QiwgeGZCLCBwb2x5QSwgeGZBLCBtYXhTZXBhcmF0aW9uKTtcbiAgICAgICAgdmFyIGVkZ2VCID0gbWF4U2VwYXJhdGlvbi5iZXN0SW5kZXg7XG4gICAgICAgIHZhciBzZXBhcmF0aW9uQiA9IG1heFNlcGFyYXRpb24ubWF4U2VwYXJhdGlvbjtcbiAgICAgICAgaWYgKHNlcGFyYXRpb25CID4gdG90YWxSYWRpdXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBwb2x5MTsgLy8gcmVmZXJlbmNlIHBvbHlnb25cbiAgICAgICAgdmFyIHBvbHkyOyAvLyBpbmNpZGVudCBwb2x5Z29uXG4gICAgICAgIHZhciB4ZjE7XG4gICAgICAgIHZhciB4ZjI7XG4gICAgICAgIHZhciBlZGdlMTsgLy8gcmVmZXJlbmNlIGVkZ2VcbiAgICAgICAgdmFyIGZsaXA7XG4gICAgICAgIHZhciBrX3RvbCA9IDAuMSAqIFNldHRpbmdzLmxpbmVhclNsb3A7XG4gICAgICAgIGlmIChzZXBhcmF0aW9uQiA+IHNlcGFyYXRpb25BICsga190b2wpIHtcbiAgICAgICAgICAgIHBvbHkxID0gcG9seUI7XG4gICAgICAgICAgICBwb2x5MiA9IHBvbHlBO1xuICAgICAgICAgICAgeGYxID0geGZCO1xuICAgICAgICAgICAgeGYyID0geGZBO1xuICAgICAgICAgICAgZWRnZTEgPSBlZGdlQjtcbiAgICAgICAgICAgIG1hbmlmb2xkLnR5cGUgPSBNYW5pZm9sZFR5cGUuZV9mYWNlQjtcbiAgICAgICAgICAgIGZsaXAgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9seTEgPSBwb2x5QTtcbiAgICAgICAgICAgIHBvbHkyID0gcG9seUI7XG4gICAgICAgICAgICB4ZjEgPSB4ZkE7XG4gICAgICAgICAgICB4ZjIgPSB4ZkI7XG4gICAgICAgICAgICBlZGdlMSA9IGVkZ2VBO1xuICAgICAgICAgICAgbWFuaWZvbGQudHlwZSA9IE1hbmlmb2xkVHlwZS5lX2ZhY2VBO1xuICAgICAgICAgICAgZmxpcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluY2lkZW50RWRnZSA9IFtuZXcgQ2xpcFZlcnRleCgpLCBuZXcgQ2xpcFZlcnRleCgpXTtcbiAgICAgICAgZmluZEluY2lkZW50RWRnZShpbmNpZGVudEVkZ2UsIHBvbHkxLCB4ZjEsIGVkZ2UxLCBwb2x5MiwgeGYyKTtcbiAgICAgICAgdmFyIGNvdW50MSA9IHBvbHkxLm1fY291bnQ7XG4gICAgICAgIHZhciB2ZXJ0aWNlczEgPSBwb2x5MS5tX3ZlcnRpY2VzO1xuICAgICAgICB2YXIgaXYxID0gZWRnZTE7XG4gICAgICAgIHZhciBpdjIgPSBlZGdlMSArIDEgPCBjb3VudDEgPyBlZGdlMSArIDEgOiAwO1xuICAgICAgICB2YXIgdjExID0gdmVydGljZXMxW2l2MV07XG4gICAgICAgIHZhciB2MTIgPSB2ZXJ0aWNlczFbaXYyXTtcbiAgICAgICAgdmFyIGxvY2FsVGFuZ2VudCA9IFZlYzIuc3ViKHYxMiwgdjExKTtcbiAgICAgICAgbG9jYWxUYW5nZW50Lm5vcm1hbGl6ZSgpO1xuICAgICAgICB2YXIgbG9jYWxOb3JtYWwgPSBWZWMyLmNyb3NzVmVjMk51bShsb2NhbFRhbmdlbnQsIDEuMCk7XG4gICAgICAgIHZhciBwbGFuZVBvaW50ID0gVmVjMi5jb21iaW5lKDAuNSwgdjExLCAwLjUsIHYxMik7XG4gICAgICAgIHZhciB0YW5nZW50ID0gUm90Lm11bFZlYzIoeGYxLnEsIGxvY2FsVGFuZ2VudCk7XG4gICAgICAgIHZhciBub3JtYWwgPSBWZWMyLmNyb3NzVmVjMk51bSh0YW5nZW50LCAxLjApO1xuICAgICAgICB2MTEgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZjEsIHYxMSk7XG4gICAgICAgIHYxMiA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmMSwgdjEyKTtcbiAgICAgICAgLy8gRmFjZSBvZmZzZXQuXG4gICAgICAgIHZhciBmcm9udE9mZnNldCA9IFZlYzIuZG90KG5vcm1hbCwgdjExKTtcbiAgICAgICAgLy8gU2lkZSBvZmZzZXRzLCBleHRlbmRlZCBieSBwb2x5dG9wZSBza2luIHRoaWNrbmVzcy5cbiAgICAgICAgdmFyIHNpZGVPZmZzZXQxID0gLVZlYzIuZG90KHRhbmdlbnQsIHYxMSkgKyB0b3RhbFJhZGl1cztcbiAgICAgICAgdmFyIHNpZGVPZmZzZXQyID0gVmVjMi5kb3QodGFuZ2VudCwgdjEyKSArIHRvdGFsUmFkaXVzO1xuICAgICAgICAvLyBDbGlwIGluY2lkZW50IGVkZ2UgYWdhaW5zdCBleHRydWRlZCBlZGdlMSBzaWRlIGVkZ2VzLlxuICAgICAgICB2YXIgY2xpcFBvaW50czEgPSBbbmV3IENsaXBWZXJ0ZXgoKSwgbmV3IENsaXBWZXJ0ZXgoKV07XG4gICAgICAgIHZhciBjbGlwUG9pbnRzMiA9IFtuZXcgQ2xpcFZlcnRleCgpLCBuZXcgQ2xpcFZlcnRleCgpXTtcbiAgICAgICAgdmFyIG5wO1xuICAgICAgICAvLyBDbGlwIHRvIGJveCBzaWRlIDFcbiAgICAgICAgbnAgPSBjbGlwU2VnbWVudFRvTGluZShjbGlwUG9pbnRzMSwgaW5jaWRlbnRFZGdlLCBWZWMyLm5lZyh0YW5nZW50KSwgc2lkZU9mZnNldDEsIGl2MSk7XG4gICAgICAgIGlmIChucCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGlwIHRvIG5lZ2F0aXZlIGJveCBzaWRlIDFcbiAgICAgICAgbnAgPSBjbGlwU2VnbWVudFRvTGluZShjbGlwUG9pbnRzMiwgY2xpcFBvaW50czEsIHRhbmdlbnQsIHNpZGVPZmZzZXQyLCBpdjIpO1xuICAgICAgICBpZiAobnAgPCAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IGNsaXBQb2ludHMyIGNvbnRhaW5zIHRoZSBjbGlwcGVkIHBvaW50cy5cbiAgICAgICAgbWFuaWZvbGQubG9jYWxOb3JtYWwgPSBsb2NhbE5vcm1hbDtcbiAgICAgICAgbWFuaWZvbGQubG9jYWxQb2ludCA9IHBsYW5lUG9pbnQ7XG4gICAgICAgIHZhciBwb2ludENvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUG9pbnRzMi5sZW5ndGggLyogbWF4TWFuaWZvbGRQb2ludHMgKi87ICsraSkge1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRpb24gPSBWZWMyLmRvdChub3JtYWwsIGNsaXBQb2ludHMyW2ldLnYpIC0gZnJvbnRPZmZzZXQ7XG4gICAgICAgICAgICBpZiAoc2VwYXJhdGlvbiA8PSB0b3RhbFJhZGl1cykge1xuICAgICAgICAgICAgICAgIHZhciBjcCA9IG1hbmlmb2xkLnBvaW50c1twb2ludENvdW50XTtcbiAgICAgICAgICAgICAgICBjcC5sb2NhbFBvaW50LnNldFZlYzIoVHJhbnNmb3JtLm11bFRWZWMyKHhmMiwgY2xpcFBvaW50czJbaV0udikpO1xuICAgICAgICAgICAgICAgIGNwLmlkID0gY2xpcFBvaW50czJbaV0uaWQ7XG4gICAgICAgICAgICAgICAgaWYgKGZsaXApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3dhcCBmZWF0dXJlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2YgPSBjcC5pZC5jZjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4QSA9IGNmLmluZGV4QTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4QiA9IGNmLmluZGV4QjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVBID0gY2YudHlwZUE7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlQiA9IGNmLnR5cGVCO1xuICAgICAgICAgICAgICAgICAgICBjZi5pbmRleEEgPSBpbmRleEI7XG4gICAgICAgICAgICAgICAgICAgIGNmLmluZGV4QiA9IGluZGV4QTtcbiAgICAgICAgICAgICAgICAgICAgY2YudHlwZUEgPSB0eXBlQjtcbiAgICAgICAgICAgICAgICAgICAgY2YudHlwZUIgPSB0eXBlQTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytwb2ludENvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1hbmlmb2xkLnBvaW50Q291bnQgPSBwb2ludENvdW50O1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICBDb250YWN0LmFkZFR5cGUoUG9seWdvblNoYXBlLlRZUEUsIENpcmNsZVNoYXBlLlRZUEUsIFBvbHlnb25DaXJjbGVDb250YWN0KTtcbiAgICBmdW5jdGlvbiBQb2x5Z29uQ2lyY2xlQ29udGFjdChtYW5pZm9sZCwgeGZBLCBmaXh0dXJlQSwgaW5kZXhBLCB4ZkIsIGZpeHR1cmVCLCBpbmRleEIpIHtcbiAgICAgICAgQ29sbGlkZVBvbHlnb25DaXJjbGUobWFuaWZvbGQsIGZpeHR1cmVBLmdldFNoYXBlKCksIHhmQSwgZml4dHVyZUIuZ2V0U2hhcGUoKSwgeGZCKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ29sbGlkZVBvbHlnb25DaXJjbGUobWFuaWZvbGQsIHBvbHlnb25BLCB4ZkEsIGNpcmNsZUIsIHhmQikge1xuICAgICAgICBtYW5pZm9sZC5wb2ludENvdW50ID0gMDtcbiAgICAgICAgLy8gQ29tcHV0ZSBjaXJjbGUgcG9zaXRpb24gaW4gdGhlIGZyYW1lIG9mIHRoZSBwb2x5Z29uLlxuICAgICAgICB2YXIgYyA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQiwgY2lyY2xlQi5tX3ApO1xuICAgICAgICB2YXIgY0xvY2FsID0gVHJhbnNmb3JtLm11bFRWZWMyKHhmQSwgYyk7XG4gICAgICAgIC8vIEZpbmQgdGhlIG1pbiBzZXBhcmF0aW5nIGVkZ2UuXG4gICAgICAgIHZhciBub3JtYWxJbmRleCA9IDA7XG4gICAgICAgIHZhciBzZXBhcmF0aW9uID0gLUluZmluaXR5O1xuICAgICAgICB2YXIgcmFkaXVzID0gcG9seWdvbkEubV9yYWRpdXMgKyBjaXJjbGVCLm1fcmFkaXVzO1xuICAgICAgICB2YXIgdmVydGV4Q291bnQgPSBwb2x5Z29uQS5tX2NvdW50O1xuICAgICAgICB2YXIgdmVydGljZXMgPSBwb2x5Z29uQS5tX3ZlcnRpY2VzO1xuICAgICAgICB2YXIgbm9ybWFscyA9IHBvbHlnb25BLm1fbm9ybWFscztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcyA9IFZlYzIuZG90KG5vcm1hbHNbaV0sIFZlYzIuc3ViKGNMb2NhbCwgdmVydGljZXNbaV0pKTtcbiAgICAgICAgICAgIGlmIChzID4gcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgLy8gRWFybHkgb3V0LlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzID4gc2VwYXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHNlcGFyYXRpb24gPSBzO1xuICAgICAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBWZXJ0aWNlcyB0aGF0IHN1YnRlbmQgdGhlIGluY2lkZW50IGZhY2UuXG4gICAgICAgIHZhciB2ZXJ0SW5kZXgxID0gbm9ybWFsSW5kZXg7XG4gICAgICAgIHZhciB2ZXJ0SW5kZXgyID0gdmVydEluZGV4MSArIDEgPCB2ZXJ0ZXhDb3VudCA/IHZlcnRJbmRleDEgKyAxIDogMDtcbiAgICAgICAgdmFyIHYxID0gdmVydGljZXNbdmVydEluZGV4MV07XG4gICAgICAgIHZhciB2MiA9IHZlcnRpY2VzW3ZlcnRJbmRleDJdO1xuICAgICAgICAvLyBJZiB0aGUgY2VudGVyIGlzIGluc2lkZSB0aGUgcG9seWdvbiAuLi5cbiAgICAgICAgaWYgKHNlcGFyYXRpb24gPCBtYXRoJDEuRVBTSUxPTikge1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDE7XG4gICAgICAgICAgICBtYW5pZm9sZC50eXBlID0gTWFuaWZvbGRUeXBlLmVfZmFjZUE7XG4gICAgICAgICAgICBtYW5pZm9sZC5sb2NhbE5vcm1hbC5zZXRWZWMyKG5vcm1hbHNbbm9ybWFsSW5kZXhdKTtcbiAgICAgICAgICAgIG1hbmlmb2xkLmxvY2FsUG9pbnQuc2V0Q29tYmluZSgwLjUsIHYxLCAwLjUsIHYyKTtcbiAgICAgICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5sb2NhbFBvaW50ID0gY2lyY2xlQi5tX3A7XG4gICAgICAgICAgICAvLyBtYW5pZm9sZC5wb2ludHNbMF0uaWQua2V5ID0gMDtcbiAgICAgICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi5pbmRleEEgPSAwO1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLnR5cGVBID0gQ29udGFjdEZlYXR1cmVUeXBlLmVfdmVydGV4O1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLmluZGV4QiA9IDA7XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YudHlwZUIgPSBDb250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXg7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xuICAgICAgICB2YXIgdTEgPSBWZWMyLmRvdChWZWMyLnN1YihjTG9jYWwsIHYxKSwgVmVjMi5zdWIodjIsIHYxKSk7XG4gICAgICAgIHZhciB1MiA9IFZlYzIuZG90KFZlYzIuc3ViKGNMb2NhbCwgdjIpLCBWZWMyLnN1Yih2MSwgdjIpKTtcbiAgICAgICAgaWYgKHUxIDw9IDAuMCkge1xuICAgICAgICAgICAgaWYgKFZlYzIuZGlzdGFuY2VTcXVhcmVkKGNMb2NhbCwgdjEpID4gcmFkaXVzICogcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDE7XG4gICAgICAgICAgICBtYW5pZm9sZC50eXBlID0gTWFuaWZvbGRUeXBlLmVfZmFjZUE7XG4gICAgICAgICAgICBtYW5pZm9sZC5sb2NhbE5vcm1hbC5zZXRDb21iaW5lKDEsIGNMb2NhbCwgLTEsIHYxKTtcbiAgICAgICAgICAgIG1hbmlmb2xkLmxvY2FsTm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgbWFuaWZvbGQubG9jYWxQb2ludCA9IHYxO1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmxvY2FsUG9pbnQuc2V0VmVjMihjaXJjbGVCLm1fcCk7XG4gICAgICAgICAgICAvLyBtYW5pZm9sZC5wb2ludHNbMF0uaWQua2V5ID0gMDtcbiAgICAgICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi5pbmRleEEgPSAwO1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLnR5cGVBID0gQ29udGFjdEZlYXR1cmVUeXBlLmVfdmVydGV4O1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLmluZGV4QiA9IDA7XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YudHlwZUIgPSBDb250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodTIgPD0gMC4wKSB7XG4gICAgICAgICAgICBpZiAoVmVjMi5kaXN0YW5jZVNxdWFyZWQoY0xvY2FsLCB2MikgPiByYWRpdXMgKiByYWRpdXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludENvdW50ID0gMTtcbiAgICAgICAgICAgIG1hbmlmb2xkLnR5cGUgPSBNYW5pZm9sZFR5cGUuZV9mYWNlQTtcbiAgICAgICAgICAgIG1hbmlmb2xkLmxvY2FsTm9ybWFsLnNldENvbWJpbmUoMSwgY0xvY2FsLCAtMSwgdjIpO1xuICAgICAgICAgICAgbWFuaWZvbGQubG9jYWxOb3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgICAgICBtYW5pZm9sZC5sb2NhbFBvaW50LnNldFZlYzIodjIpO1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmxvY2FsUG9pbnQuc2V0VmVjMihjaXJjbGVCLm1fcCk7XG4gICAgICAgICAgICAvLyBtYW5pZm9sZC5wb2ludHNbMF0uaWQua2V5ID0gMDtcbiAgICAgICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi5pbmRleEEgPSAwO1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLnR5cGVBID0gQ29udGFjdEZlYXR1cmVUeXBlLmVfdmVydGV4O1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLmluZGV4QiA9IDA7XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YudHlwZUIgPSBDb250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZmFjZUNlbnRlciA9IFZlYzIubWlkKHYxLCB2Mik7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdGlvbl8xID0gVmVjMi5kb3QoY0xvY2FsLCBub3JtYWxzW3ZlcnRJbmRleDFdKSAtIFZlYzIuZG90KGZhY2VDZW50ZXIsIG5vcm1hbHNbdmVydEluZGV4MV0pO1xuICAgICAgICAgICAgaWYgKHNlcGFyYXRpb25fMSA+IHJhZGl1cykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hbmlmb2xkLnBvaW50Q291bnQgPSAxO1xuICAgICAgICAgICAgbWFuaWZvbGQudHlwZSA9IE1hbmlmb2xkVHlwZS5lX2ZhY2VBO1xuICAgICAgICAgICAgbWFuaWZvbGQubG9jYWxOb3JtYWwuc2V0VmVjMihub3JtYWxzW3ZlcnRJbmRleDFdKTtcbiAgICAgICAgICAgIG1hbmlmb2xkLmxvY2FsUG9pbnQuc2V0VmVjMihmYWNlQ2VudGVyKTtcbiAgICAgICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5sb2NhbFBvaW50LnNldFZlYzIoY2lyY2xlQi5tX3ApO1xuICAgICAgICAgICAgLy8gbWFuaWZvbGQucG9pbnRzWzBdLmlkLmtleSA9IDA7XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YuaW5kZXhBID0gMDtcbiAgICAgICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi50eXBlQSA9IENvbnRhY3RGZWF0dXJlVHlwZS5lX3ZlcnRleDtcbiAgICAgICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi5pbmRleEIgPSAwO1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLnR5cGVCID0gQ29udGFjdEZlYXR1cmVUeXBlLmVfdmVydGV4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIENvbnRhY3QuYWRkVHlwZShFZGdlU2hhcGUuVFlQRSwgUG9seWdvblNoYXBlLlRZUEUsIEVkZ2VQb2x5Z29uQ29udGFjdCk7XG4gICAgQ29udGFjdC5hZGRUeXBlKENoYWluU2hhcGUuVFlQRSwgUG9seWdvblNoYXBlLlRZUEUsIENoYWluUG9seWdvbkNvbnRhY3QpO1xuICAgIGZ1bmN0aW9uIEVkZ2VQb2x5Z29uQ29udGFjdChtYW5pZm9sZCwgeGZBLCBmQSwgaW5kZXhBLCB4ZkIsIGZCLCBpbmRleEIpIHtcbiAgICAgICAgQ29sbGlkZUVkZ2VQb2x5Z29uKG1hbmlmb2xkLCBmQS5nZXRTaGFwZSgpLCB4ZkEsIGZCLmdldFNoYXBlKCksIHhmQik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENoYWluUG9seWdvbkNvbnRhY3QobWFuaWZvbGQsIHhmQSwgZkEsIGluZGV4QSwgeGZCLCBmQiwgaW5kZXhCKSB7XG4gICAgICAgIHZhciBjaGFpbiA9IGZBLmdldFNoYXBlKCk7XG4gICAgICAgIHZhciBlZGdlID0gbmV3IEVkZ2VTaGFwZSgpO1xuICAgICAgICBjaGFpbi5nZXRDaGlsZEVkZ2UoZWRnZSwgaW5kZXhBKTtcbiAgICAgICAgQ29sbGlkZUVkZ2VQb2x5Z29uKG1hbmlmb2xkLCBlZGdlLCB4ZkEsIGZCLmdldFNoYXBlKCksIHhmQik7XG4gICAgfVxuICAgIHZhciBFUEF4aXNUeXBlO1xuICAgIChmdW5jdGlvbiAoRVBBeGlzVHlwZSkge1xuICAgICAgICBFUEF4aXNUeXBlW0VQQXhpc1R5cGVbXCJlX3Vua25vd25cIl0gPSAtMV0gPSBcImVfdW5rbm93blwiO1xuICAgICAgICBFUEF4aXNUeXBlW0VQQXhpc1R5cGVbXCJlX2VkZ2VBXCJdID0gMV0gPSBcImVfZWRnZUFcIjtcbiAgICAgICAgRVBBeGlzVHlwZVtFUEF4aXNUeXBlW1wiZV9lZGdlQlwiXSA9IDJdID0gXCJlX2VkZ2VCXCI7XG4gICAgfSkoRVBBeGlzVHlwZSB8fCAoRVBBeGlzVHlwZSA9IHt9KSk7XG4gICAgLy8gdW51c2VkP1xuICAgIHZhciBWZXJ0ZXhUeXBlO1xuICAgIChmdW5jdGlvbiAoVmVydGV4VHlwZSkge1xuICAgICAgICBWZXJ0ZXhUeXBlW1ZlcnRleFR5cGVbXCJlX2lzb2xhdGVkXCJdID0gMF0gPSBcImVfaXNvbGF0ZWRcIjtcbiAgICAgICAgVmVydGV4VHlwZVtWZXJ0ZXhUeXBlW1wiZV9jb25jYXZlXCJdID0gMV0gPSBcImVfY29uY2F2ZVwiO1xuICAgICAgICBWZXJ0ZXhUeXBlW1ZlcnRleFR5cGVbXCJlX2NvbnZleFwiXSA9IDJdID0gXCJlX2NvbnZleFwiO1xuICAgIH0pKFZlcnRleFR5cGUgfHwgKFZlcnRleFR5cGUgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoaXMgc3RydWN0dXJlIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgYmVzdCBzZXBhcmF0aW5nIGF4aXMuXG4gICAgICovXG4gICAgdmFyIEVQQXhpcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRVBBeGlzKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFUEF4aXM7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGhvbGRzIHBvbHlnb24gQiBleHByZXNzZWQgaW4gZnJhbWUgQS5cbiAgICAgKi9cbiAgICB2YXIgVGVtcFBvbHlnb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRlbXBQb2x5Z29uKCkge1xuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IFtdOyAvLyBbU2V0dGluZ3MubWF4UG9seWdvblZlcnRpY2VzXVxuICAgICAgICAgICAgdGhpcy5ub3JtYWxzID0gW107IC8vIFtTZXR0aW5ncy5tYXhQb2x5Z29uVmVydGljZXNdO1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRlbXBQb2x5Z29uO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIGZhY2UgdXNlZCBmb3IgY2xpcHBpbmdcbiAgICAgKi9cbiAgICB2YXIgUmVmZXJlbmNlRmFjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVmZXJlbmNlRmFjZSgpIHtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICB0aGlzLnNpZGVOb3JtYWwxID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICB0aGlzLnNpZGVOb3JtYWwyID0gVmVjMi56ZXJvKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlZmVyZW5jZUZhY2U7XG4gICAgfSgpKTtcbiAgICAvLyByZXVzZWRcbiAgICB2YXIgZWRnZUF4aXMgPSBuZXcgRVBBeGlzKCk7XG4gICAgdmFyIHBvbHlnb25BeGlzID0gbmV3IEVQQXhpcygpO1xuICAgIHZhciBwb2x5Z29uQkEgPSBuZXcgVGVtcFBvbHlnb24oKTtcbiAgICB2YXIgcmYgPSBuZXcgUmVmZXJlbmNlRmFjZSgpO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY29sbGlkZXMgYW5kIGVkZ2UgYW5kIGEgcG9seWdvbiwgdGFraW5nIGludG8gYWNjb3VudCBlZGdlXG4gICAgICogYWRqYWNlbmN5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbGxpZGVFZGdlUG9seWdvbihtYW5pZm9sZCwgZWRnZUEsIHhmQSwgcG9seWdvbkIsIHhmQikge1xuICAgICAgICAvLyBBbGdvcml0aG06XG4gICAgICAgIC8vIDEuIENsYXNzaWZ5IHYxIGFuZCB2MlxuICAgICAgICAvLyAyLiBDbGFzc2lmeSBwb2x5Z29uIGNlbnRyb2lkIGFzIGZyb250IG9yIGJhY2tcbiAgICAgICAgLy8gMy4gRmxpcCBub3JtYWwgaWYgbmVjZXNzYXJ5XG4gICAgICAgIC8vIDQuIEluaXRpYWxpemUgbm9ybWFsIHJhbmdlIHRvIFstcGksIHBpXSBhYm91dCBmYWNlIG5vcm1hbFxuICAgICAgICAvLyA1LiBBZGp1c3Qgbm9ybWFsIHJhbmdlIGFjY29yZGluZyB0byBhZGphY2VudCBlZGdlc1xuICAgICAgICAvLyA2LiBWaXNpdCBlYWNoIHNlcGFyYXRpbmcgYXhlcywgb25seSBhY2NlcHQgYXhlcyB3aXRoaW4gdGhlIHJhbmdlXG4gICAgICAgIC8vIDcuIFJldHVybiBpZiBfYW55XyBheGlzIGluZGljYXRlcyBzZXBhcmF0aW9uXG4gICAgICAgIC8vIDguIENsaXBcbiAgICAgICAgLy8gbGV0IG1fdHlwZTE6IFZlcnRleFR5cGU7XG4gICAgICAgIC8vIGxldCBtX3R5cGUyOiBWZXJ0ZXhUeXBlO1xuICAgICAgICB2YXIgeGYgPSBUcmFuc2Zvcm0ubXVsVFhmKHhmQSwgeGZCKTtcbiAgICAgICAgdmFyIGNlbnRyb2lkQiA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmLCBwb2x5Z29uQi5tX2NlbnRyb2lkKTtcbiAgICAgICAgdmFyIHYwID0gZWRnZUEubV92ZXJ0ZXgwO1xuICAgICAgICB2YXIgdjEgPSBlZGdlQS5tX3ZlcnRleDE7XG4gICAgICAgIHZhciB2MiA9IGVkZ2VBLm1fdmVydGV4MjtcbiAgICAgICAgdmFyIHYzID0gZWRnZUEubV92ZXJ0ZXgzO1xuICAgICAgICB2YXIgaGFzVmVydGV4MCA9IGVkZ2VBLm1faGFzVmVydGV4MDtcbiAgICAgICAgdmFyIGhhc1ZlcnRleDMgPSBlZGdlQS5tX2hhc1ZlcnRleDM7XG4gICAgICAgIHZhciBlZGdlMSA9IFZlYzIuc3ViKHYyLCB2MSk7XG4gICAgICAgIGVkZ2UxLm5vcm1hbGl6ZSgpO1xuICAgICAgICB2YXIgbm9ybWFsMSA9IFZlYzIubmVvKGVkZ2UxLnksIC1lZGdlMS54KTtcbiAgICAgICAgdmFyIG9mZnNldDEgPSBWZWMyLmRvdChub3JtYWwxLCBWZWMyLnN1YihjZW50cm9pZEIsIHYxKSk7XG4gICAgICAgIHZhciBvZmZzZXQwID0gMC4wO1xuICAgICAgICB2YXIgb2Zmc2V0MiA9IDAuMDtcbiAgICAgICAgdmFyIGNvbnZleDEgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNvbnZleDIgPSBmYWxzZTtcbiAgICAgICAgdmFyIG5vcm1hbDA7XG4gICAgICAgIHZhciBub3JtYWwyO1xuICAgICAgICAvLyBJcyB0aGVyZSBhIHByZWNlZGluZyBlZGdlP1xuICAgICAgICBpZiAoaGFzVmVydGV4MCkge1xuICAgICAgICAgICAgdmFyIGVkZ2UwID0gVmVjMi5zdWIodjEsIHYwKTtcbiAgICAgICAgICAgIGVkZ2UwLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgbm9ybWFsMCA9IFZlYzIubmVvKGVkZ2UwLnksIC1lZGdlMC54KTtcbiAgICAgICAgICAgIGNvbnZleDEgPSBWZWMyLmNyb3NzVmVjMlZlYzIoZWRnZTAsIGVkZ2UxKSA+PSAwLjA7XG4gICAgICAgICAgICBvZmZzZXQwID0gVmVjMi5kb3Qobm9ybWFsMCwgY2VudHJvaWRCKSAtIFZlYzIuZG90KG5vcm1hbDAsIHYwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJcyB0aGVyZSBhIGZvbGxvd2luZyBlZGdlP1xuICAgICAgICBpZiAoaGFzVmVydGV4Mykge1xuICAgICAgICAgICAgdmFyIGVkZ2UyID0gVmVjMi5zdWIodjMsIHYyKTtcbiAgICAgICAgICAgIGVkZ2UyLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgbm9ybWFsMiA9IFZlYzIubmVvKGVkZ2UyLnksIC1lZGdlMi54KTtcbiAgICAgICAgICAgIGNvbnZleDIgPSBWZWMyLmNyb3NzVmVjMlZlYzIoZWRnZTEsIGVkZ2UyKSA+IDAuMDtcbiAgICAgICAgICAgIG9mZnNldDIgPSBWZWMyLmRvdChub3JtYWwyLCBjZW50cm9pZEIpIC0gVmVjMi5kb3Qobm9ybWFsMiwgdjIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcm9udDtcbiAgICAgICAgdmFyIG5vcm1hbCA9IFZlYzIuemVybygpO1xuICAgICAgICB2YXIgbG93ZXJMaW1pdCA9IFZlYzIuemVybygpO1xuICAgICAgICB2YXIgdXBwZXJMaW1pdCA9IFZlYzIuemVybygpO1xuICAgICAgICAvLyBEZXRlcm1pbmUgZnJvbnQgb3IgYmFjayBjb2xsaXNpb24uIERldGVybWluZSBjb2xsaXNpb24gbm9ybWFsIGxpbWl0cy5cbiAgICAgICAgaWYgKGhhc1ZlcnRleDAgJiYgaGFzVmVydGV4Mykge1xuICAgICAgICAgICAgaWYgKGNvbnZleDEgJiYgY29udmV4Mikge1xuICAgICAgICAgICAgICAgIGZyb250ID0gb2Zmc2V0MCA+PSAwLjAgfHwgb2Zmc2V0MSA+PSAwLjAgfHwgb2Zmc2V0MiA+PSAwLjA7XG4gICAgICAgICAgICAgICAgaWYgKGZyb250KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbC5zZXRWZWMyKG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlckxpbWl0LnNldFZlYzIobm9ybWFsMCk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyTGltaXQuc2V0VmVjMihub3JtYWwyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbC5zZXRNdWwoLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyTGltaXQuc2V0TXVsKC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb252ZXgxKSB7XG4gICAgICAgICAgICAgICAgZnJvbnQgPSBvZmZzZXQwID49IDAuMCB8fCAob2Zmc2V0MSA+PSAwLjAgJiYgb2Zmc2V0MiA+PSAwLjApO1xuICAgICAgICAgICAgICAgIGlmIChmcm9udCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWwuc2V0VmVjMihub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJMaW1pdC5zZXRWZWMyKG5vcm1hbDApO1xuICAgICAgICAgICAgICAgICAgICB1cHBlckxpbWl0LnNldFZlYzIobm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWwuc2V0TXVsKC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJMaW1pdC5zZXRNdWwoLTEsIG5vcm1hbDIpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29udmV4Mikge1xuICAgICAgICAgICAgICAgIGZyb250ID0gb2Zmc2V0MiA+PSAwLjAgfHwgKG9mZnNldDAgPj0gMC4wICYmIG9mZnNldDEgPj0gMC4wKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsLnNldFZlYzIobm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyTGltaXQuc2V0VmVjMihub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJMaW1pdC5zZXRWZWMyKG5vcm1hbDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsLnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyTGltaXQuc2V0TXVsKC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJMaW1pdC5zZXRNdWwoLTEsIG5vcm1hbDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyb250ID0gb2Zmc2V0MCA+PSAwLjAgJiYgb2Zmc2V0MSA+PSAwLjAgJiYgb2Zmc2V0MiA+PSAwLjA7XG4gICAgICAgICAgICAgICAgaWYgKGZyb250KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbC5zZXRWZWMyKG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlckxpbWl0LnNldFZlYzIobm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyTGltaXQuc2V0VmVjMihub3JtYWwxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbC5zZXRNdWwoLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMik7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyTGltaXQuc2V0TXVsKC0xLCBub3JtYWwwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzVmVydGV4MCkge1xuICAgICAgICAgICAgaWYgKGNvbnZleDEpIHtcbiAgICAgICAgICAgICAgICBmcm9udCA9IG9mZnNldDAgPj0gMC4wIHx8IG9mZnNldDEgPj0gMC4wO1xuICAgICAgICAgICAgICAgIGlmIChmcm9udCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWwuc2V0VmVjMihub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJMaW1pdC5zZXRWZWMyKG5vcm1hbDApO1xuICAgICAgICAgICAgICAgICAgICB1cHBlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWwuc2V0TXVsKC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJMaW1pdC5zZXRWZWMyKG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJvbnQgPSBvZmZzZXQwID49IDAuMCAmJiBvZmZzZXQxID49IDAuMDtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsLnNldFZlYzIobm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyTGltaXQuc2V0VmVjMihub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJMaW1pdC5zZXRNdWwoLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsLnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyTGltaXQuc2V0VmVjMihub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJMaW1pdC5zZXRNdWwoLTEsIG5vcm1hbDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNWZXJ0ZXgzKSB7XG4gICAgICAgICAgICBpZiAoY29udmV4Mikge1xuICAgICAgICAgICAgICAgIGZyb250ID0gb2Zmc2V0MSA+PSAwLjAgfHwgb2Zmc2V0MiA+PSAwLjA7XG4gICAgICAgICAgICAgICAgaWYgKGZyb250KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbC5zZXRWZWMyKG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyTGltaXQuc2V0VmVjMihub3JtYWwyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbC5zZXRNdWwoLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyTGltaXQuc2V0VmVjMihub3JtYWwxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9udCA9IG9mZnNldDEgPj0gMC4wICYmIG9mZnNldDIgPj0gMC4wO1xuICAgICAgICAgICAgICAgIGlmIChmcm9udCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWwuc2V0VmVjMihub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJMaW1pdC5zZXRNdWwoLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlckxpbWl0LnNldFZlYzIobm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWwuc2V0TXVsKC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJMaW1pdC5zZXRNdWwoLTEsIG5vcm1hbDIpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlckxpbWl0LnNldFZlYzIobm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbnQgPSBvZmZzZXQxID49IDAuMDtcbiAgICAgICAgICAgIGlmIChmcm9udCkge1xuICAgICAgICAgICAgICAgIG5vcm1hbC5zZXRWZWMyKG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIGxvd2VyTGltaXQuc2V0TXVsKC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICB1cHBlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3JtYWwuc2V0TXVsKC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICBsb3dlckxpbWl0LnNldFZlYzIobm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgdXBwZXJMaW1pdC5zZXRWZWMyKG5vcm1hbDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBwb2x5Z29uQiBpbiBmcmFtZUFcbiAgICAgICAgcG9seWdvbkJBLmNvdW50ID0gcG9seWdvbkIubV9jb3VudDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uQi5tX2NvdW50OyArK2kpIHtcbiAgICAgICAgICAgIHBvbHlnb25CQS52ZXJ0aWNlc1tpXSA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmLCBwb2x5Z29uQi5tX3ZlcnRpY2VzW2ldKTtcbiAgICAgICAgICAgIHBvbHlnb25CQS5ub3JtYWxzW2ldID0gUm90Lm11bFZlYzIoeGYucSwgcG9seWdvbkIubV9ub3JtYWxzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFkaXVzID0gMi4wICogU2V0dGluZ3MucG9seWdvblJhZGl1cztcbiAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDA7XG4gICAgICAgIHsgLy8gQ29tcHV0ZUVkZ2VTZXBhcmF0aW9uXG4gICAgICAgICAgICBlZGdlQXhpcy50eXBlID0gRVBBeGlzVHlwZS5lX2VkZ2VBO1xuICAgICAgICAgICAgZWRnZUF4aXMuaW5kZXggPSBmcm9udCA/IDAgOiAxO1xuICAgICAgICAgICAgZWRnZUF4aXMuc2VwYXJhdGlvbiA9IEluZmluaXR5O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uQkEuY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gVmVjMi5kb3Qobm9ybWFsLCBWZWMyLnN1Yihwb2x5Z29uQkEudmVydGljZXNbaV0sIHYxKSk7XG4gICAgICAgICAgICAgICAgaWYgKHMgPCBlZGdlQXhpcy5zZXBhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VBeGlzLnNlcGFyYXRpb24gPSBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyB2YWxpZCBub3JtYWwgY2FuIGJlIGZvdW5kIHRoYW4gdGhpcyBlZGdlIHNob3VsZCBub3QgY29sbGlkZS5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZWRnZUF4aXMudHlwZSA9PSBFUEF4aXNUeXBlLmVfdW5rbm93bikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZGdlQXhpcy5zZXBhcmF0aW9uID4gcmFkaXVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgeyAvLyBDb21wdXRlUG9seWdvblNlcGFyYXRpb25cbiAgICAgICAgICAgIHBvbHlnb25BeGlzLnR5cGUgPSBFUEF4aXNUeXBlLmVfdW5rbm93bjtcbiAgICAgICAgICAgIHBvbHlnb25BeGlzLmluZGV4ID0gLTE7XG4gICAgICAgICAgICBwb2x5Z29uQXhpcy5zZXBhcmF0aW9uID0gLUluZmluaXR5O1xuICAgICAgICAgICAgdmFyIHBlcnAgPSBWZWMyLm5lbygtbm9ybWFsLnksIG5vcm1hbC54KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbkJBLmNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IFZlYzIubmVnKHBvbHlnb25CQS5ub3JtYWxzW2ldKTtcbiAgICAgICAgICAgICAgICB2YXIgczEgPSBWZWMyLmRvdChuLCBWZWMyLnN1Yihwb2x5Z29uQkEudmVydGljZXNbaV0sIHYxKSk7XG4gICAgICAgICAgICAgICAgdmFyIHMyID0gVmVjMi5kb3QobiwgVmVjMi5zdWIocG9seWdvbkJBLnZlcnRpY2VzW2ldLCB2MikpO1xuICAgICAgICAgICAgICAgIHZhciBzID0gbWF0aCQxLm1pbihzMSwgczIpO1xuICAgICAgICAgICAgICAgIGlmIChzID4gcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGNvbGxpc2lvblxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXhpcy50eXBlID0gRVBBeGlzVHlwZS5lX2VkZ2VCO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXhpcy5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BeGlzLnNlcGFyYXRpb24gPSBzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRqYWNlbmN5XG4gICAgICAgICAgICAgICAgaWYgKFZlYzIuZG90KG4sIHBlcnApID49IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVmVjMi5kb3QoVmVjMi5zdWIobiwgdXBwZXJMaW1pdCksIG5vcm1hbCkgPCAtU2V0dGluZ3MuYW5ndWxhclNsb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVmVjMi5kb3QoVmVjMi5zdWIobiwgbG93ZXJMaW1pdCksIG5vcm1hbCkgPCAtU2V0dGluZ3MuYW5ndWxhclNsb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzID4gcG9seWdvbkF4aXMuc2VwYXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXhpcy50eXBlID0gRVBBeGlzVHlwZS5lX2VkZ2VCO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXhpcy5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BeGlzLnNlcGFyYXRpb24gPSBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9seWdvbkF4aXMudHlwZSAhPSBFUEF4aXNUeXBlLmVfdW5rbm93biAmJiBwb2x5Z29uQXhpcy5zZXBhcmF0aW9uID4gcmFkaXVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGh5c3RlcmVzaXMgZm9yIGppdHRlciByZWR1Y3Rpb24uXG4gICAgICAgIHZhciBrX3JlbGF0aXZlVG9sID0gMC45ODtcbiAgICAgICAgdmFyIGtfYWJzb2x1dGVUb2wgPSAwLjAwMTtcbiAgICAgICAgdmFyIHByaW1hcnlBeGlzO1xuICAgICAgICBpZiAocG9seWdvbkF4aXMudHlwZSA9PSBFUEF4aXNUeXBlLmVfdW5rbm93bikge1xuICAgICAgICAgICAgcHJpbWFyeUF4aXMgPSBlZGdlQXhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb2x5Z29uQXhpcy5zZXBhcmF0aW9uID4ga19yZWxhdGl2ZVRvbCAqIGVkZ2VBeGlzLnNlcGFyYXRpb24gKyBrX2Fic29sdXRlVG9sKSB7XG4gICAgICAgICAgICBwcmltYXJ5QXhpcyA9IHBvbHlnb25BeGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJpbWFyeUF4aXMgPSBlZGdlQXhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWUgPSBbbmV3IENsaXBWZXJ0ZXgoKSwgbmV3IENsaXBWZXJ0ZXgoKV07XG4gICAgICAgIGlmIChwcmltYXJ5QXhpcy50eXBlID09IEVQQXhpc1R5cGUuZV9lZGdlQSkge1xuICAgICAgICAgICAgbWFuaWZvbGQudHlwZSA9IE1hbmlmb2xkVHlwZS5lX2ZhY2VBO1xuICAgICAgICAgICAgLy8gU2VhcmNoIGZvciB0aGUgcG9seWdvbiBub3JtYWwgdGhhdCBpcyBtb3N0IGFudGktcGFyYWxsZWwgdG8gdGhlIGVkZ2VcbiAgICAgICAgICAgIC8vIG5vcm1hbC5cbiAgICAgICAgICAgIHZhciBiZXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIGJlc3RWYWx1ZSA9IFZlYzIuZG90KG5vcm1hbCwgcG9seWdvbkJBLm5vcm1hbHNbMF0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2x5Z29uQkEuY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IFZlYzIuZG90KG5vcm1hbCwgcG9seWdvbkJBLm5vcm1hbHNbaV0pO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IGJlc3RWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaTEgPSBiZXN0SW5kZXg7XG4gICAgICAgICAgICB2YXIgaTIgPSBpMSArIDEgPCBwb2x5Z29uQkEuY291bnQgPyBpMSArIDEgOiAwO1xuICAgICAgICAgICAgaWVbMF0udiA9IHBvbHlnb25CQS52ZXJ0aWNlc1tpMV07XG4gICAgICAgICAgICBpZVswXS5pZC5jZi5pbmRleEEgPSAwO1xuICAgICAgICAgICAgaWVbMF0uaWQuY2YuaW5kZXhCID0gaTE7XG4gICAgICAgICAgICBpZVswXS5pZC5jZi50eXBlQSA9IENvbnRhY3RGZWF0dXJlVHlwZS5lX2ZhY2U7XG4gICAgICAgICAgICBpZVswXS5pZC5jZi50eXBlQiA9IENvbnRhY3RGZWF0dXJlVHlwZS5lX3ZlcnRleDtcbiAgICAgICAgICAgIGllWzFdLnYgPSBwb2x5Z29uQkEudmVydGljZXNbaTJdO1xuICAgICAgICAgICAgaWVbMV0uaWQuY2YuaW5kZXhBID0gMDtcbiAgICAgICAgICAgIGllWzFdLmlkLmNmLmluZGV4QiA9IGkyO1xuICAgICAgICAgICAgaWVbMV0uaWQuY2YudHlwZUEgPSBDb250YWN0RmVhdHVyZVR5cGUuZV9mYWNlO1xuICAgICAgICAgICAgaWVbMV0uaWQuY2YudHlwZUIgPSBDb250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXg7XG4gICAgICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgICAgICByZi5pMSA9IDA7XG4gICAgICAgICAgICAgICAgcmYuaTIgPSAxO1xuICAgICAgICAgICAgICAgIHJmLnYxID0gdjE7XG4gICAgICAgICAgICAgICAgcmYudjIgPSB2MjtcbiAgICAgICAgICAgICAgICByZi5ub3JtYWwuc2V0VmVjMihub3JtYWwxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJmLmkxID0gMTtcbiAgICAgICAgICAgICAgICByZi5pMiA9IDA7XG4gICAgICAgICAgICAgICAgcmYudjEgPSB2MjtcbiAgICAgICAgICAgICAgICByZi52MiA9IHYxO1xuICAgICAgICAgICAgICAgIHJmLm5vcm1hbC5zZXRNdWwoLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWFuaWZvbGQudHlwZSA9IE1hbmlmb2xkVHlwZS5lX2ZhY2VCO1xuICAgICAgICAgICAgaWVbMF0udiA9IHYxO1xuICAgICAgICAgICAgaWVbMF0uaWQuY2YuaW5kZXhBID0gMDtcbiAgICAgICAgICAgIGllWzBdLmlkLmNmLmluZGV4QiA9IHByaW1hcnlBeGlzLmluZGV4O1xuICAgICAgICAgICAgaWVbMF0uaWQuY2YudHlwZUEgPSBDb250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXg7XG4gICAgICAgICAgICBpZVswXS5pZC5jZi50eXBlQiA9IENvbnRhY3RGZWF0dXJlVHlwZS5lX2ZhY2U7XG4gICAgICAgICAgICBpZVsxXS52ID0gdjI7XG4gICAgICAgICAgICBpZVsxXS5pZC5jZi5pbmRleEEgPSAwO1xuICAgICAgICAgICAgaWVbMV0uaWQuY2YuaW5kZXhCID0gcHJpbWFyeUF4aXMuaW5kZXg7XG4gICAgICAgICAgICBpZVsxXS5pZC5jZi50eXBlQSA9IENvbnRhY3RGZWF0dXJlVHlwZS5lX3ZlcnRleDtcbiAgICAgICAgICAgIGllWzFdLmlkLmNmLnR5cGVCID0gQ29udGFjdEZlYXR1cmVUeXBlLmVfZmFjZTtcbiAgICAgICAgICAgIHJmLmkxID0gcHJpbWFyeUF4aXMuaW5kZXg7XG4gICAgICAgICAgICByZi5pMiA9IHJmLmkxICsgMSA8IHBvbHlnb25CQS5jb3VudCA/IHJmLmkxICsgMSA6IDA7XG4gICAgICAgICAgICByZi52MSA9IHBvbHlnb25CQS52ZXJ0aWNlc1tyZi5pMV07XG4gICAgICAgICAgICByZi52MiA9IHBvbHlnb25CQS52ZXJ0aWNlc1tyZi5pMl07XG4gICAgICAgICAgICByZi5ub3JtYWwuc2V0VmVjMihwb2x5Z29uQkEubm9ybWFsc1tyZi5pMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJmLnNpZGVOb3JtYWwxLnNldE51bShyZi5ub3JtYWwueSwgLXJmLm5vcm1hbC54KTtcbiAgICAgICAgcmYuc2lkZU5vcm1hbDIuc2V0TXVsKC0xLCByZi5zaWRlTm9ybWFsMSk7XG4gICAgICAgIHJmLnNpZGVPZmZzZXQxID0gVmVjMi5kb3QocmYuc2lkZU5vcm1hbDEsIHJmLnYxKTtcbiAgICAgICAgcmYuc2lkZU9mZnNldDIgPSBWZWMyLmRvdChyZi5zaWRlTm9ybWFsMiwgcmYudjIpO1xuICAgICAgICAvLyBDbGlwIGluY2lkZW50IGVkZ2UgYWdhaW5zdCBleHRydWRlZCBlZGdlMSBzaWRlIGVkZ2VzLlxuICAgICAgICB2YXIgY2xpcFBvaW50czEgPSBbbmV3IENsaXBWZXJ0ZXgoKSwgbmV3IENsaXBWZXJ0ZXgoKV07XG4gICAgICAgIHZhciBjbGlwUG9pbnRzMiA9IFtuZXcgQ2xpcFZlcnRleCgpLCBuZXcgQ2xpcFZlcnRleCgpXTtcbiAgICAgICAgdmFyIG5wO1xuICAgICAgICAvLyBDbGlwIHRvIGJveCBzaWRlIDFcbiAgICAgICAgbnAgPSBjbGlwU2VnbWVudFRvTGluZShjbGlwUG9pbnRzMSwgaWUsIHJmLnNpZGVOb3JtYWwxLCByZi5zaWRlT2Zmc2V0MSwgcmYuaTEpO1xuICAgICAgICBpZiAobnAgPCBTZXR0aW5ncy5tYXhNYW5pZm9sZFBvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsaXAgdG8gbmVnYXRpdmUgYm94IHNpZGUgMVxuICAgICAgICBucCA9IGNsaXBTZWdtZW50VG9MaW5lKGNsaXBQb2ludHMyLCBjbGlwUG9pbnRzMSwgcmYuc2lkZU5vcm1hbDIsIHJmLnNpZGVPZmZzZXQyLCByZi5pMik7XG4gICAgICAgIGlmIChucCA8IFNldHRpbmdzLm1heE1hbmlmb2xkUG9pbnRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IGNsaXBQb2ludHMyIGNvbnRhaW5zIHRoZSBjbGlwcGVkIHBvaW50cy5cbiAgICAgICAgaWYgKHByaW1hcnlBeGlzLnR5cGUgPT0gRVBBeGlzVHlwZS5lX2VkZ2VBKSB7XG4gICAgICAgICAgICBtYW5pZm9sZC5sb2NhbE5vcm1hbCA9IFZlYzIuY2xvbmUocmYubm9ybWFsKTtcbiAgICAgICAgICAgIG1hbmlmb2xkLmxvY2FsUG9pbnQgPSBWZWMyLmNsb25lKHJmLnYxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hbmlmb2xkLmxvY2FsTm9ybWFsID0gVmVjMi5jbG9uZShwb2x5Z29uQi5tX25vcm1hbHNbcmYuaTFdKTtcbiAgICAgICAgICAgIG1hbmlmb2xkLmxvY2FsUG9pbnQgPSBWZWMyLmNsb25lKHBvbHlnb25CLm1fdmVydGljZXNbcmYuaTFdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9pbnRDb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU2V0dGluZ3MubWF4TWFuaWZvbGRQb2ludHM7ICsraSkge1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRpb24gPSBWZWMyLmRvdChyZi5ub3JtYWwsIFZlYzIuc3ViKGNsaXBQb2ludHMyW2ldLnYsIHJmLnYxKSk7XG4gICAgICAgICAgICBpZiAoc2VwYXJhdGlvbiA8PSByYWRpdXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3AgPSBtYW5pZm9sZC5wb2ludHNbcG9pbnRDb3VudF07IC8vIE1hbmlmb2xkUG9pbnRcbiAgICAgICAgICAgICAgICBpZiAocHJpbWFyeUF4aXMudHlwZSA9PSBFUEF4aXNUeXBlLmVfZWRnZUEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3AubG9jYWxQb2ludCA9IFRyYW5zZm9ybS5tdWxUVmVjMih4ZiwgY2xpcFBvaW50czJbaV0udik7XG4gICAgICAgICAgICAgICAgICAgIGNwLmlkID0gY2xpcFBvaW50czJbaV0uaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjcC5sb2NhbFBvaW50ID0gY2xpcFBvaW50czJbaV0udjtcbiAgICAgICAgICAgICAgICAgICAgY3AuaWQuY2YudHlwZUEgPSBjbGlwUG9pbnRzMltpXS5pZC5jZi50eXBlQjtcbiAgICAgICAgICAgICAgICAgICAgY3AuaWQuY2YudHlwZUIgPSBjbGlwUG9pbnRzMltpXS5pZC5jZi50eXBlQTtcbiAgICAgICAgICAgICAgICAgICAgY3AuaWQuY2YuaW5kZXhBID0gY2xpcFBvaW50czJbaV0uaWQuY2YuaW5kZXhCO1xuICAgICAgICAgICAgICAgICAgICBjcC5pZC5jZi5pbmRleEIgPSBjbGlwUG9pbnRzMltpXS5pZC5jZi5pbmRleEE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsrcG9pbnRDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYW5pZm9sZC5wb2ludENvdW50ID0gcG9pbnRDb3VudDtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgU29sdmVyLlRpbWVTdGVwID0gVGltZVN0ZXA7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIERpc3RhbmNlLnRlc3RPdmVybGFwID0gdGVzdE92ZXJsYXA7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIERpc3RhbmNlLklucHV0ID0gRGlzdGFuY2VJbnB1dDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgRGlzdGFuY2UuT3V0cHV0ID0gRGlzdGFuY2VPdXRwdXQ7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIERpc3RhbmNlLlByb3h5ID0gRGlzdGFuY2VQcm94eTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgRGlzdGFuY2UuQ2FjaGUgPSBTaW1wbGV4Q2FjaGU7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIFRpbWVPZkltcGFjdC5JbnB1dCA9IFRPSUlucHV0O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBUaW1lT2ZJbXBhY3QuT3V0cHV0ID0gVE9JT3V0cHV0O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4pIHtcbiAgICAgIHZhciBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH07XG4gICAgXHRyZXR1cm4gZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuICAgIH1cblxuICAgIHZhciBzdGF0cyA9IHt9O1xuXG4gICAgdmFyIGV4dGVuZCA9IGZ1bmN0aW9uKGJhc2UpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBiYXNlW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAhIGlzIHRoZSBkZWZpbml0aXZlIEphdmFTY3JpcHQgdHlwZSB0ZXN0aW5nIGxpYnJhcnlcbiAgICAgKiBcbiAgICAgKiBAY29weXJpZ2h0IDIwMTMtMjAxNCBFbnJpY28gTWFyaW5vIC8gSm9yZGFuIEhhcmJhbmRcbiAgICAgKiBAbGljZW5zZSBNSVRcbiAgICAgKi9cblxuICAgIHZhciBpc18xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgIHZhciBvYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG4gICAgdmFyIG93bnMgPSBvYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgdG9TdHIgPSBvYmpQcm90by50b1N0cmluZztcblxuICAgIHZhciBoZXhSZWdleCA9IC9eW0EtRmEtZjAtOV0rJC87XG5cbiAgICB2YXIgaXMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4gICAgaXMuYSA9IGlzLmFuID0gaXMudHlwZSA9IGZ1bmN0aW9uKHZhbHVlLCB0eXBlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSB0eXBlO1xuICAgIH07XG5cbiAgICBpcy5kZWZpbmVkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH07XG5cbiAgICBpcy5lbXB0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHRvU3RyLmNhbGwodmFsdWUpO1xuICAgICAgdmFyIGtleTtcblxuICAgICAgaWYgKCdbb2JqZWN0IEFycmF5XScgPT09IHR5cGUgfHwgJ1tvYmplY3QgQXJndW1lbnRzXScgPT09IHR5cGVcbiAgICAgICAgICB8fCAnW29iamVjdCBTdHJpbmddJyA9PT0gdHlwZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ1tvYmplY3QgT2JqZWN0XScgPT09IHR5cGUpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICBpZiAob3ducy5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gIXZhbHVlO1xuICAgIH07XG5cbiAgICBpcy5lcXVhbCA9IGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGUgPSB0b1N0ci5jYWxsKHZhbHVlKTtcbiAgICAgIHZhciBrZXk7XG5cbiAgICAgIGlmICh0eXBlICE9PSB0b1N0ci5jYWxsKG90aGVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgnW29iamVjdCBPYmplY3RdJyA9PT0gdHlwZSkge1xuICAgICAgICBmb3IgKGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgIGlmICghaXMuZXF1YWwodmFsdWVba2V5XSwgb3RoZXJba2V5XSkgfHwgIShrZXkgaW4gb3RoZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoa2V5IGluIG90aGVyKSB7XG4gICAgICAgICAgaWYgKCFpcy5lcXVhbCh2YWx1ZVtrZXldLCBvdGhlcltrZXldKSB8fCAhKGtleSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgnW29iamVjdCBBcnJheV0nID09PSB0eXBlKSB7XG4gICAgICAgIGtleSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKGtleSAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgtLWtleSkge1xuICAgICAgICAgIGlmICghaXMuZXF1YWwodmFsdWVba2V5XSwgb3RoZXJba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgnW29iamVjdCBGdW5jdGlvbl0nID09PSB0eXBlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm90b3R5cGUgPT09IG90aGVyLnByb3RvdHlwZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdbb2JqZWN0IERhdGVdJyA9PT0gdHlwZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpID09PSBvdGhlci5nZXRUaW1lKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgaXMuaW5zdGFuY2UgPSBmdW5jdGlvbih2YWx1ZSwgY29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yO1xuICAgIH07XG5cbiAgICBpcy5uaWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH07XG5cbiAgICBpcy51bmRlZiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbiAgICB9O1xuXG4gICAgaXMuYXJyYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICdbb2JqZWN0IEFycmF5XScgPT09IHRvU3RyLmNhbGwodmFsdWUpO1xuICAgIH07XG5cbiAgICBpcy5lbXB0eWFycmF5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpcy5hcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICBpcy5hcnJheWxpa2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICEhdmFsdWUgJiYgIWlzLmJvb2xlYW4odmFsdWUpICYmIG93bnMuY2FsbCh2YWx1ZSwgJ2xlbmd0aCcpXG4gICAgICAgICAgJiYgaXNGaW5pdGUodmFsdWUubGVuZ3RoKSAmJiBpcy5udW1iZXIodmFsdWUubGVuZ3RoKSAmJiB2YWx1ZS5sZW5ndGggPj0gMDtcbiAgICB9O1xuXG4gICAgaXMuYm9vbGVhbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gJ1tvYmplY3QgQm9vbGVhbl0nID09PSB0b1N0ci5jYWxsKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgaXMuZWxlbWVudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgJiYgdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMTtcbiAgICB9O1xuXG4gICAgaXMuZm4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICdbb2JqZWN0IEZ1bmN0aW9uXScgPT09IHRvU3RyLmNhbGwodmFsdWUpO1xuICAgIH07XG5cbiAgICBpcy5udW1iZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICdbb2JqZWN0IE51bWJlcl0nID09PSB0b1N0ci5jYWxsKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgaXMubmFuID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiAhaXMubnVtYmVyKHZhbHVlKSB8fCB2YWx1ZSAhPT0gdmFsdWU7XG4gICAgfTtcblxuICAgIGlzLm9iamVjdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gJ1tvYmplY3QgT2JqZWN0XScgPT09IHRvU3RyLmNhbGwodmFsdWUpO1xuICAgIH07XG5cbiAgICBpcy5oYXNoID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpcy5vYmplY3QodmFsdWUpICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiYgIXZhbHVlLm5vZGVUeXBlXG4gICAgICAgICAgJiYgIXZhbHVlLnNldEludGVydmFsO1xuICAgIH07XG5cbiAgICBpcy5yZWdleHAgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICdbb2JqZWN0IFJlZ0V4cF0nID09PSB0b1N0ci5jYWxsKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgaXMuc3RyaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiAnW29iamVjdCBTdHJpbmddJyA9PT0gdG9TdHIuY2FsbCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIGlzLmhleCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXMuc3RyaW5nKHZhbHVlKSAmJiAoIXZhbHVlLmxlbmd0aCB8fCBoZXhSZWdleC50ZXN0KHZhbHVlKSk7XG4gICAgfTtcbiAgICB9KTtcblxuICAgIHZhciBfYXdhaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICBmdW5jdGlvbiBmb3JrKGZuLCBuKSB7XG4gICAgICAgIGNvdW50ICs9IG4gPSAodHlwZW9mIG4gPT09ICdudW1iZXInICYmIG4gPj0gMSA/IG4gOiAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZuICYmIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICBuLS0sIGNvdW50LS0sIGNhbGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgdGhlbiA9IFtdO1xuICAgICAgZnVuY3Rpb24gY2FsbCgpIHtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgd2hpbGUgKHRoZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoZW4uc2hpZnQoKSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3JrLnRoZW4gPSBmdW5jdGlvbihmbikge1xuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGVuLnB1c2goZm4pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZvcms7XG4gICAgfTtcblxuICAgIHN0YXRzLmNyZWF0ZSA9IDA7XG5cbiAgICBmdW5jdGlvbiBDbGFzcyhhcmcpIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDbGFzcykpIHtcbiAgICAgICAgaWYgKGlzXzEuZm4oYXJnKSkge1xuICAgICAgICAgIHJldHVybiBDbGFzcy5hcHAuYXBwbHkoQ2xhc3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNfMS5vYmplY3QoYXJnKSkge1xuICAgICAgICAgIHJldHVybiBDbGFzcy5hdGxhcy5hcHBseShDbGFzcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRzLmNyZWF0ZSsrO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9pbml0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9pbml0W2ldLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9pbml0ID0gW107XG5cbiAgICBDbGFzcy5faW5pdCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICBfaW5pdC5wdXNoKGZuKTtcbiAgICB9O1xuXG4gICAgdmFyIF9sb2FkID0gW107XG5cbiAgICBDbGFzcy5fbG9hZCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICBfbG9hZC5wdXNoKGZuKTtcbiAgICB9O1xuXG4gICAgdmFyIF9jb25maWcgPSB7fTtcblxuICAgIENsYXNzLmNvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgaXNfMS5zdHJpbmcoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICByZXR1cm4gX2NvbmZpZ1thcmd1bWVudHNbMF1dO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgaXNfMS5vYmplY3QoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICBleHRlbmQoX2NvbmZpZywgYXJndW1lbnRzWzBdKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIGlzXzEuc3RyaW5nKGFyZ3VtZW50c1swXSkpIDtcbiAgICB9O1xuXG4gICAgdmFyIF9hcHBfcXVldWUgPSBbXTtcbiAgICB2YXIgX3N0YWdlcyA9IFtdO1xuICAgIHZhciBfbG9hZGVkID0gZmFsc2U7XG4gICAgdmFyIF9wYXVzZWQgPSBmYWxzZTtcblxuICAgIENsYXNzLmFwcCA9IGZ1bmN0aW9uKGFwcCwgb3B0cykge1xuICAgICAgaWYgKCFfbG9hZGVkKSB7XG4gICAgICAgIF9hcHBfcXVldWUucHVzaChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbG9hZGVyID0gQ2xhc3MuY29uZmlnKCdhcHAtbG9hZGVyJyk7XG4gICAgICBsb2FkZXIoZnVuY3Rpb24oc3RhZ2UsIGNhbnZhcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9sb2FkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgX2xvYWRbaV0uY2FsbCh0aGlzLCBzdGFnZSwgY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICBhcHAoc3RhZ2UsIGNhbnZhcyk7XG4gICAgICAgIF9zdGFnZXMucHVzaChzdGFnZSk7XG4gICAgICAgIHN0YWdlLnN0YXJ0KCk7XG4gICAgICB9LCBvcHRzKTtcbiAgICB9O1xuXG4gICAgdmFyIGxvYWRpbmcgPSBfYXdhaXQoKTtcblxuICAgIENsYXNzLnByZWxvYWQgPSBmdW5jdGlvbihsb2FkKSB7XG4gICAgICBpZiAodHlwZW9mIGxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB1cmwgPSBDbGFzcy5yZXNvbHZlKGxvYWQpO1xuICAgICAgICBpZiAoL1xcLmpzKCR8XFw/fFxcIykvLnRlc3QodXJsKSkge1xuICAgICAgICAgIGxvYWQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgbG9hZFNjcmlwdCh1cmwsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxvYWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gaWYgKCFfc3RhcnRlZCkge1xuICAgICAgLy8gX3ByZWxvYWRfcXVldWUucHVzaChsb2FkKTtcbiAgICAgIC8vIHJldHVybjtcbiAgICAgIC8vIH1cbiAgICAgIGxvYWQobG9hZGluZygpKTtcbiAgICB9O1xuXG4gICAgQ2xhc3Muc3RhcnQgPSBmdW5jdGlvbihjb25maWcpIHtcblxuICAgICAgQ2xhc3MuY29uZmlnKGNvbmZpZyk7XG5cbiAgICAgIC8vIGZhbHNlICYmIGNvbnNvbGUubG9nKCdQcmVsb2FkaW5nLi4uJyk7XG4gICAgICAvLyBfc3RhcnRlZCA9IHRydWU7XG4gICAgICAvLyB3aGlsZSAoX3ByZWxvYWRfcXVldWUubGVuZ3RoKSB7XG4gICAgICAvLyB2YXIgbG9hZCA9IF9wcmVsb2FkX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAvLyBsb2FkKGxvYWRpbmcoKSk7XG4gICAgICAvLyB9XG5cbiAgICAgIGxvYWRpbmcudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgX2xvYWRlZCA9IHRydWU7XG4gICAgICAgIHdoaWxlIChfYXBwX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBhcmdzID0gX2FwcF9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIENsYXNzLmFwcC5hcHBseShDbGFzcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDbGFzcy5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFfcGF1c2VkKSB7XG4gICAgICAgIF9wYXVzZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gX3N0YWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIF9zdGFnZXNbaV0ucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBDbGFzcy5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChfcGF1c2VkKSB7XG4gICAgICAgIF9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IF9zdGFnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBfc3RhZ2VzW2ldLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIENsYXNzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBDbGFzcygpO1xuICAgIH07XG5cbiAgICBDbGFzcy5yZXNvbHZlID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFNjcmlwdFNyYygpIHtcbiAgICAgICAgLy8gSFRNTDVcbiAgICAgICAgaWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHtcbiAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJRT49MTBcbiAgICAgICAgdmFyIHN0YWNrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICAgICAgICBzdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzdGFjayA9IHN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAvLyBVc2VzIHRoZSBsYXN0IGxpbmUsIHdoZXJlIHRoZSBjYWxsIHN0YXJ0ZWRcbiAgICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gc3RhY2tbaV0ubWF0Y2goLyhcXHcrXFw6XFwvXFwvW14vXSo/XFwvLis/KSg6XFxkKykoOlxcZCspPy8pO1xuICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICByZXR1cm4gdXJsWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElFPDExXG4gICAgICAgIGlmIChzY3JpcHRzLmxlbmd0aCAmJiAncmVhZHlTdGF0ZScgaW4gc2NyaXB0c1swXSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSBzY3JpcHRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgaWYgKHNjcmlwdHNbaV0ucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJykge1xuICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0c1tpXS5zcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhyZWY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgaWYgKC9eXFwuXFwvLy50ZXN0KHVybCkpIHtcbiAgICAgICAgICB2YXIgc3JjID0gZ2V0U2NyaXB0U3JjKCk7XG4gICAgICAgICAgdmFyIGJhc2UgPSBzcmMuc3Vic3RyaW5nKDAsIHNyYy5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgICAgICAgdXJsID0gYmFzZSArIHVybC5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgLy8gfSBlbHNlIGlmICgvXlxcLlxcLlxcLy8udGVzdCh1cmwpKSB7XG4gICAgICAgICAgLy8gdXJsID0gYmFzZSArIHVybDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgdmFyIGNvcmUgPSBDbGFzcztcblxuICAgIGZ1bmN0aW9uIGxvYWRTY3JpcHQoc3JjLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciB8fCAnRXJyb3IgbG9hZGluZyBzY3JpcHQ6ICcgKyBzcmMpO1xuICAgICAgfSk7XG4gICAgICBlbC5zcmMgPSBzcmM7XG4gICAgICBlbC5pZCA9ICdwcmVsb2FkLScgKyBEYXRlLm5vdygpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTWF0cml4JDEoYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgdGhpcy5yZXNldChhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB9XG4gICAgTWF0cml4JDEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ1snICsgdGhpcy5hICsgJywgJyArIHRoaXMuYiArICcsICcgKyB0aGlzLmMgKyAnLCAnICsgdGhpcy5kICsgJywgJ1xuICAgICAgICAgICsgdGhpcy5lICsgJywgJyArIHRoaXMuZiArICddJztcbiAgICB9O1xuXG4gICAgTWF0cml4JDEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IE1hdHJpeCQxKHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRoaXMuZCwgdGhpcy5lLCB0aGlzLmYpO1xuICAgIH07XG5cbiAgICBNYXRyaXgkMS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMuYSA9IGEuYSwgdGhpcy5kID0gYS5kO1xuICAgICAgICB0aGlzLmIgPSBhLmIsIHRoaXMuYyA9IGEuYztcbiAgICAgICAgdGhpcy5lID0gYS5lLCB0aGlzLmYgPSBhLmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmEgPSBhIHx8IDEsIHRoaXMuZCA9IGQgfHwgMTtcbiAgICAgICAgdGhpcy5iID0gYiB8fCAwLCB0aGlzLmMgPSBjIHx8IDA7XG4gICAgICAgIHRoaXMuZSA9IGUgfHwgMCwgdGhpcy5mID0gZiB8fCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIE1hdHJpeCQxLnByb3RvdHlwZS5pZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgdGhpcy5hID0gMTtcbiAgICAgIHRoaXMuYiA9IDA7XG4gICAgICB0aGlzLmMgPSAwO1xuICAgICAgdGhpcy5kID0gMTtcbiAgICAgIHRoaXMuZSA9IDA7XG4gICAgICB0aGlzLmYgPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIE1hdHJpeCQxLnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgaWYgKCFhbmdsZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuXG4gICAgICB2YXIgdSA9IGFuZ2xlID8gTWF0aC5jb3MoYW5nbGUpIDogMTtcbiAgICAgIC8vIGFuZHJvaWQgYnVnIG1heSBnaXZlIGJhZCAwIHZhbHVlc1xuICAgICAgdmFyIHYgPSBhbmdsZSA/IE1hdGguc2luKGFuZ2xlKSA6IDA7XG5cbiAgICAgIHZhciBhID0gdSAqIHRoaXMuYSAtIHYgKiB0aGlzLmI7XG4gICAgICB2YXIgYiA9IHUgKiB0aGlzLmIgKyB2ICogdGhpcy5hO1xuICAgICAgdmFyIGMgPSB1ICogdGhpcy5jIC0gdiAqIHRoaXMuZDtcbiAgICAgIHZhciBkID0gdSAqIHRoaXMuZCArIHYgKiB0aGlzLmM7XG4gICAgICB2YXIgZSA9IHUgKiB0aGlzLmUgLSB2ICogdGhpcy5mO1xuICAgICAgdmFyIGYgPSB1ICogdGhpcy5mICsgdiAqIHRoaXMuZTtcblxuICAgICAgdGhpcy5hID0gYTtcbiAgICAgIHRoaXMuYiA9IGI7XG4gICAgICB0aGlzLmMgPSBjO1xuICAgICAgdGhpcy5kID0gZDtcbiAgICAgIHRoaXMuZSA9IGU7XG4gICAgICB0aGlzLmYgPSBmO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgTWF0cml4JDEucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGlmICgheCAmJiAheSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuZSArPSB4O1xuICAgICAgdGhpcy5mICs9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgTWF0cml4JDEucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgaWYgKCEoeCAtIDEpICYmICEoeSAtIDEpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgdGhpcy5hICo9IHg7XG4gICAgICB0aGlzLmIgKj0geTtcbiAgICAgIHRoaXMuYyAqPSB4O1xuICAgICAgdGhpcy5kICo9IHk7XG4gICAgICB0aGlzLmUgKj0geDtcbiAgICAgIHRoaXMuZiAqPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIE1hdHJpeCQxLnByb3RvdHlwZS5za2V3ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgaWYgKCF4ICYmICF5KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuXG4gICAgICB2YXIgYSA9IHRoaXMuYSArIHRoaXMuYiAqIHg7XG4gICAgICB2YXIgYiA9IHRoaXMuYiArIHRoaXMuYSAqIHk7XG4gICAgICB2YXIgYyA9IHRoaXMuYyArIHRoaXMuZCAqIHg7XG4gICAgICB2YXIgZCA9IHRoaXMuZCArIHRoaXMuYyAqIHk7XG4gICAgICB2YXIgZSA9IHRoaXMuZSArIHRoaXMuZiAqIHg7XG4gICAgICB2YXIgZiA9IHRoaXMuZiArIHRoaXMuZSAqIHk7XG5cbiAgICAgIHRoaXMuYSA9IGE7XG4gICAgICB0aGlzLmIgPSBiO1xuICAgICAgdGhpcy5jID0gYztcbiAgICAgIHRoaXMuZCA9IGQ7XG4gICAgICB0aGlzLmUgPSBlO1xuICAgICAgdGhpcy5mID0gZjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBNYXRyaXgkMS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24obSkge1xuICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuXG4gICAgICB2YXIgbiA9IHRoaXM7XG5cbiAgICAgIHZhciBhID0gbi5hICogbS5hICsgbi5iICogbS5jO1xuICAgICAgdmFyIGIgPSBuLmIgKiBtLmQgKyBuLmEgKiBtLmI7XG4gICAgICB2YXIgYyA9IG4uYyAqIG0uYSArIG4uZCAqIG0uYztcbiAgICAgIHZhciBkID0gbi5kICogbS5kICsgbi5jICogbS5iO1xuICAgICAgdmFyIGUgPSBuLmUgKiBtLmEgKyBtLmUgKyBuLmYgKiBtLmM7XG4gICAgICB2YXIgZiA9IG4uZiAqIG0uZCArIG0uZiArIG4uZSAqIG0uYjtcblxuICAgICAgdGhpcy5hID0gYTtcbiAgICAgIHRoaXMuYiA9IGI7XG4gICAgICB0aGlzLmMgPSBjO1xuICAgICAgdGhpcy5kID0gZDtcbiAgICAgIHRoaXMuZSA9IGU7XG4gICAgICB0aGlzLmYgPSBmO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgTWF0cml4JDEucHJvdG90eXBlLmludmVyc2UgPSBNYXRyaXgkMS5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX2RpcnR5KSB7XG4gICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW52ZXJzZWQgPSB0aGlzLmludmVyc2VkIHx8IG5ldyBNYXRyaXgkMSgpO1xuICAgICAgICB2YXIgeiA9IHRoaXMuYSAqIHRoaXMuZCAtIHRoaXMuYiAqIHRoaXMuYztcbiAgICAgICAgdGhpcy5pbnZlcnNlZC5hID0gdGhpcy5kIC8gejtcbiAgICAgICAgdGhpcy5pbnZlcnNlZC5iID0gLXRoaXMuYiAvIHo7XG4gICAgICAgIHRoaXMuaW52ZXJzZWQuYyA9IC10aGlzLmMgLyB6O1xuICAgICAgICB0aGlzLmludmVyc2VkLmQgPSB0aGlzLmEgLyB6O1xuICAgICAgICB0aGlzLmludmVyc2VkLmUgPSAodGhpcy5jICogdGhpcy5mIC0gdGhpcy5lICogdGhpcy5kKSAvIHo7XG4gICAgICAgIHRoaXMuaW52ZXJzZWQuZiA9ICh0aGlzLmUgKiB0aGlzLmIgLSB0aGlzLmEgKiB0aGlzLmYpIC8gejtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmludmVyc2VkO1xuICAgIH07XG5cbiAgICBNYXRyaXgkMS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24ocCwgcSkge1xuICAgICAgcSA9IHEgfHwge307XG4gICAgICBxLnggPSB0aGlzLmEgKiBwLnggKyB0aGlzLmMgKiBwLnkgKyB0aGlzLmU7XG4gICAgICBxLnkgPSB0aGlzLmIgKiBwLnggKyB0aGlzLmQgKiBwLnkgKyB0aGlzLmY7XG4gICAgICByZXR1cm4gcTtcbiAgICB9O1xuXG4gICAgTWF0cml4JDEucHJvdG90eXBlLm1hcFggPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKVxuICAgICAgICB5ID0geC55LCB4ID0geC54O1xuICAgICAgcmV0dXJuIHRoaXMuYSAqIHggKyB0aGlzLmMgKiB5ICsgdGhpcy5lO1xuICAgIH07XG5cbiAgICBNYXRyaXgkMS5wcm90b3R5cGUubWFwWSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcpXG4gICAgICAgIHkgPSB4LnksIHggPSB4Lng7XG4gICAgICByZXR1cm4gdGhpcy5iICogeCArIHRoaXMuZCAqIHkgKyB0aGlzLmY7XG4gICAgfTtcblxuICAgIHZhciBtYXRyaXggPSBNYXRyaXgkMTtcblxuICAgIHZhciBjcmVhdGUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocHJvdG8sIHByb3BzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlLmNhbGwoT2JqZWN0LCBwcm90bywgcHJvcHMpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwcm90bywgcHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzKVxuICAgICAgICAgIHRocm93IEVycm9yKCdTZWNvbmQgYXJndW1lbnQgaXMgbm90IHN1cHBvcnRlZCEnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm90byAhPT0gJ29iamVjdCcgfHwgcHJvdG8gPT09IG51bGwpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgcHJvdG90eXBlIScpO1xuICAgICAgICBub29wLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICByZXR1cm4gbmV3IG5vb3A7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgbmF0aXZlID0gTWF0aDtcblxuICAgIHZhciBtYXRoID0gY3JlYXRlKE1hdGgpO1xuXG4gICAgdmFyIHJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgICBpZiAodHlwZW9mIG1pbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbWF4ID0gMSwgbWluID0gMDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1heCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbWF4ID0gbWluLCBtaW4gPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1pbiA9PSBtYXggPyBtaW4gOiBuYXRpdmUucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcbiAgICB9O1xuXG4gICAgdmFyIHJvdGF0ZSA9IGZ1bmN0aW9uKG51bSwgbWluLCBtYXgpIHtcbiAgICAgIGlmICh0eXBlb2YgbWluID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtYXggPSAxLCBtaW4gPSAwO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWF4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtYXggPSBtaW4sIG1pbiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAobWF4ID4gbWluKSB7XG4gICAgICAgIG51bSA9IChudW0gLSBtaW4pICUgKG1heCAtIG1pbik7XG4gICAgICAgIHJldHVybiBudW0gKyAobnVtIDwgMCA/IG1heCA6IG1pbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBudW0gPSAobnVtIC0gbWF4KSAlIChtaW4gLSBtYXgpO1xuICAgICAgICByZXR1cm4gbnVtICsgKG51bSA8PSAwID8gbWluIDogbWF4KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxpbWl0ID0gZnVuY3Rpb24obnVtLCBtaW4sIG1heCkge1xuICAgICAgaWYgKG51bSA8IG1pbikge1xuICAgICAgICByZXR1cm4gbWluO1xuICAgICAgfSBlbHNlIGlmIChudW0gPiBtYXgpIHtcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudW07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsZW5ndGggPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4gbmF0aXZlLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgfTtcbiAgICBtYXRoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBtYXRoLnJvdGF0ZSA9IHJvdGF0ZTtcbiAgICBtYXRoLmxpbWl0ID0gbGltaXQ7XG4gICAgbWF0aC5sZW5ndGggPSBsZW5ndGg7XG5cbiAgICBmdW5jdGlvbiBUZXh0dXJlJDEoaW1hZ2UsIHJhdGlvKSB7XG4gICAgICBpZiAodHlwZW9mIGltYWdlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzLnNyYyhpbWFnZSwgcmF0aW8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIFRleHR1cmUkMS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlJDEodGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNpZ25hdHVyZXM6IChpbWFnZSksICh4LCB5LCB3LCBoKSwgKHcsIGgpXG4gICAgICovXG4gICAgVGV4dHVyZSQxLnByb3RvdHlwZS5zcmMgPSBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBpbWFnZSA9IHgsIHJhdGlvID0geSB8fCAxO1xuXG4gICAgICAgIHRoaXMuX2ltYWdlID0gaW1hZ2U7XG4gICAgICAgIHRoaXMuX3N4ID0gdGhpcy5fZHggPSAwO1xuICAgICAgICB0aGlzLl9zeSA9IHRoaXMuX2R5ID0gMDtcbiAgICAgICAgdGhpcy5fc3cgPSB0aGlzLl9kdyA9IGltYWdlLndpZHRoIC8gcmF0aW87XG4gICAgICAgIHRoaXMuX3NoID0gdGhpcy5fZGggPSBpbWFnZS5oZWlnaHQgLyByYXRpbztcblxuICAgICAgICB0aGlzLndpZHRoID0gaW1hZ2Uud2lkdGggLyByYXRpbztcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQgLyByYXRpbztcblxuICAgICAgICB0aGlzLnJhdGlvID0gcmF0aW87XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB3ID0geCwgaCA9IHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc3ggPSB4LCB0aGlzLl9zeSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3cgPSB0aGlzLl9kdyA9IHc7XG4gICAgICAgIHRoaXMuX3NoID0gdGhpcy5fZGggPSBoO1xuXG4gICAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgICB0aGlzLmhlaWdodCA9IGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2lnbmF0dXJlczogKHgsIHksIHcsIGgpLCAoeCwgeSlcbiAgICAgKi9cbiAgICBUZXh0dXJlJDEucHJvdG90eXBlLmRlc3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgICB0aGlzLl9keCA9IHgsIHRoaXMuX2R5ID0geTtcbiAgICAgIHRoaXMuX2R4ID0geCwgdGhpcy5fZHkgPSB5O1xuICAgICAgaWYgKHR5cGVvZiB3ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLl9kdyA9IHcsIHRoaXMuX2RoID0gaDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHcsIHRoaXMuaGVpZ2h0ID0gaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBUZXh0dXJlJDEucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjb250ZXh0LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQpIHtcbiAgICAgIHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlO1xuICAgICAgaWYgKGltYWdlID09PSBudWxsIHx8IHR5cGVvZiBpbWFnZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3ggPSB0aGlzLl9zeCwgc3kgPSB0aGlzLl9zeTtcbiAgICAgIHZhciBzdyA9IHRoaXMuX3N3LCBzaCA9IHRoaXMuX3NoO1xuICAgICAgdmFyIGR4ID0gdGhpcy5fZHgsIGR5ID0gdGhpcy5fZHk7XG4gICAgICB2YXIgZHcgPSB0aGlzLl9kdywgZGggPSB0aGlzLl9kaDtcblxuICAgICAgaWYgKHR5cGVvZiB4MyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgeDEgPSBtYXRoLmxpbWl0KHgxLCAwLCB0aGlzLl9zdyksIHgyID0gbWF0aC5saW1pdCh4MiwgMCwgdGhpcy5fc3cgLSB4MSk7XG4gICAgICAgIHkxID0gbWF0aC5saW1pdCh5MSwgMCwgdGhpcy5fc2gpLCB5MiA9IG1hdGgubGltaXQoeTIsIDAsIHRoaXMuX3NoIC0geTEpO1xuICAgICAgICBzeCArPSB4MSwgc3kgKz0geTEsIHN3ID0geDIsIHNoID0geTI7XG4gICAgICAgIGR4ID0geDMsIGR5ID0geTMsIGR3ID0geDQsIGRoID0geTQ7XG5cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHgyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkeCA9IHgxLCBkeSA9IHkxLCBkdyA9IHgyLCBkaCA9IHkyO1xuXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB4MSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZHcgPSB4MSwgZGggPSB5MTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhdGlvID0gdGhpcy5yYXRpbyB8fCAxO1xuICAgICAgc3ggKj0gcmF0aW8sIHN5ICo9IHJhdGlvLCBzdyAqPSByYXRpbywgc2ggKj0gcmF0aW87XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW1hZ2UuZHJhdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGltYWdlLmRyYXcoY29udGV4dCwgc3gsIHN5LCBzdywgc2gsIGR4LCBkeSwgZHcsIGRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0cy5kcmF3Kys7XG4gICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIHN4LCBzeSwgc3csIHNoLCBkeCwgZHksIGR3LCBkaCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGlmICghaW1hZ2UuX2RyYXdfZmFpbGVkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBkcmF3OiAnLCBpbWFnZSk7XG4gICAgICAgICAgY29uc29sZS5sb2coZXgpO1xuICAgICAgICAgIGltYWdlLl9kcmF3X2ZhaWxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHRleHR1cmUgPSBUZXh0dXJlJDE7XG5cbiAgICB2YXIgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uKHN0ciwgc3ViKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHN1YiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAmJiBzdHIuc3Vic3RyaW5nKDAsIHN1Yi5sZW5ndGgpID09IHN1YjtcbiAgICB9O1xuXG4gICAgdmFyIHN0cmluZyA9IHtcbiAgICBcdHN0YXJ0c1dpdGg6IHN0YXJ0c1dpdGhcbiAgICB9O1xuXG4gICAgLy8gbmFtZSA6IGF0bGFzXG4gICAgdmFyIF9hdGxhc2VzX21hcCA9IHt9O1xuICAgIC8vIFthdGxhc11cbiAgICB2YXIgX2F0bGFzZXNfYXJyID0gW107XG5cbiAgICAvLyBUT0RPOiBwcmludCBzdWJxdWVyeSBub3QgZm91bmQgZXJyb3JcbiAgICAvLyBUT0RPOiBpbmRleCB0ZXh0dXJlc1xuXG4gICAgY29yZS5hdGxhcyA9IGZ1bmN0aW9uKGRlZikge1xuICAgICAgdmFyIGF0bGFzID0gaXNfMS5mbihkZWYuZHJhdykgPyBkZWYgOiBuZXcgQXRsYXMoZGVmKTtcbiAgICAgIGlmIChkZWYubmFtZSkge1xuICAgICAgICBfYXRsYXNlc19tYXBbZGVmLm5hbWVdID0gYXRsYXM7XG4gICAgICB9XG4gICAgICBfYXRsYXNlc19hcnIucHVzaChhdGxhcyk7XG5cbiAgICAgIGRlcHJlY2F0ZWQoZGVmLCAnaW1hZ2VQYXRoJyk7XG4gICAgICBkZXByZWNhdGVkKGRlZiwgJ2ltYWdlUmF0aW8nKTtcblxuICAgICAgdmFyIHVybCA9IGRlZi5pbWFnZVBhdGg7XG4gICAgICB2YXIgcmF0aW8gPSBkZWYuaW1hZ2VSYXRpbyB8fCAxO1xuICAgICAgaWYgKGlzXzEuc3RyaW5nKGRlZi5pbWFnZSkpIHtcbiAgICAgICAgdXJsID0gZGVmLmltYWdlO1xuICAgICAgfSBlbHNlIGlmIChpc18xLmhhc2goZGVmLmltYWdlKSkge1xuICAgICAgICB1cmwgPSBkZWYuaW1hZ2Uuc3JjIHx8IGRlZi5pbWFnZS51cmw7XG4gICAgICAgIHJhdGlvID0gZGVmLmltYWdlLnJhdGlvIHx8IHJhdGlvO1xuICAgICAgfVxuICAgICAgdXJsICYmIGNvcmUucHJlbG9hZChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHVybCA9IGNvcmUucmVzb2x2ZSh1cmwpO1xuICAgICAgICB2YXIgaW1hZ2Vsb2FkZXIgPSBjb3JlLmNvbmZpZygnaW1hZ2UtbG9hZGVyJyk7XG5cbiAgICAgICAgaW1hZ2Vsb2FkZXIodXJsLCBmdW5jdGlvbihpbWFnZSkge1xuICAgICAgICAgIGF0bGFzLnNyYyhpbWFnZSwgcmF0aW8pO1xuICAgICAgICAgIGRvbmUoKTtcblxuICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBhdGxhcztcbiAgICB9O1xuXG4gICAgQXRsYXMuX3N1cGVyID0gdGV4dHVyZTtcbiAgICBBdGxhcy5wcm90b3R5cGUgPSBjcmVhdGUoQXRsYXMuX3N1cGVyLnByb3RvdHlwZSk7XG5cbiAgICBmdW5jdGlvbiBBdGxhcyhkZWYpIHtcbiAgICAgIEF0bGFzLl9zdXBlci5jYWxsKHRoaXMpO1xuXG4gICAgICB2YXIgYXRsYXMgPSB0aGlzO1xuXG4gICAgICBkZXByZWNhdGVkKGRlZiwgJ2ZpbHRlcicpO1xuICAgICAgZGVwcmVjYXRlZChkZWYsICdjdXRvdXRzJyk7XG4gICAgICBkZXByZWNhdGVkKGRlZiwgJ3Nwcml0ZXMnKTtcbiAgICAgIGRlcHJlY2F0ZWQoZGVmLCAnZmFjdG9yeScpO1xuXG4gICAgICB2YXIgbWFwID0gZGVmLm1hcCB8fCBkZWYuZmlsdGVyO1xuICAgICAgdmFyIHBwdSA9IGRlZi5wcHUgfHwgZGVmLnJhdGlvIHx8IDE7XG4gICAgICB2YXIgdHJpbSA9IGRlZi50cmltIHx8IDA7XG4gICAgICB2YXIgdGV4dHVyZXMgPSBkZWYudGV4dHVyZXM7XG4gICAgICB2YXIgZmFjdG9yeSA9IGRlZi5mYWN0b3J5O1xuICAgICAgdmFyIGN1dG91dHMgPSBkZWYuY3V0b3V0cyB8fCBkZWYuc3ByaXRlcztcblxuICAgICAgZnVuY3Rpb24gbWFrZShkZWYpIHtcbiAgICAgICAgaWYgKCFkZWYgfHwgaXNfMS5mbihkZWYuZHJhdykpIHtcbiAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmID0gZXh0ZW5kKHt9LCBkZWYpO1xuXG4gICAgICAgIGlmIChpc18xLmZuKG1hcCkpIHtcbiAgICAgICAgICBkZWYgPSBtYXAoZGVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcHUgIT0gMSkge1xuICAgICAgICAgIGRlZi54ICo9IHBwdSwgZGVmLnkgKj0gcHB1O1xuICAgICAgICAgIGRlZi53aWR0aCAqPSBwcHUsIGRlZi5oZWlnaHQgKj0gcHB1O1xuICAgICAgICAgIGRlZi50b3AgKj0gcHB1LCBkZWYuYm90dG9tICo9IHBwdTtcbiAgICAgICAgICBkZWYubGVmdCAqPSBwcHUsIGRlZi5yaWdodCAqPSBwcHU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJpbSAhPSAwKSB7XG4gICAgICAgICAgZGVmLnggKz0gdHJpbSwgZGVmLnkgKz0gdHJpbTtcbiAgICAgICAgICBkZWYud2lkdGggLT0gMiAqIHRyaW0sIGRlZi5oZWlnaHQgLT0gMiAqIHRyaW07XG4gICAgICAgICAgZGVmLnRvcCAtPSB0cmltLCBkZWYuYm90dG9tIC09IHRyaW07XG4gICAgICAgICAgZGVmLmxlZnQgLT0gdHJpbSwgZGVmLnJpZ2h0IC09IHRyaW07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGV4dHVyZSA9IGF0bGFzLnBpcGUoKTtcbiAgICAgICAgdGV4dHVyZS50b3AgPSBkZWYudG9wLCB0ZXh0dXJlLmJvdHRvbSA9IGRlZi5ib3R0b207XG4gICAgICAgIHRleHR1cmUubGVmdCA9IGRlZi5sZWZ0LCB0ZXh0dXJlLnJpZ2h0ID0gZGVmLnJpZ2h0O1xuICAgICAgICB0ZXh0dXJlLnNyYyhkZWYueCwgZGVmLnksIGRlZi53aWR0aCwgZGVmLmhlaWdodCk7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmaW5kKHF1ZXJ5KSB7XG4gICAgICAgIGlmICh0ZXh0dXJlcykge1xuICAgICAgICAgIGlmIChpc18xLmZuKHRleHR1cmVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHR1cmVzKHF1ZXJ5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzXzEuaGFzaCh0ZXh0dXJlcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlc1txdWVyeV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXRvdXRzKSB7IC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbCwgbiA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXRvdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc3RyaW5nLnN0YXJ0c1dpdGgoY3V0b3V0c1tpXS5uYW1lLCBxdWVyeSkpIHtcbiAgICAgICAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjdXRvdXRzW2ldO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbIHJlc3VsdCwgY3V0b3V0c1tpXSBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1dG91dHNbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG4gPT09IDAgJiYgaXNfMS5mbihmYWN0b3J5KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb24oc3VicXVlcnkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkocXVlcnkgKyAoc3VicXVlcnkgPyBzdWJxdWVyeSA6ICcnKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2VsZWN0ID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgaWYgKCFxdWVyeSkge1xuICAgICAgICAgIC8vIFRPRE86IGlmIGB0ZXh0dXJlc2AgaXMgdGV4dHVyZSBkZWYsIG1hcCBvciBmbj9cbiAgICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLnBpcGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvdW5kID0gZmluZChxdWVyeSk7XG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKGZvdW5kLCBmaW5kLCBtYWtlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIH1cbiAgICB2YXIgbmZUZXh0dXJlID0gbmV3IHRleHR1cmUoKTtcbiAgICBuZlRleHR1cmUueCA9IG5mVGV4dHVyZS55ID0gbmZUZXh0dXJlLndpZHRoID0gbmZUZXh0dXJlLmhlaWdodCA9IDA7XG4gICAgbmZUZXh0dXJlLnBpcGUgPSBuZlRleHR1cmUuc3JjID0gbmZUZXh0dXJlLmRlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgbmZUZXh0dXJlLmRyYXcgPSBmdW5jdGlvbigpIHtcbiAgICB9O1xuXG4gICAgdmFyIG5mU2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbihuZlRleHR1cmUpO1xuXG4gICAgZnVuY3Rpb24gU2VsZWN0aW9uKHJlc3VsdCwgZmluZCwgbWFrZSkge1xuICAgICAgZnVuY3Rpb24gbGluayhyZXN1bHQsIHN1YnF1ZXJ5KSB7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIG5mVGV4dHVyZTtcblxuICAgICAgICB9IGVsc2UgaWYgKGlzXzEuZm4ocmVzdWx0LmRyYXcpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB9IGVsc2UgaWYgKGlzXzEuaGFzaChyZXN1bHQpICYmIGlzXzEubnVtYmVyKHJlc3VsdC53aWR0aClcbiAgICAgICAgICAgICYmIGlzXzEubnVtYmVyKHJlc3VsdC5oZWlnaHQpICYmIGlzXzEuZm4obWFrZSkpIHtcbiAgICAgICAgICByZXR1cm4gbWFrZShyZXN1bHQpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNfMS5oYXNoKHJlc3VsdCkgJiYgaXNfMS5kZWZpbmVkKHN1YnF1ZXJ5KSkge1xuICAgICAgICAgIHJldHVybiBsaW5rKHJlc3VsdFtzdWJxdWVyeV0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNfMS5mbihyZXN1bHQpKSB7XG4gICAgICAgICAgcmV0dXJuIGxpbmsocmVzdWx0KHN1YnF1ZXJ5KSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChpc18xLmFycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICByZXR1cm4gbGluayhyZXN1bHRbMF0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNfMS5zdHJpbmcocmVzdWx0KSAmJiBpc18xLmZuKGZpbmQpKSB7XG4gICAgICAgICAgcmV0dXJuIGxpbmsoZmluZChyZXN1bHQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm9uZSA9IGZ1bmN0aW9uKHN1YnF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBsaW5rKHJlc3VsdCwgc3VicXVlcnkpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5hcnJheSA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgICB2YXIgYXJyYXkgPSBpc18xLmFycmF5KGFycikgPyBhcnIgOiBbXTtcbiAgICAgICAgaWYgKGlzXzEuYXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtpXSA9IGxpbmsocmVzdWx0W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyYXlbMF0gPSBsaW5rKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb3JlLnRleHR1cmUgPSBmdW5jdGlvbihxdWVyeSkge1xuICAgICAgaWYgKCFpc18xLnN0cmluZyhxdWVyeSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ocXVlcnkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gbnVsbCwgYXRsYXMsIGk7XG5cbiAgICAgIGlmICgoaSA9IHF1ZXJ5LmluZGV4T2YoJzonKSkgPiAwICYmIHF1ZXJ5Lmxlbmd0aCA+IGkgKyAxKSB7XG4gICAgICAgIGF0bGFzID0gX2F0bGFzZXNfbWFwW3F1ZXJ5LnNsaWNlKDAsIGkpXTtcbiAgICAgICAgcmVzdWx0ID0gYXRsYXMgJiYgYXRsYXMuc2VsZWN0KHF1ZXJ5LnNsaWNlKGkgKyAxKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzdWx0ICYmIChhdGxhcyA9IF9hdGxhc2VzX21hcFtxdWVyeV0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGF0bGFzLnNlbGVjdCgpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyAhcmVzdWx0ICYmIGkgPCBfYXRsYXNlc19hcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gX2F0bGFzZXNfYXJyW2ldLnNlbGVjdChxdWVyeSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RleHR1cmUgbm90IGZvdW5kOiAnICsgcXVlcnkpO1xuICAgICAgICByZXN1bHQgPSBuZlNlbGVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZChoYXNoLCBuYW1lLCBtc2cpIHtcbiAgICAgIGlmIChuYW1lIGluIGhhc2gpXG4gICAgICAgIGNvbnNvbGUubG9nKG1zZyA/IG1zZy5yZXBsYWNlKCclbmFtZScsIG5hbWUpIDogJ1xcJycgKyBuYW1lXG4gICAgICAgICAgICArICdcXCcgZmllbGQgb2YgdGV4dHVyZSBhdGxhcyBpcyBkZXByZWNhdGVkLicpO1xuICAgIH1cblxuICAgIHZhciBpaWQkMSA9IDA7XG5cbiAgICAvLyBUT0RPOiBkbyBub3QgY2xlYXIgbmV4dC9wcmV2L3BhcmVudCBvbiByZW1vdmVcblxuICAgIGNvcmUucHJvdG90eXBlLl9sYWJlbCA9ICcnO1xuXG4gICAgY29yZS5wcm90b3R5cGUuX3Zpc2libGUgPSB0cnVlO1xuXG4gICAgY29yZS5wcm90b3R5cGUuX3BhcmVudCA9IG51bGw7XG4gICAgY29yZS5wcm90b3R5cGUuX25leHQgPSBudWxsO1xuICAgIGNvcmUucHJvdG90eXBlLl9wcmV2ID0gbnVsbDtcblxuICAgIGNvcmUucHJvdG90eXBlLl9maXJzdCA9IG51bGw7XG4gICAgY29yZS5wcm90b3R5cGUuX2xhc3QgPSBudWxsO1xuXG4gICAgY29yZS5wcm90b3R5cGUuX2F0dHJzID0gbnVsbDtcbiAgICBjb3JlLnByb3RvdHlwZS5fZmxhZ3MgPSBudWxsO1xuXG4gICAgY29yZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnWycgKyB0aGlzLl9sYWJlbCArICddJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGxhYmVsKClcbiAgICAgKi9cbiAgICBjb3JlLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYWJlbChpZCk7XG4gICAgfTtcblxuICAgIGNvcmUucHJvdG90eXBlLmxhYmVsID0gZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgIGlmICh0eXBlb2YgbGFiZWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYWJlbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xhYmVsID0gbGFiZWw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgY29yZS5wcm90b3R5cGUuYXR0ciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXR0cnMgIT09IG51bGwgPyB0aGlzLl9hdHRyc1tuYW1lXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgICh0aGlzLl9hdHRycyAhPT0gbnVsbCA/IHRoaXMuX2F0dHJzIDogdGhpcy5fYXR0cnMgPSB7fSlbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBjb3JlLnByb3RvdHlwZS52aXNpYmxlID0gZnVuY3Rpb24odmlzaWJsZSkge1xuICAgICAgaWYgKHR5cGVvZiB2aXNpYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlO1xuICAgICAgdGhpcy5fcGFyZW50ICYmICh0aGlzLl9wYXJlbnQuX3RzX2NoaWxkcmVuID0gKytpaWQkMSk7XG4gICAgICB0aGlzLl90c19waW4gPSArK2lpZCQxO1xuICAgICAgdGhpcy50b3VjaCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNvcmUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2libGUoZmFsc2UpO1xuICAgIH07XG5cbiAgICBjb3JlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52aXNpYmxlKHRydWUpO1xuICAgIH07XG5cbiAgICBjb3JlLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgfTtcblxuICAgIGNvcmUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbih2aXNpYmxlKSB7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMuX25leHQ7XG4gICAgICB3aGlsZSAobmV4dCAmJiB2aXNpYmxlICYmICFuZXh0Ll92aXNpYmxlKSB7XG4gICAgICAgIG5leHQgPSBuZXh0Ll9uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcblxuICAgIGNvcmUucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbih2aXNpYmxlKSB7XG4gICAgICB2YXIgcHJldiA9IHRoaXMuX3ByZXY7XG4gICAgICB3aGlsZSAocHJldiAmJiB2aXNpYmxlICYmICFwcmV2Ll92aXNpYmxlKSB7XG4gICAgICAgIHByZXYgPSBwcmV2Ll9wcmV2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfTtcblxuICAgIGNvcmUucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24odmlzaWJsZSkge1xuICAgICAgdmFyIG5leHQgPSB0aGlzLl9maXJzdDtcbiAgICAgIHdoaWxlIChuZXh0ICYmIHZpc2libGUgJiYgIW5leHQuX3Zpc2libGUpIHtcbiAgICAgICAgbmV4dCA9IG5leHQuX25leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuXG4gICAgY29yZS5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKHZpc2libGUpIHtcbiAgICAgIHZhciBwcmV2ID0gdGhpcy5fbGFzdDtcbiAgICAgIHdoaWxlIChwcmV2ICYmIHZpc2libGUgJiYgIXByZXYuX3Zpc2libGUpIHtcbiAgICAgICAgcHJldiA9IHByZXYuX3ByZXY7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9O1xuXG4gICAgY29yZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbih2aXNpdG9yLCBkYXRhKSB7XG4gICAgICB2YXIgcmV2ZXJzZSA9IHZpc2l0b3IucmV2ZXJzZTtcbiAgICAgIHZhciB2aXNpYmxlID0gdmlzaXRvci52aXNpYmxlO1xuICAgICAgaWYgKHZpc2l0b3Iuc3RhcnQgJiYgdmlzaXRvci5zdGFydCh0aGlzLCBkYXRhKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGQsIG5leHQgPSByZXZlcnNlID8gdGhpcy5sYXN0KHZpc2libGUpIDogdGhpcy5maXJzdCh2aXNpYmxlKTtcbiAgICAgIHdoaWxlIChjaGlsZCA9IG5leHQpIHtcbiAgICAgICAgbmV4dCA9IHJldmVyc2UgPyBjaGlsZC5wcmV2KHZpc2libGUpIDogY2hpbGQubmV4dCh2aXNpYmxlKTtcbiAgICAgICAgaWYgKGNoaWxkLnZpc2l0KHZpc2l0b3IsIGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2aXNpdG9yLmVuZCAmJiB2aXNpdG9yLmVuZCh0aGlzLCBkYXRhKTtcbiAgICB9O1xuXG4gICAgY29yZS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oY2hpbGQsIG1vcmUpIHtcbiAgICAgIGlmIChpc18xLmFycmF5KGNoaWxkKSlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICBhcHBlbmQodGhpcywgY2hpbGRbaV0pO1xuXG4gICAgICBlbHNlIGlmICh0eXBlb2YgbW9yZSAhPT0gJ3VuZGVmaW5lZCcpIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgYXBwZW5kKHRoaXMsIGFyZ3VtZW50c1tpXSk7XG5cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIGFwcGVuZCh0aGlzLCBjaGlsZCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBjb3JlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24oY2hpbGQsIG1vcmUpIHtcbiAgICAgIGlmIChpc18xLmFycmF5KGNoaWxkKSlcbiAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgIHByZXBlbmQodGhpcywgY2hpbGRbaV0pO1xuXG4gICAgICBlbHNlIGlmICh0eXBlb2YgbW9yZSAhPT0gJ3VuZGVmaW5lZCcpIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICBwcmVwZW5kKHRoaXMsIGFyZ3VtZW50c1tpXSk7XG5cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHByZXBlbmQodGhpcywgY2hpbGQpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgY29yZS5wcm90b3R5cGUuYXBwZW5kVG8gPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgIGFwcGVuZChwYXJlbnQsIHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNvcmUucHJvdG90eXBlLnByZXBlbmRUbyA9IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgcHJlcGVuZChwYXJlbnQsIHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNvcmUucHJvdG90eXBlLmluc2VydE5leHQgPSBmdW5jdGlvbihzaWJsaW5nLCBtb3JlKSB7XG4gICAgICBpZiAoaXNfMS5hcnJheShzaWJsaW5nKSlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWJsaW5nLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIGluc2VydEFmdGVyKHNpYmxpbmdbaV0sIHRoaXMpO1xuXG4gICAgICBlbHNlIGlmICh0eXBlb2YgbW9yZSAhPT0gJ3VuZGVmaW5lZCcpIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgaW5zZXJ0QWZ0ZXIoYXJndW1lbnRzW2ldLCB0aGlzKTtcblxuICAgICAgZWxzZSBpZiAodHlwZW9mIHNpYmxpbmcgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBpbnNlcnRBZnRlcihzaWJsaW5nLCB0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNvcmUucHJvdG90eXBlLmluc2VydFByZXYgPSBmdW5jdGlvbihzaWJsaW5nLCBtb3JlKSB7XG4gICAgICBpZiAoaXNfMS5hcnJheShzaWJsaW5nKSlcbiAgICAgICAgZm9yICh2YXIgaSA9IHNpYmxpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgaW5zZXJ0QmVmb3JlKHNpYmxpbmdbaV0sIHRoaXMpO1xuXG4gICAgICBlbHNlIGlmICh0eXBlb2YgbW9yZSAhPT0gJ3VuZGVmaW5lZCcpIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICBpbnNlcnRCZWZvcmUoYXJndW1lbnRzW2ldLCB0aGlzKTtcblxuICAgICAgZWxzZSBpZiAodHlwZW9mIHNpYmxpbmcgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBpbnNlcnRCZWZvcmUoc2libGluZywgdGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBjb3JlLnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uKHByZXYpIHtcbiAgICAgIGluc2VydEFmdGVyKHRoaXMsIHByZXYpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNvcmUucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uKG5leHQpIHtcbiAgICAgIGluc2VydEJlZm9yZSh0aGlzLCBuZXh0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhcHBlbmQocGFyZW50LCBjaGlsZCkge1xuICAgICAgX2Vuc3VyZShjaGlsZCk7XG4gICAgICBfZW5zdXJlKHBhcmVudCk7XG5cbiAgICAgIGNoaWxkLnJlbW92ZSgpO1xuXG4gICAgICBpZiAocGFyZW50Ll9sYXN0KSB7XG4gICAgICAgIHBhcmVudC5fbGFzdC5fbmV4dCA9IGNoaWxkO1xuICAgICAgICBjaGlsZC5fcHJldiA9IHBhcmVudC5fbGFzdDtcbiAgICAgIH1cblxuICAgICAgY2hpbGQuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgIHBhcmVudC5fbGFzdCA9IGNoaWxkO1xuXG4gICAgICBpZiAoIXBhcmVudC5fZmlyc3QpIHtcbiAgICAgICAgcGFyZW50Ll9maXJzdCA9IGNoaWxkO1xuICAgICAgfVxuXG4gICAgICBjaGlsZC5fcGFyZW50Ll9mbGFnKGNoaWxkLCB0cnVlKTtcblxuICAgICAgY2hpbGQuX3RzX3BhcmVudCA9ICsraWlkJDE7XG4gICAgICBwYXJlbnQuX3RzX2NoaWxkcmVuID0gKytpaWQkMTtcbiAgICAgIHBhcmVudC50b3VjaCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBlbmQocGFyZW50LCBjaGlsZCkge1xuICAgICAgX2Vuc3VyZShjaGlsZCk7XG4gICAgICBfZW5zdXJlKHBhcmVudCk7XG5cbiAgICAgIGNoaWxkLnJlbW92ZSgpO1xuXG4gICAgICBpZiAocGFyZW50Ll9maXJzdCkge1xuICAgICAgICBwYXJlbnQuX2ZpcnN0Ll9wcmV2ID0gY2hpbGQ7XG4gICAgICAgIGNoaWxkLl9uZXh0ID0gcGFyZW50Ll9maXJzdDtcbiAgICAgIH1cblxuICAgICAgY2hpbGQuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgIHBhcmVudC5fZmlyc3QgPSBjaGlsZDtcblxuICAgICAgaWYgKCFwYXJlbnQuX2xhc3QpIHtcbiAgICAgICAgcGFyZW50Ll9sYXN0ID0gY2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkLl9wYXJlbnQuX2ZsYWcoY2hpbGQsIHRydWUpO1xuXG4gICAgICBjaGlsZC5fdHNfcGFyZW50ID0gKytpaWQkMTtcbiAgICAgIHBhcmVudC5fdHNfY2hpbGRyZW4gPSArK2lpZCQxO1xuICAgICAgcGFyZW50LnRvdWNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluc2VydEJlZm9yZShzZWxmLCBuZXh0KSB7XG4gICAgICBfZW5zdXJlKHNlbGYpO1xuICAgICAgX2Vuc3VyZShuZXh0KTtcblxuICAgICAgc2VsZi5yZW1vdmUoKTtcblxuICAgICAgdmFyIHBhcmVudCA9IG5leHQuX3BhcmVudDtcbiAgICAgIHZhciBwcmV2ID0gbmV4dC5fcHJldjtcblxuICAgICAgbmV4dC5fcHJldiA9IHNlbGY7XG4gICAgICBwcmV2ICYmIChwcmV2Ll9uZXh0ID0gc2VsZikgfHwgcGFyZW50ICYmIChwYXJlbnQuX2ZpcnN0ID0gc2VsZik7XG5cbiAgICAgIHNlbGYuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgIHNlbGYuX3ByZXYgPSBwcmV2O1xuICAgICAgc2VsZi5fbmV4dCA9IG5leHQ7XG5cbiAgICAgIHNlbGYuX3BhcmVudC5fZmxhZyhzZWxmLCB0cnVlKTtcblxuICAgICAgc2VsZi5fdHNfcGFyZW50ID0gKytpaWQkMTtcbiAgICAgIHNlbGYudG91Y2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIoc2VsZiwgcHJldikge1xuICAgICAgX2Vuc3VyZShzZWxmKTtcbiAgICAgIF9lbnN1cmUocHJldik7XG5cbiAgICAgIHNlbGYucmVtb3ZlKCk7XG5cbiAgICAgIHZhciBwYXJlbnQgPSBwcmV2Ll9wYXJlbnQ7XG4gICAgICB2YXIgbmV4dCA9IHByZXYuX25leHQ7XG5cbiAgICAgIHByZXYuX25leHQgPSBzZWxmO1xuICAgICAgbmV4dCAmJiAobmV4dC5fcHJldiA9IHNlbGYpIHx8IHBhcmVudCAmJiAocGFyZW50Ll9sYXN0ID0gc2VsZik7XG5cbiAgICAgIHNlbGYuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgIHNlbGYuX3ByZXYgPSBwcmV2O1xuICAgICAgc2VsZi5fbmV4dCA9IG5leHQ7XG5cbiAgICAgIHNlbGYuX3BhcmVudC5fZmxhZyhzZWxmLCB0cnVlKTtcblxuICAgICAgc2VsZi5fdHNfcGFyZW50ID0gKytpaWQkMTtcbiAgICAgIHNlbGYudG91Y2goKTtcbiAgICB9XG4gICAgY29yZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oY2hpbGQsIG1vcmUpIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChpc18xLmFycmF5KGNoaWxkKSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBfZW5zdXJlKGNoaWxkW2ldKS5yZW1vdmUoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb3JlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgX2Vuc3VyZShhcmd1bWVudHNbaV0pLnJlbW92ZSgpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2Vuc3VyZShjaGlsZCkucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wcmV2KSB7XG4gICAgICAgIHRoaXMuX3ByZXYuX25leHQgPSB0aGlzLl9uZXh0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX25leHQpIHtcbiAgICAgICAgdGhpcy5fbmV4dC5fcHJldiA9IHRoaXMuX3ByZXY7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudC5fZmlyc3QgPT09IHRoaXMpIHtcbiAgICAgICAgICB0aGlzLl9wYXJlbnQuX2ZpcnN0ID0gdGhpcy5fbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGFyZW50Ll9sYXN0ID09PSB0aGlzKSB7XG4gICAgICAgICAgdGhpcy5fcGFyZW50Ll9sYXN0ID0gdGhpcy5fcHJldjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BhcmVudC5fZmxhZyh0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5fcGFyZW50Ll90c19jaGlsZHJlbiA9ICsraWlkJDE7XG4gICAgICAgIHRoaXMuX3BhcmVudC50b3VjaCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcmV2ID0gdGhpcy5fbmV4dCA9IHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICB0aGlzLl90c19wYXJlbnQgPSArK2lpZCQxO1xuICAgICAgLy8gdGhpcy5fcGFyZW50LnRvdWNoKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBjb3JlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoaWxkLCBuZXh0ID0gdGhpcy5fZmlyc3Q7XG4gICAgICB3aGlsZSAoY2hpbGQgPSBuZXh0KSB7XG4gICAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcbiAgICAgICAgY2hpbGQuX3ByZXYgPSBjaGlsZC5fbmV4dCA9IGNoaWxkLl9wYXJlbnQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2ZsYWcoY2hpbGQsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZmlyc3QgPSB0aGlzLl9sYXN0ID0gbnVsbDtcblxuICAgICAgdGhpcy5fdHNfY2hpbGRyZW4gPSArK2lpZCQxO1xuICAgICAgdGhpcy50b3VjaCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNvcmUucHJvdG90eXBlLnRvdWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl90c190b3VjaCA9ICsraWlkJDE7XG4gICAgICB0aGlzLl9wYXJlbnQgJiYgdGhpcy5fcGFyZW50LnRvdWNoKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVlcCBmbGFncyB1c2VkIGZvciBvcHRpbWl6aW5nIGV2ZW50IGRpc3RyaWJ1dGlvbi5cbiAgICAgKi9cbiAgICBjb3JlLnByb3RvdHlwZS5fZmxhZyA9IGZ1bmN0aW9uKG9iaiwgbmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmxhZ3MgIT09IG51bGwgJiYgdGhpcy5fZmxhZ3Nbb2JqXSB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgdGhpcy5fZmxhZ3MgPSB0aGlzLl9mbGFncyB8fCB7fTtcbiAgICAgICAgICBpZiAoIXRoaXMuX2ZsYWdzW29ial0gJiYgdGhpcy5fcGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQuX2ZsYWcob2JqLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZmxhZ3Nbb2JqXSA9ICh0aGlzLl9mbGFnc1tvYmpdIHx8IDApICsgMTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzICYmIHRoaXMuX2ZsYWdzW29ial0gPiAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2ZsYWdzW29ial0gPT0gMSAmJiB0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fZmxhZyhvYmosIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZmxhZ3Nbb2JqXSA9IHRoaXMuX2ZsYWdzW29ial0gLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKG9iai5fZmxhZ3MpIHtcbiAgICAgICAgICBmb3IgKCB2YXIgdHlwZSBpbiBvYmouX2ZsYWdzKSB7XG4gICAgICAgICAgICBpZiAob2JqLl9mbGFnc1t0eXBlXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fZmxhZyh0eXBlLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvcmUucHJvdG90eXBlLmhpdFRlc3QgPSBmdW5jdGlvbihoaXQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuX3Bpbi5fd2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5fcGluLl9oZWlnaHQ7XG4gICAgICByZXR1cm4gaGl0LnggPj0gMCAmJiBoaXQueCA8PSB3aWR0aCAmJiBoaXQueSA+PSAwICYmIGhpdC55IDw9IGhlaWdodDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2Vuc3VyZShvYmopIHtcbiAgICAgIGlmIChvYmogJiYgb2JqIGluc3RhbmNlb2YgY29yZSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgICAgdGhyb3cgJ0ludmFsaWQgbm9kZTogJyArIG9iajtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnQgPSBmdW5jdGlvbihwcm90b3R5cGUsIGNhbGxiYWNrKSB7XG5cbiAgICAgIHByb3RvdHlwZS5fbGlzdGVuZXJzID0gbnVsbDtcblxuICAgICAgcHJvdG90eXBlLm9uID0gcHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uKHR5cGVzLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXR5cGVzIHx8ICF0eXBlcy5sZW5ndGggfHwgdHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc2FycmF5ID0gdHlwZW9mIHR5cGVzICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdHlwZXMuam9pbiA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgaWYgKHR5cGVzID0gKGlzYXJyYXkgPyB0eXBlcy5qb2luKCcgJykgOiB0eXBlcykubWF0Y2goL1xcUysvZykpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBjYWxsYmFjayh0aGlzLCB0eXBlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICBwcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZXMsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdHlwZXMgfHwgIXR5cGVzLmxlbmd0aCB8fCB0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzYXJyYXkgPSB0eXBlb2YgdHlwZXMgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB0eXBlcy5qb2luID09PSAnZnVuY3Rpb24nO1xuICAgICAgICBpZiAodHlwZXMgPSAoaXNhcnJheSA/IHR5cGVzLmpvaW4oJyAnKSA6IHR5cGVzKS5tYXRjaCgvXFxTKy9nKSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV0sIGFsbCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSwgaW5kZXg7XG4gICAgICAgICAgICBpZiAoYWxsICYmIChpbmRleCA9IGFsbC5pbmRleE9mKGxpc3RlbmVyKSkgPj0gMCkge1xuICAgICAgICAgICAgICBhbGwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgaWYgKCFhbGwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodGhpcywgdHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgcHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycyAmJiB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gICAgICB9O1xuXG4gICAgICBwcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzKG5hbWUpO1xuICAgICAgICBpZiAoIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGlzdGVuZXJzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgbGlzdGVuZXJzW2xdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgfTtcblxuICAgICAgcHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihuYW1lLCBhcmdzKSB7XG4gICAgICAgIHRoaXMucHVibGlzaChuYW1lLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgfTtcblxuICAgIGV2ZW50KGNvcmUucHJvdG90eXBlLCBmdW5jdGlvbihvYmosIG5hbWUsIG9uKSB7XG4gICAgICBvYmouX2ZsYWcobmFtZSwgb24pO1xuICAgIH0pO1xuXG4gICAgdmFyIGlpZCA9IDA7XG5cbiAgICBjb3JlLl9pbml0KGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcGluID0gbmV3IFBpbih0aGlzKTtcbiAgICB9KTtcblxuICAgIGNvcmUucHJvdG90eXBlLm1hdHJpeCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gICAgICBpZiAocmVsYXRpdmUgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpbi5yZWxhdGl2ZU1hdHJpeCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3Bpbi5hYnNvbHV0ZU1hdHJpeCgpO1xuICAgIH07XG5cbiAgICBjb3JlLnByb3RvdHlwZS5waW4gPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMuX3Bpbi5zZXQoYSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Bpbi5nZXQoYSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcGluLnNldChhLCBiKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BpbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUGluKG93bmVyKSB7XG5cbiAgICAgIHRoaXMuX293bmVyID0gb3duZXI7XG4gICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuXG4gICAgICAvLyByZWxhdGl2ZSB0byBwYXJlbnRcbiAgICAgIHRoaXMuX3JlbGF0aXZlTWF0cml4ID0gbmV3IG1hdHJpeCgpO1xuXG4gICAgICAvLyByZWxhdGl2ZSB0byBzdGFnZVxuICAgICAgdGhpcy5fYWJzb2x1dGVNYXRyaXggPSBuZXcgbWF0cml4KCk7XG5cbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgUGluLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLl90ZXh0dXJlQWxwaGEgPSAxO1xuICAgICAgdGhpcy5fYWxwaGEgPSAxO1xuXG4gICAgICB0aGlzLl93aWR0aCA9IDA7XG4gICAgICB0aGlzLl9oZWlnaHQgPSAwO1xuXG4gICAgICB0aGlzLl9zY2FsZVggPSAxO1xuICAgICAgdGhpcy5fc2NhbGVZID0gMTtcbiAgICAgIHRoaXMuX3NrZXdYID0gMDtcbiAgICAgIHRoaXMuX3NrZXdZID0gMDtcbiAgICAgIHRoaXMuX3JvdGF0aW9uID0gMDtcblxuICAgICAgLy8gc2NhbGUvc2tldy9yb3RhdGUgY2VudGVyXG4gICAgICB0aGlzLl9waXZvdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9waXZvdFggPSBudWxsO1xuICAgICAgdGhpcy5fcGl2b3RZID0gbnVsbDtcblxuICAgICAgLy8gc2VsZiBwaW4gcG9pbnRcbiAgICAgIHRoaXMuX2hhbmRsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2hhbmRsZVggPSAwO1xuICAgICAgdGhpcy5faGFuZGxlWSA9IDA7XG5cbiAgICAgIC8vIHBhcmVudCBwaW4gcG9pbnRcbiAgICAgIHRoaXMuX2FsaWduZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FsaWduWCA9IDA7XG4gICAgICB0aGlzLl9hbGlnblkgPSAwO1xuXG4gICAgICAvLyBhcyBzZWVuIGJ5IHBhcmVudCBweFxuICAgICAgdGhpcy5fb2Zmc2V0WCA9IDA7XG4gICAgICB0aGlzLl9vZmZzZXRZID0gMDtcblxuICAgICAgdGhpcy5fYm94WCA9IDA7XG4gICAgICB0aGlzLl9ib3hZID0gMDtcbiAgICAgIHRoaXMuX2JveFdpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgICB0aGlzLl9ib3hIZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgICAgIC8vIFRPRE86IGFsc28gc2V0IGZvciBvd25lclxuICAgICAgdGhpcy5fdHNfdHJhbnNsYXRlID0gKytpaWQ7XG4gICAgICB0aGlzLl90c190cmFuc2Zvcm0gPSArK2lpZDtcbiAgICAgIHRoaXMuX3RzX21hdHJpeCA9ICsraWlkO1xuICAgIH07XG5cbiAgICBQaW4ucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3BhcmVudCA9IHRoaXMuX293bmVyLl9wYXJlbnQgJiYgdGhpcy5fb3duZXIuX3BhcmVudC5fcGluO1xuXG4gICAgICAvLyBpZiBoYW5kbGVkIGFuZCB0cmFuc2Zvcm1lZCB0aGVuIGJlIHRyYW5zbGF0ZWRcbiAgICAgIGlmICh0aGlzLl9oYW5kbGVkICYmIHRoaXMuX21vX2hhbmRsZSAhPSB0aGlzLl90c190cmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5fbW9faGFuZGxlID0gdGhpcy5fdHNfdHJhbnNmb3JtO1xuICAgICAgICB0aGlzLl90c190cmFuc2xhdGUgPSArK2lpZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2FsaWduZWQgJiYgdGhpcy5fcGFyZW50XG4gICAgICAgICAgJiYgdGhpcy5fbW9fYWxpZ24gIT0gdGhpcy5fcGFyZW50Ll90c190cmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5fbW9fYWxpZ24gPSB0aGlzLl9wYXJlbnQuX3RzX3RyYW5zZm9ybTtcbiAgICAgICAgdGhpcy5fdHNfdHJhbnNsYXRlID0gKytpaWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBQaW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3duZXIgKyAnICgnICsgKHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5fb3duZXIgOiBudWxsKSArICcpJztcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogdHMgZmllbGRzIHJlcXVpcmUgcmVmYWN0b3JpbmdcblxuICAgIFBpbi5wcm90b3R5cGUuYWJzb2x1dGVNYXRyaXggPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgdmFyIHRzID0gTWF0aC5tYXgoXG4gICAgICAgIHRoaXMuX3RzX3RyYW5zZm9ybSxcbiAgICAgICAgdGhpcy5fdHNfdHJhbnNsYXRlLFxuICAgICAgICB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuX3RzX21hdHJpeCA6IDBcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5fbW9fYWJzID09IHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hYnNvbHV0ZU1hdHJpeDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21vX2FicyA9IHRzO1xuXG4gICAgICB2YXIgYWJzID0gdGhpcy5fYWJzb2x1dGVNYXRyaXg7XG4gICAgICBhYnMucmVzZXQodGhpcy5yZWxhdGl2ZU1hdHJpeCgpKTtcblxuICAgICAgdGhpcy5fcGFyZW50ICYmIGFicy5jb25jYXQodGhpcy5fcGFyZW50Ll9hYnNvbHV0ZU1hdHJpeCk7XG5cbiAgICAgIHRoaXMuX3RzX21hdHJpeCA9ICsraWlkO1xuXG4gICAgICByZXR1cm4gYWJzO1xuICAgIH07XG5cbiAgICBQaW4ucHJvdG90eXBlLnJlbGF0aXZlTWF0cml4ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIHZhciB0cyA9IE1hdGgubWF4KHRoaXMuX3RzX3RyYW5zZm9ybSwgdGhpcy5fdHNfdHJhbnNsYXRlLFxuICAgICAgICAgIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5fdHNfdHJhbnNmb3JtIDogMCk7XG4gICAgICBpZiAodGhpcy5fbW9fcmVsID09IHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWxhdGl2ZU1hdHJpeDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21vX3JlbCA9IHRzO1xuXG4gICAgICB2YXIgcmVsID0gdGhpcy5fcmVsYXRpdmVNYXRyaXg7XG5cbiAgICAgIHJlbC5pZGVudGl0eSgpO1xuICAgICAgaWYgKHRoaXMuX3Bpdm90ZWQpIHtcbiAgICAgICAgcmVsLnRyYW5zbGF0ZSgtdGhpcy5fcGl2b3RYICogdGhpcy5fd2lkdGgsIC10aGlzLl9waXZvdFkgKiB0aGlzLl9oZWlnaHQpO1xuICAgICAgfVxuICAgICAgcmVsLnNjYWxlKHRoaXMuX3NjYWxlWCwgdGhpcy5fc2NhbGVZKTtcbiAgICAgIHJlbC5za2V3KHRoaXMuX3NrZXdYLCB0aGlzLl9za2V3WSk7XG4gICAgICByZWwucm90YXRlKHRoaXMuX3JvdGF0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9waXZvdGVkKSB7XG4gICAgICAgIHJlbC50cmFuc2xhdGUodGhpcy5fcGl2b3RYICogdGhpcy5fd2lkdGgsIHRoaXMuX3Bpdm90WSAqIHRoaXMuX2hlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSBlZmZlY3RpdmUgYm94XG4gICAgICBpZiAodGhpcy5fcGl2b3RlZCkge1xuICAgICAgICAvLyBvcmlnaW5cbiAgICAgICAgdGhpcy5fYm94WCA9IDA7XG4gICAgICAgIHRoaXMuX2JveFkgPSAwO1xuICAgICAgICB0aGlzLl9ib3hXaWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICB0aGlzLl9ib3hIZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFhYmJcbiAgICAgICAgdmFyIHAsIHE7XG4gICAgICAgIGlmIChyZWwuYSA+IDAgJiYgcmVsLmMgPiAwIHx8IHJlbC5hIDwgMCAmJiByZWwuYyA8IDApIHtcbiAgICAgICAgICBwID0gMCwgcSA9IHJlbC5hICogdGhpcy5fd2lkdGggKyByZWwuYyAqIHRoaXMuX2hlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwID0gcmVsLmEgKiB0aGlzLl93aWR0aCwgcSA9IHJlbC5jICogdGhpcy5faGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID4gcSkge1xuICAgICAgICAgIHRoaXMuX2JveFggPSBxO1xuICAgICAgICAgIHRoaXMuX2JveFdpZHRoID0gcCAtIHE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fYm94WCA9IHA7XG4gICAgICAgICAgdGhpcy5fYm94V2lkdGggPSBxIC0gcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsLmIgPiAwICYmIHJlbC5kID4gMCB8fCByZWwuYiA8IDAgJiYgcmVsLmQgPCAwKSB7XG4gICAgICAgICAgcCA9IDAsIHEgPSByZWwuYiAqIHRoaXMuX3dpZHRoICsgcmVsLmQgKiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcCA9IHJlbC5iICogdGhpcy5fd2lkdGgsIHEgPSByZWwuZCAqIHRoaXMuX2hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA+IHEpIHtcbiAgICAgICAgICB0aGlzLl9ib3hZID0gcTtcbiAgICAgICAgICB0aGlzLl9ib3hIZWlnaHQgPSBwIC0gcTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9ib3hZID0gcDtcbiAgICAgICAgICB0aGlzLl9ib3hIZWlnaHQgPSBxIC0gcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl94ID0gdGhpcy5fb2Zmc2V0WDtcbiAgICAgIHRoaXMuX3kgPSB0aGlzLl9vZmZzZXRZO1xuXG4gICAgICB0aGlzLl94IC09IHRoaXMuX2JveFggKyB0aGlzLl9oYW5kbGVYICogdGhpcy5fYm94V2lkdGg7XG4gICAgICB0aGlzLl95IC09IHRoaXMuX2JveFkgKyB0aGlzLl9oYW5kbGVZICogdGhpcy5fYm94SGVpZ2h0O1xuXG4gICAgICBpZiAodGhpcy5fYWxpZ25lZCAmJiB0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50LnJlbGF0aXZlTWF0cml4KCk7XG4gICAgICAgIHRoaXMuX3ggKz0gdGhpcy5fYWxpZ25YICogdGhpcy5fcGFyZW50Ll93aWR0aDtcbiAgICAgICAgdGhpcy5feSArPSB0aGlzLl9hbGlnblkgKiB0aGlzLl9wYXJlbnQuX2hlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmVsLnRyYW5zbGF0ZSh0aGlzLl94LCB0aGlzLl95KTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlbGF0aXZlTWF0cml4O1xuICAgIH07XG5cbiAgICBQaW4ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBnZXR0ZXJzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGdldHRlcnNba2V5XSh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVE9ETzogVXNlIGRlZmluZVByb3BlcnR5IGluc3RlYWQ/IFdoYXQgYWJvdXQgbXVsdGktZmllbGQgcGlubmluZz9cbiAgICBQaW4ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0ZXJzW2FdID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBiICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHNldHRlcnNbYV0odGhpcywgYik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAoYiBpbiBhKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzZXR0ZXJzW2JdID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBhW2JdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2V0dGVyc1tiXSh0aGlzLCBhW2JdLCBhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9vd25lcikge1xuICAgICAgICB0aGlzLl9vd25lci5fdHNfcGluID0gKytpaWQ7XG4gICAgICAgIHRoaXMuX293bmVyLnRvdWNoKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdmFyIGdldHRlcnMgPSB7XG4gICAgICBhbHBoYSA6IGZ1bmN0aW9uKHBpbikge1xuICAgICAgICByZXR1cm4gcGluLl9hbHBoYTtcbiAgICAgIH0sXG5cbiAgICAgIHRleHR1cmVBbHBoYSA6IGZ1bmN0aW9uKHBpbikge1xuICAgICAgICByZXR1cm4gcGluLl90ZXh0dXJlQWxwaGE7XG4gICAgICB9LFxuXG4gICAgICB3aWR0aCA6IGZ1bmN0aW9uKHBpbikge1xuICAgICAgICByZXR1cm4gcGluLl93aWR0aDtcbiAgICAgIH0sXG5cbiAgICAgIGhlaWdodCA6IGZ1bmN0aW9uKHBpbikge1xuICAgICAgICByZXR1cm4gcGluLl9oZWlnaHQ7XG4gICAgICB9LFxuXG4gICAgICBib3hXaWR0aCA6IGZ1bmN0aW9uKHBpbikge1xuICAgICAgICByZXR1cm4gcGluLl9ib3hXaWR0aDtcbiAgICAgIH0sXG5cbiAgICAgIGJveEhlaWdodCA6IGZ1bmN0aW9uKHBpbikge1xuICAgICAgICByZXR1cm4gcGluLl9ib3hIZWlnaHQ7XG4gICAgICB9LFxuXG4gICAgICAvLyBzY2FsZSA6IGZ1bmN0aW9uKHBpbikge1xuICAgICAgLy8gfSxcblxuICAgICAgc2NhbGVYIDogZnVuY3Rpb24ocGluKSB7XG4gICAgICAgIHJldHVybiBwaW4uX3NjYWxlWDtcbiAgICAgIH0sXG5cbiAgICAgIHNjYWxlWSA6IGZ1bmN0aW9uKHBpbikge1xuICAgICAgICByZXR1cm4gcGluLl9zY2FsZVk7XG4gICAgICB9LFxuXG4gICAgICAvLyBza2V3IDogZnVuY3Rpb24ocGluKSB7XG4gICAgICAvLyB9LFxuXG4gICAgICBza2V3WCA6IGZ1bmN0aW9uKHBpbikge1xuICAgICAgICByZXR1cm4gcGluLl9za2V3WDtcbiAgICAgIH0sXG5cbiAgICAgIHNrZXdZIDogZnVuY3Rpb24ocGluKSB7XG4gICAgICAgIHJldHVybiBwaW4uX3NrZXdZO1xuICAgICAgfSxcblxuICAgICAgcm90YXRpb24gOiBmdW5jdGlvbihwaW4pIHtcbiAgICAgICAgcmV0dXJuIHBpbi5fcm90YXRpb247XG4gICAgICB9LFxuXG4gICAgICAvLyBwaXZvdCA6IGZ1bmN0aW9uKHBpbikge1xuICAgICAgLy8gfSxcblxuICAgICAgcGl2b3RYIDogZnVuY3Rpb24ocGluKSB7XG4gICAgICAgIHJldHVybiBwaW4uX3Bpdm90WDtcbiAgICAgIH0sXG5cbiAgICAgIHBpdm90WSA6IGZ1bmN0aW9uKHBpbikge1xuICAgICAgICByZXR1cm4gcGluLl9waXZvdFk7XG4gICAgICB9LFxuXG4gICAgICAvLyBvZmZzZXQgOiBmdW5jdGlvbihwaW4pIHtcbiAgICAgIC8vIH0sXG5cbiAgICAgIG9mZnNldFggOiBmdW5jdGlvbihwaW4pIHtcbiAgICAgICAgcmV0dXJuIHBpbi5fb2Zmc2V0WDtcbiAgICAgIH0sXG5cbiAgICAgIG9mZnNldFkgOiBmdW5jdGlvbihwaW4pIHtcbiAgICAgICAgcmV0dXJuIHBpbi5fb2Zmc2V0WTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIGFsaWduIDogZnVuY3Rpb24ocGluKSB7XG4gICAgICAvLyB9LFxuXG4gICAgICBhbGlnblggOiBmdW5jdGlvbihwaW4pIHtcbiAgICAgICAgcmV0dXJuIHBpbi5fYWxpZ25YO1xuICAgICAgfSxcblxuICAgICAgYWxpZ25ZIDogZnVuY3Rpb24ocGluKSB7XG4gICAgICAgIHJldHVybiBwaW4uX2FsaWduWTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIGhhbmRsZSA6IGZ1bmN0aW9uKHBpbikge1xuICAgICAgLy8gfSxcblxuICAgICAgaGFuZGxlWCA6IGZ1bmN0aW9uKHBpbikge1xuICAgICAgICByZXR1cm4gcGluLl9oYW5kbGVYO1xuICAgICAgfSxcblxuICAgICAgaGFuZGxlWSA6IGZ1bmN0aW9uKHBpbikge1xuICAgICAgICByZXR1cm4gcGluLl9oYW5kbGVZO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc2V0dGVycyA9IHtcbiAgICAgIGFscGhhIDogZnVuY3Rpb24ocGluLCB2YWx1ZSkge1xuICAgICAgICBwaW4uX2FscGhhID0gdmFsdWU7XG4gICAgICB9LFxuXG4gICAgICB0ZXh0dXJlQWxwaGEgOiBmdW5jdGlvbihwaW4sIHZhbHVlKSB7XG4gICAgICAgIHBpbi5fdGV4dHVyZUFscGhhID0gdmFsdWU7XG4gICAgICB9LFxuXG4gICAgICB3aWR0aCA6IGZ1bmN0aW9uKHBpbiwgdmFsdWUpIHtcbiAgICAgICAgcGluLl93aWR0aF8gPSB2YWx1ZTtcbiAgICAgICAgcGluLl93aWR0aCA9IHZhbHVlO1xuICAgICAgICBwaW4uX3RzX3RyYW5zZm9ybSA9ICsraWlkO1xuICAgICAgfSxcblxuICAgICAgaGVpZ2h0IDogZnVuY3Rpb24ocGluLCB2YWx1ZSkge1xuICAgICAgICBwaW4uX2hlaWdodF8gPSB2YWx1ZTtcbiAgICAgICAgcGluLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICAgICAgcGluLl90c190cmFuc2Zvcm0gPSArK2lpZDtcbiAgICAgIH0sXG5cbiAgICAgIHNjYWxlIDogZnVuY3Rpb24ocGluLCB2YWx1ZSkge1xuICAgICAgICBwaW4uX3NjYWxlWCA9IHZhbHVlO1xuICAgICAgICBwaW4uX3NjYWxlWSA9IHZhbHVlO1xuICAgICAgICBwaW4uX3RzX3RyYW5zZm9ybSA9ICsraWlkO1xuICAgICAgfSxcblxuICAgICAgc2NhbGVYIDogZnVuY3Rpb24ocGluLCB2YWx1ZSkge1xuICAgICAgICBwaW4uX3NjYWxlWCA9IHZhbHVlO1xuICAgICAgICBwaW4uX3RzX3RyYW5zZm9ybSA9ICsraWlkO1xuICAgICAgfSxcblxuICAgICAgc2NhbGVZIDogZnVuY3Rpb24ocGluLCB2YWx1ZSkge1xuICAgICAgICBwaW4uX3NjYWxlWSA9IHZhbHVlO1xuICAgICAgICBwaW4uX3RzX3RyYW5zZm9ybSA9ICsraWlkO1xuICAgICAgfSxcblxuICAgICAgc2tldyA6IGZ1bmN0aW9uKHBpbiwgdmFsdWUpIHtcbiAgICAgICAgcGluLl9za2V3WCA9IHZhbHVlO1xuICAgICAgICBwaW4uX3NrZXdZID0gdmFsdWU7XG4gICAgICAgIHBpbi5fdHNfdHJhbnNmb3JtID0gKytpaWQ7XG4gICAgICB9LFxuXG4gICAgICBza2V3WCA6IGZ1bmN0aW9uKHBpbiwgdmFsdWUpIHtcbiAgICAgICAgcGluLl9za2V3WCA9IHZhbHVlO1xuICAgICAgICBwaW4uX3RzX3RyYW5zZm9ybSA9ICsraWlkO1xuICAgICAgfSxcblxuICAgICAgc2tld1kgOiBmdW5jdGlvbihwaW4sIHZhbHVlKSB7XG4gICAgICAgIHBpbi5fc2tld1kgPSB2YWx1ZTtcbiAgICAgICAgcGluLl90c190cmFuc2Zvcm0gPSArK2lpZDtcbiAgICAgIH0sXG5cbiAgICAgIHJvdGF0aW9uIDogZnVuY3Rpb24ocGluLCB2YWx1ZSkge1xuICAgICAgICBwaW4uX3JvdGF0aW9uID0gdmFsdWU7XG4gICAgICAgIHBpbi5fdHNfdHJhbnNmb3JtID0gKytpaWQ7XG4gICAgICB9LFxuXG4gICAgICBwaXZvdCA6IGZ1bmN0aW9uKHBpbiwgdmFsdWUpIHtcbiAgICAgICAgcGluLl9waXZvdFggPSB2YWx1ZTtcbiAgICAgICAgcGluLl9waXZvdFkgPSB2YWx1ZTtcbiAgICAgICAgcGluLl9waXZvdGVkID0gdHJ1ZTtcbiAgICAgICAgcGluLl90c190cmFuc2Zvcm0gPSArK2lpZDtcbiAgICAgIH0sXG5cbiAgICAgIHBpdm90WCA6IGZ1bmN0aW9uKHBpbiwgdmFsdWUpIHtcbiAgICAgICAgcGluLl9waXZvdFggPSB2YWx1ZTtcbiAgICAgICAgcGluLl9waXZvdGVkID0gdHJ1ZTtcbiAgICAgICAgcGluLl90c190cmFuc2Zvcm0gPSArK2lpZDtcbiAgICAgIH0sXG5cbiAgICAgIHBpdm90WSA6IGZ1bmN0aW9uKHBpbiwgdmFsdWUpIHtcbiAgICAgICAgcGluLl9waXZvdFkgPSB2YWx1ZTtcbiAgICAgICAgcGluLl9waXZvdGVkID0gdHJ1ZTtcbiAgICAgICAgcGluLl90c190cmFuc2Zvcm0gPSArK2lpZDtcbiAgICAgIH0sXG5cbiAgICAgIG9mZnNldCA6IGZ1bmN0aW9uKHBpbiwgdmFsdWUpIHtcbiAgICAgICAgcGluLl9vZmZzZXRYID0gdmFsdWU7XG4gICAgICAgIHBpbi5fb2Zmc2V0WSA9IHZhbHVlO1xuICAgICAgICBwaW4uX3RzX3RyYW5zbGF0ZSA9ICsraWlkO1xuICAgICAgfSxcblxuICAgICAgb2Zmc2V0WCA6IGZ1bmN0aW9uKHBpbiwgdmFsdWUpIHtcbiAgICAgICAgcGluLl9vZmZzZXRYID0gdmFsdWU7XG4gICAgICAgIHBpbi5fdHNfdHJhbnNsYXRlID0gKytpaWQ7XG4gICAgICB9LFxuXG4gICAgICBvZmZzZXRZIDogZnVuY3Rpb24ocGluLCB2YWx1ZSkge1xuICAgICAgICBwaW4uX29mZnNldFkgPSB2YWx1ZTtcbiAgICAgICAgcGluLl90c190cmFuc2xhdGUgPSArK2lpZDtcbiAgICAgIH0sXG5cbiAgICAgIGFsaWduIDogZnVuY3Rpb24ocGluLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmFsaWduWChwaW4sIHZhbHVlKTtcbiAgICAgICAgdGhpcy5hbGlnblkocGluLCB2YWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICBhbGlnblggOiBmdW5jdGlvbihwaW4sIHZhbHVlKSB7XG4gICAgICAgIHBpbi5fYWxpZ25YID0gdmFsdWU7XG4gICAgICAgIHBpbi5fYWxpZ25lZCA9IHRydWU7XG4gICAgICAgIHBpbi5fdHNfdHJhbnNsYXRlID0gKytpaWQ7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVYKHBpbiwgdmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgYWxpZ25ZIDogZnVuY3Rpb24ocGluLCB2YWx1ZSkge1xuICAgICAgICBwaW4uX2FsaWduWSA9IHZhbHVlO1xuICAgICAgICBwaW4uX2FsaWduZWQgPSB0cnVlO1xuICAgICAgICBwaW4uX3RzX3RyYW5zbGF0ZSA9ICsraWlkO1xuXG4gICAgICAgIHRoaXMuaGFuZGxlWShwaW4sIHZhbHVlKTtcbiAgICAgIH0sXG5cbiAgICAgIGhhbmRsZSA6IGZ1bmN0aW9uKHBpbiwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVYKHBpbiwgdmFsdWUpO1xuICAgICAgICB0aGlzLmhhbmRsZVkocGluLCB2YWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICBoYW5kbGVYIDogZnVuY3Rpb24ocGluLCB2YWx1ZSkge1xuICAgICAgICBwaW4uX2hhbmRsZVggPSB2YWx1ZTtcbiAgICAgICAgcGluLl9oYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgcGluLl90c190cmFuc2xhdGUgPSArK2lpZDtcbiAgICAgIH0sXG5cbiAgICAgIGhhbmRsZVkgOiBmdW5jdGlvbihwaW4sIHZhbHVlKSB7XG4gICAgICAgIHBpbi5faGFuZGxlWSA9IHZhbHVlO1xuICAgICAgICBwaW4uX2hhbmRsZWQgPSB0cnVlO1xuICAgICAgICBwaW4uX3RzX3RyYW5zbGF0ZSA9ICsraWlkO1xuICAgICAgfSxcblxuICAgICAgcmVzaXplTW9kZSA6IGZ1bmN0aW9uKHBpbiwgdmFsdWUsIGFsbCkge1xuICAgICAgICBpZiAoYWxsKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09ICdpbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJ2luLXBhZCc7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSAnb3V0Jykge1xuICAgICAgICAgICAgdmFsdWUgPSAnb3V0LWNyb3AnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY2FsZVRvKHBpbiwgYWxsLnJlc2l6ZVdpZHRoLCBhbGwucmVzaXplSGVpZ2h0LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHJlc2l6ZVdpZHRoIDogZnVuY3Rpb24ocGluLCB2YWx1ZSwgYWxsKSB7XG4gICAgICAgIGlmICghYWxsIHx8ICFhbGwucmVzaXplTW9kZSkge1xuICAgICAgICAgIHNjYWxlVG8ocGluLCB2YWx1ZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHJlc2l6ZUhlaWdodCA6IGZ1bmN0aW9uKHBpbiwgdmFsdWUsIGFsbCkge1xuICAgICAgICBpZiAoIWFsbCB8fCAhYWxsLnJlc2l6ZU1vZGUpIHtcbiAgICAgICAgICBzY2FsZVRvKHBpbiwgbnVsbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBzY2FsZU1vZGUgOiBmdW5jdGlvbihwaW4sIHZhbHVlLCBhbGwpIHtcbiAgICAgICAgaWYgKGFsbCkge1xuICAgICAgICAgIHNjYWxlVG8ocGluLCBhbGwuc2NhbGVXaWR0aCwgYWxsLnNjYWxlSGVpZ2h0LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHNjYWxlV2lkdGggOiBmdW5jdGlvbihwaW4sIHZhbHVlLCBhbGwpIHtcbiAgICAgICAgaWYgKCFhbGwgfHwgIWFsbC5zY2FsZU1vZGUpIHtcbiAgICAgICAgICBzY2FsZVRvKHBpbiwgdmFsdWUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBzY2FsZUhlaWdodCA6IGZ1bmN0aW9uKHBpbiwgdmFsdWUsIGFsbCkge1xuICAgICAgICBpZiAoIWFsbCB8fCAhYWxsLnNjYWxlTW9kZSkge1xuICAgICAgICAgIHNjYWxlVG8ocGluLCBudWxsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG1hdHJpeCA6IGZ1bmN0aW9uKHBpbiwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zY2FsZVgocGluLCB2YWx1ZS5hKTtcbiAgICAgICAgdGhpcy5za2V3WChwaW4sIHZhbHVlLmMgLyB2YWx1ZS5kKTtcbiAgICAgICAgdGhpcy5za2V3WShwaW4sIHZhbHVlLmIgLyB2YWx1ZS5hKTtcbiAgICAgICAgdGhpcy5zY2FsZVkocGluLCB2YWx1ZS5kKTtcbiAgICAgICAgdGhpcy5vZmZzZXRYKHBpbiwgdmFsdWUuZSk7XG4gICAgICAgIHRoaXMub2Zmc2V0WShwaW4sIHZhbHVlLmYpO1xuICAgICAgICB0aGlzLnJvdGF0aW9uKHBpbiwgMCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNjYWxlVG8ocGluLCB3aWR0aCwgaGVpZ2h0LCBtb2RlKSB7XG4gICAgICB2YXIgdyA9IHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcic7XG4gICAgICB2YXIgaCA9IHR5cGVvZiBoZWlnaHQgPT09ICdudW1iZXInO1xuICAgICAgdmFyIG0gPSB0eXBlb2YgbW9kZSA9PT0gJ3N0cmluZyc7XG4gICAgICBwaW4uX3RzX3RyYW5zZm9ybSA9ICsraWlkO1xuICAgICAgaWYgKHcpIHtcbiAgICAgICAgcGluLl9zY2FsZVggPSB3aWR0aCAvIHBpbi5fd2lkdGhfO1xuICAgICAgICBwaW4uX3dpZHRoID0gcGluLl93aWR0aF87XG4gICAgICB9XG4gICAgICBpZiAoaCkge1xuICAgICAgICBwaW4uX3NjYWxlWSA9IGhlaWdodCAvIHBpbi5faGVpZ2h0XztcbiAgICAgICAgcGluLl9oZWlnaHQgPSBwaW4uX2hlaWdodF87XG4gICAgICB9XG4gICAgICBpZiAodyAmJiBoICYmIG0pIHtcbiAgICAgICAgaWYgKG1vZGUgPT0gJ291dCcgfHwgbW9kZSA9PSAnb3V0LWNyb3AnKSB7XG4gICAgICAgICAgcGluLl9zY2FsZVggPSBwaW4uX3NjYWxlWSA9IE1hdGgubWF4KHBpbi5fc2NhbGVYLCBwaW4uX3NjYWxlWSk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSAnaW4nIHx8IG1vZGUgPT0gJ2luLXBhZCcpIHtcbiAgICAgICAgICBwaW4uX3NjYWxlWCA9IHBpbi5fc2NhbGVZID0gTWF0aC5taW4ocGluLl9zY2FsZVgsIHBpbi5fc2NhbGVZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kZSA9PSAnb3V0LWNyb3AnIHx8IG1vZGUgPT0gJ2luLXBhZCcpIHtcbiAgICAgICAgICBwaW4uX3dpZHRoID0gd2lkdGggLyBwaW4uX3NjYWxlWDtcbiAgICAgICAgICBwaW4uX2hlaWdodCA9IGhlaWdodCAvIHBpbi5fc2NhbGVZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvcmUucHJvdG90eXBlLnNjYWxlVG8gPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKVxuICAgICAgICBjID0gYiwgYiA9IGEueSwgYSA9IGEueDtcbiAgICAgIHNjYWxlVG8odGhpcy5fcGluLCBhLCBiLCBjKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBVc2VkIGJ5IFR3ZWVuIGNsYXNzXG4gICAgUGluLl9hZGRfc2hvcnRjdXRzID0gZnVuY3Rpb24oQ2xhc3MpIHtcbiAgICAgIENsYXNzLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24odywgaCkge1xuICAgICAgICB0aGlzLnBpbignd2lkdGgnLCB3KTtcbiAgICAgICAgdGhpcy5waW4oJ2hlaWdodCcsIGgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIENsYXNzLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBpbignd2lkdGgnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBpbignd2lkdGgnLCB3KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICBDbGFzcy5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oaCkge1xuICAgICAgICBpZiAodHlwZW9mIGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGluKCdoZWlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBpbignaGVpZ2h0JywgaCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgQ2xhc3MucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JylcbiAgICAgICAgICBiID0gYS55LCBhID0gYS54O1xuICAgICAgICB0aGlzLnBpbignb2Zmc2V0WCcsIGEpO1xuICAgICAgICB0aGlzLnBpbignb2Zmc2V0WScsIGIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIENsYXNzLnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIHRoaXMucGluKCdyb3RhdGlvbicsIGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIENsYXNzLnByb3RvdHlwZS5za2V3ID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKVxuICAgICAgICAgIGIgPSBhLnksIGEgPSBhLng7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBiID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICBiID0gYTtcbiAgICAgICAgdGhpcy5waW4oJ3NrZXdYJywgYSk7XG4gICAgICAgIHRoaXMucGluKCdza2V3WScsIGIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIENsYXNzLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JylcbiAgICAgICAgICBiID0gYS55LCBhID0gYS54O1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgYiA9IGE7XG4gICAgICAgIHRoaXMucGluKCdzY2FsZVgnLCBhKTtcbiAgICAgICAgdGhpcy5waW4oJ3NjYWxlWScsIGIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIENsYXNzLnByb3RvdHlwZS5hbHBoYSA9IGZ1bmN0aW9uKGEsIHRhKSB7XG4gICAgICAgIHRoaXMucGluKCdhbHBoYScsIGEpO1xuICAgICAgICBpZiAodHlwZW9mIHRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMucGluKCd0ZXh0dXJlQWxwaGEnLCB0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBQaW4uX2FkZF9zaG9ydGN1dHMoY29yZSk7XG5cbiAgICB2YXIgcGluID0gUGluO1xuXG4gICAgY29yZS5wcm90b3R5cGUuX3RleHR1cmVzID0gbnVsbDtcbiAgICBjb3JlLnByb3RvdHlwZS5fYWxwaGEgPSAxO1xuXG4gICAgY29yZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgaWYgKCF0aGlzLl92aXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YXRzLm5vZGUrKztcblxuICAgICAgdmFyIG0gPSB0aGlzLm1hdHJpeCgpO1xuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0obS5hLCBtLmIsIG0uYywgbS5kLCBtLmUsIG0uZik7XG5cbiAgICAgIC8vIG1vdmUgdGhpcyBlbHNld2hlcmUhXG4gICAgICB0aGlzLl9hbHBoYSA9IHRoaXMuX3Bpbi5fYWxwaGEgKiAodGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50Ll9hbHBoYSA6IDEpO1xuICAgICAgdmFyIGFscGhhID0gdGhpcy5fcGluLl90ZXh0dXJlQWxwaGEgKiB0aGlzLl9hbHBoYTtcblxuICAgICAgaWYgKGNvbnRleHQuZ2xvYmFsQWxwaGEgIT0gYWxwaGEpIHtcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fdGV4dHVyZXMgIT09IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLl90ZXh0dXJlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl90ZXh0dXJlc1tpXS5kcmF3KGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZXh0Lmdsb2JhbEFscGhhICE9IHRoaXMuX2FscGhhKSB7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLl9hbHBoYTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkLCBuZXh0ID0gdGhpcy5fZmlyc3Q7XG4gICAgICB3aGlsZSAoY2hpbGQgPSBuZXh0KSB7XG4gICAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcbiAgICAgICAgY2hpbGQucmVuZGVyKGNvbnRleHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb3JlLnByb3RvdHlwZS5fdGlja0JlZm9yZSA9IG51bGw7XG4gICAgY29yZS5wcm90b3R5cGUuX3RpY2tBZnRlciA9IG51bGw7XG4gICAgY29yZS5wcm90b3R5cGUuTUFYX0VMQVBTRSA9IEluZmluaXR5O1xuXG4gICAgY29yZS5wcm90b3R5cGUuX3RpY2sgPSBmdW5jdGlvbihlbGFwc2VkLCBub3csIGxhc3QpIHtcbiAgICAgIGlmICghdGhpcy5fdmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGFwc2VkID4gdGhpcy5NQVhfRUxBUFNFKSB7XG4gICAgICAgIGVsYXBzZWQgPSB0aGlzLk1BWF9FTEFQU0U7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aWNrZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuX3RpY2tCZWZvcmUgIT09IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90aWNrQmVmb3JlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3RhdHMudGljaysrO1xuICAgICAgICAgIHZhciB0aWNrRm4gPSB0aGlzLl90aWNrQmVmb3JlW2ldO1xuICAgICAgICAgIHRpY2tlZCA9IHRpY2tGbi5jYWxsKHRoaXMsIGVsYXBzZWQsIG5vdywgbGFzdCkgPT09IHRydWUgfHwgdGlja2VkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZCwgbmV4dCA9IHRoaXMuX2ZpcnN0O1xuICAgICAgd2hpbGUgKGNoaWxkID0gbmV4dCkge1xuICAgICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG4gICAgICAgIGlmIChjaGlsZC5fZmxhZygnX3RpY2snKSkge1xuICAgICAgICAgIHRpY2tlZCA9IGNoaWxkLl90aWNrKGVsYXBzZWQsIG5vdywgbGFzdCkgPT09IHRydWUgPyB0cnVlIDogdGlja2VkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl90aWNrQWZ0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90aWNrQWZ0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdGF0cy50aWNrKys7XG4gICAgICAgICAgdmFyIHRpY2tGbiA9IHRoaXMuX3RpY2tBZnRlcltpXTtcbiAgICAgICAgICB0aWNrZWQgPSB0aWNrRm4uY2FsbCh0aGlzLCBlbGFwc2VkLCBub3csIGxhc3QpID09PSB0cnVlIHx8IHRpY2tlZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGlja2VkO1xuICAgIH07XG5cbiAgICBjb3JlLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24odGlja2VyLCBiZWZvcmUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGlja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RpY2tCZWZvcmUgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl90aWNrQmVmb3JlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGlja0JlZm9yZS5wdXNoKHRpY2tlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fdGlja0FmdGVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fdGlja0FmdGVyID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGlja0FmdGVyLnB1c2godGlja2VyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZsYWcoJ190aWNrJywgdGhpcy5fdGlja0FmdGVyICE9PSBudWxsICYmIHRoaXMuX3RpY2tBZnRlci5sZW5ndGggPiAwXG4gICAgICAgICAgfHwgdGhpcy5fdGlja0JlZm9yZSAhPT0gbnVsbCAmJiB0aGlzLl90aWNrQmVmb3JlLmxlbmd0aCA+IDApO1xuICAgIH07XG5cbiAgICBjb3JlLnByb3RvdHlwZS51bnRpY2sgPSBmdW5jdGlvbih0aWNrZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgdGlja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpO1xuICAgICAgaWYgKHRoaXMuX3RpY2tCZWZvcmUgIT09IG51bGwgJiYgKGkgPSB0aGlzLl90aWNrQmVmb3JlLmluZGV4T2YodGlja2VyKSkgPj0gMCkge1xuICAgICAgICB0aGlzLl90aWNrQmVmb3JlLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl90aWNrQWZ0ZXIgIT09IG51bGwgJiYgKGkgPSB0aGlzLl90aWNrQWZ0ZXIuaW5kZXhPZih0aWNrZXIpKSA+PSAwKSB7XG4gICAgICAgIHRoaXMuX3RpY2tBZnRlci5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvcmUucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbihmbiwgdGltZSkge1xuICAgICAgdGhpcy5zZXRUaW1lb3V0KGZuLCB0aW1lKTtcbiAgICB9O1xuXG4gICAgY29yZS5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uKGZuLCB0aW1lKSB7XG4gICAgICBmdW5jdGlvbiB0aW1lcih0KSB7XG4gICAgICAgIGlmICgodGltZSAtPSB0KSA8IDApIHtcbiAgICAgICAgICB0aGlzLnVudGljayh0aW1lcik7XG4gICAgICAgICAgZm4uY2FsbCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50aWNrKHRpbWVyKTtcbiAgICAgIHJldHVybiB0aW1lcjtcbiAgICB9O1xuXG4gICAgY29yZS5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24odGltZXIpIHtcbiAgICAgIHRoaXMudW50aWNrKHRpbWVyKTtcbiAgICB9O1xuXG4gICAgUm9vdC5fc3VwZXIgPSBjb3JlO1xuICAgIFJvb3QucHJvdG90eXBlID0gY3JlYXRlKFJvb3QuX3N1cGVyLnByb3RvdHlwZSk7XG5cbiAgICBjb3JlLnJvb3QgPSBmdW5jdGlvbihyZXF1ZXN0LCByZW5kZXIpIHtcbiAgICAgIHJldHVybiBuZXcgUm9vdChyZXF1ZXN0LCByZW5kZXIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBSb290KHJlcXVlc3QsIHJlbmRlcikge1xuICAgICAgUm9vdC5fc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMubGFiZWwoJ1Jvb3QnKTtcblxuICAgICAgdmFyIHBhdXNlZCA9IHRydWU7XG4gICAgICB2YXIgc3RvcHBlZCA9IHRydWU7XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICBpZiAocGF1c2VkID09PSB0cnVlIHx8IHN0b3BwZWQgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0cy50aWNrID0gc3RhdHMubm9kZSA9IHN0YXRzLmRyYXcgPSAwO1xuXG4gICAgICAgIHZhciBsYXN0ID0gbGFzdFRpbWUgfHwgbm93O1xuICAgICAgICB2YXIgZWxhcHNlZCA9IG5vdyAtIGxhc3Q7XG4gICAgICAgIGxhc3RUaW1lID0gbm93O1xuXG4gICAgICAgIHZhciB0aWNrZWQgPSBzZWxmLl90aWNrKGVsYXBzZWQsIG5vdywgbGFzdCk7XG4gICAgICAgIGlmIChzZWxmLl9tb190b3VjaCAhPSBzZWxmLl90c190b3VjaCkge1xuICAgICAgICAgIHNlbGYuX21vX3RvdWNoID0gc2VsZi5fdHNfdG91Y2g7XG4gICAgICAgICAgcmVuZGVyKHNlbGYpO1xuICAgICAgICAgIHJlcXVlc3QobG9vcCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGlja2VkKSB7XG4gICAgICAgICAgcmVxdWVzdChsb29wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdHMuZnBzID0gZWxhcHNlZCA/IDEwMDAgLyBlbGFwc2VkIDogMDtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bWUoKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChwYXVzZWQpIHtcbiAgICAgICAgICB0aGlzLnB1Ymxpc2goJ3Jlc3VtZScpO1xuICAgICAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgIHJlcXVlc3QobG9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghcGF1c2VkKSB7XG4gICAgICAgICAgdGhpcy5wdWJsaXNoKCdwYXVzZScpO1xuICAgICAgICB9XG4gICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgdGhpcy50b3VjaF9yb290ID0gdGhpcy50b3VjaDtcbiAgICAgIHRoaXMudG91Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG91Y2hfcm9vdCgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH1cbiAgICBSb290LnByb3RvdHlwZS5iYWNrZ3JvdW5kID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgIC8vIHRvIGJlIGltcGxlbWVudGVkIGJ5IGxvYWRlcnNcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSb290LnByb3RvdHlwZS52aWV3cG9ydCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHJhdGlvKSB7XG4gICAgICBpZiAodHlwZW9mIHdpZHRoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCB0aGlzLl92aWV3cG9ydCk7XG4gICAgICB9XG4gICAgICB0aGlzLl92aWV3cG9ydCA9IHtcbiAgICAgICAgd2lkdGggOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0IDogaGVpZ2h0LFxuICAgICAgICByYXRpbyA6IHJhdGlvIHx8IDFcbiAgICAgIH07XG4gICAgICB0aGlzLnZpZXdib3goKTtcbiAgICAgIHZhciBkYXRhID0gZXh0ZW5kKHt9LCB0aGlzLl92aWV3cG9ydCk7XG4gICAgICB0aGlzLnZpc2l0KHtcbiAgICAgICAgc3RhcnQgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgaWYgKCFub2RlLl9mbGFnKCd2aWV3cG9ydCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5wdWJsaXNoKCd2aWV3cG9ydCcsIFsgZGF0YSBdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogc3RhdGljL2ZpeGVkIHZpZXdib3hcbiAgICBSb290LnByb3RvdHlwZS52aWV3Ym94ID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgbW9kZSkge1xuICAgICAgaWYgKHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGhlaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5fdmlld2JveCA9IHtcbiAgICAgICAgICB3aWR0aCA6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodCA6IGhlaWdodCxcbiAgICAgICAgICBtb2RlIDogL14oaW58b3V0fGluLXBhZHxvdXQtY3JvcCkkLy50ZXN0KG1vZGUpID8gbW9kZSA6ICdpbi1wYWQnXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBib3ggPSB0aGlzLl92aWV3Ym94O1xuICAgICAgdmFyIHNpemUgPSB0aGlzLl92aWV3cG9ydDtcbiAgICAgIGlmIChzaXplICYmIGJveCkge1xuICAgICAgICB0aGlzLnBpbih7XG4gICAgICAgICAgd2lkdGggOiBib3gud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0IDogYm94LmhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zY2FsZVRvKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCBib3gubW9kZSk7XG4gICAgICB9IGVsc2UgaWYgKHNpemUpIHtcbiAgICAgICAgdGhpcy5waW4oe1xuICAgICAgICAgIHdpZHRoIDogc2l6ZS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgOiBzaXplLmhlaWdodFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBsaWIgPSBjb3JlO1xuICAgIHZhciBNYXRyaXggPSBtYXRyaXg7XG4gICAgdmFyIFRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIGxpYi5NYXRyaXggPSBNYXRyaXg7XG4gICAgbGliLlRleHR1cmUgPSBUZXh0dXJlO1xuXG4gICAgY29yZS5jYW52YXMgPSBmdW5jdGlvbih0eXBlLCBhdHRyaWJ1dGVzLCBkcmF3Rm4pIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzID09PSAnb2JqZWN0JykgOyBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRyYXdGbiA9IGF0dHJpYnV0ZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZHJhd0ZuID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHR5cGUgPSAnMmQnO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KHR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgICAgdmFyIHRleHR1cmUkMSA9IG5ldyB0ZXh0dXJlKGNhbnZhcyk7XG5cbiAgICAgIHRleHR1cmUkMS5jb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgfTtcblxuICAgICAgdGV4dHVyZSQxLnNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCByYXRpbykge1xuICAgICAgICByYXRpbyA9IHJhdGlvIHx8IDE7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogcmF0aW87XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiByYXRpbztcbiAgICAgICAgdGhpcy5zcmMoY2FudmFzLCByYXRpbyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgdGV4dHVyZSQxLmNhbnZhcyA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBmbi5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmbiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRyYXdGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRyYXdGbi5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgaWYgKHR5cGVvZiBkcmF3Rm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZHJhd0ZuLmNhbGwodGV4dHVyZSQxLCBjb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRleHR1cmUkMTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uKGltZywgb3dpZHRoLCBvaGVpZ2h0LCBzdHJldGNoLCBpbm5lciwgaW5zZXJ0KSB7XG5cbiAgICAgIHZhciB3aWR0aCA9IGltZy53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgICAgdmFyIGxlZnQgPSBpbWcubGVmdDtcbiAgICAgIHZhciByaWdodCA9IGltZy5yaWdodDtcbiAgICAgIHZhciB0b3AgPSBpbWcudG9wO1xuICAgICAgdmFyIGJvdHRvbSA9IGltZy5ib3R0b207XG5cbiAgICAgIGxlZnQgPSB0eXBlb2YgbGVmdCA9PT0gJ251bWJlcicgJiYgbGVmdCA9PT0gbGVmdCA/IGxlZnQgOiAwO1xuICAgICAgcmlnaHQgPSB0eXBlb2YgcmlnaHQgPT09ICdudW1iZXInICYmIHJpZ2h0ID09PSByaWdodCA/IHJpZ2h0IDogMDtcbiAgICAgIHRvcCA9IHR5cGVvZiB0b3AgPT09ICdudW1iZXInICYmIHRvcCA9PT0gdG9wID8gdG9wIDogMDtcbiAgICAgIGJvdHRvbSA9IHR5cGVvZiBib3R0b20gPT09ICdudW1iZXInICYmIGJvdHRvbSA9PT0gYm90dG9tID8gYm90dG9tIDogMDtcblxuICAgICAgd2lkdGggPSB3aWR0aCAtIGxlZnQgLSByaWdodDtcbiAgICAgIGhlaWdodCA9IGhlaWdodCAtIHRvcCAtIGJvdHRvbTtcblxuICAgICAgaWYgKCFpbm5lcikge1xuICAgICAgICBvd2lkdGggPSBNYXRoLm1heChvd2lkdGggLSBsZWZ0IC0gcmlnaHQsIDApO1xuICAgICAgICBvaGVpZ2h0ID0gTWF0aC5tYXgob2hlaWdodCAtIHRvcCAtIGJvdHRvbSwgMCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgaWYgKHRvcCA+IDAgJiYgbGVmdCA+IDApXG4gICAgICAgIGluc2VydChpKyssIDAsIDAsIGxlZnQsIHRvcCwgMCwgMCwgbGVmdCwgdG9wKTtcbiAgICAgIGlmIChib3R0b20gPiAwICYmIGxlZnQgPiAwKVxuICAgICAgICBpbnNlcnQoaSsrLCAwLCBoZWlnaHQgKyB0b3AsIGxlZnQsIGJvdHRvbSwgMCwgb2hlaWdodCArIHRvcCwgbGVmdCwgYm90dG9tKTtcbiAgICAgIGlmICh0b3AgPiAwICYmIHJpZ2h0ID4gMClcbiAgICAgICAgaW5zZXJ0KGkrKywgd2lkdGggKyBsZWZ0LCAwLCByaWdodCwgdG9wLCBvd2lkdGggKyBsZWZ0LCAwLCByaWdodCwgdG9wKTtcbiAgICAgIGlmIChib3R0b20gPiAwICYmIHJpZ2h0ID4gMClcbiAgICAgICAgaW5zZXJ0KGkrKywgd2lkdGggKyBsZWZ0LCBoZWlnaHQgKyB0b3AsIHJpZ2h0LCBib3R0b20sIG93aWR0aCArIGxlZnQsXG4gICAgICAgICAgICBvaGVpZ2h0ICsgdG9wLCByaWdodCwgYm90dG9tKTtcblxuICAgICAgaWYgKHN0cmV0Y2gpIHtcbiAgICAgICAgaWYgKHRvcCA+IDApXG4gICAgICAgICAgaW5zZXJ0KGkrKywgbGVmdCwgMCwgd2lkdGgsIHRvcCwgbGVmdCwgMCwgb3dpZHRoLCB0b3ApO1xuICAgICAgICBpZiAoYm90dG9tID4gMClcbiAgICAgICAgICBpbnNlcnQoaSsrLCBsZWZ0LCBoZWlnaHQgKyB0b3AsIHdpZHRoLCBib3R0b20sIGxlZnQsIG9oZWlnaHQgKyB0b3AsXG4gICAgICAgICAgICAgIG93aWR0aCwgYm90dG9tKTtcbiAgICAgICAgaWYgKGxlZnQgPiAwKVxuICAgICAgICAgIGluc2VydChpKyssIDAsIHRvcCwgbGVmdCwgaGVpZ2h0LCAwLCB0b3AsIGxlZnQsIG9oZWlnaHQpO1xuICAgICAgICBpZiAocmlnaHQgPiAwKVxuICAgICAgICAgIGluc2VydChpKyssIHdpZHRoICsgbGVmdCwgdG9wLCByaWdodCwgaGVpZ2h0LCBvd2lkdGggKyBsZWZ0LCB0b3AsIHJpZ2h0LFxuICAgICAgICAgICAgICBvaGVpZ2h0KTtcbiAgICAgICAgLy8gY2VudGVyXG4gICAgICAgIGluc2VydChpKyssIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLCBvd2lkdGgsIG9oZWlnaHQpO1xuXG4gICAgICB9IGVsc2UgeyAvLyB0aWxlXG4gICAgICAgIHZhciBsID0gbGVmdCwgciA9IG93aWR0aCwgdztcbiAgICAgICAgd2hpbGUgKHIgPiAwKSB7XG4gICAgICAgICAgdyA9IE1hdGgubWluKHdpZHRoLCByKSwgciAtPSB3aWR0aDtcbiAgICAgICAgICB2YXIgdCA9IHRvcCwgYiA9IG9oZWlnaHQsIGg7XG4gICAgICAgICAgd2hpbGUgKGIgPiAwKSB7XG4gICAgICAgICAgICBoID0gTWF0aC5taW4oaGVpZ2h0LCBiKSwgYiAtPSBoZWlnaHQ7XG4gICAgICAgICAgICBpbnNlcnQoaSsrLCBsZWZ0LCB0b3AsIHcsIGgsIGwsIHQsIHcsIGgpO1xuICAgICAgICAgICAgaWYgKHIgPD0gMCkge1xuICAgICAgICAgICAgICBpZiAobGVmdClcbiAgICAgICAgICAgICAgICBpbnNlcnQoaSsrLCAwLCB0b3AsIGxlZnQsIGgsIDAsIHQsIGxlZnQsIGgpO1xuICAgICAgICAgICAgICBpZiAocmlnaHQpXG4gICAgICAgICAgICAgICAgaW5zZXJ0KGkrKywgd2lkdGggKyBsZWZ0LCB0b3AsIHJpZ2h0LCBoLCBsICsgdywgdCwgcmlnaHQsIGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCArPSBoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9wKVxuICAgICAgICAgICAgaW5zZXJ0KGkrKywgbGVmdCwgMCwgdywgdG9wLCBsLCAwLCB3LCB0b3ApO1xuICAgICAgICAgIGlmIChib3R0b20pXG4gICAgICAgICAgICBpbnNlcnQoaSsrLCBsZWZ0LCBoZWlnaHQgKyB0b3AsIHcsIGJvdHRvbSwgbCwgdCwgdywgYm90dG9tKTtcbiAgICAgICAgICBsICs9IHc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfTtcblxuICAgIHZhciBpbWFnZSA9IEltYWdlJDE7XG5cbiAgICBjb3JlLmltYWdlID0gZnVuY3Rpb24oaW1hZ2UpIHtcbiAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UkMSgpO1xuICAgICAgaW1hZ2UgJiYgaW1nLmltYWdlKGltYWdlKTtcbiAgICAgIHJldHVybiBpbWc7XG4gICAgfTtcblxuICAgIEltYWdlJDEuX3N1cGVyID0gY29yZTtcbiAgICBJbWFnZSQxLnByb3RvdHlwZSA9IGNyZWF0ZShJbWFnZSQxLl9zdXBlci5wcm90b3R5cGUpO1xuXG4gICAgZnVuY3Rpb24gSW1hZ2UkMSgpIHtcbiAgICAgIEltYWdlJDEuX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmxhYmVsKCdJbWFnZScpO1xuICAgICAgdGhpcy5fdGV4dHVyZXMgPSBbXTtcbiAgICAgIHRoaXMuX2ltYWdlID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGltYWdlXG4gICAgICovXG4gICAgSW1hZ2UkMS5wcm90b3R5cGUuc2V0SW1hZ2UgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZShhLCBiLCBjKTtcbiAgICB9O1xuXG4gICAgSW1hZ2UkMS5wcm90b3R5cGUuaW1hZ2UgPSBmdW5jdGlvbihpbWFnZSkge1xuICAgICAgdGhpcy5faW1hZ2UgPSBjb3JlLnRleHR1cmUoaW1hZ2UpLm9uZSgpO1xuICAgICAgdGhpcy5waW4oJ3dpZHRoJywgdGhpcy5faW1hZ2UgPyB0aGlzLl9pbWFnZS53aWR0aCA6IDApO1xuICAgICAgdGhpcy5waW4oJ2hlaWdodCcsIHRoaXMuX2ltYWdlID8gdGhpcy5faW1hZ2UuaGVpZ2h0IDogMCk7XG4gICAgICB0aGlzLl90ZXh0dXJlc1swXSA9IHRoaXMuX2ltYWdlLnBpcGUoKTtcbiAgICAgIHRoaXMuX3RleHR1cmVzLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgSW1hZ2UkMS5wcm90b3R5cGUudGlsZSA9IGZ1bmN0aW9uKGlubmVyKSB7XG4gICAgICB0aGlzLl9yZXBlYXQoZmFsc2UsIGlubmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBJbWFnZSQxLnByb3RvdHlwZS5zdHJldGNoID0gZnVuY3Rpb24oaW5uZXIpIHtcbiAgICAgIHRoaXMuX3JlcGVhdCh0cnVlLCBpbm5lcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgSW1hZ2UkMS5wcm90b3R5cGUuX3JlcGVhdCA9IGZ1bmN0aW9uKHN0cmV0Y2gsIGlubmVyKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLnVudGljayh0aGlzLl9yZXBlYXRUaWNrZXIpO1xuICAgICAgdGhpcy50aWNrKHRoaXMuX3JlcGVhdFRpY2tlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbW9fc3RyZXRjaCA9PSB0aGlzLl9waW4uX3RzX3RyYW5zZm9ybSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb19zdHJldGNoID0gdGhpcy5fcGluLl90c190cmFuc2Zvcm07XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMucGluKCd3aWR0aCcpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5waW4oJ2hlaWdodCcpO1xuICAgICAgICB0aGlzLl90ZXh0dXJlcy5sZW5ndGggPSByZXBlYXQodGhpcy5faW1hZ2UsIHdpZHRoLCBoZWlnaHQsIHN0cmV0Y2gsIGlubmVyLFxuICAgICAgICAgICAgaW5zZXJ0KTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBpbnNlcnQoaSwgc3gsIHN5LCBzdywgc2gsIGR4LCBkeSwgZHcsIGRoKSB7XG4gICAgICAgIHZhciByZXBlYXQgPSBzZWxmLl90ZXh0dXJlcy5sZW5ndGggPiBpID8gc2VsZi5fdGV4dHVyZXNbaV1cbiAgICAgICAgICAgIDogc2VsZi5fdGV4dHVyZXNbaV0gPSBzZWxmLl9pbWFnZS5waXBlKCk7XG4gICAgICAgIHJlcGVhdC5zcmMoc3gsIHN5LCBzdywgc2gpO1xuICAgICAgICByZXBlYXQuZGVzdChkeCwgZHksIGR3LCBkaCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvcmUuYW5pbSA9IGZ1bmN0aW9uKGZyYW1lcywgZnBzKSB7XG4gICAgICB2YXIgYW5pbSA9IG5ldyBBbmltKCk7XG4gICAgICBhbmltLmZyYW1lcyhmcmFtZXMpLmdvdG9GcmFtZSgwKTtcbiAgICAgIGZwcyAmJiBhbmltLmZwcyhmcHMpO1xuICAgICAgcmV0dXJuIGFuaW07XG4gICAgfTtcblxuICAgIEFuaW0uX3N1cGVyID0gY29yZTtcbiAgICBBbmltLnByb3RvdHlwZSA9IGNyZWF0ZShBbmltLl9zdXBlci5wcm90b3R5cGUpO1xuXG4gICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIGF0bGFzIGZwcyBvciB0ZXh0dXJlIHRpbWVcbiAgICBjb3JlLkFuaW0gPSB7XG4gICAgICBGUFMgOiAxNVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBBbmltKCkge1xuICAgICAgQW5pbS5fc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMubGFiZWwoJ0FuaW0nKTtcblxuICAgICAgdGhpcy5fdGV4dHVyZXMgPSBbXTtcblxuICAgICAgdGhpcy5fZnBzID0gY29yZS5BbmltLkZQUztcbiAgICAgIHRoaXMuX2Z0ID0gMTAwMCAvIHRoaXMuX2ZwcztcblxuICAgICAgdGhpcy5fdGltZSA9IC0xO1xuICAgICAgdGhpcy5fcmVwZWF0ID0gMDtcblxuICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgdGhpcy5fZnJhbWVzID0gW107XG5cbiAgICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgICB0aGlzLnRpY2soZnVuY3Rpb24odCwgbm93LCBsYXN0KSB7XG4gICAgICAgIGlmICh0aGlzLl90aW1lIDwgMCB8fCB0aGlzLl9mcmFtZXMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZ25vcmUgb2xkIGVsYXBzZWRcbiAgICAgICAgdmFyIGlnbm9yZSA9IGxhc3RUaW1lICE9IGxhc3Q7XG4gICAgICAgIGxhc3RUaW1lID0gbm93O1xuICAgICAgICBpZiAoaWdub3JlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90aW1lICs9IHQ7XG4gICAgICAgIGlmICh0aGlzLl90aW1lIDwgdGhpcy5fZnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbiA9IHRoaXMuX3RpbWUgLyB0aGlzLl9mdCB8IDA7XG4gICAgICAgIHRoaXMuX3RpbWUgLT0gbiAqIHRoaXMuX2Z0O1xuICAgICAgICB0aGlzLm1vdmVGcmFtZShuKTtcbiAgICAgICAgaWYgKHRoaXMuX3JlcGVhdCA+IDAgJiYgKHRoaXMuX3JlcGVhdCAtPSBuKSA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgdGhpcy5fY2FsbGJhY2sgJiYgdGhpcy5fY2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LCBmYWxzZSk7XG4gICAgfVxuICAgIEFuaW0ucHJvdG90eXBlLmZwcyA9IGZ1bmN0aW9uKGZwcykge1xuICAgICAgaWYgKHR5cGVvZiBmcHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcHM7XG4gICAgICB9XG4gICAgICB0aGlzLl9mcHMgPSBmcHMgPiAwID8gZnBzIDogY29yZS5BbmltLkZQUztcbiAgICAgIHRoaXMuX2Z0ID0gMTAwMCAvIHRoaXMuX2ZwcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgZnJhbWVzXG4gICAgICovXG4gICAgQW5pbS5wcm90b3R5cGUuc2V0RnJhbWVzID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzKGEsIGIsIGMpO1xuICAgIH07XG5cbiAgICBBbmltLnByb3RvdHlwZS5mcmFtZXMgPSBmdW5jdGlvbihmcmFtZXMpIHtcbiAgICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICAgIHRoaXMuX2ZyYW1lcyA9IGNvcmUudGV4dHVyZShmcmFtZXMpLmFycmF5KCk7XG4gICAgICB0aGlzLnRvdWNoKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgQW5pbS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZnJhbWVzID8gdGhpcy5fZnJhbWVzLmxlbmd0aCA6IDA7XG4gICAgfTtcblxuICAgIEFuaW0ucHJvdG90eXBlLmdvdG9GcmFtZSA9IGZ1bmN0aW9uKGZyYW1lLCByZXNpemUpIHtcbiAgICAgIHRoaXMuX2luZGV4ID0gbWF0aC5yb3RhdGUoZnJhbWUsIHRoaXMuX2ZyYW1lcy5sZW5ndGgpIHwgMDtcbiAgICAgIHJlc2l6ZSA9IHJlc2l6ZSB8fCAhdGhpcy5fdGV4dHVyZXNbMF07XG4gICAgICB0aGlzLl90ZXh0dXJlc1swXSA9IHRoaXMuX2ZyYW1lc1t0aGlzLl9pbmRleF07XG4gICAgICBpZiAocmVzaXplKSB7XG4gICAgICAgIHRoaXMucGluKCd3aWR0aCcsIHRoaXMuX3RleHR1cmVzWzBdLndpZHRoKTtcbiAgICAgICAgdGhpcy5waW4oJ2hlaWdodCcsIHRoaXMuX3RleHR1cmVzWzBdLmhlaWdodCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRvdWNoKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgQW5pbS5wcm90b3R5cGUubW92ZUZyYW1lID0gZnVuY3Rpb24obW92ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ290b0ZyYW1lKHRoaXMuX2luZGV4ICsgbW92ZSk7XG4gICAgfTtcblxuICAgIEFuaW0ucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uKHJlcGVhdCwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX3JlcGVhdCA9IHJlcGVhdCAqIHRoaXMuX2ZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMucGxheSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIEFuaW0ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbihmcmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiBmcmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5nb3RvRnJhbWUoZnJhbWUpO1xuICAgICAgICB0aGlzLl90aW1lID0gMDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fdGltZSA8IDApIHtcbiAgICAgICAgdGhpcy5fdGltZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG91Y2goKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBBbmltLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgIHRoaXMuX3RpbWUgPSAtMTtcbiAgICAgIGlmICh0eXBlb2YgZnJhbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuZ290b0ZyYW1lKGZyYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBjb3JlLnN0cmluZyA9IGZ1bmN0aW9uKGZyYW1lcykge1xuICAgICAgcmV0dXJuIG5ldyBTdHIoKS5mcmFtZXMoZnJhbWVzKTtcbiAgICB9O1xuXG4gICAgU3RyLl9zdXBlciA9IGNvcmU7XG4gICAgU3RyLnByb3RvdHlwZSA9IGNyZWF0ZShTdHIuX3N1cGVyLnByb3RvdHlwZSk7XG5cbiAgICBmdW5jdGlvbiBTdHIoKSB7XG4gICAgICBTdHIuX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmxhYmVsKCdTdHJpbmcnKTtcbiAgICAgIHRoaXMuX3RleHR1cmVzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBmcmFtZXNcbiAgICAgKi9cbiAgICBTdHIucHJvdG90eXBlLnNldEZvbnQgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmFtZXMoYSwgYiwgYyk7XG4gICAgfTtcblxuICAgIFN0ci5wcm90b3R5cGUuZnJhbWVzID0gZnVuY3Rpb24oZnJhbWVzKSB7XG4gICAgICB0aGlzLl90ZXh0dXJlcyA9IFtdO1xuICAgICAgaWYgKHR5cGVvZiBmcmFtZXMgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnJhbWVzID0gY29yZS50ZXh0dXJlKGZyYW1lcyk7XG4gICAgICAgIHRoaXMuX2l0ZW0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmcmFtZXMub25lKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZyYW1lcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5faXRlbSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYW1lc1t2YWx1ZV07XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmcmFtZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5faXRlbSA9IGZyYW1lcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdmFsdWVcbiAgICAgKi9cbiAgICBTdHIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUoYSwgYiwgYyk7XG4gICAgfTtcblxuICAgIFN0ci5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3ZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmICFpc18xLmFycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NwYWNpbmcgPSB0aGlzLl9zcGFjaW5nIHx8IDA7XG5cbiAgICAgIHZhciB3aWR0aCA9IDAsIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbWFnZSA9IHRoaXMuX3RleHR1cmVzW2ldID0gdGhpcy5faXRlbSh2YWx1ZVtpXSk7XG4gICAgICAgIHdpZHRoICs9IGkgPiAwID8gdGhpcy5fc3BhY2luZyA6IDA7XG4gICAgICAgIGltYWdlLmRlc3Qod2lkdGgsIDApO1xuICAgICAgICB3aWR0aCA9IHdpZHRoICsgaW1hZ2Uud2lkdGg7XG4gICAgICAgIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgaW1hZ2UuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGluKCd3aWR0aCcsIHdpZHRoKTtcbiAgICAgIHRoaXMucGluKCdoZWlnaHQnLCBoZWlnaHQpO1xuICAgICAgdGhpcy5fdGV4dHVyZXMubGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNvcmUucm93ID0gZnVuY3Rpb24oYWxpZ24pIHtcbiAgICAgIHJldHVybiBjb3JlLmNyZWF0ZSgpLnJvdyhhbGlnbikubGFiZWwoJ1JvdycpO1xuICAgIH07XG5cbiAgICBjb3JlLnByb3RvdHlwZS5yb3cgPSBmdW5jdGlvbihhbGlnbikge1xuICAgICAgdGhpcy5zZXF1ZW5jZSgncm93JywgYWxpZ24pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNvcmUuY29sdW1uID0gZnVuY3Rpb24oYWxpZ24pIHtcbiAgICAgIHJldHVybiBjb3JlLmNyZWF0ZSgpLmNvbHVtbihhbGlnbikubGFiZWwoJ1JvdycpO1xuICAgIH07XG5cbiAgICBjb3JlLnByb3RvdHlwZS5jb2x1bW4gPSBmdW5jdGlvbihhbGlnbikge1xuICAgICAgdGhpcy5zZXF1ZW5jZSgnY29sdW1uJywgYWxpZ24pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNvcmUuc2VxdWVuY2UgPSBmdW5jdGlvbih0eXBlLCBhbGlnbikge1xuICAgICAgcmV0dXJuIGNvcmUuY3JlYXRlKCkuc2VxdWVuY2UodHlwZSwgYWxpZ24pLmxhYmVsKCdTZXF1ZW5jZScpO1xuICAgIH07XG5cbiAgICBjb3JlLnByb3RvdHlwZS5zZXF1ZW5jZSA9IGZ1bmN0aW9uKHR5cGUsIGFsaWduKSB7XG5cbiAgICAgIHRoaXMuX3BhZGRpbmcgPSB0aGlzLl9wYWRkaW5nIHx8IDA7XG4gICAgICB0aGlzLl9zcGFjaW5nID0gdGhpcy5fc3BhY2luZyB8fCAwO1xuXG4gICAgICB0aGlzLnVudGljayh0aGlzLl9sYXlvdXRUaWtlcik7XG4gICAgICB0aGlzLnRpY2sodGhpcy5fbGF5b3V0VGlrZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vX3NlcSA9PSB0aGlzLl90c190b3VjaCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb19zZXEgPSB0aGlzLl90c190b3VjaDtcblxuICAgICAgICB2YXIgYWxpZ25DaGlsZHJlbiA9ICh0aGlzLl9tb19zZXFBbGlnbiAhPSB0aGlzLl90c19jaGlsZHJlbik7XG4gICAgICAgIHRoaXMuX21vX3NlcUFsaWduID0gdGhpcy5fdHNfY2hpbGRyZW47XG5cbiAgICAgICAgdmFyIHdpZHRoID0gMCwgaGVpZ2h0ID0gMDtcblxuICAgICAgICB2YXIgY2hpbGQsIG5leHQgPSB0aGlzLmZpcnN0KHRydWUpO1xuICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoY2hpbGQgPSBuZXh0KSB7XG4gICAgICAgICAgbmV4dCA9IGNoaWxkLm5leHQodHJ1ZSk7XG5cbiAgICAgICAgICBjaGlsZC5tYXRyaXgodHJ1ZSk7XG4gICAgICAgICAgdmFyIHcgPSBjaGlsZC5waW4oJ2JveFdpZHRoJyk7XG4gICAgICAgICAgdmFyIGggPSBjaGlsZC5waW4oJ2JveEhlaWdodCcpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAgICFmaXJzdCAmJiAoaGVpZ2h0ICs9IHRoaXMuX3NwYWNpbmcpO1xuICAgICAgICAgICAgY2hpbGQucGluKCdvZmZzZXRZJykgIT0gaGVpZ2h0ICYmIGNoaWxkLnBpbignb2Zmc2V0WScsIGhlaWdodCk7XG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB3KTtcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCArIGg7XG4gICAgICAgICAgICBhbGlnbkNoaWxkcmVuICYmIGNoaWxkLnBpbignYWxpZ25YJywgYWxpZ24pO1xuXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdyb3cnKSB7XG4gICAgICAgICAgICAhZmlyc3QgJiYgKHdpZHRoICs9IHRoaXMuX3NwYWNpbmcpO1xuICAgICAgICAgICAgY2hpbGQucGluKCdvZmZzZXRYJykgIT0gd2lkdGggJiYgY2hpbGQucGluKCdvZmZzZXRYJywgd2lkdGgpO1xuICAgICAgICAgICAgd2lkdGggPSB3aWR0aCArIHc7XG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIGgpO1xuICAgICAgICAgICAgYWxpZ25DaGlsZHJlbiAmJiBjaGlsZC5waW4oJ2FsaWduWScsIGFsaWduKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB3aWR0aCArPSAyICogdGhpcy5fcGFkZGluZztcbiAgICAgICAgaGVpZ2h0ICs9IDIgKiB0aGlzLl9wYWRkaW5nO1xuICAgICAgICB0aGlzLnBpbignd2lkdGgnKSAhPSB3aWR0aCAmJiB0aGlzLnBpbignd2lkdGgnLCB3aWR0aCk7XG4gICAgICAgIHRoaXMucGluKCdoZWlnaHQnKSAhPSBoZWlnaHQgJiYgdGhpcy5waW4oJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBjb3JlLmJveCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvcmUuY3JlYXRlKCkuYm94KCkubGFiZWwoJ0JveCcpO1xuICAgIH07XG5cbiAgICBjb3JlLnByb3RvdHlwZS5ib3ggPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3BhZGRpbmcgPSB0aGlzLl9wYWRkaW5nIHx8IDA7XG5cbiAgICAgIHRoaXMudW50aWNrKHRoaXMuX2xheW91dFRpa2VyKTtcbiAgICAgIHRoaXMudGljayh0aGlzLl9sYXlvdXRUaWtlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbW9fYm94ID09IHRoaXMuX3RzX3RvdWNoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21vX2JveCA9IHRoaXMuX3RzX3RvdWNoO1xuXG4gICAgICAgIHZhciB3aWR0aCA9IDAsIGhlaWdodCA9IDA7XG4gICAgICAgIHZhciBjaGlsZCwgbmV4dCA9IHRoaXMuZmlyc3QodHJ1ZSk7XG4gICAgICAgIHdoaWxlIChjaGlsZCA9IG5leHQpIHtcbiAgICAgICAgICBuZXh0ID0gY2hpbGQubmV4dCh0cnVlKTtcbiAgICAgICAgICBjaGlsZC5tYXRyaXgodHJ1ZSk7XG4gICAgICAgICAgdmFyIHcgPSBjaGlsZC5waW4oJ2JveFdpZHRoJyk7XG4gICAgICAgICAgdmFyIGggPSBjaGlsZC5waW4oJ2JveEhlaWdodCcpO1xuICAgICAgICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHcpO1xuICAgICAgICAgIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgaCk7XG4gICAgICAgIH1cbiAgICAgICAgd2lkdGggKz0gMiAqIHRoaXMuX3BhZGRpbmc7XG4gICAgICAgIGhlaWdodCArPSAyICogdGhpcy5fcGFkZGluZztcbiAgICAgICAgdGhpcy5waW4oJ3dpZHRoJykgIT0gd2lkdGggJiYgdGhpcy5waW4oJ3dpZHRoJywgd2lkdGgpO1xuICAgICAgICB0aGlzLnBpbignaGVpZ2h0JykgIT0gaGVpZ2h0ICYmIHRoaXMucGluKCdoZWlnaHQnLCBoZWlnaHQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgY29yZS5sYXllciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvcmUuY3JlYXRlKCkubGF5ZXIoKS5sYWJlbCgnTGF5ZXInKTtcbiAgICB9O1xuXG4gICAgY29yZS5wcm90b3R5cGUubGF5ZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy51bnRpY2sodGhpcy5fbGF5b3V0VGlrZXIpO1xuICAgICAgdGhpcy50aWNrKHRoaXMuX2xheW91dFRpa2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCgpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgdmFyIHdpZHRoID0gcGFyZW50LnBpbignd2lkdGgnKTtcbiAgICAgICAgICBpZiAodGhpcy5waW4oJ3dpZHRoJykgIT0gd2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMucGluKCd3aWR0aCcsIHdpZHRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGhlaWdodCA9IHBhcmVudC5waW4oJ2hlaWdodCcpO1xuICAgICAgICAgIGlmICh0aGlzLnBpbignaGVpZ2h0JykgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnBpbignaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IG1vdmUgcGFkZGluZyB0byBwaW5cbiAgICBjb3JlLnByb3RvdHlwZS5wYWRkaW5nID0gZnVuY3Rpb24ocGFkKSB7XG4gICAgICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNvcmUucHJvdG90eXBlLnNwYWNpbmcgPSBmdW5jdGlvbihzcGFjZSkge1xuICAgICAgdGhpcy5fc3BhY2luZyA9IHNwYWNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9pZGVudGl0eSh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9dmFyIF9jYWNoZSA9IHt9O1xuICAgIHZhciBfbW9kZXMgPSB7fTtcbiAgICB2YXIgX2Vhc2luZ3MgPSB7fTtcblxuICAgIGZ1bmN0aW9uIEVhc2luZyh0b2tlbikge1xuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gX2lkZW50aXR5O1xuICAgICAgfVxuICAgICAgdmFyIGZuID0gX2NhY2hlW3Rva2VuXTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgICB9XG4gICAgICB2YXIgbWF0Y2ggPSAvXihcXHcrKSgtKGlufG91dHxpbi1vdXR8b3V0LWluKSk/KFxcKCguKilcXCkpPyQvaS5leGVjKHRva2VuKTtcbiAgICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gX2lkZW50aXR5O1xuICAgICAgfVxuICAgICAgdmFyIGVhc2luZyA9IF9lYXNpbmdzW21hdGNoWzFdXTtcbiAgICAgIHZhciBtb2RlID0gX21vZGVzW21hdGNoWzNdXTtcbiAgICAgIHZhciBwYXJhbXMgPSBtYXRjaFs1XTtcbiAgICAgIGlmIChlYXNpbmcgJiYgZWFzaW5nLmZuKSB7XG4gICAgICAgIGZuID0gZWFzaW5nLmZuO1xuICAgICAgfSBlbHNlIGlmIChlYXNpbmcgJiYgZWFzaW5nLmZjKSB7XG4gICAgICAgIGZuID0gZWFzaW5nLmZjLmFwcGx5KGVhc2luZy5mYywgcGFyYW1zXG4gICAgICAgICAgICAmJiBwYXJhbXMucmVwbGFjZSgvXFxzKy8sICcnKS5zcGxpdCgnLCcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuID0gX2lkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKG1vZGUpIHtcbiAgICAgICAgZm4gPSBtb2RlLmZuKGZuKTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IEl0IGNhbiBiZSBhIG1lbW9yeSBsZWFrIHdpdGggZGlmZmVyZW50IGBwYXJhbXNgLlxuICAgICAgX2NhY2hlW3Rva2VuXSA9IGZuO1xuICAgICAgcmV0dXJuIGZuO1xuICAgIH1cbiAgICBFYXNpbmcuYWRkID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgLy8gVE9ETzogY3JlYXRlIGEgbWFwIG9mIGFsbCB7IG5hbWUtbW9kZSA6IGRhdGEgfVxuICAgICAgdmFyIG5hbWVzID0gKGRhdGEubmFtZSB8fCBkYXRhLm1vZGUpLnNwbGl0KC9cXHMrLyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgKGRhdGEubmFtZSA/IF9lYXNpbmdzIDogX21vZGVzKVtuYW1lXSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgRWFzaW5nLmFkZCh7XG4gICAgICBtb2RlIDogJ2luJyxcbiAgICAgIGZuIDogZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIEVhc2luZy5hZGQoe1xuICAgICAgbW9kZSA6ICdvdXQnLFxuICAgICAgZm4gOiBmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgcmV0dXJuIDEgLSBmKDEgLSB0KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIEVhc2luZy5hZGQoe1xuICAgICAgbW9kZSA6ICdpbi1vdXQnLFxuICAgICAgZm4gOiBmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgcmV0dXJuICh0IDwgMC41KSA/IChmKDIgKiB0KSAvIDIpIDogKDEgLSBmKDIgKiAoMSAtIHQpKSAvIDIpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgRWFzaW5nLmFkZCh7XG4gICAgICBtb2RlIDogJ291dC1pbicsXG4gICAgICBmbiA6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICByZXR1cm4gKHQgPCAwLjUpID8gKDEgLSBmKDIgKiAoMSAtIHQpKSAvIDIpIDogKGYoMiAqIHQpIC8gMik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBFYXNpbmcuYWRkKHtcbiAgICAgIG5hbWUgOiAnbGluZWFyJyxcbiAgICAgIGZuIDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIEVhc2luZy5hZGQoe1xuICAgICAgbmFtZSA6ICdxdWFkJyxcbiAgICAgIGZuIDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCAqIHQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBFYXNpbmcuYWRkKHtcbiAgICAgIG5hbWUgOiAnY3ViaWMnLFxuICAgICAgZm4gOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0ICogdCAqIHQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBFYXNpbmcuYWRkKHtcbiAgICAgIG5hbWUgOiAncXVhcnQnLFxuICAgICAgZm4gOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0ICogdCAqIHQgKiB0O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgRWFzaW5nLmFkZCh7XG4gICAgICBuYW1lIDogJ3F1aW50JyxcbiAgICAgIGZuIDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBFYXNpbmcuYWRkKHtcbiAgICAgIG5hbWUgOiAnc2luIHNpbmUnLFxuICAgICAgZm4gOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAxIC0gTWF0aC5jb3ModCAqIE1hdGguUEkgLyAyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIEVhc2luZy5hZGQoe1xuICAgICAgbmFtZSA6ICdleHAgZXhwbycsXG4gICAgICBmbiA6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT0gMCA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgRWFzaW5nLmFkZCh7XG4gICAgICBuYW1lIDogJ2NpcmNsZSBjaXJjJyxcbiAgICAgIGZuIDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgRWFzaW5nLmFkZCh7XG4gICAgICBuYW1lIDogJ2JvdW5jZScsXG4gICAgICBmbiA6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPCAxIC8gMi43NSA/IDcuNTYyNSAqIHQgKiB0IDogdCA8IDIgLyAyLjc1ID8gNy41NjI1XG4gICAgICAgICAgICAqICh0IC09IDEuNSAvIDIuNzUpICogdCArIC43NSA6IHQgPCAyLjUgLyAyLjc1ID8gNy41NjI1XG4gICAgICAgICAgICAqICh0IC09IDIuMjUgLyAyLjc1KSAqIHQgKyAuOTM3NSA6IDcuNTYyNSAqICh0IC09IDIuNjI1IC8gMi43NSkgKiB0XG4gICAgICAgICAgICArIC45ODQzNzU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBFYXNpbmcuYWRkKHtcbiAgICAgIG5hbWUgOiAncG9seScsXG4gICAgICBmYyA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5wb3codCwgZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBFYXNpbmcuYWRkKHtcbiAgICAgIG5hbWUgOiAnZWxhc3RpYycsXG4gICAgICBmYyA6IGZ1bmN0aW9uKGEsIHApIHtcbiAgICAgICAgcCA9IHAgfHwgMC40NTtcbiAgICAgICAgYSA9IGEgfHwgMTtcbiAgICAgICAgdmFyIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgcmV0dXJuIDEgKyBhICogTWF0aC5wb3coMiwgLTEwICogdClcbiAgICAgICAgICAgICAgKiBNYXRoLnNpbigodCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgRWFzaW5nLmFkZCh7XG4gICAgICBuYW1lIDogJ2JhY2snLFxuICAgICAgZmMgOiBmdW5jdGlvbihzKSB7XG4gICAgICAgIHMgPSB0eXBlb2YgcyAhPT0gJ3VuZGVmaW5lZCcgPyBzIDogMS43MDE1ODtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBlYXNpbmcgPSBFYXNpbmc7XG5cbiAgICBjb3JlLnByb3RvdHlwZS50d2VlbiA9IGZ1bmN0aW9uKGR1cmF0aW9uLCBkZWxheSwgYXBwZW5kKSB7XG4gICAgICBpZiAodHlwZW9mIGR1cmF0aW9uICE9PSAnbnVtYmVyJykge1xuICAgICAgICBhcHBlbmQgPSBkdXJhdGlvbiwgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWxheSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgYXBwZW5kID0gZGVsYXksIGRlbGF5ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl90d2VlbnMpIHtcbiAgICAgICAgdGhpcy5fdHdlZW5zID0gW107XG4gICAgICAgIHZhciB0aWNrdGltZSA9IDA7XG4gICAgICAgIHRoaXMudGljayhmdW5jdGlvbihlbGFwc2VkLCBub3csIGxhc3QpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX3R3ZWVucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZ25vcmUgb2xkIGVsYXBzZWRcbiAgICAgICAgICB2YXIgaWdub3JlID0gdGlja3RpbWUgIT0gbGFzdDtcbiAgICAgICAgICB0aWNrdGltZSA9IG5vdztcbiAgICAgICAgICBpZiAoaWdub3JlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaGVhZCA9IHRoaXMuX3R3ZWVuc1swXTtcblxuICAgICAgICAgIHZhciBuZXh0ID0gaGVhZC50aWNrKHRoaXMsIGVsYXBzZWQsIG5vdywgbGFzdCk7XG5cbiAgICAgICAgICBpZiAobmV4dCAmJiBoZWFkID09PSB0aGlzLl90d2VlbnNbMF0pIHtcbiAgICAgICAgICAgIHRoaXMuX3R3ZWVucy5zaGlmdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXh0W2ldLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLl90d2VlbnMudW5zaGlmdChuZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG91Y2goKTtcbiAgICAgIGlmICghYXBwZW5kKSB7XG4gICAgICAgIHRoaXMuX3R3ZWVucy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHR3ZWVuID0gbmV3IFR3ZWVuKHRoaXMsIGR1cmF0aW9uLCBkZWxheSk7XG4gICAgICB0aGlzLl90d2VlbnMucHVzaCh0d2Vlbik7XG4gICAgICByZXR1cm4gdHdlZW47XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFR3ZWVuKG93bmVyLCBkdXJhdGlvbiwgZGVsYXkpIHtcbiAgICAgIHRoaXMuX2VuZCA9IHt9O1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbiB8fCA0MDA7XG4gICAgICB0aGlzLl9kZWxheSA9IGRlbGF5IHx8IDA7XG5cbiAgICAgIHRoaXMuX293bmVyID0gb3duZXI7XG4gICAgICB0aGlzLl90aW1lID0gMDtcbiAgICB9XG4gICAgVHdlZW4ucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbihub2RlLCBlbGFwc2VkLCBub3csIGxhc3QpIHtcbiAgICAgIHRoaXMuX3RpbWUgKz0gZWxhcHNlZDtcblxuICAgICAgaWYgKHRoaXMuX3RpbWUgPCB0aGlzLl9kZWxheSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0aW1lID0gdGhpcy5fdGltZSAtIHRoaXMuX2RlbGF5O1xuXG4gICAgICBpZiAoIXRoaXMuX3N0YXJ0KSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0ID0ge307XG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gdGhpcy5fZW5kKSB7XG4gICAgICAgICAgdGhpcy5fc3RhcnRba2V5XSA9IHRoaXMuX293bmVyLnBpbihrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwLCBvdmVyO1xuICAgICAgaWYgKHRpbWUgPCB0aGlzLl9kdXJhdGlvbikge1xuICAgICAgICBwID0gdGltZSAvIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICBvdmVyID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwID0gMTtcbiAgICAgICAgb3ZlciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fZWFzaW5nID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcCA9IHRoaXMuX2Vhc2luZyhwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHEgPSAxIC0gcDtcblxuICAgICAgZm9yICggdmFyIGtleSBpbiB0aGlzLl9lbmQpIHtcbiAgICAgICAgdGhpcy5fb3duZXIucGluKGtleSwgdGhpcy5fc3RhcnRba2V5XSAqIHEgKyB0aGlzLl9lbmRba2V5XSAqIHApO1xuICAgICAgfVxuXG4gICAgICBpZiAob3Zlcikge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFt0aGlzLl9oaWRlLCB0aGlzLl9yZW1vdmUsIHRoaXMuX2RvbmVdO1xuICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbGVtZW50ID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25leHQgfHwgYWN0aW9ucztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVHdlZW4ucHJvdG90eXBlLnR3ZWVuID0gZnVuY3Rpb24oZHVyYXRpb24sIGRlbGF5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmV4dCA9IG5ldyBUd2Vlbih0aGlzLl9vd25lciwgZHVyYXRpb24sIGRlbGF5KTtcbiAgICB9O1xuXG4gICAgVHdlZW4ucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oZHVyYXRpb24pIHtcbiAgICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVHdlZW4ucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24oZGVsYXkpIHtcbiAgICAgIHRoaXMuX2RlbGF5ID0gZGVsYXk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVHdlZW4ucHJvdG90eXBlLmVhc2UgPSBmdW5jdGlvbihlYXNpbmckMSkge1xuICAgICAgdGhpcy5fZWFzaW5nID0gZWFzaW5nKGVhc2luZyQxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBUd2Vlbi5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICB0aGlzLl9kb25lID0gZm47XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVHdlZW4ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2hpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFR3ZWVuLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBUd2Vlbi5wcm90b3R5cGUucGluID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKCB2YXIgYXR0ciBpbiBhKSB7XG4gICAgICAgICAgcGlubmluZyh0aGlzLl9vd25lciwgdGhpcy5fZW5kLCBhdHRyLCBhW2F0dHJdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGlubmluZyh0aGlzLl9vd25lciwgdGhpcy5fZW5kLCBhLCBiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwaW5uaW5nKG5vZGUsIG1hcCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBub2RlLnBpbihrZXkpID09PSAnbnVtYmVyJykge1xuICAgICAgICBtYXBba2V5XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZS5waW4oa2V5ICsgJ1gnKSA9PT0gJ251bWJlcidcbiAgICAgICAgICAmJiB0eXBlb2Ygbm9kZS5waW4oa2V5ICsgJ1knKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbWFwW2tleSArICdYJ10gPSB2YWx1ZTtcbiAgICAgICAgbWFwW2tleSArICdZJ10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwaW4uX2FkZF9zaG9ydGN1dHMoVHdlZW4pO1xuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5kb25lKGZuKSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIFR3ZWVuLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24oZm4pIHtcbiAgICAgIHRoaXMuZG9uZShmbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTk9PUFxuICAgICAqL1xuICAgIFR3ZWVuLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKGZvcndhcmQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBjb3JlLl9sb2FkKGZ1bmN0aW9uKHN0YWdlLCBlbGVtKSB7XG4gICAgICBNb3VzZS5zdWJzY3JpYmUoc3RhZ2UsIGVsZW0pO1xuICAgIH0pO1xuXG4gICAgLy8gVE9ETzogY2FwdHVyZSBtb3VzZVxuXG4gICAgTW91c2UuQ0xJQ0sgPSAnY2xpY2snO1xuICAgIE1vdXNlLlNUQVJUID0gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJztcbiAgICBNb3VzZS5NT1ZFID0gJ3RvdWNobW92ZSBtb3VzZW1vdmUnO1xuICAgIE1vdXNlLkVORCA9ICd0b3VjaGVuZCBtb3VzZXVwJztcbiAgICBNb3VzZS5DQU5DRUwgPSAndG91Y2hjYW5jZWwgbW91c2VjYW5jZWwnO1xuXG4gICAgTW91c2Uuc3Vic2NyaWJlID0gZnVuY3Rpb24oc3RhZ2UsIGVsZW0pIHtcbiAgICAgIGlmIChzdGFnZS5tb3VzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN0YWdlLm1vdXNlID0gbmV3IE1vdXNlKHN0YWdlLCBlbGVtKTtcblxuICAgICAgLy8gYGNsaWNrYCBldmVudHMgYXJlIHN5bnRoZXNpemVkIGZyb20gc3RhcnQvZW5kIGV2ZW50cyBvbiBzYW1lIG5vZGVzXG4gICAgICAvLyBgbW91c2VjYW5jZWxgIGV2ZW50cyBhcmUgc3ludGhlc2l6ZWQgb24gYmx1ciBvciBtb3VzZXVwIG91dHNpZGUgZWxlbWVudFxuXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoYW5kbGVTdGFydCk7XG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaGFuZGxlRW5kKTtcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgaGFuZGxlTW92ZSk7XG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgaGFuZGxlQ2FuY2VsKTtcblxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVTdGFydCk7XG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVFbmQpO1xuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3ZlKTtcblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZUNhbmNlbCk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgaGFuZGxlQ2FuY2VsKTtcblxuICAgICAgdmFyIGNsaWNrbGlzdCA9IFtdLCBjYW5jZWxsaXN0ID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0KGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHN0YWdlLm1vdXNlLmxvY2F0ZShldmVudCk7XG4gICAgICAgIC8vIGZhbHNlICYmIGNvbnNvbGUubG9nKCdNb3VzZSBTdGFydDogJyArIGV2ZW50LnR5cGUgKyAnICcgKyBtb3VzZSk7XG4gICAgICAgIHN0YWdlLm1vdXNlLnB1Ymxpc2goZXZlbnQudHlwZSwgZXZlbnQpO1xuXG4gICAgICAgIHN0YWdlLm1vdXNlLmxvb2t1cCgnY2xpY2snLCBjbGlja2xpc3QpO1xuICAgICAgICBzdGFnZS5tb3VzZS5sb29rdXAoJ21vdXNlY2FuY2VsJywgY2FuY2VsbGlzdCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc3RhZ2UubW91c2UubG9jYXRlKGV2ZW50KTtcbiAgICAgICAgc3RhZ2UubW91c2UucHVibGlzaChldmVudC50eXBlLCBldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUVuZChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyB1cC9lbmQgbG9jYXRpb24gaXMgbm90IGF2YWlsYWJsZSwgbGFzdCBvbmUgaXMgdXNlZCBpbnN0ZWFkXG4gICAgICAgIC8vIGZhbHNlICYmIGNvbnNvbGUubG9nKCdNb3VzZSBFbmQ6ICcgKyBldmVudC50eXBlICsgJyAnICsgbW91c2UpO1xuICAgICAgICBzdGFnZS5tb3VzZS5wdWJsaXNoKGV2ZW50LnR5cGUsIGV2ZW50KTtcblxuICAgICAgICBpZiAoY2xpY2tsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgIC8vIGZhbHNlICYmIGNvbnNvbGUubG9nKCdNb3VzZSBDbGljazogJyArIGNsaWNrbGlzdC5sZW5ndGgpO1xuICAgICAgICAgIHN0YWdlLm1vdXNlLnB1Ymxpc2goJ2NsaWNrJywgZXZlbnQsIGNsaWNrbGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FuY2VsbGlzdC5sZW5ndGggPSAwO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVDYW5jZWwoZXZlbnQpIHtcbiAgICAgICAgaWYgKGNhbmNlbGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gZmFsc2UgJiYgY29uc29sZS5sb2coJ01vdXNlIENhbmNlbDogJyArIGV2ZW50LnR5cGUpO1xuICAgICAgICAgIHN0YWdlLm1vdXNlLnB1Ymxpc2goJ21vdXNlY2FuY2VsJywgZXZlbnQsIGNhbmNlbGxpc3QpO1xuICAgICAgICB9XG4gICAgICAgIGNsaWNrbGlzdC5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBNb3VzZShzdGFnZSwgZWxlbSkge1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vdXNlKSkge1xuICAgICAgICAvLyBvbGQtc3R5bGUgbW91c2Ugc3Vic2NyaXB0aW9uXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhdGlvID0gc3RhZ2Uudmlld3BvcnQoKS5yYXRpbyB8fCAxO1xuXG4gICAgICBzdGFnZS5vbigndmlld3BvcnQnLCBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHJhdGlvID0gc2l6ZS5yYXRpbyB8fCByYXRpbztcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnggPSAwO1xuICAgICAgdGhpcy55ID0gMDtcbiAgICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnggfCAwKSArICd4JyArICh0aGlzLnkgfCAwKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmxvY2F0ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGxvY2F0ZUVsZXZlbnQoZWxlbSwgZXZlbnQsIHRoaXMpO1xuICAgICAgICB0aGlzLnggKj0gcmF0aW87XG4gICAgICAgIHRoaXMueSAqPSByYXRpbztcbiAgICAgIH07XG4gICAgICB0aGlzLmxvb2t1cCA9IGZ1bmN0aW9uKHR5cGUsIGNvbGxlY3QpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5yb290ID0gc3RhZ2U7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBudWxsO1xuICAgICAgICBjb2xsZWN0Lmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY29sbGVjdCA9IGNvbGxlY3Q7XG5cbiAgICAgICAgdGhpcy5yb290LnZpc2l0KHRoaXMudmlzaXRvciwgdGhpcyk7XG4gICAgICB9O1xuICAgICAgdGhpcy5wdWJsaXNoID0gZnVuY3Rpb24odHlwZSwgZXZlbnQsIHRhcmdldHMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5yb290ID0gc3RhZ2U7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy5jb2xsZWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGltZVN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBpZiAodGFyZ2V0cykge1xuICAgICAgICAgIHdoaWxlICh0YXJnZXRzLmxlbmd0aClcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc2l0b3IuZW5kKHRhcmdldHMuc2hpZnQoKSwgdGhpcykpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHRhcmdldHMubGVuZ3RoID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJvb3QudmlzaXQodGhpcy52aXNpdG9yLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMudmlzaXRvciA9IHtcbiAgICAgICAgcmV2ZXJzZSA6IHRydWUsXG4gICAgICAgIHZpc2libGUgOiB0cnVlLFxuICAgICAgICBzdGFydCA6IGZ1bmN0aW9uKG5vZGUsIG1vdXNlKSB7XG4gICAgICAgICAgcmV0dXJuICFub2RlLl9mbGFnKG1vdXNlLnR5cGUpO1xuICAgICAgICB9LFxuICAgICAgICBlbmQgOiBmdW5jdGlvbihub2RlLCBtb3VzZSkge1xuICAgICAgICAgIC8vIG1vdXNlOiBldmVudC9jb2xsZWN0LCB0eXBlLCByb290XG4gICAgICAgICAgcmVsLnJhdyA9IG1vdXNlLmV2ZW50O1xuICAgICAgICAgIHJlbC50eXBlID0gbW91c2UudHlwZTtcbiAgICAgICAgICByZWwudGltZVN0YW1wID0gbW91c2UudGltZVN0YW1wO1xuICAgICAgICAgIHJlbC5hYnMueCA9IG1vdXNlLng7XG4gICAgICAgICAgcmVsLmFicy55ID0gbW91c2UueTtcblxuICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBub2RlLmxpc3RlbmVycyhtb3VzZS50eXBlKTtcbiAgICAgICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLm1hdHJpeCgpLmludmVyc2UoKS5tYXAobW91c2UsIHJlbCk7XG4gICAgICAgICAgaWYgKCEobm9kZSA9PT0gbW91c2Uucm9vdCB8fCBub2RlLmF0dHIoJ3NweScpIHx8IG5vZGUuaGl0VGVzdChyZWwpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW91c2UuY29sbGVjdCkge1xuICAgICAgICAgICAgbW91c2UuY29sbGVjdC5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW91c2UuZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBjYW5jZWwgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGlzdGVuZXJzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgIGNhbmNlbCA9IGxpc3RlbmVyc1tsXS5jYWxsKG5vZGUsIHJlbCkgPyB0cnVlIDogY2FuY2VsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbmNlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIC8vIFRPRE86IGRlZmluZSBwZXIgbW91c2Ugb2JqZWN0IHdpdGggZ2V0LW9ubHkgeCBhbmQgeVxuICAgIHZhciByZWwgPSB7fSwgYWJzID0ge307XG5cbiAgICBkZWZpbmVWYWx1ZShyZWwsICdjbG9uZScsIGZ1bmN0aW9uKG9iaikge1xuICAgICAgb2JqID0gb2JqIHx8IHt9LCBvYmoueCA9IHRoaXMueCwgb2JqLnkgPSB0aGlzLnk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0pO1xuICAgIGRlZmluZVZhbHVlKHJlbCwgJ3RvU3RyaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKHRoaXMueCB8IDApICsgJ3gnICsgKHRoaXMueSB8IDApICsgJyAoJyArIHRoaXMuYWJzICsgJyknO1xuICAgIH0pO1xuICAgIGRlZmluZVZhbHVlKHJlbCwgJ2FicycsIGFicyk7XG4gICAgZGVmaW5lVmFsdWUoYWJzLCAnY2xvbmUnLCBmdW5jdGlvbihvYmopIHtcbiAgICAgIG9iaiA9IG9iaiB8fCB7fSwgb2JqLnggPSB0aGlzLngsIG9iai55ID0gdGhpcy55O1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9KTtcbiAgICBkZWZpbmVWYWx1ZShhYnMsICd0b1N0cmluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggfCAwKSArICd4JyArICh0aGlzLnkgfCAwKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGRlZmluZVZhbHVlKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgICAgdmFsdWUgOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYXRlRWxldmVudChlbCwgZXYsIGxvYykge1xuICAgICAgLy8gcGFnZVgvWSBpZiBhdmFpbGFibGU/XG4gICAgICBpZiAoZXYudG91Y2hlcyAmJiBldi50b3VjaGVzLmxlbmd0aCkge1xuICAgICAgICBsb2MueCA9IGV2LnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgbG9jLnkgPSBldi50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2MueCA9IGV2LmNsaWVudFg7XG4gICAgICAgIGxvYy55ID0gZXYuY2xpZW50WTtcbiAgICAgIH1cbiAgICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBsb2MueCAtPSByZWN0LmxlZnQ7XG4gICAgICBsb2MueSAtPSByZWN0LnRvcDtcbiAgICAgIGxvYy54IC09IGVsLmNsaWVudExlZnQgfCAwO1xuICAgICAgbG9jLnkgLT0gZWwuY2xpZW50VG9wIHwgMDtcbiAgICAgIHJldHVybiBsb2M7XG4gICAgfVxuICAgIHZhciBtb3VzZSA9IE1vdXNlO1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBsb2FkZXIgZm9yIHdlYi5cbiAgICAgKi9cblxuXG5cbiAgICBjb3JlLl9zdXBwb3J0ZWQgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgcmV0dXJuIChlbGVtLmdldENvbnRleHQgJiYgZWxlbS5nZXRDb250ZXh0KCcyZCcpKSA/IHRydWUgOiBmYWxzZTtcbiAgICB9KSgpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjb3JlLl9zdXBwb3J0ZWQpIHtcbiAgICAgICAgY29yZS5zdGFydCgpO1xuICAgICAgfVxuICAgICAgLy8gVE9ETyBpZiBub3Qgc3VwcG9ydGVkXG4gICAgfSwgZmFsc2UpO1xuXG4gICAgY29yZS5jb25maWcoe1xuICAgICAgJ2FwcC1sb2FkZXInIDogQXBwTG9hZGVyLFxuICAgICAgJ2ltYWdlLWxvYWRlcicgOiBJbWFnZUxvYWRlclxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gQXBwTG9hZGVyKGFwcCwgY29uZmlncykge1xuICAgICAgY29uZmlncyA9IGNvbmZpZ3MgfHwge307XG4gICAgICB2YXIgY2FudmFzID0gY29uZmlncy5jYW52YXMsIGNvbnRleHQgPSBudWxsLCBmdWxsID0gZmFsc2U7XG4gICAgICB2YXIgd2lkdGggPSAwLCBoZWlnaHQgPSAwLCByYXRpbyA9IDE7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FudmFzID09PSAnc3RyaW5nJykge1xuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3V0anMnKVxuICAgICAgICAgICAgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YWdlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIGZ1bGwgPSB0cnVlO1xuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG5cbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICBib2R5Lmluc2VydEJlZm9yZShjYW52YXMsIGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgdmFyIGJhY2tpbmdTdG9yZVJhdGlvID0gY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvXG4gICAgICAgICAgfHwgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvXG4gICAgICAgICAgfHwgY29udGV4dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgIHJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuXG4gICAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgIHx8IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgfTtcbiAgICAgIHZhciByb290ID0gY29yZS5yb290KHJlcXVlc3RBbmltYXRpb25GcmFtZSwgcmVuZGVyKTtcblxuICAgICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICBpZiAod2lkdGggPiAwICYmIGhlaWdodCA+IDApIHtcbiAgICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICByb290LnJlbmRlcihjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByb290LmJhY2tncm91bmQgPSBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgYXBwKHJvb3QsIGNhbnZhcyk7XG5cbiAgICAgIC8vIHJlc2l6ZSgpO1xuICAgICAgLy8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZSwgZmFsc2UpO1xuICAgICAgLy8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgcmVzaXplLCBmYWxzZSk7XG5cbiAgICAgIHZhciBsYXN0V2lkdGggPSAtMTtcbiAgICAgIHZhciBsYXN0SGVpZ2h0ID0gLTE7XG4gICAgICAoZnVuY3Rpb24gcmVzaXplTG9vcCgpIHtcbiAgICAgICAgdmFyIHdpZHRoLCBoZWlnaHQ7XG4gICAgICAgIGlmIChmdWxsKSB7XG4gICAgICAgICAgLy8gc2NyZWVuLmF2YWlsV2lkdGgvSGVpZ2h0P1xuICAgICAgICAgIHdpZHRoID0gKHdpbmRvdy5pbm5lcldpZHRoID4gMCA/IHdpbmRvdy5pbm5lcldpZHRoIDogc2NyZWVuLndpZHRoKTtcbiAgICAgICAgICBoZWlnaHQgPSAod2luZG93LmlubmVySGVpZ2h0ID4gMCA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHNjcmVlbi5oZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgICAgIGhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RXaWR0aCAhPT0gd2lkdGggfHwgbGFzdEhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgbGFzdFdpZHRoID0gd2lkdGg7XG4gICAgICAgICAgbGFzdEhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICByZXNpemUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVzaXplTG9vcCk7XG4gICAgICB9KSgpO1xuXG4gICAgICBmdW5jdGlvbiByZXNpemUoKSB7XG5cbiAgICAgICAgaWYgKGZ1bGwpIHtcbiAgICAgICAgICAvLyBzY3JlZW4uYXZhaWxXaWR0aC9IZWlnaHQ/XG4gICAgICAgICAgd2lkdGggPSAod2luZG93LmlubmVyV2lkdGggPiAwID8gd2luZG93LmlubmVyV2lkdGggOiBzY3JlZW4ud2lkdGgpO1xuICAgICAgICAgIGhlaWdodCA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgPiAwID8gd2luZG93LmlubmVySGVpZ2h0IDogc2NyZWVuLmhlaWdodCk7XG5cbiAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgICAgICBoZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgd2lkdGggKj0gcmF0aW87XG4gICAgICAgIGhlaWdodCAqPSByYXRpbztcblxuICAgICAgICBpZiAoY2FudmFzLndpZHRoID09PSB3aWR0aCAmJiBjYW52YXMuaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICByb290LnZpZXdwb3J0KHdpZHRoLCBoZWlnaHQsIHJhdGlvKTtcblxuICAgICAgICByZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJbWFnZUxvYWRlcihzcmMsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdWNjZXNzKGltYWdlKTtcbiAgICAgIH07XG4gICAgICBpbWFnZS5vbmVycm9yID0gZXJyb3I7XG4gICAgICBpbWFnZS5zcmMgPSBzcmM7XG4gICAgfVxuXG4gICAgdmFyIHdlYiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGxpYjtcblxuICAgIG1vZHVsZS5leHBvcnRzLmludGVybmFsID0ge307XG5cblxuICAgIG1vZHVsZS5leHBvcnRzLmludGVybmFsLkltYWdlID0gaW1hZ2U7XG5cblxuXG5cbiAgICBtb2R1bGUuZXhwb3J0cy5Nb3VzZSA9IG1vdXNlO1xuICAgIG1vZHVsZS5leHBvcnRzLk1hdGggPSBtYXRoO1xuICAgIG1vZHVsZS5leHBvcnRzLl9leHRlbmQgPSBleHRlbmQ7XG4gICAgbW9kdWxlLmV4cG9ydHMuX2NyZWF0ZSA9IGNyZWF0ZTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHRlc3RiZWQob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgICAgICAgICBvcHRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB3ZWIoZnVuY3Rpb24gKHN0YWdlLCBjYW52YXMpIHtcbiAgICAgICAgICAgIHN0YWdlLm9uKHdlYi5Nb3VzZS5TVEFSVCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5mb2N1cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGFnZS5NQVhfRUxBUFNFID0gMTAwMCAvIDMwO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdmFyIHRlc3RiZWQgPSB7fTtcbiAgICAgICAgICAgIHRlc3RiZWQuY2FudmFzID0gY2FudmFzO1xuICAgICAgICAgICAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhZ2Uub24oJ3Jlc3VtZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0ZXN0YmVkLl9yZXN1bWUgJiYgdGVzdGJlZC5fcmVzdW1lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YWdlLm9uKCdwYXVzZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRlc3RiZWQuX3BhdXNlICYmIHRlc3RiZWQuX3BhdXNlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRlc3RiZWQuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdXNlZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0ZXN0YmVkLnRvZ2dsZVBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBhdXNlZCA/IHRlc3RiZWQucmVzdW1lKCkgOiB0ZXN0YmVkLnBhdXNlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGVzdGJlZC5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdGFnZS5wYXVzZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRlc3RiZWQucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0YWdlLnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgIHRlc3RiZWQuZm9jdXMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0ZXN0YmVkLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5mb2N1cygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRlc3RiZWQud2lkdGggPSA4MDtcbiAgICAgICAgICAgIHRlc3RiZWQuaGVpZ2h0ID0gNjA7XG4gICAgICAgICAgICB0ZXN0YmVkLnggPSAwO1xuICAgICAgICAgICAgdGVzdGJlZC55ID0gLTEwO1xuICAgICAgICAgICAgdGVzdGJlZC5zY2FsZVkgPSAtMTtcbiAgICAgICAgICAgIHRlc3RiZWQucmF0aW8gPSAxNjtcbiAgICAgICAgICAgIHRlc3RiZWQuaHogPSA2MDtcbiAgICAgICAgICAgIHRlc3RiZWQuc3BlZWQgPSAxO1xuICAgICAgICAgICAgdGVzdGJlZC5hY3RpdmVLZXlzID0ge307XG4gICAgICAgICAgICB0ZXN0YmVkLmJhY2tncm91bmQgPSAnIzIyMjIyMic7XG4gICAgICAgICAgICB0ZXN0YmVkLmZpbmRPbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbzogaW1wbGVtZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGVzdGJlZC5maW5kQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIHRvZG86IGltcGxlbWVudFxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc3RhdHVzVGV4dCA9ICcnO1xuICAgICAgICAgICAgdmFyIHN0YXR1c01hcCA9IHt9O1xuICAgICAgICAgICAgZnVuY3Rpb24gc3RhdHVzU2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c01hcFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0YXR1c01lcmdlKG9iaikge1xuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mb3ItaW5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1NldChrZXksIG9ialtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXN0YmVkLnN0YXR1cyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNTZXQoYSwgYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGEgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c01lcmdlKGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlc3RiZWQuX3N0YXR1cyAmJiB0ZXN0YmVkLl9zdGF0dXMoc3RhdHVzVGV4dCwgc3RhdHVzTWFwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0ZXN0YmVkLmluZm8gPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgICAgIHRlc3RiZWQuX2luZm8gJiYgdGVzdGJlZC5faW5mbyh0ZXh0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbGFzdERyYXdIYXNoID0gXCJcIjtcbiAgICAgICAgICAgIHZhciBkcmF3SGFzaCA9IFwiXCI7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkcmF3aW5nVGV4dHVyZSA9IG5ldyB3ZWIuVGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgIHN0YWdlLmFwcGVuZCh3ZWIuaW1hZ2UoZHJhd2luZ1RleHR1cmUpKTtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gW107XG4gICAgICAgICAgICAgICAgc3RhZ2UudGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgIGRyYXdpbmdUZXh0dXJlLmRyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgMCwgdGVzdGJlZC5zY2FsZVksIC10ZXN0YmVkLngsIC10ZXN0YmVkLnkpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMiAvIHRlc3RiZWQucmF0aW87XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lQ2FwID0gJ3JvdW5kJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZHJhd2luZyA9IGJ1ZmZlci5zaGlmdCgpOyBkcmF3aW5nOyBkcmF3aW5nID0gYnVmZmVyLnNoaWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdpbmcoY3R4LCB0ZXN0YmVkLnJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGVzdGJlZC5kcmF3UG9pbnQgPSBmdW5jdGlvbiAocCwgciwgY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnB1c2goZnVuY3Rpb24gKGN0eCwgcmF0aW8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMocC54LCBwLnksIDUgLyByYXRpbywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkcmF3SGFzaCArPSBcInBvaW50XCIgKyBwLnggKyAnLCcgKyBwLnkgKyAnLCcgKyByICsgJywnICsgY29sb3I7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0ZXN0YmVkLmRyYXdDaXJjbGUgPSBmdW5jdGlvbiAocCwgciwgY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnB1c2goZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhwLngsIHAueSwgciwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkcmF3SGFzaCArPSBcImNpcmNsZVwiICsgcC54ICsgJywnICsgcC55ICsgJywnICsgciArICcsJyArIGNvbG9yO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGVzdGJlZC5kcmF3U2VnbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaChmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGEueCwgYS55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oYi54LCBiLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkcmF3SGFzaCArPSBcInNlZ21lbnRcIiArIGEueCArICcsJyArIGEueSArICcsJyArIGIueCArICcsJyArIGIueSArICcsJyArIGNvbG9yO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGVzdGJlZC5kcmF3UG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMsIGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcG9pbnRzIHx8ICFwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnB1c2goZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBvaW50c1tpXS54LCBwb2ludHNbaV0ueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdIYXNoICs9IFwic2VnbWVudFwiO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0hhc2ggKz0gcG9pbnRzW2ldLnggKyAnLCcgKyBwb2ludHNbaV0ueSArICcsJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkcmF3SGFzaCArPSBjb2xvcjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRlc3RiZWQuZHJhd0FBQkIgPSBmdW5jdGlvbiAoYWFiYiwgY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnB1c2goZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhhYWJiLmxvd2VyQm91bmQueCwgYWFiYi5sb3dlckJvdW5kLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhhYWJiLnVwcGVyQm91bmQueCwgYWFiYi5sb3dlckJvdW5kLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhhYWJiLnVwcGVyQm91bmQueCwgYWFiYi51cHBlckJvdW5kLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhhYWJiLmxvd2VyQm91bmQueCwgYWFiYi51cHBlckJvdW5kLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkcmF3SGFzaCArPSBcImFhYmJcIjtcbiAgICAgICAgICAgICAgICAgICAgZHJhd0hhc2ggKz0gYWFiYi5sb3dlckJvdW5kLnggKyAnLCcgKyBhYWJiLmxvd2VyQm91bmQueSArICcsJztcbiAgICAgICAgICAgICAgICAgICAgZHJhd0hhc2ggKz0gYWFiYi51cHBlckJvdW5kLnggKyAnLCcgKyBhYWJiLnVwcGVyQm91bmQueSArICcsJztcbiAgICAgICAgICAgICAgICAgICAgZHJhd0hhc2ggKz0gY29sb3I7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0ZXN0YmVkLmNvbG9yID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHIgKiAyNTYgfCAwO1xuICAgICAgICAgICAgICAgICAgICBnID0gZyAqIDI1NiB8IDA7XG4gICAgICAgICAgICAgICAgICAgIGIgPSBiICogMjU2IHwgMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyZ2IoJyArIHIgKyAnLCAnICsgZyArICcsICcgKyBiICsgJyknO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgdmFyIHdvcmxkID0gY2FsbGJhY2sodGVzdGJlZCk7XG4gICAgICAgICAgICB2YXIgdmlld2VyID0gbmV3IFZpZXdlcih3b3JsZCwgdGVzdGJlZCk7XG4gICAgICAgICAgICB2YXIgbGFzdFggPSAwO1xuICAgICAgICAgICAgdmFyIGxhc3RZID0gMDtcbiAgICAgICAgICAgIHN0YWdlLnRpY2soZnVuY3Rpb24gKGR0LCB0KSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNhbWVyYSBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGlmIChsYXN0WCAhPT0gdGVzdGJlZC54IHx8IGxhc3RZICE9PSB0ZXN0YmVkLnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld2VyLm9mZnNldCgtdGVzdGJlZC54LCAtdGVzdGJlZC55KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFggPSB0ZXN0YmVkLng7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RZID0gdGVzdGJlZC55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmlld2VyLnRpY2soZnVuY3Rpb24gKGR0LCB0KSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCB0ZXN0YmVkIHN0ZXAsIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZXN0YmVkLnN0ZXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVzdGJlZC5zdGVwKGR0LCB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVzdGJlZC5kcmF3U2VnbWVudCh0YXJnZXRCb2R5LmdldFBvc2l0aW9uKCksIG1vdXNlTW92ZSwgJ3JnYmEoMjU1LDI1NSwyNTUsMC4yKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGFzdERyYXdIYXNoICE9PSBkcmF3SGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RHJhd0hhc2ggPSBkcmF3SGFzaDtcbiAgICAgICAgICAgICAgICAgICAgc3RhZ2UudG91Y2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHJhd0hhc2ggPSBcIlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBzdGFnZS5lbXB0eSgpO1xuICAgICAgICAgICAgc3RhZ2UuYmFja2dyb3VuZCh0ZXN0YmVkLmJhY2tncm91bmQpO1xuICAgICAgICAgICAgc3RhZ2Uudmlld2JveCh0ZXN0YmVkLndpZHRoLCB0ZXN0YmVkLmhlaWdodCk7XG4gICAgICAgICAgICBzdGFnZS5waW4oJ2FsaWduWCcsIC0wLjUpO1xuICAgICAgICAgICAgc3RhZ2UucGluKCdhbGlnblknLCAtMC41KTtcbiAgICAgICAgICAgIHN0YWdlLnByZXBlbmQodmlld2VyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRCb2R5KHBvaW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHk7XG4gICAgICAgICAgICAgICAgdmFyIGFhYmIgPSBuZXcgQUFCQihwb2ludCwgcG9pbnQpO1xuICAgICAgICAgICAgICAgIHdvcmxkLnF1ZXJ5QUFCQihhYWJiLCBmdW5jdGlvbiAoZml4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZml4dHVyZS5nZXRCb2R5KCkuaXNEeW5hbWljKCkgfHwgIWZpeHR1cmUudGVzdFBvaW50KHBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmaXh0dXJlLmdldEJvZHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbW91c2VHcm91bmQgPSB3b3JsZC5jcmVhdGVCb2R5KCk7XG4gICAgICAgICAgICB2YXIgbW91c2VKb2ludDtcbiAgICAgICAgICAgIHZhciB0YXJnZXRCb2R5O1xuICAgICAgICAgICAgdmFyIG1vdXNlTW92ZSA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICAgICAgdmlld2VyLmF0dHIoJ3NweScsIHRydWUpLm9uKHdlYi5Nb3VzZS5TVEFSVCwgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSB7IHg6IHBvaW50LngsIHk6IHRlc3RiZWQuc2NhbGVZICogcG9pbnQueSB9O1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRCb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBmaW5kQm9keShwb2ludCk7XG4gICAgICAgICAgICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RiZWQubW91c2VGb3JjZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRCb2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlSm9pbnQgPSBuZXcgTW91c2VKb2ludCh7IG1heEZvcmNlOiAxMDAwIH0sIG1vdXNlR3JvdW5kLCBib2R5LCBWZWMyLmNsb25lKHBvaW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmxkLmNyZWF0ZUpvaW50KG1vdXNlSm9pbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLm9uKHdlYi5Nb3VzZS5NT1ZFLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHsgeDogcG9pbnQueCwgeTogdGVzdGJlZC5zY2FsZVkgKiBwb2ludC55IH07XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNlSm9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW91c2VKb2ludC5zZXRUYXJnZXQocG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb3VzZU1vdmUueCA9IHBvaW50Lng7XG4gICAgICAgICAgICAgICAgbW91c2VNb3ZlLnkgPSBwb2ludC55O1xuICAgICAgICAgICAgfSkub24od2ViLk1vdXNlLkVORCwgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSB7IHg6IHBvaW50LngsIHk6IHRlc3RiZWQuc2NhbGVZICogcG9pbnQueSB9O1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZUpvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmxkLmRlc3Ryb3lKb2ludChtb3VzZUpvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgbW91c2VKb2ludCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRCb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3JjZSA9IFZlYzIuc3ViKHBvaW50LCB0YXJnZXRCb2R5LmdldFBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRCb2R5LmFwcGx5Rm9yY2VUb0NlbnRlcihmb3JjZS5tdWwodGVzdGJlZC5tb3VzZUZvcmNlKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEJvZHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLm9uKHdlYi5Nb3VzZS5DQU5DRUwsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgICAgIHBvaW50ID0geyB4OiBwb2ludC54LCB5OiB0ZXN0YmVkLnNjYWxlWSAqIHBvaW50LnkgfTtcbiAgICAgICAgICAgICAgICBpZiAobW91c2VKb2ludCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JsZC5kZXN0cm95Sm9pbnQobW91c2VKb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlSm9pbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Qm9keSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRCb2R5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1AnLmNoYXJDb2RlQXQoMCk6XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXN0YmVkLnRvZ2dsZVBhdXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICB2YXIgZG93bktleXMgPSB7fTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgICAgICAgICAgICAgIGRvd25LZXlzW2tleUNvZGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVBY3RpdmVLZXlzKGtleUNvZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRlc3RiZWQua2V5ZG93biAmJiB0ZXN0YmVkLmtleWRvd24oa2V5Q29kZSwgU3RyaW5nLmZyb21DaGFyQ29kZShrZXlDb2RlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgICAgICAgICBkb3duS2V5c1trZXlDb2RlXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUFjdGl2ZUtleXMoa2V5Q29kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRlc3RiZWQua2V5dXAgJiYgdGVzdGJlZC5rZXl1cChrZXlDb2RlLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleUNvZGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGFjdGl2ZUtleXMgPSB0ZXN0YmVkLmFjdGl2ZUtleXM7XG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVBY3RpdmVLZXlzKGtleUNvZGUsIGRvd24pIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgaWYgKC9cXHcvLnRlc3QoY2hhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlS2V5c1tjaGFyXSA9IGRvd247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjdGl2ZUtleXMucmlnaHQgPSBkb3duS2V5c1szOV0gfHwgYWN0aXZlS2V5c1snRCddO1xuICAgICAgICAgICAgICAgIGFjdGl2ZUtleXMubGVmdCA9IGRvd25LZXlzWzM3XSB8fCBhY3RpdmVLZXlzWydBJ107XG4gICAgICAgICAgICAgICAgYWN0aXZlS2V5cy51cCA9IGRvd25LZXlzWzM4XSB8fCBhY3RpdmVLZXlzWydXJ107XG4gICAgICAgICAgICAgICAgYWN0aXZlS2V5cy5kb3duID0gZG93bktleXNbNDBdIHx8IGFjdGl2ZUtleXNbJ1MnXTtcbiAgICAgICAgICAgICAgICBhY3RpdmVLZXlzLmZpcmUgPSBkb3duS2V5c1szMl0gfHwgZG93bktleXNbMTNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgVmlld2VyLl9zdXBlciA9IHdlYjtcbiAgICBWaWV3ZXIucHJvdG90eXBlID0gd2ViLl9jcmVhdGUoVmlld2VyLl9zdXBlci5wcm90b3R5cGUpO1xuICAgIGZ1bmN0aW9uIFZpZXdlcih3b3JsZCwgb3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBWaWV3ZXIuX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubGFiZWwoJ1BsYW5jaycpO1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLl9vcHRpb25zLnNwZWVkID0gb3B0cy5zcGVlZCB8fCAxO1xuICAgICAgICB0aGlzLl9vcHRpb25zLmh6ID0gb3B0cy5oeiB8fCA2MDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX29wdGlvbnMuaHopIDwgMSkge1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5oeiA9IDEgLyB0aGlzLl9vcHRpb25zLmh6O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wdGlvbnMuc2NhbGVZID0gb3B0cy5zY2FsZVkgfHwgLTE7XG4gICAgICAgIHRoaXMuX29wdGlvbnMucmF0aW8gPSBvcHRzLnJhdGlvIHx8IDE2O1xuICAgICAgICB0aGlzLl9vcHRpb25zLmxpbmVXaWR0aCA9IDIgLyB0aGlzLl9vcHRpb25zLnJhdGlvO1xuICAgICAgICB0aGlzLl93b3JsZCA9IHdvcmxkO1xuICAgICAgICB2YXIgdGltZVN0ZXAgPSAxIC8gdGhpcy5fb3B0aW9ucy5oejtcbiAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgdGhpcy50aWNrKGZ1bmN0aW9uIChkdCkge1xuICAgICAgICAgICAgZHQgPSBkdCAqIDAuMDAxICogX3RoaXMuX29wdGlvbnMuc3BlZWQ7XG4gICAgICAgICAgICBlbGFwc2VkVGltZSArPSBkdDtcbiAgICAgICAgICAgIHdoaWxlIChlbGFwc2VkVGltZSA+IHRpbWVTdGVwKSB7XG4gICAgICAgICAgICAgICAgd29ybGQuc3RlcCh0aW1lU3RlcCk7XG4gICAgICAgICAgICAgICAgZWxhcHNlZFRpbWUgLT0gdGltZVN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJXb3JsZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICB3b3JsZC5vbigncmVtb3ZlLWZpeHR1cmUnLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBvYmoudWkgJiYgb2JqLnVpLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgd29ybGQub24oJ3JlbW92ZS1qb2ludCcsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIG9iai51aSAmJiBvYmoudWkucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBWaWV3ZXIucHJvdG90eXBlLnJlbmRlcldvcmxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd29ybGQgPSB0aGlzLl93b3JsZDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xuICAgICAgICB2YXIgdmlld2VyID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgYiA9IHdvcmxkLmdldEJvZHlMaXN0KCk7IGI7IGIgPSBiLmdldE5leHQoKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgZiA9IGIuZ2V0Rml4dHVyZUxpc3QoKTsgZjsgZiA9IGYuZ2V0TmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmLnVpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmLnJlbmRlciAmJiBmLnJlbmRlci5zdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3Ryb2tlU3R5bGUgPSBmLnJlbmRlci5zdHJva2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYi5yZW5kZXIgJiYgYi5yZW5kZXIuc3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0cm9rZVN0eWxlID0gYi5yZW5kZXIuc3Ryb2tlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGIuaXNEeW5hbWljKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjkpJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiLmlzS2luZW1hdGljKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiLmlzU3RhdGljKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjUpJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZi5yZW5kZXIgJiYgZi5yZW5kZXIuZmlsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5maWxsU3R5bGUgPSBmLnJlbmRlci5maWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGIucmVuZGVyICYmIGIucmVuZGVyLmZpbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlsbFN0eWxlID0gYi5yZW5kZXIuZmlsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlsbFN0eWxlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBmLmdldFR5cGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gZi5nZXRTaGFwZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSAnY2lyY2xlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZi51aSA9IHZpZXdlci5kcmF3Q2lyY2xlKHNoYXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSAnZWRnZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYudWkgPSB2aWV3ZXIuZHJhd0VkZ2Uoc2hhcGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09ICdwb2x5Z29uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZi51aSA9IHZpZXdlci5kcmF3UG9seWdvbihzaGFwZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gJ2NoYWluJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZi51aSA9IHZpZXdlci5kcmF3Q2hhaW4oc2hhcGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmLnVpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLnVpLmFwcGVuZFRvKHZpZXdlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGYudWkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBiLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gYi5nZXRBbmdsZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZi51aS5fX2xhc3RYICE9PSBwLnggfHwgZi51aS5fX2xhc3RZICE9PSBwLnkgfHwgZi51aS5fX2xhc3RSICE9PSByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLnVpLl9fbGFzdFggPSBwLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLnVpLl9fbGFzdFkgPSBwLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLnVpLl9fbGFzdFIgPSByO1xuICAgICAgICAgICAgICAgICAgICAgICAgZi51aS5vZmZzZXQocC54LCBvcHRpb25zLnNjYWxlWSAqIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLnVpLnJvdGF0ZShvcHRpb25zLnNjYWxlWSAqIHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGogPSB3b3JsZC5nZXRKb2ludExpc3QoKTsgajsgaiA9IGouZ2V0TmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGouZ2V0VHlwZSgpO1xuICAgICAgICAgICAgdmFyIGEgPSBqLmdldEFuY2hvckEoKTtcbiAgICAgICAgICAgIHZhciBiID0gai5nZXRBbmNob3JCKCk7XG4gICAgICAgICAgICBpZiAoIWoudWkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC4yKSc7XG4gICAgICAgICAgICAgICAgai51aSA9IHZpZXdlci5kcmF3Sm9pbnQoaiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgai51aS5waW4oJ2hhbmRsZScsIDAuNSk7XG4gICAgICAgICAgICAgICAgaWYgKGoudWkpIHtcbiAgICAgICAgICAgICAgICAgICAgai51aS5hcHBlbmRUbyh2aWV3ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqLnVpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gKGEueCArIGIueCkgKiAwLjU7XG4gICAgICAgICAgICAgICAgdmFyIGN5ID0gb3B0aW9ucy5zY2FsZVkgKiAoYS55ICsgYi55KSAqIDAuNTtcbiAgICAgICAgICAgICAgICB2YXIgZHggPSBhLnggLSBiLng7XG4gICAgICAgICAgICAgICAgdmFyIGR5ID0gb3B0aW9ucy5zY2FsZVkgKiAoYS55IC0gYi55KTtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICAgICAgai51aS53aWR0aChkKTtcbiAgICAgICAgICAgICAgICBqLnVpLnJvdGF0ZShNYXRoLmF0YW4yKGR5LCBkeCkpO1xuICAgICAgICAgICAgICAgIGoudWkub2Zmc2V0KGN4LCBjeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZpZXdlci5wcm90b3R5cGUuZHJhd0pvaW50ID0gZnVuY3Rpb24gKGpvaW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsdyA9IG9wdGlvbnMubGluZVdpZHRoO1xuICAgICAgICB2YXIgcmF0aW8gPSBvcHRpb25zLnJhdGlvO1xuICAgICAgICB2YXIgbGVuZ3RoID0gMTA7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gd2ViLmNhbnZhcyhmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB0aGlzLnNpemUobGVuZ3RoICsgMiAqIGx3LCAyICogbHcsIHJhdGlvKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhsdywgbHcpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhsdyArIGxlbmd0aCwgbHcpO1xuICAgICAgICAgICAgY3R4LmxpbmVDYXAgPSAncm91bmQnO1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMubGluZVdpZHRoO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5zdHJva2VTdHlsZTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpbWFnZSA9IHdlYi5pbWFnZSh0ZXh0dXJlKS5zdHJldGNoKCk7XG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9O1xuICAgIFZpZXdlci5wcm90b3R5cGUuZHJhd0NpcmNsZSA9IGZ1bmN0aW9uIChzaGFwZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbHcgPSBvcHRpb25zLmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIHJhdGlvID0gb3B0aW9ucy5yYXRpbztcbiAgICAgICAgdmFyIHIgPSBzaGFwZS5tX3JhZGl1cztcbiAgICAgICAgdmFyIGN4ID0gciArIGx3O1xuICAgICAgICB2YXIgY3kgPSByICsgbHc7XG4gICAgICAgIHZhciB3ID0gciAqIDIgKyBsdyAqIDI7XG4gICAgICAgIHZhciBoID0gciAqIDIgKyBsdyAqIDI7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gd2ViLmNhbnZhcyhmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB0aGlzLnNpemUodywgaCwgcmF0aW8pO1xuICAgICAgICAgICAgY3R4LnNjYWxlKHJhdGlvLCByYXRpbyk7XG4gICAgICAgICAgICBjdHguYXJjKGN4LCBjeSwgciwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmlsbFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZmlsbFN0eWxlO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgubGluZVRvKGN4LCBjeSk7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5saW5lV2lkdGg7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLnN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGltYWdlID0gd2ViLmltYWdlKHRleHR1cmUpXG4gICAgICAgICAgICAub2Zmc2V0KHNoYXBlLm1fcC54IC0gY3gsIG9wdGlvbnMuc2NhbGVZICogc2hhcGUubV9wLnkgLSBjeSk7XG4gICAgICAgIHZhciBub2RlID0gd2ViLmNyZWF0ZSgpLmFwcGVuZChpbWFnZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgVmlld2VyLnByb3RvdHlwZS5kcmF3RWRnZSA9IGZ1bmN0aW9uIChlZGdlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsdyA9IG9wdGlvbnMubGluZVdpZHRoO1xuICAgICAgICB2YXIgcmF0aW8gPSBvcHRpb25zLnJhdGlvO1xuICAgICAgICB2YXIgdjEgPSBlZGdlLm1fdmVydGV4MTtcbiAgICAgICAgdmFyIHYyID0gZWRnZS5tX3ZlcnRleDI7XG4gICAgICAgIHZhciBkeCA9IHYyLnggLSB2MS54O1xuICAgICAgICB2YXIgZHkgPSB2Mi55IC0gdjEueTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gd2ViLmNhbnZhcyhmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB0aGlzLnNpemUobGVuZ3RoICsgMiAqIGx3LCAyICogbHcsIHJhdGlvKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhsdywgbHcpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhsdyArIGxlbmd0aCwgbHcpO1xuICAgICAgICAgICAgY3R4LmxpbmVDYXAgPSAncm91bmQnO1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMubGluZVdpZHRoO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5zdHJva2VTdHlsZTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtaW5YID0gTWF0aC5taW4odjEueCwgdjIueCk7XG4gICAgICAgIHZhciBtaW5ZID0gTWF0aC5taW4ob3B0aW9ucy5zY2FsZVkgKiB2MS55LCBvcHRpb25zLnNjYWxlWSAqIHYyLnkpO1xuICAgICAgICB2YXIgaW1hZ2UgPSB3ZWIuaW1hZ2UodGV4dHVyZSk7XG4gICAgICAgIGltYWdlLnJvdGF0ZShvcHRpb25zLnNjYWxlWSAqIE1hdGguYXRhbjIoZHksIGR4KSk7XG4gICAgICAgIGltYWdlLm9mZnNldChtaW5YIC0gbHcsIG1pblkgLSBsdyk7XG4gICAgICAgIHZhciBub2RlID0gd2ViLmNyZWF0ZSgpLmFwcGVuZChpbWFnZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgVmlld2VyLnByb3RvdHlwZS5kcmF3UG9seWdvbiA9IGZ1bmN0aW9uIChzaGFwZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbHcgPSBvcHRpb25zLmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIHJhdGlvID0gb3B0aW9ucy5yYXRpbztcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gc2hhcGUubV92ZXJ0aWNlcztcbiAgICAgICAgaWYgKCF2ZXJ0aWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICAgICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgdi54KTtcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB2LngpO1xuICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIG9wdGlvbnMuc2NhbGVZICogdi55KTtcbiAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBvcHRpb25zLnNjYWxlWSAqIHYueSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpZHRoID0gbWF4WCAtIG1pblg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBtYXhZIC0gbWluWTtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB3ZWIuY2FudmFzKGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSh3aWR0aCArIDIgKiBsdywgaGVpZ2h0ICsgMiAqIGx3LCByYXRpbyk7XG4gICAgICAgICAgICBjdHguc2NhbGUocmF0aW8sIHJhdGlvKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB4ID0gdi54IC0gbWluWCArIGx3O1xuICAgICAgICAgICAgICAgIHZhciB5ID0gb3B0aW9ucy5zY2FsZVkgKiB2LnkgLSBtaW5ZICsgbHc7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmVydGljZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbGxTdHlsZSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxTdHlsZTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5saW5lQ2FwID0gJ3JvdW5kJztcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmxpbmVXaWR0aDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaW1hZ2UgPSB3ZWIuaW1hZ2UodGV4dHVyZSk7XG4gICAgICAgIGltYWdlLm9mZnNldChtaW5YIC0gbHcsIG1pblkgLSBsdyk7XG4gICAgICAgIHZhciBub2RlID0gd2ViLmNyZWF0ZSgpLmFwcGVuZChpbWFnZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgVmlld2VyLnByb3RvdHlwZS5kcmF3Q2hhaW4gPSBmdW5jdGlvbiAoc2hhcGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGx3ID0gb3B0aW9ucy5saW5lV2lkdGg7XG4gICAgICAgIHZhciByYXRpbyA9IG9wdGlvbnMucmF0aW87XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHNoYXBlLm1fdmVydGljZXM7XG4gICAgICAgIGlmICghdmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1pblkgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHYueCk7XG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgdi54KTtcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBvcHRpb25zLnNjYWxlWSAqIHYueSk7XG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgb3B0aW9ucy5zY2FsZVkgKiB2LnkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IG1heFggLSBtaW5YO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gd2ViLmNhbnZhcyhmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB0aGlzLnNpemUod2lkdGggKyAyICogbHcsIGhlaWdodCArIDIgKiBsdywgcmF0aW8pO1xuICAgICAgICAgICAgY3R4LnNjYWxlKHJhdGlvLCByYXRpbyk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHYueCAtIG1pblggKyBsdztcbiAgICAgICAgICAgICAgICB2YXIgeSA9IG9wdGlvbnMuc2NhbGVZICogdi55IC0gbWluWSArIGx3O1xuICAgICAgICAgICAgICAgIGlmIChpID09IDApXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogaWYgbG9vcFxuICAgICAgICAgICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA+IDIpIDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbGxTdHlsZSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxTdHlsZTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5saW5lQ2FwID0gJ3JvdW5kJztcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmxpbmVXaWR0aDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaW1hZ2UgPSB3ZWIuaW1hZ2UodGV4dHVyZSk7XG4gICAgICAgIGltYWdlLm9mZnNldChtaW5YIC0gbHcsIG1pblkgLSBsdyk7XG4gICAgICAgIHZhciBub2RlID0gd2ViLmNyZWF0ZSgpLmFwcGVuZChpbWFnZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgLyoqIEBkZXByZWNhdGVkIE1lcmdlZCB3aXRoIG1haW4gbmFtZXNwYWNlICovXG4gICAgdmFyIGludGVybmFsID0ge307XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGludGVybmFsLkNvbGxpZGVQb2x5Z29ucyA9IENvbGxpZGVQb2x5Z29ucztcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaW50ZXJuYWwuU2V0dGluZ3MgPSBTZXR0aW5ncztcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaW50ZXJuYWwuU3dlZXAgPSBTd2VlcDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaW50ZXJuYWwuTWFuaWZvbGQgPSBNYW5pZm9sZDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaW50ZXJuYWwuRGlzdGFuY2UgPSBEaXN0YW5jZTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaW50ZXJuYWwuVGltZU9mSW1wYWN0ID0gVGltZU9mSW1wYWN0O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpbnRlcm5hbC5EeW5hbWljVHJlZSA9IER5bmFtaWNUcmVlO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpbnRlcm5hbC5zdGF0cyA9IHN0YXRzJDE7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIFNvbHZlci5UaW1lU3RlcCA9IFRpbWVTdGVwO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBEaXN0YW5jZS50ZXN0T3ZlcmxhcCA9IHRlc3RPdmVybGFwO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBEaXN0YW5jZS5JbnB1dCA9IERpc3RhbmNlSW5wdXQ7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIERpc3RhbmNlLk91dHB1dCA9IERpc3RhbmNlT3V0cHV0O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBEaXN0YW5jZS5Qcm94eSA9IERpc3RhbmNlUHJveHk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIERpc3RhbmNlLkNhY2hlID0gU2ltcGxleENhY2hlO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBUaW1lT2ZJbXBhY3QuSW5wdXQgPSBUT0lJbnB1dDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgVGltZU9mSW1wYWN0Lk91dHB1dCA9IFRPSU91dHB1dDtcblxuICAgIGV4cG9ydHMuQUFCQiA9IEFBQkI7XG4gICAgZXhwb3J0cy5Cb2R5ID0gQm9keTtcbiAgICBleHBvcnRzLkJveCA9IEJveFNoYXBlO1xuICAgIGV4cG9ydHMuQ2hhaW4gPSBDaGFpblNoYXBlO1xuICAgIGV4cG9ydHMuQ2lyY2xlID0gQ2lyY2xlU2hhcGU7XG4gICAgZXhwb3J0cy5Db2xsaWRlQ2lyY2xlcyA9IENvbGxpZGVDaXJjbGVzO1xuICAgIGV4cG9ydHMuQ29sbGlkZUVkZ2VDaXJjbGUgPSBDb2xsaWRlRWRnZUNpcmNsZTtcbiAgICBleHBvcnRzLkNvbGxpZGVFZGdlUG9seWdvbiA9IENvbGxpZGVFZGdlUG9seWdvbjtcbiAgICBleHBvcnRzLkNvbGxpZGVQb2x5Z29uQ2lyY2xlID0gQ29sbGlkZVBvbHlnb25DaXJjbGU7XG4gICAgZXhwb3J0cy5Db2xsaWRlUG9seWdvbnMgPSBDb2xsaWRlUG9seWdvbnM7XG4gICAgZXhwb3J0cy5Db250YWN0ID0gQ29udGFjdDtcbiAgICBleHBvcnRzLkRpc3RhbmNlID0gRGlzdGFuY2U7XG4gICAgZXhwb3J0cy5EaXN0YW5jZUpvaW50ID0gRGlzdGFuY2VKb2ludDtcbiAgICBleHBvcnRzLkR5bmFtaWNUcmVlID0gRHluYW1pY1RyZWU7XG4gICAgZXhwb3J0cy5FZGdlID0gRWRnZVNoYXBlO1xuICAgIGV4cG9ydHMuRml4dHVyZSA9IEZpeHR1cmU7XG4gICAgZXhwb3J0cy5GcmljdGlvbkpvaW50ID0gRnJpY3Rpb25Kb2ludDtcbiAgICBleHBvcnRzLkdlYXJKb2ludCA9IEdlYXJKb2ludDtcbiAgICBleHBvcnRzLkpvaW50ID0gSm9pbnQ7XG4gICAgZXhwb3J0cy5NYW5pZm9sZCA9IE1hbmlmb2xkO1xuICAgIGV4cG9ydHMuTWF0MjIgPSBNYXQyMjtcbiAgICBleHBvcnRzLk1hdDMzID0gTWF0MzM7XG4gICAgZXhwb3J0cy5NYXRoID0gbWF0aCQxO1xuICAgIGV4cG9ydHMuTW90b3JKb2ludCA9IE1vdG9ySm9pbnQ7XG4gICAgZXhwb3J0cy5Nb3VzZUpvaW50ID0gTW91c2VKb2ludDtcbiAgICBleHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uU2hhcGU7XG4gICAgZXhwb3J0cy5QcmlzbWF0aWNKb2ludCA9IFByaXNtYXRpY0pvaW50O1xuICAgIGV4cG9ydHMuUHVsbGV5Sm9pbnQgPSBQdWxsZXlKb2ludDtcbiAgICBleHBvcnRzLlJldm9sdXRlSm9pbnQgPSBSZXZvbHV0ZUpvaW50O1xuICAgIGV4cG9ydHMuUm9wZUpvaW50ID0gUm9wZUpvaW50O1xuICAgIGV4cG9ydHMuUm90ID0gUm90O1xuICAgIGV4cG9ydHMuU2VyaWFsaXplciA9IFNlcmlhbGl6ZXI7XG4gICAgZXhwb3J0cy5TZXR0aW5ncyA9IFNldHRpbmdzO1xuICAgIGV4cG9ydHMuU2hhcGUgPSBTaGFwZTtcbiAgICBleHBvcnRzLlN3ZWVwID0gU3dlZXA7XG4gICAgZXhwb3J0cy5UaW1lT2ZJbXBhY3QgPSBUaW1lT2ZJbXBhY3Q7XG4gICAgZXhwb3J0cy5UcmFuc2Zvcm0gPSBUcmFuc2Zvcm07XG4gICAgZXhwb3J0cy5WZWMyID0gVmVjMjtcbiAgICBleHBvcnRzLlZlYzMgPSBWZWMzO1xuICAgIGV4cG9ydHMuV2VsZEpvaW50ID0gV2VsZEpvaW50O1xuICAgIGV4cG9ydHMuV2hlZWxKb2ludCA9IFdoZWVsSm9pbnQ7XG4gICAgZXhwb3J0cy5Xb3JsZCA9IFdvcmxkO1xuICAgIGV4cG9ydHMuaW50ZXJuYWwgPSBpbnRlcm5hbDtcbiAgICBleHBvcnRzLnRlc3RiZWQgPSB0ZXN0YmVkO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsYW5jay13aXRoLXRlc3RiZWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/planck/dist/planck-with-testbed.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	__webpack_require__("./src/index.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.scss");
/******/ 	
/******/ })()
;